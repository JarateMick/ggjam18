{"version":3,"sources":["../inc\\platform.h","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\math.h","../deps/Include\\3rdparty/stb_image.h","../src/platform.cpp","../src/Imgui/imgui.cpp","../src/Imgui/imgui_internal.h","../src/game/../Imgui/imgui.h","../src/Imgui/imgui_draw.cpp","../src/Imgui/imgui_impl_sdl_gl3.cpp","../src/IO.cpp","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\fstream","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\ios","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\istream","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\memory","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\string","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\__locale","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\type_traits","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\new","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\iosfwd","../inc\\EngineCore.h","../deps/Include\\da_array.h","../src/sdl_window.cpp","../src/win_main.cpp","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\ostream","../src/Graphics/Shader.cpp","../src/Graphics/SpriteRenderer.cpp","../inc\\Graphics/Shader.h","../src/Camera2D.cpp","../deps/Include\\glm/detail/type_vec2.inl","../deps/Include\\glm/detail/type_mat4x4.hpp","../deps/Include\\glm/detail/type_mat4x4.inl","../deps/Include\\glm/gtc/matrix_transform.inl","../deps/Include\\glm/detail/type_vec3.inl","../inc\\Graphics/LineRenderer.h","../src/Graphics/LineRenderer.cpp","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\vector","../deps/Include\\glm/detail/type_vec4.inl","../src/Input.cpp","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\functional","../deps/Include\\3rdparty/stb_image_write.h","../inc\\Animation.h","../src/game/Entity.cpp","../deps/Include\\3rdparty/stb_sprintf.h","../deps/Include\\3rdparty/stb_perlin.h","../src/game/jam_game.h","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\algorithm","../src/game/game.h","../src/game/tetris.cpp","../src/game/Entity.h","../src/game/mapgrid.h","../src/game/aoe160k.cpp","../src/game/game.cpp","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\chrono","../inc\\core/sdl_window.h","../inc\\Input.h","../inc\\Camera2D.h","../inc\\Graphics/SpriteRenderer.h","../inc\\ResourceManager.h","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\streambuf","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\typeinfo","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\__string","../deps/Include\\glm/gtc/type_ptr.inl","../inc\\core/window.h","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\exception","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\iterator","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\locale","../deps/Include\\glm/detail/type_vec4.hpp","../deps/Include\\glm/detail/type_vec3.hpp","../deps/Include\\glm/detail/func_geometric.inl","../deps/Include\\glm/detail/func_exponential.inl","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\stdexcept","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\tuple","C:\\Users\\EetuKer\\Desktop\\Emscripten\\emsdk-portable-64bit\\emscripten\\1.37.28\\system\\include\\libcxx\\__functional_base"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAKA;AAAA;AACA;AA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;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;AACA;;;;;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;AAEA;;;;;;AAAA;AAAA;;AACA;;;;;;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;AACA;;;;;;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;;AACA;;;;;;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;AACA;;;;;;AAAA;AAAA;AACA;AAAA;;AACA;;;;;;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;AAAA;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;ADmCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;;;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;;;;;;;;;AE3nBA;AAAA;AAAA;AAAA;;;;;;;;;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACqBA;AAAA;;AAAA;;;AAAA;;;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AHilBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;;;AAGA;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAEA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;;;;;AAq+UA;AACA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;AAMA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;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AAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AFstGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AExtGA;AAAA;AAAA;;;;;;;;;;;AAYA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;AAgMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;ACz7BA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAKA;;;;;;;;;;;AD4uBA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;AAbA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAHA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;AAGA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAiBA;AAAA;AAAA;AAAA;;AAQA;;AANA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;AAnCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;ACqLA;;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAHA;AAAA;AAAA;;AASA;;;;;;;;;;;ADxLA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AC0TA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAWA;AAAA;AAAA;AAAA;AAAA;;;;AAXA;;AAAA;;;;;;;AAWA;AAAA;;AATA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;;;;;;AAGA;AAAA;AAAA;;;AAHA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;ADtVA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;ACykCA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;AAlCA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;;;;AANA;;AAAA;;;;;;AAMA;AAAA;;AAJA;AAAA;AACA;AAAA;;AACA;;;;AAAA;AAAA;;AACA;;;;AACA;;;;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;ADzjCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;ACokCA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AD5jCA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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;;;;;;;;;;;;;AI+IA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJjJA;AAAA;AAAA;;AA2BA;;AArBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAEA;;;;;;;;;;;;;;;AKUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;ADzDA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AACA;;A9B+rBA;AAAA;A8B/rBA;AACA;;A9B+1BA;AAAA;A8B/1BA;AAEA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADuiBA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;ACnhBA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;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A;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAHA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AAHA;AAAA;AAAA;;AAIA;;;AAOA;AAAA;;;;;AAWA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AAXA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AACA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAOA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;;AAEA;AAIA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;AAvKA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAKA;AAAA;AAAA;;AAJA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;;;;;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;;;;;;;;;;AAuBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;AAdA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AADA;AAAA;AAAA;;;AAEA;AAAA;;;;;;;;;;;;AAbA;;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgNA;AACA;AAKA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AA+EA;AAAA;;AA9EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AA8EA;AAAA;;AA7EA;;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AARA;AAAA;AAAA;;AAUA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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;AAAA;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;AAOA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAhBA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;;;;;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AAAA;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAuBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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AAIA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;;;;;AAOA;AAAA;AAAA;;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAGA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;;;;AAuLA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AA3LA;AACA;AAAA;AACA;AAAA;;AACA;AAAA;AACA;AACA;;;;AAGA;AAAA;AAGA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;;;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AACA;AAAA;AAAA;;;;AAgDA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AA/DA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;;;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AAGA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AA4BA;AAGA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;;;;;;;;;;;AAoDA;AAAA;AAAA;;;AACA;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AA/EA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AA8KA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAEA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AACA;AAAA;AADA;;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;;;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAlBA;AAAA;;;;;;AAsBA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;;;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AAGA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;;AACA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;;AACA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAMA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAIA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;;;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;;AACA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AA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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAIA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;;;;;AAGA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AACA;AAAA;AAAA;;;;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAOA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AARA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAUA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;;;;;;AA7bA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7mCA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AA3FA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAqCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AA5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;ACnBA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AA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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;;;;AALA;AAAA;AAAA;;AAdA;AAAA;AAAA;;AAuBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAEA;AAAA;;AAAA;AAAA;AAAA;;;;;AAAA;AAEA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA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;AAuBA;;AArBA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAGA;;;;;;;;;;AAnnBA;AAAA;AACA;;;;;;;;;;AzBkFA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;AnB7KA;;ACumBA;AAAA;ADvmBA;AACA;;ACuwBA;AAAA;ADvwBA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;A4CysBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AzB1iBA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AyByjBA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AAAA;AAAA;AAEA;AAAA;;AACA;;AACA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAEA;AAAA;;AACA;;AACA;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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;AAKA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AAyTA;;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAPA;AAAA;AAAA;;AAeA;;;;;;;;;ACnnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;ACRA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;A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AAA;;AAAA;;;AACA;AAAA;;AAAA;;;AACA;;;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;;;;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;AAqDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;;;;AAaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;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;;;;;AAEA;;AjDhbA;AAAA;AiDgbA;AACA;AAAA;;AjDjbA;AAAA;AiDibA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AjDpKA;AAAA;AiDoKA;AAEA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAMA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;;AAEA;;;AAIA;AAAA;;AAGA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;AAKA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAGA;;;;AAGA;AACA;;;AAKA;AAEA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAE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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmGA;AAAA;;;AAlGA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAfA;AAAA;AAAA;;AAiBA;AAAA;AAAA;AAlBA;AAAA;AAAA;;;AAqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AACA;;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;AAEA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;A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;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAtBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA0BA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAFA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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;;AAqEA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAhFA;AAAA;;;;;AACA;AACA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;AAOA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AAYA;AAAA;;;;;AACA;AAAA;;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AApBA;AAAA;AAAA;;;AAqBA;AAAA;;AAKA;AACA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYA;AAAA;AAAA;;AAAA;AAAA;AAqCA;AAAA;;AApCA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AA+BA;AAAA;;AA5BA;;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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AAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AASA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAVA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAQA;AAAA;;;;;AAAA;AAAA;AAAA;;;;AAkBA;AAAA;AAAA;AAAA;;;;;AAKA;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAMA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AArCA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;AAEA;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAGA;AAAA;AAAA;AAAA;;AArEA;AAAA;AAAA;;;AAMA;AAAA;AAkLA;AAAA;;;AA/KA;AAAA;;;AA8DA;AAAA;;;AA8BA;AAAA;;;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAQA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AARA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;;;AAKA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;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AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAOA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAwDA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;;AAjEA;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AACA;;;AAEA;AAAA;AAAA;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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAldA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;ADpnBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;;;AAAA;;;;;;;;;ACy0BA;AAAA;;;;;;;;;AAtNA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;ADlpBA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;ACkpBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;ADjqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;ACiqBA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;AAqYA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AArYA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;;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A;AAAA;AhDkXA;AAAA;AAAA;AAAA;;;;;;AgDzWA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAVA;AAAA;AhDkXA;AAAA;AAAA;;;AAMA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AmC64DA;AAAA;;;;AARA;AAAA;;;;AAlyDA;AAAA;AAAA;AAAA;AAAA;AAkyDA;AAAA;AAAA;AnCt4DA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;;AiDxaA;AAAA;AAAA;AAAA;;AjD2aA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AgDzYA;AAAA;AhD0YA;AAAA;;;AgD1YA;AAAA;AhD2YA;AAAA;AAAA;;;;;;;;;;AKkOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ALpOA;AAGA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AgDrYA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAVA;AAAA;AhD8YA;AAAA;AAAA;;;AAEA;;;AgDjZA;AAAA;AhDiZA;AAAA;AAAA;;;;AgDjZA;AAAA;;;AAAA;AAAA;AhDmZA;AAAA;AAAA;;;;;;AgD1YA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAVA;AAAA;AhDmZA;AAAA;AAAA;;;;;;AgDnZA;AAAA;AhDyZA;AAAA;AAAA;;;;;AgD1ZA;AAAA;AhD2ZA;;;;;;;AgDlZA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AhDkZA;AAAA;AACA;AAAA;;;;;;;;;;;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AA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AApDA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AAAA;;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAiCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAnCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AA2BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;AA1BA;AAAA;AACA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;AAGA;AAAA;;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;A1CjsCA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;A4CpPA;AACA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAUA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AApCA;AAAA;AAAA;;AAsCA;;;;;;;;AAjDA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;;;;;;;;AzB6GA;AAAA;AAAA;AACA;;;;;;;;;;;;AnBiCA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAFA;;;AAIA;AAAA;AACA;;AAKA;AAAA;;AAOA;AAAA;AAAA;AACA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;A+ChJA;AACA;;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;AAMA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;AAtBA;AAAA;AAAA;;;AASA;AAoBA;AAAA;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","file":"moottori.js","sourcesContent":["#pragma once\r\n#include <cstring>\r\n\r\n \r\n\r\n#define ASSERTION_ENABLED 1\r\n\r\n#if _WIN32\r\n#define EXPORT extern \"C\" __declspec(dllexport)\r\n#else\r\n#define EXPORT extern \"C\" \r\n#endif\r\n\r\n\r\n\r\n#define Kilobytes(Value) ((Value)*1024LL)\r\n#define Megabytes(Value) (Kilobytes(Value)*1024LL)\r\n#define Gigabytes(Value) (Megabytes(Value)*1024LL)\r\n#define Terabytes(Value) (Gigabytes(Value)*1024LL)\r\n\r\n#define ArrayCount(Array) (sizeof(Array) / sizeof((Array)[0]))\r\n\r\n// #define LOGI(msg) printf(msg);\r\n#define  LOGI(...) printf(__VA_ARGS__)\r\n#define  LOGW(...)  printf(__VA_ARGS__)\r\n#define  LOGE(...)  printf(__VA_ARGS__)\t\r\n\r\n#if ASSERTION_ENABLED == 1\r\n#ifdef _WIN32\r\n#define debugBreak() __debugbreak();\r\n#else\r\n// #include <assert.h>\t\r\n// #define debugBreak() assert(false); // TODO: android break to debugger\r\n#define debugBreak()\r\n#endif\r\n\r\n// plug assert to playback on windows ?\r\n#define ASSERT(expr)   \\\r\n\tif (expr) { } \\\r\n\telse \\\r\n\t{    \\\r\n\t\tdebugBreak();                 \\\r\n\t}\r\n#else\r\n#define ASSERT(expr) \r\n#endif\r\n\r\n\r\n#if __EMSCRIPTEN__1___\r\n#undef ignore\r\n#include <Audio.h>\r\n#include <../src/Audio.cpp>\r\n#endif\r\n\r\n\r\n// some timings\r\n#define NAME(ending) (func_timing##ending)\r\n\r\n#define START_TIMING() \\\r\n\tauto NAME(1)(std::chrono::high_resolution_clock::now()); \\\r\n\r\n#define END_TIMING() \\\r\n\tauto NAME(2)(std::chrono::high_resolution_clock::now());\t\\\r\n\tauto elapsedTime(NAME(2) - NAME(1));\t\t\t\t\t\t\\\r\n\tprintf(\"Time: %f\\n\", std::chrono::duration_cast<std::chrono::duration<float, std::milli>>(elapsedTime).count()  );\r\n\r\n#define START_TIMING2() \\\r\n\tauto NAME(3)(std::chrono::high_resolution_clock::now()); \\\r\n\r\n#define END_TIMING2() \\\r\n\tauto NAME(4)(std::chrono::high_resolution_clock::now());\t\\\r\n\tauto elapsedTime2(NAME(4) - NAME(3));\t\t\t\t\t\t\\\r\n\tprintf(\"Time: %f\\n\", std::chrono::duration_cast<std::chrono::duration<float, std::milli>>(elapsedTime2).count()  );\r\n\r\n\r\n// meta programming\r\n#define introspect()\r\n#define ignore // )\r\n// #define I\r\n// lol\r\n\r\nintrospect() struct Vec2\r\n{\r\n\tfloat x;\r\n\tfloat y;\r\n\r\n\tignore Vec2& operator+=(const Vec2& rhs);\r\n\tignore Vec2& operator-=(const Vec2& rhs);\r\n\tignore friend Vec2 operator+(Vec2 lhs, const Vec2& rhs);\r\n\tignore friend Vec2 operator-(Vec2 lhs, const Vec2& rhs);\r\n\r\n\t// ignore Vec2 operator+=(const float rhs);\r\n\r\n\tignore Vec2& operator*=(const float s);\r\n\tignore Vec2& operator/=(const float s);\r\n\r\n\tignore Vec2 operator*(const float s);\r\n\tignore Vec2 operator/(const float s);\r\n\r\n\tignore float length();\r\n\r\n\tignore void normalizeInPlace();\r\n\tignore void safeNormalizeInPlace();\r\n\tignore Vec2 normalize();\r\n};\r\n\r\n\r\nstatic Vec2 rotateVec(Vec2* vec, float theta)\r\n{\r\n\tfloat cs = cos(theta);\r\n\tfloat sn = sin(theta);\r\n\r\n\tfloat x = vec->x * cs - vec->y * sn;\r\n\tfloat y = vec->x * sn + vec->y * cs;\r\n\r\n\treturn \t{ x, y };\r\n}\r\n\r\nVec2 Vec2::operator/(const float s)\r\n{\r\n\treturn { x / s, y / s };\r\n}\r\n\r\nVec2 Vec2::operator*(const float s)\r\n{\r\n\treturn { x * s, y * s };\r\n}\r\n\r\nvoid Vec2::normalizeInPlace()\r\n{\r\n\tfloat x = (this->x);\r\n\tfloat y = (this->y);\r\n\tfloat l = sqrt(x * x + y * y);\r\n\r\n\tthis->x /= l;\r\n\tthis->y /= l;\r\n}\r\n\r\nvoid Vec2::safeNormalizeInPlace()\r\n{\r\n\tif (this->x == 0.f && this->y == 0.f)\r\n\t\treturn;\r\n\r\n\tfloat x = (this->x);\r\n\tfloat y = (this->y);\r\n\tfloat l = sqrt(x * x + y * y);\r\n\r\n\tthis->x /= l;\r\n\tthis->y /= l;\r\n}\r\n// tll ei pelt vaaroja!\r\nVec2 Vec2::normalize()\r\n{\r\n\tfloat x = (this->x);\r\n\tfloat y = (this->y);\r\n\tfloat l = sqrt(x * x + y * y);\r\n\r\n\treturn { x / l, y / l };\r\n}\r\n\r\nVec2& Vec2::operator+=(const Vec2& rhs)\r\n{\r\n\tx += rhs.x;\t\ty += rhs.y;\r\n\treturn *this;\r\n}\r\n\r\nVec2& Vec2::operator-=(const Vec2& rhs)\r\n{\r\n\tx -= rhs.x;\t\ty -= rhs.y;\r\n\treturn *this;\r\n}\r\n\r\nVec2 operator+(Vec2 lhs, const Vec2& rhs)\r\n{\r\n\treturn { lhs.x + rhs.x, lhs.y + rhs.y };\r\n}\r\n\r\nVec2 operator-(Vec2 lhs, const Vec2& rhs)\r\n{\r\n\treturn { lhs.x - rhs.x, lhs.y - rhs.y };\r\n}\r\n\r\nVec2& Vec2::operator*=(const float s)\r\n{\r\n\tx *= s;\r\n\ty *= s;\r\n\treturn *this;\r\n}\r\n\r\nVec2& Vec2::operator/=(const float s)\r\n{\r\n\tx /= s;\r\n\ty /= s;\r\n\treturn *this;\r\n}\r\n\r\nfloat Vec2::length()\r\n{\r\n\tfloat x = abs(this->x);\r\n\tfloat y = abs(this->y);\r\n\treturn sqrt(x * x + y * y);\r\n}\r\n\r\nintrospect() struct vec3\r\n{\r\n\tfloat x;\r\n\tfloat y;\r\n\tfloat z;\r\n};\r\nintrospect() struct vec4\r\n{\r\n\tunion\r\n\t{\r\n\t\tstruct {\r\n\t\t\tfloat x;\r\n\t\t\tfloat y;\r\n\t\t\tfloat w;\r\n\t\t\tfloat h;\r\n\t\t};\r\n\r\n\t\t// vec2f pos;\r\n\t\t// vec2f ps;\r\n\t};\r\n};\r\n\r\n\r\n\r\nstruct Vertex\r\n{\r\n\tVec2 position;\r\n\tVertex(float x, float y) : position{ x, y } { }\r\n};\r\n\r\n#include <stdint.h>\r\nstruct game_memory;\r\nstruct EngineCore;\r\n\r\n\r\n#define INIT_GAME(name) void name(game_memory *memory, EngineCore* core)\r\ntypedef INIT_GAME(init_game);\r\n\r\n#define UPDATE_GAME(name) void name(game_memory *memory, EngineCore* core)\r\ntypedef UPDATE_GAME(update_Game);\r\n\r\n#define DRAW_GAME(name) void name(game_memory *memory, EngineCore* core)\r\ntypedef DRAW_GAME(draw_Game);\r\n\r\n#define ON_PLAYBACK_START(name) void name(game_memory *memory, EngineCore* core)\r\ntypedef ON_PLAYBACK_START(playback_start);\r\n\r\nstruct game_memory\r\n{\r\n\tbool isInitialized;\r\n\r\n\tuint64_t permanentStorageSize;\r\n\tvoid* permanentStorage;\r\n\r\n\tuint64_t transientStorageSize;\r\n\tvoid* transientStorage;\r\n};\r\n\r\n#define ipos 0\r\n#define iuv  1\r\n#define iid  2\r\n#define icolor 3\r\nstruct RenderData\r\n{\r\n\tfloat* buffer[3];\r\n\tfloat* base[3];\r\n\r\n\tunsigned int* baseColor, *bufferColor;\r\n\r\n\tfloat ts = 0.f;\r\n\tint indCount = 0;\r\n\r\n\tint MAX_TEXTURES = 8;\r\n\tunsigned int textureSlots[32];\r\n\tunsigned int currentSlots = 0;\r\n\r\n\tint maxSize = 0;\r\n\r\n\tvoid initRenderData(int maxSize)\r\n\t{\r\n\t\tbuffer[ipos] = base[ipos] = new float[maxSize * 3 * 4]; // 3 per 4\r\n\t\tbuffer[iuv] = base[iuv] = new float[maxSize * 2 * 4];\r\n\t\tbuffer[iid] = base[iid] = new float[maxSize * 1 * 4];\r\n\t\tbaseColor = bufferColor = new unsigned int[maxSize * 1 * 4];\r\n\t}\r\n\r\n\tvoid setTexture(int texId)\r\n\t{\r\n\t\tbool found = false;\r\n\t\tint i = 0;\r\n\t\tfloat ts = 0.0f;\r\n\t\tfor (; i < MAX_TEXTURES; i++)\r\n\t\t{\r\n\t\t\tif (texId == textureSlots[i])\r\n\t\t\t{\r\n\t\t\t\tts = (float)(i + 1);\r\n\t\t\t\tfound = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!found)  // huom loop ^^\r\n\t\t{\r\n\t\t\ttextureSlots[currentSlots] = texId;\r\n\t\t\t++currentSlots;\r\n\t\t\tts = (float)(currentSlots);\r\n\t\t}\r\n\r\n\t\tthis->ts = ts;\r\n\t}\r\n\r\n\tvoid DrawSprite(vec4* __restrict posSize, vec4* __restrict uv, vec4* __restrict color)\r\n\t{\r\n\t\t// if (indSize == maxIndicesSize)\r\n\t\t\t// *((int*)0) = 12;\r\n\t\t\t//ASSERT(false);\r\n\t\tint r = int(color->x * 255.0f);\r\n\t\tint g = int(color->y * 255.0f);\r\n\t\tint b = int(color->w * 255.0f);\r\n\t\tint a = int(color->h * 255.0f);\r\n\r\n\t\tunsigned int c = (a << 24 | b << 16 | g << 8 | r);\r\n\r\n\r\n\t\t*(bufferColor + 0) = c;\r\n\t\t*(bufferColor + 1) = c;\r\n\t\t*(bufferColor + 2) = c;\r\n\t\t*(bufferColor + 3) = c;\r\n\t\tbufferColor += 4;\r\n\r\n\r\n\t\t*(buffer[ipos] + 0) = posSize->x;\r\n\t\t*(buffer[ipos] + 1) = posSize->y + posSize->h;\r\n\t\t*(buffer[ipos] + 2) = 0.0f;\r\n\r\n\t\t*(buffer[ipos] + 3) = posSize->x;\r\n\t\t*(buffer[ipos] + 4) = posSize->y;\r\n\t\t*(buffer[ipos] + 5) = 0.0f;\r\n\r\n\t\t*(buffer[ipos] + 6) = posSize->x + posSize->w;\r\n\t\t*(buffer[ipos] + 7) = posSize->y;\r\n\t\t*(buffer[ipos] + 8) = 0.0f;\r\n\r\n\t\t*(buffer[ipos] + 9) = posSize->x + posSize->w;\r\n\t\t*(buffer[ipos] + 10) = posSize->y + posSize->h;\r\n\t\t*(buffer[ipos] + 11) = 0.0f;\r\n\r\n\t\tbuffer[ipos] += 12;\r\n\r\n\t\t*(buffer[iuv] + 0) = uv->x;\r\n\t\t*(buffer[iuv] + 1) = uv->y;\r\n\r\n\t\t*(buffer[iuv] + 2) = uv->x;\r\n\t\t*(buffer[iuv] + 3) = uv->y + uv->h;\r\n\r\n\t\t*(buffer[iuv] + 4) = uv->x + uv->w;\r\n\t\t*(buffer[iuv] + 5) = uv->y + uv->h;\r\n\r\n\t\t*(buffer[iuv] + 6) = uv->x + uv->w;\r\n\t\t*(buffer[iuv] + 7) = uv->y;\r\n\r\n\t\tbuffer[iuv] += 8;\r\n\r\n\t\t*(buffer[iid] + 0) = ts;\r\n\t\t*(buffer[iid] + 1) = ts;\r\n\t\t*(buffer[iid] + 2) = ts;\r\n\t\t*(buffer[iid] + 3) = ts;\r\n\r\n\t\tbuffer[iid] += 4;\r\n\t\tindCount += 6;\r\n\t}\r\n\r\n};\r\n\r\n/* initialize state to random bits */\r\nstatic unsigned long state[16];\r\nstatic unsigned int r_index = 0;\r\n/* init should also reset this to 0 */\r\n/* return 32 bit random number */\r\n\r\n#define RNG_MAX 0xffffffff\r\nstatic unsigned long WELLRNG512(void)\r\n{\r\n\tunsigned long a, b, c, d;\r\n\ta = state[r_index];\r\n\tc = state[(r_index + 13) & 15];\r\n\tb = a^c ^ (a << 16) ^ (c << 15);\r\n\tc = state[(r_index + 9) & 15];\r\n\tc ^= (c >> 11);\r\n\ta = state[r_index] = b^c;\r\n\td = a ^ ((a << 5) & 0xDA442D24UL);\r\n\tr_index = (r_index + 15) & 15;\r\n\ta = state[r_index];\r\n\tstate[r_index] = a^b^d ^ (a << 2) ^ (b << 18) ^ (c << 28);\r\n\treturn state[r_index];\r\n}\r\n\r\nstruct Benchmark { float* positions; float* velocities; };\r\n\r\nstatic float RandomFloat(float a, float b) {\r\n\tfloat random = ((float)WELLRNG512()) / (float)RNG_MAX;\r\n\tfloat diff = b - a;\r\n\tfloat r = random * diff;\r\n\treturn a + r;\r\n}\r\n\r\n\r\n// #include \"3\"\r\n// #include <da_array.h>\r\n#include <da_array.h>\r\nstruct FontData\r\n{\r\n\tVec2 position;\r\n\tunsigned int color;\r\n\tint fontId;\r\n\tint size;\r\n};\r\n\r\nstruct Layer\r\n{\r\n\t// engine::shader _shader;\r\n\tunsigned int shader;\r\n\tint order;\r\n\tbool active;\r\n\t// const char* layerName;\r\n\tRenderData* data;\r\n\t// array of sprites or smt\r\n\r\n\tFontData* fontCommands = 0;\r\n\r\n\tchar* strBuffer = 0;\r\n\tint bufferLen = 0;\r\n\tint currentLen = 0;\r\n\r\n\tvoid draw(vec4* __restrict posSize, vec4* __restrict uv, vec4* __restrict color, int textureId)\r\n\t{\r\n\t\tdata->setTexture(textureId);\r\n\t\tdata->DrawSprite(posSize, uv, color);\r\n\t}\r\n\t// automatic caching ^^\r\n\r\n\tvoid setTexture(int id) {\r\n\t\tdata->setTexture(id);\r\n\t}\r\n\r\n\tvoid draw(vec4* __restrict posSize, vec4* __restrict uv, vec4* __restrict color)\r\n\t{\r\n\t\tdata->DrawSprite(posSize, uv, color);\r\n\t}\r\n\r\n#define growLen 4\r\n#define initialBuffer 32\r\n\t// watch out for allocating from dll!\r\n\tvoid drawString(const char* str, Vec2* position, unsigned int color, int fontID) // smt\r\n\t{\r\n\t\tint len = (int)strlen(str);\r\n\t\tif (len + currentLen > bufferLen)\r\n\t\t{\r\n\t\t\tif (!strBuffer) {\r\n\t\t\t\tstrBuffer = (char*)malloc(sizeof(char) * initialBuffer);\r\n\t\t\t\tbufferLen = initialBuffer;\r\n\t\t\t\tcurrentLen = 0;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tchar * buf = NULL;\r\n\t\t\t\tbuf = (char*)realloc(strBuffer, growLen * bufferLen * sizeof(char));\r\n\r\n\t\t\t\tif (buf)\r\n\t\t\t\t{\r\n\t\t\t\t\tstrBuffer = buf;\r\n\t\t\t\t\tbufferLen = growLen * bufferLen;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tFontData e{ *position, color, fontID, len };\r\n\t\tda_push(fontCommands, e);\r\n\r\n\t\tmemcpy(strBuffer + currentLen, str, len);\r\n\t\tcurrentLen += len;\r\n\r\n\t}\r\n};\r\n\r\nenum\r\n{\r\n\tOrder_first,\r\n\tOrder_second,\r\n\tOrder_third,\r\n};\r\n\r\nstatic Layer newLayer(int maxSize, int order)\r\n{\r\n\tLayer newLayer{};\r\n\tnewLayer.active = true;\r\n\tnewLayer.order = order;\r\n\tnewLayer.data = new RenderData();\r\n\tnewLayer.data->initRenderData(maxSize);\r\n\r\n\treturn newLayer;\r\n}\r\n\r\n\r\n\r\n\r\nnamespace textures\r\n{\r\n\tenum\r\n\t{\r\n\t\tTexture_infantry,\r\n\t\tTexture_Alien,\r\n\t\tTexture_Block,\r\n\t\tTexture_Bacterio,\r\n\t\tTexture_InfectionBarOver,\r\n\t\tTexture_InfectionBarUnderr,\r\n\t\tTexture_Tile,\r\n\t\tTexture_Goal,\r\n\t\tTexture_Prei,\r\n\t\tTexture_Player,\r\n\t\tTexture_Menu,\r\n\t\tTexture_Count,\r\n\t};\r\n}\r\n\r\nnamespace shaders\r\n{\r\n\tenum\r\n\t{\r\n\t\tShader_basicFragment,\r\n\t\tShader_basicVertex,\r\n\t};\r\n}\r\n\r\nnamespace engine\r\n{\r\n\tenum resource_type\r\n\t{\r\n\t\tResourceType_texture,\r\n\t\tResourceType_shader,\r\n\t\tResourceType_sound,\r\n\t\tResourceType_file, // ????\r\n\t};\r\n\r\n\tstruct Texture2D\r\n\t{\r\n\t\tint width, height;\r\n\t\tunsigned int ID;\r\n\t\tuint64_t writeTime;\r\n\t};\r\n\r\n\r\n\tstatic const char* ResourcePaths[textures::Texture_Count] = {\r\n\t\t\"assets/infantry.png\",\r\n\t\t\"assets/alienGreen.png\",\r\n\t\t\"assets/block.png\",\r\n\t\t\"assets/bacterio.png\",\r\n\t\t\"assets/InfectionBarO.png\",\r\n\t\t\"assets/InfectionBarU.png\",\r\n\t\t\"assets/tile2.png\",\r\n\t\t\"assets/Goal.png\",\r\n\t\t\"assets/prei2.png\",\r\n\t\t\"assets/player.png\",\r\n\t\t\"assets/menu.png\",\r\n\t};\r\n\r\n\tstruct Resources\r\n\t{\r\n\t\tTexture2D textures[textures::Texture_Count];\r\n\t\tbool      loaded[textures::Texture_Count];\r\n\t\tengine::Texture2D(*loadTexturePtr)(int, int, int, const unsigned char*);\r\n\t};\r\n\r\n\tvoid checkWriteTimes(Resources* resources, resource_type type);\r\n\r\n\t// static Texture2D loadTexture(int width, int height, int bytesPerPixel, const GLubyte* pixels)\r\n\tTexture2D* getTexture(Resources* resources, int id);\r\n}\r\n\r\n\r\n// #define LOG()\r\n\r\n#include <ctime>\r\n#include <stdio.h>\r\n#include <stdarg.h>\r\n\r\n#define LOG_FILE \"error.log\"\r\n#define MAX_BUFFER 2048 * 2 * 2\r\n\r\nstruct LogBuffer\r\n{\r\n\tchar buffer[MAX_BUFFER];\r\n\tint count;\r\n};\r\n\r\nbool restartLog(const char* logFile)\r\n{\r\n\tFILE* file = fopen(logFile, \"w\");\r\n\tif (!file)\r\n\t{\r\n\t\tfprintf(stderr,\r\n\t\t\t\"ERROR: could not open LOG_FILE log file %s for writing\\n\",\r\n\t\t\tLOG_FILE);\r\n\t\treturn false;\r\n\t}\r\n\ttime_t now = time(NULL);\r\n\tchar* date = ctime(&now);\r\n\tfprintf(file, \"LOG_FILE log. local time %s\\n\", date);\r\n\tfclose(file);\r\n\treturn true;\r\n}\r\n\r\nvoid adasdf() {\r\n\tFILE* file = fopen(LOG_FILE, \"a\");\r\n\tif (!file)\r\n\t{\r\n\t\tfprintf(\r\n\t\t\tstderr,\r\n\t\t\t\"ERROR: could not open LOG_FILE %s file for appending\\n\",\r\n\t\t\tLOG_FILE\r\n\t\t);\r\n\t\t// return false;\r\n\t}\r\n}\r\n\r\nbool log(LogBuffer* log, const char* message, ...) // WHAT IS THE LOG LEN\r\n{\r\n\tva_list argptr;\r\n\r\n\tva_start(argptr, message);\r\n\t// vfprintf(file, message, argptr);\r\n\r\n\tint n = vsprintf(log->buffer + log->count, message, argptr);\r\n\tva_end(argptr);\r\n\r\n\tlog->count += n;\r\n\t// fclose(file);\r\n\treturn true;\r\n}\r\n\r\nbool writeLogToFile(LogBuffer* log, int frame, const char* logFile)\r\n{\r\n\tFILE* file;\r\n\tfile = fopen(logFile, \"a\");\r\n\r\n\tif (!file)\r\n\t{\r\n\t\tfprintf(\r\n\t\t\tstderr,\r\n\t\t\t\"ERROR: could not open LOG_FILE %s file for appending\\n\",\r\n\t\t\tLOG_FILE\r\n\t\t);\r\n\t\treturn false;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tchar frameb[64];\r\n\t\tsprintf(frameb, \"frame: %i\", frame);\r\n\t\tfputs(frameb, file);\r\n\t\tfwrite(log->buffer, sizeof(char), log->count, file);\r\n\t\tfputc('\\n', file);\r\n\t\tlog->count = 0;\r\n\t\tfclose(file);\r\n\t}\r\n\treturn true;\r\n}\r\n\r\n#define LOG_VERBAL 1\r\n\r\nstatic LogBuffer* g_log;\r\n\r\n#if LOG_VERBAL\r\n#define LOG(...) log(g_log, __VA_ARGS__)\r\n#else\r\n#define LOG(...)\r\n#endif\r\n\r\n#if LOG_VERBAL\r\n#define WRITE_LOG(log, frame, logFile) writeLogToFile(log, frame, logFile)\r\n#else\r\n#define WRITE_LOG(log, frame, logFile)\r\n#endif\r\n","// -*- C++ -*-\n//===---------------------------- math.h ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MATH_H\n#define _LIBCPP_MATH_H\n\n/*\n    math.h synopsis\n\nMacros:\n\n    HUGE_VAL\n    HUGE_VALF               // C99\n    HUGE_VALL               // C99\n    INFINITY                // C99\n    NAN                     // C99\n    FP_INFINITE             // C99\n    FP_NAN                  // C99\n    FP_NORMAL               // C99\n    FP_SUBNORMAL            // C99\n    FP_ZERO                 // C99\n    FP_FAST_FMA             // C99\n    FP_FAST_FMAF            // C99\n    FP_FAST_FMAL            // C99\n    FP_ILOGB0               // C99\n    FP_ILOGBNAN             // C99\n    MATH_ERRNO              // C99\n    MATH_ERREXCEPT          // C99\n    math_errhandling        // C99\n\nTypes:\n\n    float_t                 // C99\n    double_t                // C99\n\n// C90\n\nfloating_point abs(floating_point x);\n\nfloating_point acos (arithmetic x);\nfloat          acosf(float x);\nlong double    acosl(long double x);\n\nfloating_point asin (arithmetic x);\nfloat          asinf(float x);\nlong double    asinl(long double x);\n\nfloating_point atan (arithmetic x);\nfloat          atanf(float x);\nlong double    atanl(long double x);\n\nfloating_point atan2 (arithmetic y, arithmetic x);\nfloat          atan2f(float y, float x);\nlong double    atan2l(long double y, long double x);\n\nfloating_point ceil (arithmetic x);\nfloat          ceilf(float x);\nlong double    ceill(long double x);\n\nfloating_point cos (arithmetic x);\nfloat          cosf(float x);\nlong double    cosl(long double x);\n\nfloating_point cosh (arithmetic x);\nfloat          coshf(float x);\nlong double    coshl(long double x);\n\nfloating_point exp (arithmetic x);\nfloat          expf(float x);\nlong double    expl(long double x);\n\nfloating_point fabs (arithmetic x);\nfloat          fabsf(float x);\nlong double    fabsl(long double x);\n\nfloating_point floor (arithmetic x);\nfloat          floorf(float x);\nlong double    floorl(long double x);\n\nfloating_point fmod (arithmetic x, arithmetic y);\nfloat          fmodf(float x, float y);\nlong double    fmodl(long double x, long double y);\n\nfloating_point frexp (arithmetic value, int* exp);\nfloat          frexpf(float value, int* exp);\nlong double    frexpl(long double value, int* exp);\n\nfloating_point ldexp (arithmetic value, int exp);\nfloat          ldexpf(float value, int exp);\nlong double    ldexpl(long double value, int exp);\n\nfloating_point log (arithmetic x);\nfloat          logf(float x);\nlong double    logl(long double x);\n\nfloating_point log10 (arithmetic x);\nfloat          log10f(float x);\nlong double    log10l(long double x);\n\nfloating_point modf (floating_point value, floating_point* iptr);\nfloat          modff(float value, float* iptr);\nlong double    modfl(long double value, long double* iptr);\n\nfloating_point pow (arithmetic x, arithmetic y);\nfloat          powf(float x, float y);\nlong double    powl(long double x, long double y);\n\nfloating_point sin (arithmetic x);\nfloat          sinf(float x);\nlong double    sinl(long double x);\n\nfloating_point sinh (arithmetic x);\nfloat          sinhf(float x);\nlong double    sinhl(long double x);\n\nfloating_point sqrt (arithmetic x);\nfloat          sqrtf(float x);\nlong double    sqrtl(long double x);\n\nfloating_point tan (arithmetic x);\nfloat          tanf(float x);\nlong double    tanl(long double x);\n\nfloating_point tanh (arithmetic x);\nfloat          tanhf(float x);\nlong double    tanhl(long double x);\n\n//  C99\n\nbool signbit(arithmetic x);\n\nint fpclassify(arithmetic x);\n\nbool isfinite(arithmetic x);\nbool isinf(arithmetic x);\nbool isnan(arithmetic x);\nbool isnormal(arithmetic x);\n\nbool isgreater(arithmetic x, arithmetic y);\nbool isgreaterequal(arithmetic x, arithmetic y);\nbool isless(arithmetic x, arithmetic y);\nbool islessequal(arithmetic x, arithmetic y);\nbool islessgreater(arithmetic x, arithmetic y);\nbool isunordered(arithmetic x, arithmetic y);\n\nfloating_point acosh (arithmetic x);\nfloat          acoshf(float x);\nlong double    acoshl(long double x);\n\nfloating_point asinh (arithmetic x);\nfloat          asinhf(float x);\nlong double    asinhl(long double x);\n\nfloating_point atanh (arithmetic x);\nfloat          atanhf(float x);\nlong double    atanhl(long double x);\n\nfloating_point cbrt (arithmetic x);\nfloat          cbrtf(float x);\nlong double    cbrtl(long double x);\n\nfloating_point copysign (arithmetic x, arithmetic y);\nfloat          copysignf(float x, float y);\nlong double    copysignl(long double x, long double y);\n\nfloating_point erf (arithmetic x);\nfloat          erff(float x);\nlong double    erfl(long double x);\n\nfloating_point erfc (arithmetic x);\nfloat          erfcf(float x);\nlong double    erfcl(long double x);\n\nfloating_point exp2 (arithmetic x);\nfloat          exp2f(float x);\nlong double    exp2l(long double x);\n\nfloating_point expm1 (arithmetic x);\nfloat          expm1f(float x);\nlong double    expm1l(long double x);\n\nfloating_point fdim (arithmetic x, arithmetic y);\nfloat          fdimf(float x, float y);\nlong double    fdiml(long double x, long double y);\n\nfloating_point fma (arithmetic x, arithmetic y, arithmetic z);\nfloat          fmaf(float x, float y, float z);\nlong double    fmal(long double x, long double y, long double z);\n\nfloating_point fmax (arithmetic x, arithmetic y);\nfloat          fmaxf(float x, float y);\nlong double    fmaxl(long double x, long double y);\n\nfloating_point fmin (arithmetic x, arithmetic y);\nfloat          fminf(float x, float y);\nlong double    fminl(long double x, long double y);\n\nfloating_point hypot (arithmetic x, arithmetic y);\nfloat          hypotf(float x, float y);\nlong double    hypotl(long double x, long double y);\n\nint ilogb (arithmetic x);\nint ilogbf(float x);\nint ilogbl(long double x);\n\nfloating_point lgamma (arithmetic x);\nfloat          lgammaf(float x);\nlong double    lgammal(long double x);\n\nlong long llrint (arithmetic x);\nlong long llrintf(float x);\nlong long llrintl(long double x);\n\nlong long llround (arithmetic x);\nlong long llroundf(float x);\nlong long llroundl(long double x);\n\nfloating_point log1p (arithmetic x);\nfloat          log1pf(float x);\nlong double    log1pl(long double x);\n\nfloating_point log2 (arithmetic x);\nfloat          log2f(float x);\nlong double    log2l(long double x);\n\nfloating_point logb (arithmetic x);\nfloat          logbf(float x);\nlong double    logbl(long double x);\n\nlong lrint (arithmetic x);\nlong lrintf(float x);\nlong lrintl(long double x);\n\nlong lround (arithmetic x);\nlong lroundf(float x);\nlong lroundl(long double x);\n\ndouble      nan (const char* str);\nfloat       nanf(const char* str);\nlong double nanl(const char* str);\n\nfloating_point nearbyint (arithmetic x);\nfloat          nearbyintf(float x);\nlong double    nearbyintl(long double x);\n\nfloating_point nextafter (arithmetic x, arithmetic y);\nfloat          nextafterf(float x, float y);\nlong double    nextafterl(long double x, long double y);\n\nfloating_point nexttoward (arithmetic x, long double y);\nfloat          nexttowardf(float x, long double y);\nlong double    nexttowardl(long double x, long double y);\n\nfloating_point remainder (arithmetic x, arithmetic y);\nfloat          remainderf(float x, float y);\nlong double    remainderl(long double x, long double y);\n\nfloating_point remquo (arithmetic x, arithmetic y, int* pquo);\nfloat          remquof(float x, float y, int* pquo);\nlong double    remquol(long double x, long double y, int* pquo);\n\nfloating_point rint (arithmetic x);\nfloat          rintf(float x);\nlong double    rintl(long double x);\n\nfloating_point round (arithmetic x);\nfloat          roundf(float x);\nlong double    roundl(long double x);\n\nfloating_point scalbln (arithmetic x, long ex);\nfloat          scalblnf(float x, long ex);\nlong double    scalblnl(long double x, long ex);\n\nfloating_point scalbn (arithmetic x, int ex);\nfloat          scalbnf(float x, int ex);\nlong double    scalbnl(long double x, int ex);\n\nfloating_point tgamma (arithmetic x);\nfloat          tgammaf(float x);\nlong double    tgammal(long double x);\n\nfloating_point trunc (arithmetic x);\nfloat          truncf(float x);\nlong double    truncl(long double x);\n\n*/\n\n#include <__config>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#include_next <math.h>\n\n#ifdef __cplusplus\n\n// We support including .h headers inside 'extern \"C\"' contexts, so switch\n// back to C++ linkage before including these C++ headers.\nextern \"C++\" {\n\n#include <type_traits>\n\n// signbit\n\n#ifdef signbit\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_signbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return signbit(__lcpp_x);\n}\n\n#undef signbit\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nsignbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // signbit\n\n// fpclassify\n\n#ifdef fpclassify\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nint\n__libcpp_fpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return fpclassify(__lcpp_x);\n}\n\n#undef fpclassify\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, int>::type\nfpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // fpclassify\n\n// isfinite\n\n#ifdef isfinite\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isfinite(__lcpp_x);\n}\n\n#undef isfinite\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isfinite\n\n// isinf\n\n#ifdef isinf\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isinf(__lcpp_x);\n}\n\n#undef isinf\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isinf\n\n// isnan\n\n#ifdef isnan\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnan(__lcpp_x);\n}\n\n#undef isnan\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isnan\n\n// isnormal\n\n#ifdef isnormal\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnormal(__lcpp_x);\n}\n\n#undef isnormal\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isnormal\n\n// isgreater\n\n#ifdef isgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreater\n\n// isgreaterequal\n\n#ifdef isgreaterequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreaterequal(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreaterequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreaterequal\n\n// isless\n\n#ifdef isless\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isless(__lcpp_x, __lcpp_y);\n}\n\n#undef isless\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isless\n\n// islessequal\n\n#ifdef islessequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessequal(__lcpp_x, __lcpp_y);\n}\n\n#undef islessequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessequal\n\n// islessgreater\n\n#ifdef islessgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef islessgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessgreater\n\n// isunordered\n\n#ifdef isunordered\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isunordered(__lcpp_x, __lcpp_y);\n}\n\n#undef isunordered\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isunordered\n\n// abs\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY\nfloat\nabs(float __lcpp_x) _NOEXCEPT {return fabsf(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\ndouble\nabs(double __lcpp_x) _NOEXCEPT {return fabs(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong double\nabs(long double __lcpp_x) _NOEXCEPT {return fabsl(__lcpp_x);}\n#endif // !(defined(_AIX) || defined(__sun__))\n\n// acos\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       acos(float __lcpp_x) _NOEXCEPT       {return acosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acos(long double __lcpp_x) _NOEXCEPT {return acosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nacos(_A1 __lcpp_x) _NOEXCEPT {return acos((double)__lcpp_x);}\n\n// asin\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       asin(float __lcpp_x) _NOEXCEPT       {return asinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asin(long double __lcpp_x) _NOEXCEPT {return asinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nasin(_A1 __lcpp_x) _NOEXCEPT {return asin((double)__lcpp_x);}\n\n// atan\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       atan(float __lcpp_x) _NOEXCEPT       {return atanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan(long double __lcpp_x) _NOEXCEPT {return atanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\natan(_A1 __lcpp_x) _NOEXCEPT {return atan((double)__lcpp_x);}\n\n// atan2\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       atan2(float __lcpp_y, float __lcpp_x) _NOEXCEPT             {return atan2f(__lcpp_y, __lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan2(long double __lcpp_y, long double __lcpp_x) _NOEXCEPT {return atan2l(__lcpp_y, __lcpp_x);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\natan2(_A1 __lcpp_y, _A2 __lcpp_x) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);\n}\n\n// ceil\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       ceil(float __lcpp_x) _NOEXCEPT       {return ceilf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double ceil(long double __lcpp_x) _NOEXCEPT {return ceill(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nceil(_A1 __lcpp_x) _NOEXCEPT {return ceil((double)__lcpp_x);}\n\n// cos\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       cos(float __lcpp_x) _NOEXCEPT       {return cosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cos(long double __lcpp_x) _NOEXCEPT {return cosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncos(_A1 __lcpp_x) _NOEXCEPT {return cos((double)__lcpp_x);}\n\n// cosh\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       cosh(float __lcpp_x) _NOEXCEPT       {return coshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cosh(long double __lcpp_x) _NOEXCEPT {return coshl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncosh(_A1 __lcpp_x) _NOEXCEPT {return cosh((double)__lcpp_x);}\n\n// exp\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       exp(float __lcpp_x) _NOEXCEPT       {return expf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp(long double __lcpp_x) _NOEXCEPT {return expl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexp(_A1 __lcpp_x) _NOEXCEPT {return exp((double)__lcpp_x);}\n\n// fabs\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       fabs(float __lcpp_x) _NOEXCEPT       {return fabsf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double fabs(long double __lcpp_x) _NOEXCEPT {return fabsl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfabs(_A1 __lcpp_x) _NOEXCEPT {return fabs((double)__lcpp_x);}\n\n// floor\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       floor(float __lcpp_x) _NOEXCEPT       {return floorf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double floor(long double __lcpp_x) _NOEXCEPT {return floorl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfloor(_A1 __lcpp_x) _NOEXCEPT {return floor((double)__lcpp_x);}\n\n// fmod\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       fmod(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fmodf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmod(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fmodl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmod(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// frexp\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       frexp(float __lcpp_x, int* __lcpp_e) _NOEXCEPT       {return frexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double frexp(long double __lcpp_x, int* __lcpp_e) _NOEXCEPT {return frexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfrexp(_A1 __lcpp_x, int* __lcpp_e) _NOEXCEPT {return frexp((double)__lcpp_x, __lcpp_e);}\n\n// ldexp\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       ldexp(float __lcpp_x, int __lcpp_e) _NOEXCEPT       {return ldexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double ldexp(long double __lcpp_x, int __lcpp_e) _NOEXCEPT {return ldexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nldexp(_A1 __lcpp_x, int __lcpp_e) _NOEXCEPT {return ldexp((double)__lcpp_x, __lcpp_e);}\n\n// log\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       log(float __lcpp_x) _NOEXCEPT       {return logf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log(long double __lcpp_x) _NOEXCEPT {return logl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog(_A1 __lcpp_x) _NOEXCEPT {return log((double)__lcpp_x);}\n\n// log10\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       log10(float __lcpp_x) _NOEXCEPT       {return log10f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log10(long double __lcpp_x) _NOEXCEPT {return log10l(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog10(_A1 __lcpp_x) _NOEXCEPT {return log10((double)__lcpp_x);}\n\n// modf\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       modf(float __lcpp_x, float* __lcpp_y) _NOEXCEPT             {return modff(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double modf(long double __lcpp_x, long double* __lcpp_y) _NOEXCEPT {return modfl(__lcpp_x, __lcpp_y);}\n#endif\n\n// pow\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       pow(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return powf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double pow(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return powl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\npow(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// sin\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       sin(float __lcpp_x) _NOEXCEPT       {return sinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sin(long double __lcpp_x) _NOEXCEPT {return sinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsin(_A1 __lcpp_x) _NOEXCEPT {return sin((double)__lcpp_x);}\n\n// sinh\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       sinh(float __lcpp_x) _NOEXCEPT       {return sinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sinh(long double __lcpp_x) _NOEXCEPT {return sinhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsinh(_A1 __lcpp_x) _NOEXCEPT {return sinh((double)__lcpp_x);}\n\n// sqrt\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       sqrt(float __lcpp_x) _NOEXCEPT       {return sqrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sqrt(long double __lcpp_x) _NOEXCEPT {return sqrtl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsqrt(_A1 __lcpp_x) _NOEXCEPT {return sqrt((double)__lcpp_x);}\n\n// tan\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       tan(float __lcpp_x) _NOEXCEPT       {return tanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tan(long double __lcpp_x) _NOEXCEPT {return tanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntan(_A1 __lcpp_x) _NOEXCEPT {return tan((double)__lcpp_x);}\n\n// tanh\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       tanh(float __lcpp_x) _NOEXCEPT       {return tanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tanh(long double __lcpp_x) _NOEXCEPT {return tanhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntanh(_A1 __lcpp_x) _NOEXCEPT {return tanh((double)__lcpp_x);}\n\n// acosh\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       acosh(float __lcpp_x) _NOEXCEPT       {return acoshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acosh(long double __lcpp_x) _NOEXCEPT {return acoshl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nacosh(_A1 __lcpp_x) _NOEXCEPT {return acosh((double)__lcpp_x);}\n#endif\n\n// asinh\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       asinh(float __lcpp_x) _NOEXCEPT       {return asinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asinh(long double __lcpp_x) _NOEXCEPT {return asinhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nasinh(_A1 __lcpp_x) _NOEXCEPT {return asinh((double)__lcpp_x);}\n#endif\n\n// atanh\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       atanh(float __lcpp_x) _NOEXCEPT       {return atanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atanh(long double __lcpp_x) _NOEXCEPT {return atanhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\natanh(_A1 __lcpp_x) _NOEXCEPT {return atanh((double)__lcpp_x);}\n#endif\n\n// cbrt\n\n#ifndef _LIBCPP_MSVCRT\ninline _LIBCPP_INLINE_VISIBILITY float       cbrt(float __lcpp_x) _NOEXCEPT       {return cbrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cbrt(long double __lcpp_x) _NOEXCEPT {return cbrtl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncbrt(_A1 __lcpp_x) _NOEXCEPT {return cbrt((double)__lcpp_x);}\n#endif\n\n// copysign\n\n#if !defined(_VC_CRT_MAJOR_VERSION) || (_VC_CRT_MAJOR_VERSION < 12)\ninline _LIBCPP_INLINE_VISIBILITY float copysign(float __lcpp_x,\n                                                float __lcpp_y) _NOEXCEPT {\n  return copysignf(__lcpp_x, __lcpp_y);\n}\ninline _LIBCPP_INLINE_VISIBILITY long double\ncopysign(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {\n  return copysignl(__lcpp_x, __lcpp_y);\n}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\ncopysign(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n#ifndef _LIBCPP_MSVCRT\n\n// erf\n\ninline _LIBCPP_INLINE_VISIBILITY float       erf(float __lcpp_x) _NOEXCEPT       {return erff(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erf(long double __lcpp_x) _NOEXCEPT {return erfl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nerf(_A1 __lcpp_x) _NOEXCEPT {return erf((double)__lcpp_x);}\n\n// erfc\n\ninline _LIBCPP_INLINE_VISIBILITY float       erfc(float __lcpp_x) _NOEXCEPT       {return erfcf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erfc(long double __lcpp_x) _NOEXCEPT {return erfcl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nerfc(_A1 __lcpp_x) _NOEXCEPT {return erfc((double)__lcpp_x);}\n\n// exp2\n\ninline _LIBCPP_INLINE_VISIBILITY float       exp2(float __lcpp_x) _NOEXCEPT       {return exp2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp2(long double __lcpp_x) _NOEXCEPT {return exp2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexp2(_A1 __lcpp_x) _NOEXCEPT {return exp2((double)__lcpp_x);}\n\n// expm1\n\ninline _LIBCPP_INLINE_VISIBILITY float       expm1(float __lcpp_x) _NOEXCEPT       {return expm1f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double expm1(long double __lcpp_x) _NOEXCEPT {return expm1l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexpm1(_A1 __lcpp_x) _NOEXCEPT {return expm1((double)__lcpp_x);}\n\n// fdim\n\ninline _LIBCPP_INLINE_VISIBILITY float       fdim(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fdimf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fdim(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fdiml(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfdim(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fma\n\ninline _LIBCPP_INLINE_VISIBILITY float       fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) _NOEXCEPT                   {return fmaf(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) _NOEXCEPT {return fmal(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2, class _A3>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value &&\n    std::is_arithmetic<_A3>::value,\n    std::__promote<_A1, _A2, _A3>\n>::type\nfma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2, _A3>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value &&\n                     std::is_same<_A3, __result_type>::value)), \"\");\n    return fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);\n}\n\n// fmax\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmax(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fmaxf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmax(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fmaxl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmax(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fmin\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmin(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fminf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmin(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fminl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmin(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// hypot\n\ninline _LIBCPP_INLINE_VISIBILITY float       hypot(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return hypotf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double hypot(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return hypotl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nhypot(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// ilogb\n\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(float __lcpp_x) _NOEXCEPT       {return ilogbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(long double __lcpp_x) _NOEXCEPT {return ilogbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, int>::type\nilogb(_A1 __lcpp_x) _NOEXCEPT {return ilogb((double)__lcpp_x);}\n\n// lgamma\n\ninline _LIBCPP_INLINE_VISIBILITY float       lgamma(float __lcpp_x) _NOEXCEPT       {return lgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double lgamma(long double __lcpp_x) _NOEXCEPT {return lgammal(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlgamma(_A1 __lcpp_x) _NOEXCEPT {return lgamma((double)__lcpp_x);}\n\n// llrint\n\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(float __lcpp_x) _NOEXCEPT       {return llrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(long double __lcpp_x) _NOEXCEPT {return llrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long long>::type\nllrint(_A1 __lcpp_x) _NOEXCEPT {return llrint((double)__lcpp_x);}\n\n// llround\n\ninline _LIBCPP_INLINE_VISIBILITY long long llround(float __lcpp_x) _NOEXCEPT       {return llroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llround(long double __lcpp_x) _NOEXCEPT {return llroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long long>::type\nllround(_A1 __lcpp_x) _NOEXCEPT {return llround((double)__lcpp_x);}\n\n// log1p\n\ninline _LIBCPP_INLINE_VISIBILITY float       log1p(float __lcpp_x) _NOEXCEPT       {return log1pf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log1p(long double __lcpp_x) _NOEXCEPT {return log1pl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog1p(_A1 __lcpp_x) _NOEXCEPT {return log1p((double)__lcpp_x);}\n\n// log2\n\ninline _LIBCPP_INLINE_VISIBILITY float       log2(float __lcpp_x) _NOEXCEPT       {return log2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log2(long double __lcpp_x) _NOEXCEPT {return log2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog2(_A1 __lcpp_x) _NOEXCEPT {return log2((double)__lcpp_x);}\n\n// logb\n\ninline _LIBCPP_INLINE_VISIBILITY float       logb(float __lcpp_x) _NOEXCEPT       {return logbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double logb(long double __lcpp_x) _NOEXCEPT {return logbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlogb(_A1 __lcpp_x) _NOEXCEPT {return logb((double)__lcpp_x);}\n\n// lrint\n\ninline _LIBCPP_INLINE_VISIBILITY long lrint(float __lcpp_x) _NOEXCEPT       {return lrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lrint(long double __lcpp_x) _NOEXCEPT {return lrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long>::type\nlrint(_A1 __lcpp_x) _NOEXCEPT {return lrint((double)__lcpp_x);}\n\n// lround\n\ninline _LIBCPP_INLINE_VISIBILITY long lround(float __lcpp_x) _NOEXCEPT       {return lroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lround(long double __lcpp_x) _NOEXCEPT {return lroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long>::type\nlround(_A1 __lcpp_x) _NOEXCEPT {return lround((double)__lcpp_x);}\n\n// nan\n\n// nearbyint\n\ninline _LIBCPP_INLINE_VISIBILITY float       nearbyint(float __lcpp_x) _NOEXCEPT       {return nearbyintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double nearbyint(long double __lcpp_x) _NOEXCEPT {return nearbyintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nnearbyint(_A1 __lcpp_x) _NOEXCEPT {return nearbyint((double)__lcpp_x);}\n\n// nextafter\n\ninline _LIBCPP_INLINE_VISIBILITY float       nextafter(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return nextafterf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nextafter(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nextafterl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nnextafter(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// nexttoward\n\ninline _LIBCPP_INLINE_VISIBILITY float       nexttoward(float __lcpp_x, long double __lcpp_y) _NOEXCEPT       {return nexttowardf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nexttoward(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nexttowardl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nnexttoward(_A1 __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nexttoward((double)__lcpp_x, __lcpp_y);}\n\n// remainder\n\ninline _LIBCPP_INLINE_VISIBILITY float       remainder(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return remainderf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double remainder(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return remainderl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nremainder(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// remquo\n\ninline _LIBCPP_INLINE_VISIBILITY float       remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) _NOEXCEPT             {return remquof(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) _NOEXCEPT {return remquol(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nremquo(_A1 __lcpp_x, _A2 __lcpp_y, int* __lcpp_z) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);\n}\n\n// rint\n\ninline _LIBCPP_INLINE_VISIBILITY float       rint(float __lcpp_x) _NOEXCEPT       {return rintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double rint(long double __lcpp_x) _NOEXCEPT {return rintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nrint(_A1 __lcpp_x) _NOEXCEPT {return rint((double)__lcpp_x);}\n\n// round\n\ninline _LIBCPP_INLINE_VISIBILITY float       round(float __lcpp_x) _NOEXCEPT       {return roundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double round(long double __lcpp_x) _NOEXCEPT {return roundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nround(_A1 __lcpp_x) _NOEXCEPT {return round((double)__lcpp_x);}\n\n// scalbln\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbln(float __lcpp_x, long __lcpp_y) _NOEXCEPT       {return scalblnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbln(long double __lcpp_x, long __lcpp_y) _NOEXCEPT {return scalblnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nscalbln(_A1 __lcpp_x, long __lcpp_y) _NOEXCEPT {return scalbln((double)__lcpp_x, __lcpp_y);}\n\n// scalbn\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbn(float __lcpp_x, int __lcpp_y) _NOEXCEPT       {return scalbnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbn(long double __lcpp_x, int __lcpp_y) _NOEXCEPT {return scalbnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nscalbn(_A1 __lcpp_x, int __lcpp_y) _NOEXCEPT {return scalbn((double)__lcpp_x, __lcpp_y);}\n\n// tgamma\n\ninline _LIBCPP_INLINE_VISIBILITY float       tgamma(float __lcpp_x) _NOEXCEPT       {return tgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tgamma(long double __lcpp_x) _NOEXCEPT {return tgammal(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntgamma(_A1 __lcpp_x) _NOEXCEPT {return tgamma((double)__lcpp_x);}\n\n// trunc\n\ninline _LIBCPP_INLINE_VISIBILITY float       trunc(float __lcpp_x) _NOEXCEPT       {return truncf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double trunc(long double __lcpp_x) _NOEXCEPT {return truncl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntrunc(_A1 __lcpp_x) _NOEXCEPT {return trunc((double)__lcpp_x);}\n\n#endif // !_LIBCPP_MSVCRT\n\n} // extern \"C++\"\n\n#endif // __cplusplus\n\n#endif  // _LIBCPP_MATH_H\n","/* stb_image - v2.16 - public domain image loader - http://nothings.org/stb_image.h\r\n                                     no warranty implied; use at your own risk\r\n\r\n   Do this:\r\n      #define STB_IMAGE_IMPLEMENTATION\r\n   before you include this file in *one* C or C++ file to create the implementation.\r\n\r\n   // i.e. it should look like this:\r\n   #include ...\r\n   #include ...\r\n   #include ...\r\n   #define STB_IMAGE_IMPLEMENTATION\r\n   #include \"stb_image.h\"\r\n\r\n   You can #define STBI_ASSERT(x) before the #include to avoid using assert.h.\r\n   And #define STBI_MALLOC, STBI_REALLOC, and STBI_FREE to avoid using malloc,realloc,free\r\n\r\n\r\n   QUICK NOTES:\r\n      Primarily of interest to game developers and other people who can\r\n          avoid problematic images and only need the trivial interface\r\n\r\n      JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)\r\n      PNG 1/2/4/8/16-bit-per-channel\r\n\r\n      TGA (not sure what subset, if a subset)\r\n      BMP non-1bpp, non-RLE\r\n      PSD (composited view only, no extra channels, 8/16 bit-per-channel)\r\n\r\n      GIF (*comp always reports as 4-channel)\r\n      HDR (radiance rgbE format)\r\n      PIC (Softimage PIC)\r\n      PNM (PPM and PGM binary only)\r\n\r\n      Animated GIF still needs a proper API, but here's one way to do it:\r\n          http://gist.github.com/urraka/685d9a6340b26b830d49\r\n\r\n      - decode from memory or through FILE (define STBI_NO_STDIO to remove code)\r\n      - decode from arbitrary I/O callbacks\r\n      - SIMD acceleration on x86/x64 (SSE2) and ARM (NEON)\r\n\r\n   Full documentation under \"DOCUMENTATION\" below.\r\n\r\n\r\nLICENSE\r\n\r\n  See end of file for license information.\r\n\r\nRECENT REVISION HISTORY:\r\n\r\n      2.16  (2017-07-23) all functions have 16-bit variants; optimizations; bugfixes\r\n      2.15  (2017-03-18) fix png-1,2,4; all Imagenet JPGs; no runtime SSE detection on GCC\r\n      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs\r\n      2.13  (2016-12-04) experimental 16-bit API, only for PNG so far; fixes\r\n      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes\r\n      2.11  (2016-04-02) 16-bit PNGS; enable SSE2 in non-gcc x64\r\n                         RGB-format JPEG; remove white matting in PSD;\r\n                         allocate large structures on the stack;\r\n                         correct channel count for PNG & BMP\r\n      2.10  (2016-01-22) avoid warning introduced in 2.09\r\n      2.09  (2016-01-16) 16-bit TGA; comments in PNM files; STBI_REALLOC_SIZED\r\n\r\n   See end of file for full revision history.\r\n\r\n\r\n ============================    Contributors    =========================\r\n\r\n Image formats                          Extensions, features\r\n    Sean Barrett (jpeg, png, bmp)          Jetro Lauha (stbi_info)\r\n    Nicolas Schulz (hdr, psd)              Martin \"SpartanJ\" Golini (stbi_info)\r\n    Jonathan Dummer (tga)                  James \"moose2000\" Brown (iPhone PNG)\r\n    Jean-Marc Lienher (gif)                Ben \"Disch\" Wenger (io callbacks)\r\n    Tom Seddon (pic)                       Omar Cornut (1/2/4-bit PNG)\r\n    Thatcher Ulrich (psd)                  Nicolas Guillemot (vertical flip)\r\n    Ken Miller (pgm, ppm)                  Richard Mitton (16-bit PSD)\r\n    github:urraka (animated gif)           Junggon Kim (PNM comments)\r\n                                           Daniel Gibson (16-bit TGA)\r\n                                           socks-the-fox (16-bit PNG)\r\n                                           Jeremy Sawicki (handle all ImageNet JPGs)\r\n Optimizations & bugfixes\r\n    Fabian \"ryg\" Giesen\r\n    Arseny Kapoulkine\r\n    John-Mark Allen\r\n\r\n Bug & warning fixes\r\n    Marc LeBlanc            David Woo          Guillaume George   Martins Mozeiko\r\n    Christpher Lloyd        Jerry Jansson      Joseph Thomson     Phil Jordan\r\n    Dave Moore              Roy Eltham         Hayaki Saito       Nathan Reed\r\n    Won Chun                Luke Graham        Johan Duparc       Nick Verigakis\r\n    the Horde3D community   Thomas Ruf         Ronny Chevalier    Baldur Karlsson\r\n    Janez Zemva             John Bartholomew   Michal Cichon      github:rlyeh\r\n    Jonathan Blow           Ken Hamada         Tero Hanninen      github:romigrou\r\n    Laurent Gomila          Cort Stratton      Sergio Gonzalez    github:svdijk\r\n    Aruelien Pocheville     Thibault Reuille   Cass Everitt       github:snagar\r\n    Ryamond Barbiero        Paul Du Bois       Engin Manap        github:Zelex\r\n    Michaelangel007@github  Philipp Wiesemann  Dale Weiler        github:grim210\r\n    Oriol Ferrer Mesia      Josh Tobin         Matthew Gregan     github:sammyhw\r\n    Blazej Dariusz Roszkowski                  Gregory Mullen     github:phprus\r\n    Christian Floisand      Kevin Schmidt                         github:poppolopoppo\r\n*/\r\n\r\n#ifndef STBI_INCLUDE_STB_IMAGE_H\r\n#define STBI_INCLUDE_STB_IMAGE_H\r\n\r\n// DOCUMENTATION\r\n//\r\n// Limitations:\r\n//    - no 16-bit-per-channel PNG\r\n//    - no 12-bit-per-channel JPEG\r\n//    - no JPEGs with arithmetic coding\r\n//    - no 1-bit BMP\r\n//    - GIF always returns *comp=4\r\n//\r\n// Basic usage (see HDR discussion below for HDR usage):\r\n//    int x,y,n;\r\n//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);\r\n//    // ... process data if not NULL ...\r\n//    // ... x = width, y = height, n = # 8-bit components per pixel ...\r\n//    // ... replace '0' with '1'..'4' to force that many components per pixel\r\n//    // ... but 'n' will always be the number that it would have been if you said 0\r\n//    stbi_image_free(data)\r\n//\r\n// Standard parameters:\r\n//    int *x                 -- outputs image width in pixels\r\n//    int *y                 -- outputs image height in pixels\r\n//    int *channels_in_file  -- outputs # of image components in image file\r\n//    int desired_channels   -- if non-zero, # of image components requested in result\r\n//\r\n// The return value from an image loader is an 'unsigned char *' which points\r\n// to the pixel data, or NULL on an allocation failure or if the image is\r\n// corrupt or invalid. The pixel data consists of *y scanlines of *x pixels,\r\n// with each pixel consisting of N interleaved 8-bit components; the first\r\n// pixel pointed to is top-left-most in the image. There is no padding between\r\n// image scanlines or between pixels, regardless of format. The number of\r\n// components N is 'desired_channels' if desired_channels is non-zero, or\r\n// *channels_in_file otherwise. If desired_channels is non-zero,\r\n// *channels_in_file has the number of components that _would_ have been\r\n// output otherwise. E.g. if you set desired_channels to 4, you will always\r\n// get RGBA output, but you can check *channels_in_file to see if it's trivially\r\n// opaque because e.g. there were only 3 channels in the source image.\r\n//\r\n// An output image with N components has the following components interleaved\r\n// in this order in each pixel:\r\n//\r\n//     N=#comp     components\r\n//       1           grey\r\n//       2           grey, alpha\r\n//       3           red, green, blue\r\n//       4           red, green, blue, alpha\r\n//\r\n// If image loading fails for any reason, the return value will be NULL,\r\n// and *x, *y, *channels_in_file will be unchanged. The function\r\n// stbi_failure_reason() can be queried for an extremely brief, end-user\r\n// unfriendly explanation of why the load failed. Define STBI_NO_FAILURE_STRINGS\r\n// to avoid compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly\r\n// more user-friendly ones.\r\n//\r\n// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.\r\n//\r\n// ===========================================================================\r\n//\r\n// Philosophy\r\n//\r\n// stb libraries are designed with the following priorities:\r\n//\r\n//    1. easy to use\r\n//    2. easy to maintain\r\n//    3. good performance\r\n//\r\n// Sometimes I let \"good performance\" creep up in priority over \"easy to maintain\",\r\n// and for best performance I may provide less-easy-to-use APIs that give higher\r\n// performance, in addition to the easy to use ones. Nevertheless, it's important\r\n// to keep in mind that from the standpoint of you, a client of this library,\r\n// all you care about is #1 and #3, and stb libraries DO NOT emphasize #3 above all.\r\n//\r\n// Some secondary priorities arise directly from the first two, some of which\r\n// make more explicit reasons why performance can't be emphasized.\r\n//\r\n//    - Portable (\"ease of use\")\r\n//    - Small source code footprint (\"easy to maintain\")\r\n//    - No dependencies (\"ease of use\")\r\n//\r\n// ===========================================================================\r\n//\r\n// I/O callbacks\r\n//\r\n// I/O callbacks allow you to read from arbitrary sources, like packaged\r\n// files or some other source. Data read from callbacks are processed\r\n// through a small internal buffer (currently 128 bytes) to try to reduce\r\n// overhead.\r\n//\r\n// The three functions you must define are \"read\" (reads some bytes of data),\r\n// \"skip\" (skips some bytes of data), \"eof\" (reports if the stream is at the end).\r\n//\r\n// ===========================================================================\r\n//\r\n// SIMD support\r\n//\r\n// The JPEG decoder will try to automatically use SIMD kernels on x86 when\r\n// supported by the compiler. For ARM Neon support, you must explicitly\r\n// request it.\r\n//\r\n// (The old do-it-yourself SIMD API is no longer supported in the current\r\n// code.)\r\n//\r\n// On x86, SSE2 will automatically be used when available based on a run-time\r\n// test; if not, the generic C versions are used as a fall-back. On ARM targets,\r\n// the typical path is to have separate builds for NEON and non-NEON devices\r\n// (at least this is true for iOS and Android). Therefore, the NEON support is\r\n// toggled by a build flag: define STBI_NEON to get NEON loops.\r\n//\r\n// If for some reason you do not want to use any of SIMD code, or if\r\n// you have issues compiling it, you can disable it entirely by\r\n// defining STBI_NO_SIMD.\r\n//\r\n// ===========================================================================\r\n//\r\n// HDR image support   (disable by defining STBI_NO_HDR)\r\n//\r\n// stb_image now supports loading HDR images in general, and currently\r\n// the Radiance .HDR file format, although the support is provided\r\n// generically. You can still load any file through the existing interface;\r\n// if you attempt to load an HDR file, it will be automatically remapped to\r\n// LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;\r\n// both of these constants can be reconfigured through this interface:\r\n//\r\n//     stbi_hdr_to_ldr_gamma(2.2f);\r\n//     stbi_hdr_to_ldr_scale(1.0f);\r\n//\r\n// (note, do not use _inverse_ constants; stbi_image will invert them\r\n// appropriately).\r\n//\r\n// Additionally, there is a new, parallel interface for loading files as\r\n// (linear) floats to preserve the full dynamic range:\r\n//\r\n//    float *data = stbi_loadf(filename, &x, &y, &n, 0);\r\n//\r\n// If you load LDR images through this interface, those images will\r\n// be promoted to floating point values, run through the inverse of\r\n// constants corresponding to the above:\r\n//\r\n//     stbi_ldr_to_hdr_scale(1.0f);\r\n//     stbi_ldr_to_hdr_gamma(2.2f);\r\n//\r\n// Finally, given a filename (or an open file or memory block--see header\r\n// file for details) containing image data, you can query for the \"most\r\n// appropriate\" interface to use (that is, whether the image is HDR or\r\n// not), using:\r\n//\r\n//     stbi_is_hdr(char *filename);\r\n//\r\n// ===========================================================================\r\n//\r\n// iPhone PNG support:\r\n//\r\n// By default we convert iphone-formatted PNGs back to RGB, even though\r\n// they are internally encoded differently. You can disable this conversion\r\n// by by calling stbi_convert_iphone_png_to_rgb(0), in which case\r\n// you will always just get the native iphone \"format\" through (which\r\n// is BGR stored in RGB).\r\n//\r\n// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per\r\n// pixel to remove any premultiplied alpha *only* if the image file explicitly\r\n// says there's premultiplied data (currently only happens in iPhone images,\r\n// and only if iPhone convert-to-rgb processing is on).\r\n//\r\n// ===========================================================================\r\n//\r\n// ADDITIONAL CONFIGURATION\r\n//\r\n//  - You can suppress implementation of any of the decoders to reduce\r\n//    your code footprint by #defining one or more of the following\r\n//    symbols before creating the implementation.\r\n//\r\n//        STBI_NO_JPEG\r\n//        STBI_NO_PNG\r\n//        STBI_NO_BMP\r\n//        STBI_NO_PSD\r\n//        STBI_NO_TGA\r\n//        STBI_NO_GIF\r\n//        STBI_NO_HDR\r\n//        STBI_NO_PIC\r\n//        STBI_NO_PNM   (.ppm and .pgm)\r\n//\r\n//  - You can request *only* certain decoders and suppress all other ones\r\n//    (this will be more forward-compatible, as addition of new decoders\r\n//    doesn't require you to disable them explicitly):\r\n//\r\n//        STBI_ONLY_JPEG\r\n//        STBI_ONLY_PNG\r\n//        STBI_ONLY_BMP\r\n//        STBI_ONLY_PSD\r\n//        STBI_ONLY_TGA\r\n//        STBI_ONLY_GIF\r\n//        STBI_ONLY_HDR\r\n//        STBI_ONLY_PIC\r\n//        STBI_ONLY_PNM   (.ppm and .pgm)\r\n//\r\n//   - If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still\r\n//     want the zlib decoder to be available, #define STBI_SUPPORT_ZLIB\r\n//\r\n\r\n\r\n#ifndef STBI_NO_STDIO\r\n#include <stdio.h>\r\n#endif // STBI_NO_STDIO\r\n\r\n#define STBI_VERSION 1\r\n\r\nenum\r\n{\r\n   STBI_default = 0, // only used for desired_channels\r\n\r\n   STBI_grey       = 1,\r\n   STBI_grey_alpha = 2,\r\n   STBI_rgb        = 3,\r\n   STBI_rgb_alpha  = 4\r\n};\r\n\r\ntypedef unsigned char stbi_uc;\r\ntypedef unsigned short stbi_us;\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#ifdef STB_IMAGE_STATIC\r\n#define STBIDEF static\r\n#else\r\n#define STBIDEF extern\r\n#endif\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// PRIMARY API - works on images of any type\r\n//\r\n\r\n//\r\n// load image by filename, open file, or memory buffer\r\n//\r\n\r\ntypedef struct\r\n{\r\n   int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read\r\n   void     (*skip)  (void *user,int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative\r\n   int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data\r\n} stbi_io_callbacks;\r\n\r\n////////////////////////////////////\r\n//\r\n// 8-bits-per-channel interface\r\n//\r\n\r\nSTBIDEF stbi_uc *stbi_load_from_memory   (stbi_uc           const *buffer, int len   , int *x, int *y, int *channels_in_file, int desired_channels);\r\nSTBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk  , void *user, int *x, int *y, int *channels_in_file, int desired_channels);\r\n\r\n#ifndef STBI_NO_STDIO\r\nSTBIDEF stbi_uc *stbi_load            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);\r\nSTBIDEF stbi_uc *stbi_load_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);\r\n// for stbi_load_from_file, file pointer is left pointing immediately after image\r\n#endif\r\n\r\n////////////////////////////////////\r\n//\r\n// 16-bits-per-channel interface\r\n//\r\n\r\nSTBIDEF stbi_us *stbi_load_16_from_memory   (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);\r\nSTBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels);\r\n\r\n#ifndef STBI_NO_STDIO\r\nSTBIDEF stbi_us *stbi_load_16          (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);\r\nSTBIDEF stbi_us *stbi_load_from_file_16(FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);\r\n#endif\r\n\r\n////////////////////////////////////\r\n//\r\n// float-per-channel interface\r\n//\r\n#ifndef STBI_NO_LINEAR\r\n   STBIDEF float *stbi_loadf_from_memory     (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);\r\n   STBIDEF float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y,  int *channels_in_file, int desired_channels);\r\n\r\n   #ifndef STBI_NO_STDIO\r\n   STBIDEF float *stbi_loadf            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);\r\n   STBIDEF float *stbi_loadf_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);\r\n   #endif\r\n#endif\r\n\r\n#ifndef STBI_NO_HDR\r\n   STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma);\r\n   STBIDEF void   stbi_hdr_to_ldr_scale(float scale);\r\n#endif // STBI_NO_HDR\r\n\r\n#ifndef STBI_NO_LINEAR\r\n   STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);\r\n   STBIDEF void   stbi_ldr_to_hdr_scale(float scale);\r\n#endif // STBI_NO_LINEAR\r\n\r\n// stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR\r\nSTBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);\r\nSTBIDEF int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);\r\n#ifndef STBI_NO_STDIO\r\nSTBIDEF int      stbi_is_hdr          (char const *filename);\r\nSTBIDEF int      stbi_is_hdr_from_file(FILE *f);\r\n#endif // STBI_NO_STDIO\r\n\r\n\r\n// get a VERY brief reason for failure\r\n// NOT THREADSAFE\r\nSTBIDEF const char *stbi_failure_reason  (void);\r\n\r\n// free the loaded image -- this is just free()\r\nSTBIDEF void     stbi_image_free      (void *retval_from_stbi_load);\r\n\r\n// get image dimensions & components without fully decoding\r\nSTBIDEF int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);\r\nSTBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);\r\n\r\n#ifndef STBI_NO_STDIO\r\nSTBIDEF int      stbi_info            (char const *filename,     int *x, int *y, int *comp);\r\nSTBIDEF int      stbi_info_from_file  (FILE *f,                  int *x, int *y, int *comp);\r\n\r\n#endif\r\n\r\n\r\n\r\n// for image formats that explicitly notate that they have premultiplied alpha,\r\n// we just return the colors as stored in the file. set this flag to force\r\n// unpremultiplication. results are undefined if the unpremultiply overflow.\r\nSTBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);\r\n\r\n// indicate whether we should process iphone images back to canonical format,\r\n// or just pass them through \"as-is\"\r\nSTBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);\r\n\r\n// flip the image vertically, so the first pixel in the output array is the bottom left\r\nSTBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);\r\n\r\n// ZLIB client - used by PNG, available for other purposes\r\n\r\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);\r\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);\r\nSTBIDEF char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);\r\nSTBIDEF int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);\r\n\r\nSTBIDEF char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);\r\nSTBIDEF int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);\r\n\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n//\r\n//\r\n////   end header file   /////////////////////////////////////////////////////\r\n#endif // STBI_INCLUDE_STB_IMAGE_H\r\n\r\n#ifdef STB_IMAGE_IMPLEMENTATION\r\n\r\n#if defined(STBI_ONLY_JPEG) || defined(STBI_ONLY_PNG) || defined(STBI_ONLY_BMP) \\\r\n  || defined(STBI_ONLY_TGA) || defined(STBI_ONLY_GIF) || defined(STBI_ONLY_PSD) \\\r\n  || defined(STBI_ONLY_HDR) || defined(STBI_ONLY_PIC) || defined(STBI_ONLY_PNM) \\\r\n  || defined(STBI_ONLY_ZLIB)\r\n   #ifndef STBI_ONLY_JPEG\r\n   #define STBI_NO_JPEG\r\n   #endif\r\n   #ifndef STBI_ONLY_PNG\r\n   #define STBI_NO_PNG\r\n   #endif\r\n   #ifndef STBI_ONLY_BMP\r\n   #define STBI_NO_BMP\r\n   #endif\r\n   #ifndef STBI_ONLY_PSD\r\n   #define STBI_NO_PSD\r\n   #endif\r\n   #ifndef STBI_ONLY_TGA\r\n   #define STBI_NO_TGA\r\n   #endif\r\n   #ifndef STBI_ONLY_GIF\r\n   #define STBI_NO_GIF\r\n   #endif\r\n   #ifndef STBI_ONLY_HDR\r\n   #define STBI_NO_HDR\r\n   #endif\r\n   #ifndef STBI_ONLY_PIC\r\n   #define STBI_NO_PIC\r\n   #endif\r\n   #ifndef STBI_ONLY_PNM\r\n   #define STBI_NO_PNM\r\n   #endif\r\n#endif\r\n\r\n#if defined(STBI_NO_PNG) && !defined(STBI_SUPPORT_ZLIB) && !defined(STBI_NO_ZLIB)\r\n#define STBI_NO_ZLIB\r\n#endif\r\n\r\n\r\n#include <stdarg.h>\r\n#include <stddef.h> // ptrdiff_t on osx\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <limits.h>\r\n\r\n#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)\r\n#include <math.h>  // ldexp\r\n#endif\r\n\r\n#ifndef STBI_NO_STDIO\r\n#include <stdio.h>\r\n#endif\r\n\r\n#ifndef STBI_ASSERT\r\n#include <assert.h>\r\n#define STBI_ASSERT(x) assert(x)\r\n#endif\r\n\r\n\r\n#ifndef _MSC_VER\r\n   #ifdef __cplusplus\r\n   #define stbi_inline inline\r\n   #else\r\n   #define stbi_inline\r\n   #endif\r\n#else\r\n   #define stbi_inline __forceinline\r\n#endif\r\n\r\n\r\n#ifdef _MSC_VER\r\ntypedef unsigned short stbi__uint16;\r\ntypedef   signed short stbi__int16;\r\ntypedef unsigned int   stbi__uint32;\r\ntypedef   signed int   stbi__int32;\r\n#else\r\n#include <stdint.h>\r\ntypedef uint16_t stbi__uint16;\r\ntypedef int16_t  stbi__int16;\r\ntypedef uint32_t stbi__uint32;\r\ntypedef int32_t  stbi__int32;\r\n#endif\r\n\r\n// should produce compiler error if size is wrong\r\ntypedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];\r\n\r\n#ifdef _MSC_VER\r\n#define STBI_NOTUSED(v)  (void)(v)\r\n#else\r\n#define STBI_NOTUSED(v)  (void)sizeof(v)\r\n#endif\r\n\r\n#ifdef _MSC_VER\r\n#define STBI_HAS_LROTL\r\n#endif\r\n\r\n#ifdef STBI_HAS_LROTL\r\n   #define stbi_lrot(x,y)  _lrotl(x,y)\r\n#else\r\n   #define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (32 - (y))))\r\n#endif\r\n\r\n#if defined(STBI_MALLOC) && defined(STBI_FREE) && (defined(STBI_REALLOC) || defined(STBI_REALLOC_SIZED))\r\n// ok\r\n#elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC) && !defined(STBI_REALLOC_SIZED)\r\n// ok\r\n#else\r\n#error \"Must define all or none of STBI_MALLOC, STBI_FREE, and STBI_REALLOC (or STBI_REALLOC_SIZED).\"\r\n#endif\r\n\r\n#ifndef STBI_MALLOC\r\n#define STBI_MALLOC(sz)           malloc(sz)\r\n#define STBI_REALLOC(p,newsz)     realloc(p,newsz)\r\n#define STBI_FREE(p)              free(p)\r\n#endif\r\n\r\n#ifndef STBI_REALLOC_SIZED\r\n#define STBI_REALLOC_SIZED(p,oldsz,newsz) STBI_REALLOC(p,newsz)\r\n#endif\r\n\r\n// x86/x64 detection\r\n#if defined(__x86_64__) || defined(_M_X64)\r\n#define STBI__X64_TARGET\r\n#elif defined(__i386) || defined(_M_IX86)\r\n#define STBI__X86_TARGET\r\n#endif\r\n\r\n#if defined(__GNUC__) && defined(STBI__X86_TARGET) && !defined(__SSE2__) && !defined(STBI_NO_SIMD)\r\n// gcc doesn't support sse2 intrinsics unless you compile with -msse2,\r\n// which in turn means it gets to use SSE2 everywhere. This is unfortunate,\r\n// but previous attempts to provide the SSE2 functions with runtime\r\n// detection caused numerous issues. The way architecture extensions are\r\n// exposed in GCC/Clang is, sadly, not really suited for one-file libs.\r\n// New behavior: if compiled with -msse2, we use SSE2 without any\r\n// detection; if not, we don't use it at all.\r\n#define STBI_NO_SIMD\r\n#endif\r\n\r\n#if defined(__MINGW32__) && defined(STBI__X86_TARGET) && !defined(STBI_MINGW_ENABLE_SSE2) && !defined(STBI_NO_SIMD)\r\n// Note that __MINGW32__ doesn't actually mean 32-bit, so we have to avoid STBI__X64_TARGET\r\n//\r\n// 32-bit MinGW wants ESP to be 16-byte aligned, but this is not in the\r\n// Windows ABI and VC++ as well as Windows DLLs don't maintain that invariant.\r\n// As a result, enabling SSE2 on 32-bit MinGW is dangerous when not\r\n// simultaneously enabling \"-mstackrealign\".\r\n//\r\n// See https://github.com/nothings/stb/issues/81 for more information.\r\n//\r\n// So default to no SSE2 on 32-bit MinGW. If you've read this far and added\r\n// -mstackrealign to your build settings, feel free to #define STBI_MINGW_ENABLE_SSE2.\r\n#define STBI_NO_SIMD\r\n#endif\r\n\r\n#if !defined(STBI_NO_SIMD) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET))\r\n#define STBI_SSE2\r\n#include <emmintrin.h>\r\n\r\n#ifdef _MSC_VER\r\n\r\n#if _MSC_VER >= 1400  // not VC6\r\n#include <intrin.h> // __cpuid\r\nstatic int stbi__cpuid3(void)\r\n{\r\n   int info[4];\r\n   __cpuid(info,1);\r\n   return info[3];\r\n}\r\n#else\r\nstatic int stbi__cpuid3(void)\r\n{\r\n   int res;\r\n   __asm {\r\n      mov  eax,1\r\n      cpuid\r\n      mov  res,edx\r\n   }\r\n   return res;\r\n}\r\n#endif\r\n\r\n#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name\r\n\r\nstatic int stbi__sse2_available(void)\r\n{\r\n   int info3 = stbi__cpuid3();\r\n   return ((info3 >> 26) & 1) != 0;\r\n}\r\n#else // assume GCC-style if not VC++\r\n#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))\r\n\r\nstatic int stbi__sse2_available(void)\r\n{\r\n   // If we're even attempting to compile this on GCC/Clang, that means\r\n   // -msse2 is on, which means the compiler is allowed to use SSE2\r\n   // instructions at will, and so are we.\r\n   return 1;\r\n}\r\n#endif\r\n#endif\r\n\r\n// ARM NEON\r\n#if defined(STBI_NO_SIMD) && defined(STBI_NEON)\r\n#undef STBI_NEON\r\n#endif\r\n\r\n#ifdef STBI_NEON\r\n#include <arm_neon.h>\r\n// assume GCC or Clang on ARM targets\r\n#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))\r\n#endif\r\n\r\n#ifndef STBI_SIMD_ALIGN\r\n#define STBI_SIMD_ALIGN(type, name) type name\r\n#endif\r\n\r\n///////////////////////////////////////////////\r\n//\r\n//  stbi__context struct and start_xxx functions\r\n\r\n// stbi__context structure is our basic context used by all images, so it\r\n// contains all the IO context, plus some basic image information\r\ntypedef struct\r\n{\r\n   stbi__uint32 img_x, img_y;\r\n   int img_n, img_out_n;\r\n\r\n   stbi_io_callbacks io;\r\n   void *io_user_data;\r\n\r\n   int read_from_callbacks;\r\n   int buflen;\r\n   stbi_uc buffer_start[128];\r\n\r\n   stbi_uc *img_buffer, *img_buffer_end;\r\n   stbi_uc *img_buffer_original, *img_buffer_original_end;\r\n} stbi__context;\r\n\r\n\r\nstatic void stbi__refill_buffer(stbi__context *s);\r\n\r\n// initialize a memory-decode context\r\nstatic void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)\r\n{\r\n   s->io.read = NULL;\r\n   s->read_from_callbacks = 0;\r\n   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;\r\n   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;\r\n}\r\n\r\n// initialize a callback-based context\r\nstatic void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)\r\n{\r\n   s->io = *c;\r\n   s->io_user_data = user;\r\n   s->buflen = sizeof(s->buffer_start);\r\n   s->read_from_callbacks = 1;\r\n   s->img_buffer_original = s->buffer_start;\r\n   stbi__refill_buffer(s);\r\n   s->img_buffer_original_end = s->img_buffer_end;\r\n}\r\n\r\n#ifndef STBI_NO_STDIO\r\n\r\nstatic int stbi__stdio_read(void *user, char *data, int size)\r\n{\r\n   return (int) fread(data,1,size,(FILE*) user);\r\n}\r\n\r\nstatic void stbi__stdio_skip(void *user, int n)\r\n{\r\n   fseek((FILE*) user, n, SEEK_CUR);\r\n}\r\n\r\nstatic int stbi__stdio_eof(void *user)\r\n{\r\n   return feof((FILE*) user);\r\n}\r\n\r\nstatic stbi_io_callbacks stbi__stdio_callbacks =\r\n{\r\n   stbi__stdio_read,\r\n   stbi__stdio_skip,\r\n   stbi__stdio_eof,\r\n};\r\n\r\nstatic void stbi__start_file(stbi__context *s, FILE *f)\r\n{\r\n   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);\r\n}\r\n\r\n//static void stop_file(stbi__context *s) { }\r\n\r\n#endif // !STBI_NO_STDIO\r\n\r\nstatic void stbi__rewind(stbi__context *s)\r\n{\r\n   // conceptually rewind SHOULD rewind to the beginning of the stream,\r\n   // but we just rewind to the beginning of the initial buffer, because\r\n   // we only use it after doing 'test', which only ever looks at at most 92 bytes\r\n   s->img_buffer = s->img_buffer_original;\r\n   s->img_buffer_end = s->img_buffer_original_end;\r\n}\r\n\r\nenum\r\n{\r\n   STBI_ORDER_RGB,\r\n   STBI_ORDER_BGR\r\n};\r\n\r\ntypedef struct\r\n{\r\n   int bits_per_channel;\r\n   int num_channels;\r\n   int channel_order;\r\n} stbi__result_info;\r\n\r\n#ifndef STBI_NO_JPEG\r\nstatic int      stbi__jpeg_test(stbi__context *s);\r\nstatic void    *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\r\nstatic int      stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_PNG\r\nstatic int      stbi__png_test(stbi__context *s);\r\nstatic void    *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\r\nstatic int      stbi__png_info(stbi__context *s, int *x, int *y, int *comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_BMP\r\nstatic int      stbi__bmp_test(stbi__context *s);\r\nstatic void    *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\r\nstatic int      stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_TGA\r\nstatic int      stbi__tga_test(stbi__context *s);\r\nstatic void    *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\r\nstatic int      stbi__tga_info(stbi__context *s, int *x, int *y, int *comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_PSD\r\nstatic int      stbi__psd_test(stbi__context *s);\r\nstatic void    *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc);\r\nstatic int      stbi__psd_info(stbi__context *s, int *x, int *y, int *comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_HDR\r\nstatic int      stbi__hdr_test(stbi__context *s);\r\nstatic float   *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\r\nstatic int      stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_PIC\r\nstatic int      stbi__pic_test(stbi__context *s);\r\nstatic void    *stbi__pic_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\r\nstatic int      stbi__pic_info(stbi__context *s, int *x, int *y, int *comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_GIF\r\nstatic int      stbi__gif_test(stbi__context *s);\r\nstatic void    *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\r\nstatic int      stbi__gif_info(stbi__context *s, int *x, int *y, int *comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_PNM\r\nstatic int      stbi__pnm_test(stbi__context *s);\r\nstatic void    *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);\r\nstatic int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp);\r\n#endif\r\n\r\n// this is not threadsafe\r\nstatic const char *stbi__g_failure_reason;\r\n\r\nSTBIDEF const char *stbi_failure_reason(void)\r\n{\r\n   return stbi__g_failure_reason;\r\n}\r\n\r\nstatic int stbi__err(const char *str)\r\n{\r\n   stbi__g_failure_reason = str;\r\n   return 0;\r\n}\r\n\r\nstatic void *stbi__malloc(size_t size)\r\n{\r\n    return STBI_MALLOC(size);\r\n}\r\n\r\n// stb_image uses ints pervasively, including for offset calculations.\r\n// therefore the largest decoded image size we can support with the\r\n// current code, even on 64-bit targets, is INT_MAX. this is not a\r\n// significant limitation for the intended use case.\r\n//\r\n// we do, however, need to make sure our size calculations don't\r\n// overflow. hence a few helper functions for size calculations that\r\n// multiply integers together, making sure that they're non-negative\r\n// and no overflow occurs.\r\n\r\n// return 1 if the sum is valid, 0 on overflow.\r\n// negative terms are considered invalid.\r\nstatic int stbi__addsizes_valid(int a, int b)\r\n{\r\n   if (b < 0) return 0;\r\n   // now 0 <= b <= INT_MAX, hence also\r\n   // 0 <= INT_MAX - b <= INTMAX.\r\n   // And \"a + b <= INT_MAX\" (which might overflow) is the\r\n   // same as a <= INT_MAX - b (no overflow)\r\n   return a <= INT_MAX - b;\r\n}\r\n\r\n// returns 1 if the product is valid, 0 on overflow.\r\n// negative factors are considered invalid.\r\nstatic int stbi__mul2sizes_valid(int a, int b)\r\n{\r\n   if (a < 0 || b < 0) return 0;\r\n   if (b == 0) return 1; // mul-by-0 is always safe\r\n   // portable way to check for no overflows in a*b\r\n   return a <= INT_MAX/b;\r\n}\r\n\r\n// returns 1 if \"a*b + add\" has no negative terms/factors and doesn't overflow\r\nstatic int stbi__mad2sizes_valid(int a, int b, int add)\r\n{\r\n   return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);\r\n}\r\n\r\n// returns 1 if \"a*b*c + add\" has no negative terms/factors and doesn't overflow\r\nstatic int stbi__mad3sizes_valid(int a, int b, int c, int add)\r\n{\r\n   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&\r\n      stbi__addsizes_valid(a*b*c, add);\r\n}\r\n\r\n// returns 1 if \"a*b*c*d + add\" has no negative terms/factors and doesn't overflow\r\nstatic int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)\r\n{\r\n   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&\r\n      stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);\r\n}\r\n\r\n// mallocs with size overflow checking\r\nstatic void *stbi__malloc_mad2(int a, int b, int add)\r\n{\r\n   if (!stbi__mad2sizes_valid(a, b, add)) return NULL;\r\n   return stbi__malloc(a*b + add);\r\n}\r\n\r\nstatic void *stbi__malloc_mad3(int a, int b, int c, int add)\r\n{\r\n   if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;\r\n   return stbi__malloc(a*b*c + add);\r\n}\r\n\r\nstatic void *stbi__malloc_mad4(int a, int b, int c, int d, int add)\r\n{\r\n   if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;\r\n   return stbi__malloc(a*b*c*d + add);\r\n}\r\n\r\n// stbi__err - error\r\n// stbi__errpf - error returning pointer to float\r\n// stbi__errpuc - error returning pointer to unsigned char\r\n\r\n#ifdef STBI_NO_FAILURE_STRINGS\r\n   #define stbi__err(x,y)  0\r\n#elif defined(STBI_FAILURE_USERMSG)\r\n   #define stbi__err(x,y)  stbi__err(y)\r\n#else\r\n   #define stbi__err(x,y)  stbi__err(x)\r\n#endif\r\n\r\n#define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))\r\n#define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))\r\n\r\nSTBIDEF void stbi_image_free(void *retval_from_stbi_load)\r\n{\r\n   STBI_FREE(retval_from_stbi_load);\r\n}\r\n\r\n#ifndef STBI_NO_LINEAR\r\nstatic float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);\r\n#endif\r\n\r\n#ifndef STBI_NO_HDR\r\nstatic stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);\r\n#endif\r\n\r\nstatic int stbi__vertically_flip_on_load = 0;\r\n\r\nSTBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)\r\n{\r\n    stbi__vertically_flip_on_load = flag_true_if_should_flip;\r\n}\r\n\r\nstatic void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)\r\n{\r\n   memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields\r\n   ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed\r\n   ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order\r\n   ri->num_channels = 0;\r\n\r\n   #ifndef STBI_NO_JPEG\r\n   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);\r\n   #endif\r\n   #ifndef STBI_NO_PNG\r\n   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);\r\n   #endif\r\n   #ifndef STBI_NO_BMP\r\n   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);\r\n   #endif\r\n   #ifndef STBI_NO_GIF\r\n   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);\r\n   #endif\r\n   #ifndef STBI_NO_PSD\r\n   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);\r\n   #endif\r\n   #ifndef STBI_NO_PIC\r\n   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);\r\n   #endif\r\n   #ifndef STBI_NO_PNM\r\n   if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);\r\n   #endif\r\n\r\n   #ifndef STBI_NO_HDR\r\n   if (stbi__hdr_test(s)) {\r\n      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);\r\n      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);\r\n   }\r\n   #endif\r\n\r\n   #ifndef STBI_NO_TGA\r\n   // test tga last because it's a crappy test!\r\n   if (stbi__tga_test(s))\r\n      return stbi__tga_load(s,x,y,comp,req_comp, ri);\r\n   #endif\r\n\r\n   return stbi__errpuc(\"unknown image type\", \"Image not of any known type, or corrupt\");\r\n}\r\n\r\nstatic stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)\r\n{\r\n   int i;\r\n   int img_len = w * h * channels;\r\n   stbi_uc *reduced;\r\n\r\n   reduced = (stbi_uc *) stbi__malloc(img_len);\r\n   if (reduced == NULL) return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n\r\n   for (i = 0; i < img_len; ++i)\r\n      reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling\r\n\r\n   STBI_FREE(orig);\r\n   return reduced;\r\n}\r\n\r\nstatic stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)\r\n{\r\n   int i;\r\n   int img_len = w * h * channels;\r\n   stbi__uint16 *enlarged;\r\n\r\n   enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);\r\n   if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n\r\n   for (i = 0; i < img_len; ++i)\r\n      enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff\r\n\r\n   STBI_FREE(orig);\r\n   return enlarged;\r\n}\r\n\r\nstatic void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)\r\n{\r\n   int row;\r\n   size_t bytes_per_row = (size_t)w * bytes_per_pixel;\r\n   stbi_uc temp[2048];\r\n   stbi_uc *bytes = (stbi_uc *)image;\r\n\r\n   for (row = 0; row < (h>>1); row++) {\r\n      stbi_uc *row0 = bytes + row*bytes_per_row;\r\n      stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;\r\n      // swap row0 with row1\r\n      size_t bytes_left = bytes_per_row;\r\n      while (bytes_left) {\r\n         size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);\r\n         memcpy(temp, row0, bytes_copy);\r\n         memcpy(row0, row1, bytes_copy);\r\n         memcpy(row1, temp, bytes_copy);\r\n         row0 += bytes_copy;\r\n         row1 += bytes_copy;\r\n         bytes_left -= bytes_copy;\r\n      }\r\n   }\r\n}\r\n\r\nstatic unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   stbi__result_info ri;\r\n   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);\r\n\r\n   if (result == NULL)\r\n      return NULL;\r\n\r\n   if (ri.bits_per_channel != 8) {\r\n      STBI_ASSERT(ri.bits_per_channel == 16);\r\n      result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);\r\n      ri.bits_per_channel = 8;\r\n   }\r\n\r\n   // @TODO: move stbi__convert_format to here\r\n\r\n   if (stbi__vertically_flip_on_load) {\r\n      int channels = req_comp ? req_comp : *comp;\r\n      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));\r\n   }\r\n\r\n   return (unsigned char *) result;\r\n}\r\n\r\nstatic stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   stbi__result_info ri;\r\n   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);\r\n\r\n   if (result == NULL)\r\n      return NULL;\r\n\r\n   if (ri.bits_per_channel != 16) {\r\n      STBI_ASSERT(ri.bits_per_channel == 8);\r\n      result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);\r\n      ri.bits_per_channel = 16;\r\n   }\r\n\r\n   // @TODO: move stbi__convert_format16 to here\r\n   // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision\r\n\r\n   if (stbi__vertically_flip_on_load) {\r\n      int channels = req_comp ? req_comp : *comp;\r\n      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));\r\n   }\r\n\r\n   return (stbi__uint16 *) result;\r\n}\r\n\r\n#ifndef STBI_NO_HDR\r\nstatic void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   if (stbi__vertically_flip_on_load && result != NULL) {\r\n      int channels = req_comp ? req_comp : *comp;\r\n      stbi__vertical_flip(result, *x, *y, channels * sizeof(float));\r\n   }\r\n}\r\n#endif\r\n\r\n#ifndef STBI_NO_STDIO\r\n\r\nstatic FILE *stbi__fopen(char const *filename, char const *mode)\r\n{\r\n   FILE *f;\r\n#if defined(_MSC_VER) && _MSC_VER >= 1400\r\n   if (0 != fopen_s(&f, filename, mode))\r\n      f=0;\r\n#else\r\n   f = fopen(filename, mode);\r\n#endif\r\n   return f;\r\n}\r\n\r\n\r\nSTBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   FILE *f = stbi__fopen(filename, \"rb\");\r\n   unsigned char *result;\r\n   if (!f) return stbi__errpuc(\"can't fopen\", \"Unable to open file\");\r\n   result = stbi_load_from_file(f,x,y,comp,req_comp);\r\n   fclose(f);\r\n   return result;\r\n}\r\n\r\nSTBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   unsigned char *result;\r\n   stbi__context s;\r\n   stbi__start_file(&s,f);\r\n   result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);\r\n   if (result) {\r\n      // need to 'unget' all the characters in the IO buffer\r\n      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);\r\n   }\r\n   return result;\r\n}\r\n\r\nSTBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   stbi__uint16 *result;\r\n   stbi__context s;\r\n   stbi__start_file(&s,f);\r\n   result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);\r\n   if (result) {\r\n      // need to 'unget' all the characters in the IO buffer\r\n      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);\r\n   }\r\n   return result;\r\n}\r\n\r\nSTBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   FILE *f = stbi__fopen(filename, \"rb\");\r\n   stbi__uint16 *result;\r\n   if (!f) return (stbi_us *) stbi__errpuc(\"can't fopen\", \"Unable to open file\");\r\n   result = stbi_load_from_file_16(f,x,y,comp,req_comp);\r\n   fclose(f);\r\n   return result;\r\n}\r\n\r\n\r\n#endif //!STBI_NO_STDIO\r\n\r\nSTBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)\r\n{\r\n   stbi__context s;\r\n   stbi__start_mem(&s,buffer,len);\r\n   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);\r\n}\r\n\r\nSTBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)\r\n{\r\n   stbi__context s;\r\n   stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);\r\n   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);\r\n}\r\n\r\nSTBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   stbi__context s;\r\n   stbi__start_mem(&s,buffer,len);\r\n   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);\r\n}\r\n\r\nSTBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   stbi__context s;\r\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);\r\n   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);\r\n}\r\n\r\n#ifndef STBI_NO_LINEAR\r\nstatic float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   unsigned char *data;\r\n   #ifndef STBI_NO_HDR\r\n   if (stbi__hdr_test(s)) {\r\n      stbi__result_info ri;\r\n      float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);\r\n      if (hdr_data)\r\n         stbi__float_postprocess(hdr_data,x,y,comp,req_comp);\r\n      return hdr_data;\r\n   }\r\n   #endif\r\n   data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);\r\n   if (data)\r\n      return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);\r\n   return stbi__errpf(\"unknown image type\", \"Image not of any known type, or corrupt\");\r\n}\r\n\r\nSTBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   stbi__context s;\r\n   stbi__start_mem(&s,buffer,len);\r\n   return stbi__loadf_main(&s,x,y,comp,req_comp);\r\n}\r\n\r\nSTBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   stbi__context s;\r\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);\r\n   return stbi__loadf_main(&s,x,y,comp,req_comp);\r\n}\r\n\r\n#ifndef STBI_NO_STDIO\r\nSTBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   float *result;\r\n   FILE *f = stbi__fopen(filename, \"rb\");\r\n   if (!f) return stbi__errpf(\"can't fopen\", \"Unable to open file\");\r\n   result = stbi_loadf_from_file(f,x,y,comp,req_comp);\r\n   fclose(f);\r\n   return result;\r\n}\r\n\r\nSTBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)\r\n{\r\n   stbi__context s;\r\n   stbi__start_file(&s,f);\r\n   return stbi__loadf_main(&s,x,y,comp,req_comp);\r\n}\r\n#endif // !STBI_NO_STDIO\r\n\r\n#endif // !STBI_NO_LINEAR\r\n\r\n// these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is\r\n// defined, for API simplicity; if STBI_NO_LINEAR is defined, it always\r\n// reports false!\r\n\r\nSTBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)\r\n{\r\n   #ifndef STBI_NO_HDR\r\n   stbi__context s;\r\n   stbi__start_mem(&s,buffer,len);\r\n   return stbi__hdr_test(&s);\r\n   #else\r\n   STBI_NOTUSED(buffer);\r\n   STBI_NOTUSED(len);\r\n   return 0;\r\n   #endif\r\n}\r\n\r\n#ifndef STBI_NO_STDIO\r\nSTBIDEF int      stbi_is_hdr          (char const *filename)\r\n{\r\n   FILE *f = stbi__fopen(filename, \"rb\");\r\n   int result=0;\r\n   if (f) {\r\n      result = stbi_is_hdr_from_file(f);\r\n      fclose(f);\r\n   }\r\n   return result;\r\n}\r\n\r\nSTBIDEF int      stbi_is_hdr_from_file(FILE *f)\r\n{\r\n   #ifndef STBI_NO_HDR\r\n   stbi__context s;\r\n   stbi__start_file(&s,f);\r\n   return stbi__hdr_test(&s);\r\n   #else\r\n   STBI_NOTUSED(f);\r\n   return 0;\r\n   #endif\r\n}\r\n#endif // !STBI_NO_STDIO\r\n\r\nSTBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)\r\n{\r\n   #ifndef STBI_NO_HDR\r\n   stbi__context s;\r\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);\r\n   return stbi__hdr_test(&s);\r\n   #else\r\n   STBI_NOTUSED(clbk);\r\n   STBI_NOTUSED(user);\r\n   return 0;\r\n   #endif\r\n}\r\n\r\n#ifndef STBI_NO_LINEAR\r\nstatic float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;\r\n\r\nSTBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }\r\nSTBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }\r\n#endif\r\n\r\nstatic float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;\r\n\r\nSTBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }\r\nSTBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Common code used by all image loaders\r\n//\r\n\r\nenum\r\n{\r\n   STBI__SCAN_load=0,\r\n   STBI__SCAN_type,\r\n   STBI__SCAN_header\r\n};\r\n\r\nstatic void stbi__refill_buffer(stbi__context *s)\r\n{\r\n   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);\r\n   if (n == 0) {\r\n      // at end of file, treat same as if from memory, but need to handle case\r\n      // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file\r\n      s->read_from_callbacks = 0;\r\n      s->img_buffer = s->buffer_start;\r\n      s->img_buffer_end = s->buffer_start+1;\r\n      *s->img_buffer = 0;\r\n   } else {\r\n      s->img_buffer = s->buffer_start;\r\n      s->img_buffer_end = s->buffer_start + n;\r\n   }\r\n}\r\n\r\nstbi_inline static stbi_uc stbi__get8(stbi__context *s)\r\n{\r\n   if (s->img_buffer < s->img_buffer_end)\r\n      return *s->img_buffer++;\r\n   if (s->read_from_callbacks) {\r\n      stbi__refill_buffer(s);\r\n      return *s->img_buffer++;\r\n   }\r\n   return 0;\r\n}\r\n\r\nstbi_inline static int stbi__at_eof(stbi__context *s)\r\n{\r\n   if (s->io.read) {\r\n      if (!(s->io.eof)(s->io_user_data)) return 0;\r\n      // if feof() is true, check if buffer = end\r\n      // special case: we've only got the special 0 character at the end\r\n      if (s->read_from_callbacks == 0) return 1;\r\n   }\r\n\r\n   return s->img_buffer >= s->img_buffer_end;\r\n}\r\n\r\nstatic void stbi__skip(stbi__context *s, int n)\r\n{\r\n   if (n < 0) {\r\n      s->img_buffer = s->img_buffer_end;\r\n      return;\r\n   }\r\n   if (s->io.read) {\r\n      int blen = (int) (s->img_buffer_end - s->img_buffer);\r\n      if (blen < n) {\r\n         s->img_buffer = s->img_buffer_end;\r\n         (s->io.skip)(s->io_user_data, n - blen);\r\n         return;\r\n      }\r\n   }\r\n   s->img_buffer += n;\r\n}\r\n\r\nstatic int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)\r\n{\r\n   if (s->io.read) {\r\n      int blen = (int) (s->img_buffer_end - s->img_buffer);\r\n      if (blen < n) {\r\n         int res, count;\r\n\r\n         memcpy(buffer, s->img_buffer, blen);\r\n\r\n         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);\r\n         res = (count == (n-blen));\r\n         s->img_buffer = s->img_buffer_end;\r\n         return res;\r\n      }\r\n   }\r\n\r\n   if (s->img_buffer+n <= s->img_buffer_end) {\r\n      memcpy(buffer, s->img_buffer, n);\r\n      s->img_buffer += n;\r\n      return 1;\r\n   } else\r\n      return 0;\r\n}\r\n\r\nstatic int stbi__get16be(stbi__context *s)\r\n{\r\n   int z = stbi__get8(s);\r\n   return (z << 8) + stbi__get8(s);\r\n}\r\n\r\nstatic stbi__uint32 stbi__get32be(stbi__context *s)\r\n{\r\n   stbi__uint32 z = stbi__get16be(s);\r\n   return (z << 16) + stbi__get16be(s);\r\n}\r\n\r\n#if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)\r\n// nothing\r\n#else\r\nstatic int stbi__get16le(stbi__context *s)\r\n{\r\n   int z = stbi__get8(s);\r\n   return z + (stbi__get8(s) << 8);\r\n}\r\n#endif\r\n\r\n#ifndef STBI_NO_BMP\r\nstatic stbi__uint32 stbi__get32le(stbi__context *s)\r\n{\r\n   stbi__uint32 z = stbi__get16le(s);\r\n   return z + (stbi__get16le(s) << 16);\r\n}\r\n#endif\r\n\r\n#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n//  generic converter from built-in img_n to req_comp\r\n//    individual types do this automatically as much as possible (e.g. jpeg\r\n//    does all cases internally since it needs to colorspace convert anyway,\r\n//    and it never has alpha, so very few cases ). png can automatically\r\n//    interleave an alpha=255 channel, but falls back to this for other cases\r\n//\r\n//  assume data buffer is malloced, so malloc a new one and free that one\r\n//  only failure mode is malloc failing\r\n\r\nstatic stbi_uc stbi__compute_y(int r, int g, int b)\r\n{\r\n   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);\r\n}\r\n\r\nstatic unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)\r\n{\r\n   int i,j;\r\n   unsigned char *good;\r\n\r\n   if (req_comp == img_n) return data;\r\n   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);\r\n\r\n   good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);\r\n   if (good == NULL) {\r\n      STBI_FREE(data);\r\n      return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n   }\r\n\r\n   for (j=0; j < (int) y; ++j) {\r\n      unsigned char *src  = data + j * x * img_n   ;\r\n      unsigned char *dest = good + j * x * req_comp;\r\n\r\n      #define STBI__COMBO(a,b)  ((a)*8+(b))\r\n      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)\r\n      // convert source image with img_n components to one with req_comp components;\r\n      // avoid switch per pixel, so use switch per scanline and massive macros\r\n      switch (STBI__COMBO(img_n, req_comp)) {\r\n         STBI__CASE(1,2) { dest[0]=src[0], dest[1]=255;                                     } break;\r\n         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;\r\n         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=255;                     } break;\r\n         STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;\r\n         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;\r\n         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=src[1];                  } break;\r\n         STBI__CASE(3,4) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2],dest[3]=255;        } break;\r\n         STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;\r\n         STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]), dest[1] = 255;    } break;\r\n         STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;\r\n         STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]), dest[1] = src[3]; } break;\r\n         STBI__CASE(4,3) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2];                    } break;\r\n         default: STBI_ASSERT(0);\r\n      }\r\n      #undef STBI__CASE\r\n   }\r\n\r\n   STBI_FREE(data);\r\n   return good;\r\n}\r\n\r\nstatic stbi__uint16 stbi__compute_y_16(int r, int g, int b)\r\n{\r\n   return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);\r\n}\r\n\r\nstatic stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)\r\n{\r\n   int i,j;\r\n   stbi__uint16 *good;\r\n\r\n   if (req_comp == img_n) return data;\r\n   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);\r\n\r\n   good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);\r\n   if (good == NULL) {\r\n      STBI_FREE(data);\r\n      return (stbi__uint16 *) stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n   }\r\n\r\n   for (j=0; j < (int) y; ++j) {\r\n      stbi__uint16 *src  = data + j * x * img_n   ;\r\n      stbi__uint16 *dest = good + j * x * req_comp;\r\n\r\n      #define STBI__COMBO(a,b)  ((a)*8+(b))\r\n      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)\r\n      // convert source image with img_n components to one with req_comp components;\r\n      // avoid switch per pixel, so use switch per scanline and massive macros\r\n      switch (STBI__COMBO(img_n, req_comp)) {\r\n         STBI__CASE(1,2) { dest[0]=src[0], dest[1]=0xffff;                                     } break;\r\n         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;\r\n         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=0xffff;                     } break;\r\n         STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;\r\n         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;\r\n         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=src[1];                     } break;\r\n         STBI__CASE(3,4) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2],dest[3]=0xffff;        } break;\r\n         STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;\r\n         STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]), dest[1] = 0xffff; } break;\r\n         STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;\r\n         STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]), dest[1] = src[3]; } break;\r\n         STBI__CASE(4,3) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2];                       } break;\r\n         default: STBI_ASSERT(0);\r\n      }\r\n      #undef STBI__CASE\r\n   }\r\n\r\n   STBI_FREE(data);\r\n   return good;\r\n}\r\n\r\n#ifndef STBI_NO_LINEAR\r\nstatic float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)\r\n{\r\n   int i,k,n;\r\n   float *output;\r\n   if (!data) return NULL;\r\n   output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);\r\n   if (output == NULL) { STBI_FREE(data); return stbi__errpf(\"outofmem\", \"Out of memory\"); }\r\n   // compute number of non-alpha components\r\n   if (comp & 1) n = comp; else n = comp-1;\r\n   for (i=0; i < x*y; ++i) {\r\n      for (k=0; k < n; ++k) {\r\n         output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);\r\n      }\r\n      if (k < comp) output[i*comp + k] = data[i*comp+k]/255.0f;\r\n   }\r\n   STBI_FREE(data);\r\n   return output;\r\n}\r\n#endif\r\n\r\n#ifndef STBI_NO_HDR\r\n#define stbi__float2int(x)   ((int) (x))\r\nstatic stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)\r\n{\r\n   int i,k,n;\r\n   stbi_uc *output;\r\n   if (!data) return NULL;\r\n   output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);\r\n   if (output == NULL) { STBI_FREE(data); return stbi__errpuc(\"outofmem\", \"Out of memory\"); }\r\n   // compute number of non-alpha components\r\n   if (comp & 1) n = comp; else n = comp-1;\r\n   for (i=0; i < x*y; ++i) {\r\n      for (k=0; k < n; ++k) {\r\n         float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;\r\n         if (z < 0) z = 0;\r\n         if (z > 255) z = 255;\r\n         output[i*comp + k] = (stbi_uc) stbi__float2int(z);\r\n      }\r\n      if (k < comp) {\r\n         float z = data[i*comp+k] * 255 + 0.5f;\r\n         if (z < 0) z = 0;\r\n         if (z > 255) z = 255;\r\n         output[i*comp + k] = (stbi_uc) stbi__float2int(z);\r\n      }\r\n   }\r\n   STBI_FREE(data);\r\n   return output;\r\n}\r\n#endif\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n//  \"baseline\" JPEG/JFIF decoder\r\n//\r\n//    simple implementation\r\n//      - doesn't support delayed output of y-dimension\r\n//      - simple interface (only one output format: 8-bit interleaved RGB)\r\n//      - doesn't try to recover corrupt jpegs\r\n//      - doesn't allow partial loading, loading multiple at once\r\n//      - still fast on x86 (copying globals into locals doesn't help x86)\r\n//      - allocates lots of intermediate memory (full size of all components)\r\n//        - non-interleaved case requires this anyway\r\n//        - allows good upsampling (see next)\r\n//    high-quality\r\n//      - upsampled channels are bilinearly interpolated, even across blocks\r\n//      - quality integer IDCT derived from IJG's 'slow'\r\n//    performance\r\n//      - fast huffman; reasonable integer IDCT\r\n//      - some SIMD kernels for common paths on targets with SSE2/NEON\r\n//      - uses a lot of intermediate memory, could cache poorly\r\n\r\n#ifndef STBI_NO_JPEG\r\n\r\n// huffman decoding acceleration\r\n#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache\r\n\r\ntypedef struct\r\n{\r\n   stbi_uc  fast[1 << FAST_BITS];\r\n   // weirdly, repacking this into AoS is a 10% speed loss, instead of a win\r\n   stbi__uint16 code[256];\r\n   stbi_uc  values[256];\r\n   stbi_uc  size[257];\r\n   unsigned int maxcode[18];\r\n   int    delta[17];   // old 'firstsymbol' - old 'firstcode'\r\n} stbi__huffman;\r\n\r\ntypedef struct\r\n{\r\n   stbi__context *s;\r\n   stbi__huffman huff_dc[4];\r\n   stbi__huffman huff_ac[4];\r\n   stbi__uint16 dequant[4][64];\r\n   stbi__int16 fast_ac[4][1 << FAST_BITS];\r\n\r\n// sizes for components, interleaved MCUs\r\n   int img_h_max, img_v_max;\r\n   int img_mcu_x, img_mcu_y;\r\n   int img_mcu_w, img_mcu_h;\r\n\r\n// definition of jpeg image component\r\n   struct\r\n   {\r\n      int id;\r\n      int h,v;\r\n      int tq;\r\n      int hd,ha;\r\n      int dc_pred;\r\n\r\n      int x,y,w2,h2;\r\n      stbi_uc *data;\r\n      void *raw_data, *raw_coeff;\r\n      stbi_uc *linebuf;\r\n      short   *coeff;   // progressive only\r\n      int      coeff_w, coeff_h; // number of 8x8 coefficient blocks\r\n   } img_comp[4];\r\n\r\n   stbi__uint32   code_buffer; // jpeg entropy-coded buffer\r\n   int            code_bits;   // number of valid bits\r\n   unsigned char  marker;      // marker seen while filling entropy buffer\r\n   int            nomore;      // flag if we saw a marker so must stop\r\n\r\n   int            progressive;\r\n   int            spec_start;\r\n   int            spec_end;\r\n   int            succ_high;\r\n   int            succ_low;\r\n   int            eob_run;\r\n   int            jfif;\r\n   int            app14_color_transform; // Adobe APP14 tag\r\n   int            rgb;\r\n\r\n   int scan_n, order[4];\r\n   int restart_interval, todo;\r\n\r\n// kernels\r\n   void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);\r\n   void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);\r\n   stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);\r\n} stbi__jpeg;\r\n\r\nstatic int stbi__build_huffman(stbi__huffman *h, int *count)\r\n{\r\n   int i,j,k=0,code;\r\n   // build size list for each symbol (from JPEG spec)\r\n   for (i=0; i < 16; ++i)\r\n      for (j=0; j < count[i]; ++j)\r\n         h->size[k++] = (stbi_uc) (i+1);\r\n   h->size[k] = 0;\r\n\r\n   // compute actual symbols (from jpeg spec)\r\n   code = 0;\r\n   k = 0;\r\n   for(j=1; j <= 16; ++j) {\r\n      // compute delta to add to code to compute symbol id\r\n      h->delta[j] = k - code;\r\n      if (h->size[k] == j) {\r\n         while (h->size[k] == j)\r\n            h->code[k++] = (stbi__uint16) (code++);\r\n         if (code-1 >= (1 << j)) return stbi__err(\"bad code lengths\",\"Corrupt JPEG\");\r\n      }\r\n      // compute largest code + 1 for this size, preshifted as needed later\r\n      h->maxcode[j] = code << (16-j);\r\n      code <<= 1;\r\n   }\r\n   h->maxcode[j] = 0xffffffff;\r\n\r\n   // build non-spec acceleration table; 255 is flag for not-accelerated\r\n   memset(h->fast, 255, 1 << FAST_BITS);\r\n   for (i=0; i < k; ++i) {\r\n      int s = h->size[i];\r\n      if (s <= FAST_BITS) {\r\n         int c = h->code[i] << (FAST_BITS-s);\r\n         int m = 1 << (FAST_BITS-s);\r\n         for (j=0; j < m; ++j) {\r\n            h->fast[c+j] = (stbi_uc) i;\r\n         }\r\n      }\r\n   }\r\n   return 1;\r\n}\r\n\r\n// build a table that decodes both magnitude and value of small ACs in\r\n// one go.\r\nstatic void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)\r\n{\r\n   int i;\r\n   for (i=0; i < (1 << FAST_BITS); ++i) {\r\n      stbi_uc fast = h->fast[i];\r\n      fast_ac[i] = 0;\r\n      if (fast < 255) {\r\n         int rs = h->values[fast];\r\n         int run = (rs >> 4) & 15;\r\n         int magbits = rs & 15;\r\n         int len = h->size[fast];\r\n\r\n         if (magbits && len + magbits <= FAST_BITS) {\r\n            // magnitude code followed by receive_extend code\r\n            int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);\r\n            int m = 1 << (magbits - 1);\r\n            if (k < m) k += (~0U << magbits) + 1;\r\n            // if the result is small enough, we can fit it in fast_ac table\r\n            if (k >= -128 && k <= 127)\r\n               fast_ac[i] = (stbi__int16) ((k << 8) + (run << 4) + (len + magbits));\r\n         }\r\n      }\r\n   }\r\n}\r\n\r\nstatic void stbi__grow_buffer_unsafe(stbi__jpeg *j)\r\n{\r\n   do {\r\n      int b = j->nomore ? 0 : stbi__get8(j->s);\r\n      if (b == 0xff) {\r\n         int c = stbi__get8(j->s);\r\n         while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes\r\n         if (c != 0) {\r\n            j->marker = (unsigned char) c;\r\n            j->nomore = 1;\r\n            return;\r\n         }\r\n      }\r\n      j->code_buffer |= b << (24 - j->code_bits);\r\n      j->code_bits += 8;\r\n   } while (j->code_bits <= 24);\r\n}\r\n\r\n// (1 << n) - 1\r\nstatic stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};\r\n\r\n// decode a jpeg huffman value from the bitstream\r\nstbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)\r\n{\r\n   unsigned int temp;\r\n   int c,k;\r\n\r\n   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\r\n\r\n   // look at the top FAST_BITS and determine what symbol ID it is,\r\n   // if the code is <= FAST_BITS\r\n   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);\r\n   k = h->fast[c];\r\n   if (k < 255) {\r\n      int s = h->size[k];\r\n      if (s > j->code_bits)\r\n         return -1;\r\n      j->code_buffer <<= s;\r\n      j->code_bits -= s;\r\n      return h->values[k];\r\n   }\r\n\r\n   // naive test is to shift the code_buffer down so k bits are\r\n   // valid, then test against maxcode. To speed this up, we've\r\n   // preshifted maxcode left so that it has (16-k) 0s at the\r\n   // end; in other words, regardless of the number of bits, it\r\n   // wants to be compared against something shifted to have 16;\r\n   // that way we don't need to shift inside the loop.\r\n   temp = j->code_buffer >> 16;\r\n   for (k=FAST_BITS+1 ; ; ++k)\r\n      if (temp < h->maxcode[k])\r\n         break;\r\n   if (k == 17) {\r\n      // error! code not found\r\n      j->code_bits -= 16;\r\n      return -1;\r\n   }\r\n\r\n   if (k > j->code_bits)\r\n      return -1;\r\n\r\n   // convert the huffman code to the symbol id\r\n   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];\r\n   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);\r\n\r\n   // convert the id to a symbol\r\n   j->code_bits -= k;\r\n   j->code_buffer <<= k;\r\n   return h->values[c];\r\n}\r\n\r\n// bias[n] = (-1<<n) + 1\r\nstatic int const stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};\r\n\r\n// combined JPEG 'receive' and JPEG 'extend', since baseline\r\n// always extends everything it receives.\r\nstbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)\r\n{\r\n   unsigned int k;\r\n   int sgn;\r\n   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);\r\n\r\n   sgn = (stbi__int32)j->code_buffer >> 31; // sign bit is always in MSB\r\n   k = stbi_lrot(j->code_buffer, n);\r\n   STBI_ASSERT(n >= 0 && n < (int) (sizeof(stbi__bmask)/sizeof(*stbi__bmask)));\r\n   j->code_buffer = k & ~stbi__bmask[n];\r\n   k &= stbi__bmask[n];\r\n   j->code_bits -= n;\r\n   return k + (stbi__jbias[n] & ~sgn);\r\n}\r\n\r\n// get some unsigned bits\r\nstbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)\r\n{\r\n   unsigned int k;\r\n   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);\r\n   k = stbi_lrot(j->code_buffer, n);\r\n   j->code_buffer = k & ~stbi__bmask[n];\r\n   k &= stbi__bmask[n];\r\n   j->code_bits -= n;\r\n   return k;\r\n}\r\n\r\nstbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)\r\n{\r\n   unsigned int k;\r\n   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);\r\n   k = j->code_buffer;\r\n   j->code_buffer <<= 1;\r\n   --j->code_bits;\r\n   return k & 0x80000000;\r\n}\r\n\r\n// given a value that's at position X in the zigzag stream,\r\n// where does it appear in the 8x8 matrix coded as row-major?\r\nstatic stbi_uc stbi__jpeg_dezigzag[64+15] =\r\n{\r\n    0,  1,  8, 16,  9,  2,  3, 10,\r\n   17, 24, 32, 25, 18, 11,  4,  5,\r\n   12, 19, 26, 33, 40, 48, 41, 34,\r\n   27, 20, 13,  6,  7, 14, 21, 28,\r\n   35, 42, 49, 56, 57, 50, 43, 36,\r\n   29, 22, 15, 23, 30, 37, 44, 51,\r\n   58, 59, 52, 45, 38, 31, 39, 46,\r\n   53, 60, 61, 54, 47, 55, 62, 63,\r\n   // let corrupt input sample past end\r\n   63, 63, 63, 63, 63, 63, 63, 63,\r\n   63, 63, 63, 63, 63, 63, 63\r\n};\r\n\r\n// decode one 64-entry block--\r\nstatic int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)\r\n{\r\n   int diff,dc,k;\r\n   int t;\r\n\r\n   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\r\n   t = stbi__jpeg_huff_decode(j, hdc);\r\n   if (t < 0) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\r\n\r\n   // 0 all the ac values now so we can do it 32-bits at a time\r\n   memset(data,0,64*sizeof(data[0]));\r\n\r\n   diff = t ? stbi__extend_receive(j, t) : 0;\r\n   dc = j->img_comp[b].dc_pred + diff;\r\n   j->img_comp[b].dc_pred = dc;\r\n   data[0] = (short) (dc * dequant[0]);\r\n\r\n   // decode AC components, see JPEG spec\r\n   k = 1;\r\n   do {\r\n      unsigned int zig;\r\n      int c,r,s;\r\n      if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\r\n      c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);\r\n      r = fac[c];\r\n      if (r) { // fast-AC path\r\n         k += (r >> 4) & 15; // run\r\n         s = r & 15; // combined length\r\n         j->code_buffer <<= s;\r\n         j->code_bits -= s;\r\n         // decode into unzigzag'd location\r\n         zig = stbi__jpeg_dezigzag[k++];\r\n         data[zig] = (short) ((r >> 8) * dequant[zig]);\r\n      } else {\r\n         int rs = stbi__jpeg_huff_decode(j, hac);\r\n         if (rs < 0) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\r\n         s = rs & 15;\r\n         r = rs >> 4;\r\n         if (s == 0) {\r\n            if (rs != 0xf0) break; // end block\r\n            k += 16;\r\n         } else {\r\n            k += r;\r\n            // decode into unzigzag'd location\r\n            zig = stbi__jpeg_dezigzag[k++];\r\n            data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);\r\n         }\r\n      }\r\n   } while (k < 64);\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)\r\n{\r\n   int diff,dc;\r\n   int t;\r\n   if (j->spec_end != 0) return stbi__err(\"can't merge dc and ac\", \"Corrupt JPEG\");\r\n\r\n   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\r\n\r\n   if (j->succ_high == 0) {\r\n      // first scan for DC coefficient, must be first\r\n      memset(data,0,64*sizeof(data[0])); // 0 all the ac values now\r\n      t = stbi__jpeg_huff_decode(j, hdc);\r\n      diff = t ? stbi__extend_receive(j, t) : 0;\r\n\r\n      dc = j->img_comp[b].dc_pred + diff;\r\n      j->img_comp[b].dc_pred = dc;\r\n      data[0] = (short) (dc << j->succ_low);\r\n   } else {\r\n      // refinement scan for DC coefficient\r\n      if (stbi__jpeg_get_bit(j))\r\n         data[0] += (short) (1 << j->succ_low);\r\n   }\r\n   return 1;\r\n}\r\n\r\n// @OPTIMIZE: store non-zigzagged during the decode passes,\r\n// and only de-zigzag when dequantizing\r\nstatic int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)\r\n{\r\n   int k;\r\n   if (j->spec_start == 0) return stbi__err(\"can't merge dc and ac\", \"Corrupt JPEG\");\r\n\r\n   if (j->succ_high == 0) {\r\n      int shift = j->succ_low;\r\n\r\n      if (j->eob_run) {\r\n         --j->eob_run;\r\n         return 1;\r\n      }\r\n\r\n      k = j->spec_start;\r\n      do {\r\n         unsigned int zig;\r\n         int c,r,s;\r\n         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\r\n         c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);\r\n         r = fac[c];\r\n         if (r) { // fast-AC path\r\n            k += (r >> 4) & 15; // run\r\n            s = r & 15; // combined length\r\n            j->code_buffer <<= s;\r\n            j->code_bits -= s;\r\n            zig = stbi__jpeg_dezigzag[k++];\r\n            data[zig] = (short) ((r >> 8) << shift);\r\n         } else {\r\n            int rs = stbi__jpeg_huff_decode(j, hac);\r\n            if (rs < 0) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\r\n            s = rs & 15;\r\n            r = rs >> 4;\r\n            if (s == 0) {\r\n               if (r < 15) {\r\n                  j->eob_run = (1 << r);\r\n                  if (r)\r\n                     j->eob_run += stbi__jpeg_get_bits(j, r);\r\n                  --j->eob_run;\r\n                  break;\r\n               }\r\n               k += 16;\r\n            } else {\r\n               k += r;\r\n               zig = stbi__jpeg_dezigzag[k++];\r\n               data[zig] = (short) (stbi__extend_receive(j,s) << shift);\r\n            }\r\n         }\r\n      } while (k <= j->spec_end);\r\n   } else {\r\n      // refinement scan for these AC coefficients\r\n\r\n      short bit = (short) (1 << j->succ_low);\r\n\r\n      if (j->eob_run) {\r\n         --j->eob_run;\r\n         for (k = j->spec_start; k <= j->spec_end; ++k) {\r\n            short *p = &data[stbi__jpeg_dezigzag[k]];\r\n            if (*p != 0)\r\n               if (stbi__jpeg_get_bit(j))\r\n                  if ((*p & bit)==0) {\r\n                     if (*p > 0)\r\n                        *p += bit;\r\n                     else\r\n                        *p -= bit;\r\n                  }\r\n         }\r\n      } else {\r\n         k = j->spec_start;\r\n         do {\r\n            int r,s;\r\n            int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh\r\n            if (rs < 0) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\r\n            s = rs & 15;\r\n            r = rs >> 4;\r\n            if (s == 0) {\r\n               if (r < 15) {\r\n                  j->eob_run = (1 << r) - 1;\r\n                  if (r)\r\n                     j->eob_run += stbi__jpeg_get_bits(j, r);\r\n                  r = 64; // force end of block\r\n               } else {\r\n                  // r=15 s=0 should write 16 0s, so we just do\r\n                  // a run of 15 0s and then write s (which is 0),\r\n                  // so we don't have to do anything special here\r\n               }\r\n            } else {\r\n               if (s != 1) return stbi__err(\"bad huffman code\", \"Corrupt JPEG\");\r\n               // sign bit\r\n               if (stbi__jpeg_get_bit(j))\r\n                  s = bit;\r\n               else\r\n                  s = -bit;\r\n            }\r\n\r\n            // advance by r\r\n            while (k <= j->spec_end) {\r\n               short *p = &data[stbi__jpeg_dezigzag[k++]];\r\n               if (*p != 0) {\r\n                  if (stbi__jpeg_get_bit(j))\r\n                     if ((*p & bit)==0) {\r\n                        if (*p > 0)\r\n                           *p += bit;\r\n                        else\r\n                           *p -= bit;\r\n                     }\r\n               } else {\r\n                  if (r == 0) {\r\n                     *p = (short) s;\r\n                     break;\r\n                  }\r\n                  --r;\r\n               }\r\n            }\r\n         } while (k <= j->spec_end);\r\n      }\r\n   }\r\n   return 1;\r\n}\r\n\r\n// take a -128..127 value and stbi__clamp it and convert to 0..255\r\nstbi_inline static stbi_uc stbi__clamp(int x)\r\n{\r\n   // trick to use a single test to catch both cases\r\n   if ((unsigned int) x > 255) {\r\n      if (x < 0) return 0;\r\n      if (x > 255) return 255;\r\n   }\r\n   return (stbi_uc) x;\r\n}\r\n\r\n#define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))\r\n#define stbi__fsh(x)  ((x) << 12)\r\n\r\n// derived from jidctint -- DCT_ISLOW\r\n#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \\\r\n   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \\\r\n   p2 = s2;                                    \\\r\n   p3 = s6;                                    \\\r\n   p1 = (p2+p3) * stbi__f2f(0.5411961f);       \\\r\n   t2 = p1 + p3*stbi__f2f(-1.847759065f);      \\\r\n   t3 = p1 + p2*stbi__f2f( 0.765366865f);      \\\r\n   p2 = s0;                                    \\\r\n   p3 = s4;                                    \\\r\n   t0 = stbi__fsh(p2+p3);                      \\\r\n   t1 = stbi__fsh(p2-p3);                      \\\r\n   x0 = t0+t3;                                 \\\r\n   x3 = t0-t3;                                 \\\r\n   x1 = t1+t2;                                 \\\r\n   x2 = t1-t2;                                 \\\r\n   t0 = s7;                                    \\\r\n   t1 = s5;                                    \\\r\n   t2 = s3;                                    \\\r\n   t3 = s1;                                    \\\r\n   p3 = t0+t2;                                 \\\r\n   p4 = t1+t3;                                 \\\r\n   p1 = t0+t3;                                 \\\r\n   p2 = t1+t2;                                 \\\r\n   p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \\\r\n   t0 = t0*stbi__f2f( 0.298631336f);           \\\r\n   t1 = t1*stbi__f2f( 2.053119869f);           \\\r\n   t2 = t2*stbi__f2f( 3.072711026f);           \\\r\n   t3 = t3*stbi__f2f( 1.501321110f);           \\\r\n   p1 = p5 + p1*stbi__f2f(-0.899976223f);      \\\r\n   p2 = p5 + p2*stbi__f2f(-2.562915447f);      \\\r\n   p3 = p3*stbi__f2f(-1.961570560f);           \\\r\n   p4 = p4*stbi__f2f(-0.390180644f);           \\\r\n   t3 += p1+p4;                                \\\r\n   t2 += p2+p3;                                \\\r\n   t1 += p2+p4;                                \\\r\n   t0 += p1+p3;\r\n\r\nstatic void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])\r\n{\r\n   int i,val[64],*v=val;\r\n   stbi_uc *o;\r\n   short *d = data;\r\n\r\n   // columns\r\n   for (i=0; i < 8; ++i,++d, ++v) {\r\n      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing\r\n      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0\r\n           && d[40]==0 && d[48]==0 && d[56]==0) {\r\n         //    no shortcut                 0     seconds\r\n         //    (1|2|3|4|5|6|7)==0          0     seconds\r\n         //    all separate               -0.047 seconds\r\n         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds\r\n         int dcterm = d[0] << 2;\r\n         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;\r\n      } else {\r\n         STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])\r\n         // constants scaled things up by 1<<12; let's bring them back\r\n         // down, but keep 2 extra bits of precision\r\n         x0 += 512; x1 += 512; x2 += 512; x3 += 512;\r\n         v[ 0] = (x0+t3) >> 10;\r\n         v[56] = (x0-t3) >> 10;\r\n         v[ 8] = (x1+t2) >> 10;\r\n         v[48] = (x1-t2) >> 10;\r\n         v[16] = (x2+t1) >> 10;\r\n         v[40] = (x2-t1) >> 10;\r\n         v[24] = (x3+t0) >> 10;\r\n         v[32] = (x3-t0) >> 10;\r\n      }\r\n   }\r\n\r\n   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {\r\n      // no fast case since the first 1D IDCT spread components out\r\n      STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])\r\n      // constants scaled things up by 1<<12, plus we had 1<<2 from first\r\n      // loop, plus horizontal and vertical each scale by sqrt(8) so together\r\n      // we've got an extra 1<<3, so 1<<17 total we need to remove.\r\n      // so we want to round that, which means adding 0.5 * 1<<17,\r\n      // aka 65536. Also, we'll end up with -128 to 127 that we want\r\n      // to encode as 0..255 by adding 128, so we'll add that before the shift\r\n      x0 += 65536 + (128<<17);\r\n      x1 += 65536 + (128<<17);\r\n      x2 += 65536 + (128<<17);\r\n      x3 += 65536 + (128<<17);\r\n      // tried computing the shifts into temps, or'ing the temps to see\r\n      // if any were out of range, but that was slower\r\n      o[0] = stbi__clamp((x0+t3) >> 17);\r\n      o[7] = stbi__clamp((x0-t3) >> 17);\r\n      o[1] = stbi__clamp((x1+t2) >> 17);\r\n      o[6] = stbi__clamp((x1-t2) >> 17);\r\n      o[2] = stbi__clamp((x2+t1) >> 17);\r\n      o[5] = stbi__clamp((x2-t1) >> 17);\r\n      o[3] = stbi__clamp((x3+t0) >> 17);\r\n      o[4] = stbi__clamp((x3-t0) >> 17);\r\n   }\r\n}\r\n\r\n#ifdef STBI_SSE2\r\n// sse2 integer IDCT. not the fastest possible implementation but it\r\n// produces bit-identical results to the generic C version so it's\r\n// fully \"transparent\".\r\nstatic void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])\r\n{\r\n   // This is constructed to match our regular (generic) integer IDCT exactly.\r\n   __m128i row0, row1, row2, row3, row4, row5, row6, row7;\r\n   __m128i tmp;\r\n\r\n   // dot product constant: even elems=x, odd elems=y\r\n   #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))\r\n\r\n   // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)\r\n   // out(1) = c1[even]*x + c1[odd]*y\r\n   #define dct_rot(out0,out1, x,y,c0,c1) \\\r\n      __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \\\r\n      __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \\\r\n      __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \\\r\n      __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \\\r\n      __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \\\r\n      __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)\r\n\r\n   // out = in << 12  (in 16-bit, out 32-bit)\r\n   #define dct_widen(out, in) \\\r\n      __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \\\r\n      __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)\r\n\r\n   // wide add\r\n   #define dct_wadd(out, a, b) \\\r\n      __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \\\r\n      __m128i out##_h = _mm_add_epi32(a##_h, b##_h)\r\n\r\n   // wide sub\r\n   #define dct_wsub(out, a, b) \\\r\n      __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \\\r\n      __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)\r\n\r\n   // butterfly a/b, add bias, then shift by \"s\" and pack\r\n   #define dct_bfly32o(out0, out1, a,b,bias,s) \\\r\n      { \\\r\n         __m128i abiased_l = _mm_add_epi32(a##_l, bias); \\\r\n         __m128i abiased_h = _mm_add_epi32(a##_h, bias); \\\r\n         dct_wadd(sum, abiased, b); \\\r\n         dct_wsub(dif, abiased, b); \\\r\n         out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \\\r\n         out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \\\r\n      }\r\n\r\n   // 8-bit interleave step (for transposes)\r\n   #define dct_interleave8(a, b) \\\r\n      tmp = a; \\\r\n      a = _mm_unpacklo_epi8(a, b); \\\r\n      b = _mm_unpackhi_epi8(tmp, b)\r\n\r\n   // 16-bit interleave step (for transposes)\r\n   #define dct_interleave16(a, b) \\\r\n      tmp = a; \\\r\n      a = _mm_unpacklo_epi16(a, b); \\\r\n      b = _mm_unpackhi_epi16(tmp, b)\r\n\r\n   #define dct_pass(bias,shift) \\\r\n      { \\\r\n         /* even part */ \\\r\n         dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \\\r\n         __m128i sum04 = _mm_add_epi16(row0, row4); \\\r\n         __m128i dif04 = _mm_sub_epi16(row0, row4); \\\r\n         dct_widen(t0e, sum04); \\\r\n         dct_widen(t1e, dif04); \\\r\n         dct_wadd(x0, t0e, t3e); \\\r\n         dct_wsub(x3, t0e, t3e); \\\r\n         dct_wadd(x1, t1e, t2e); \\\r\n         dct_wsub(x2, t1e, t2e); \\\r\n         /* odd part */ \\\r\n         dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \\\r\n         dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \\\r\n         __m128i sum17 = _mm_add_epi16(row1, row7); \\\r\n         __m128i sum35 = _mm_add_epi16(row3, row5); \\\r\n         dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \\\r\n         dct_wadd(x4, y0o, y4o); \\\r\n         dct_wadd(x5, y1o, y5o); \\\r\n         dct_wadd(x6, y2o, y5o); \\\r\n         dct_wadd(x7, y3o, y4o); \\\r\n         dct_bfly32o(row0,row7, x0,x7,bias,shift); \\\r\n         dct_bfly32o(row1,row6, x1,x6,bias,shift); \\\r\n         dct_bfly32o(row2,row5, x2,x5,bias,shift); \\\r\n         dct_bfly32o(row3,row4, x3,x4,bias,shift); \\\r\n      }\r\n\r\n   __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));\r\n   __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));\r\n   __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));\r\n   __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));\r\n   __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));\r\n   __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));\r\n   __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));\r\n   __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));\r\n\r\n   // rounding biases in column/row passes, see stbi__idct_block for explanation.\r\n   __m128i bias_0 = _mm_set1_epi32(512);\r\n   __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));\r\n\r\n   // load\r\n   row0 = _mm_load_si128((const __m128i *) (data + 0*8));\r\n   row1 = _mm_load_si128((const __m128i *) (data + 1*8));\r\n   row2 = _mm_load_si128((const __m128i *) (data + 2*8));\r\n   row3 = _mm_load_si128((const __m128i *) (data + 3*8));\r\n   row4 = _mm_load_si128((const __m128i *) (data + 4*8));\r\n   row5 = _mm_load_si128((const __m128i *) (data + 5*8));\r\n   row6 = _mm_load_si128((const __m128i *) (data + 6*8));\r\n   row7 = _mm_load_si128((const __m128i *) (data + 7*8));\r\n\r\n   // column pass\r\n   dct_pass(bias_0, 10);\r\n\r\n   {\r\n      // 16bit 8x8 transpose pass 1\r\n      dct_interleave16(row0, row4);\r\n      dct_interleave16(row1, row5);\r\n      dct_interleave16(row2, row6);\r\n      dct_interleave16(row3, row7);\r\n\r\n      // transpose pass 2\r\n      dct_interleave16(row0, row2);\r\n      dct_interleave16(row1, row3);\r\n      dct_interleave16(row4, row6);\r\n      dct_interleave16(row5, row7);\r\n\r\n      // transpose pass 3\r\n      dct_interleave16(row0, row1);\r\n      dct_interleave16(row2, row3);\r\n      dct_interleave16(row4, row5);\r\n      dct_interleave16(row6, row7);\r\n   }\r\n\r\n   // row pass\r\n   dct_pass(bias_1, 17);\r\n\r\n   {\r\n      // pack\r\n      __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7\r\n      __m128i p1 = _mm_packus_epi16(row2, row3);\r\n      __m128i p2 = _mm_packus_epi16(row4, row5);\r\n      __m128i p3 = _mm_packus_epi16(row6, row7);\r\n\r\n      // 8bit 8x8 transpose pass 1\r\n      dct_interleave8(p0, p2); // a0e0a1e1...\r\n      dct_interleave8(p1, p3); // c0g0c1g1...\r\n\r\n      // transpose pass 2\r\n      dct_interleave8(p0, p1); // a0c0e0g0...\r\n      dct_interleave8(p2, p3); // b0d0f0h0...\r\n\r\n      // transpose pass 3\r\n      dct_interleave8(p0, p2); // a0b0c0d0...\r\n      dct_interleave8(p1, p3); // a4b4c4d4...\r\n\r\n      // store\r\n      _mm_storel_epi64((__m128i *) out, p0); out += out_stride;\r\n      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;\r\n      _mm_storel_epi64((__m128i *) out, p2); out += out_stride;\r\n      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;\r\n      _mm_storel_epi64((__m128i *) out, p1); out += out_stride;\r\n      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;\r\n      _mm_storel_epi64((__m128i *) out, p3); out += out_stride;\r\n      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));\r\n   }\r\n\r\n#undef dct_const\r\n#undef dct_rot\r\n#undef dct_widen\r\n#undef dct_wadd\r\n#undef dct_wsub\r\n#undef dct_bfly32o\r\n#undef dct_interleave8\r\n#undef dct_interleave16\r\n#undef dct_pass\r\n}\r\n\r\n#endif // STBI_SSE2\r\n\r\n#ifdef STBI_NEON\r\n\r\n// NEON integer IDCT. should produce bit-identical\r\n// results to the generic C version.\r\nstatic void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])\r\n{\r\n   int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;\r\n\r\n   int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));\r\n   int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));\r\n   int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));\r\n   int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));\r\n   int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));\r\n   int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));\r\n   int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));\r\n   int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));\r\n   int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));\r\n   int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));\r\n   int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));\r\n   int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));\r\n\r\n#define dct_long_mul(out, inq, coeff) \\\r\n   int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \\\r\n   int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)\r\n\r\n#define dct_long_mac(out, acc, inq, coeff) \\\r\n   int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \\\r\n   int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)\r\n\r\n#define dct_widen(out, inq) \\\r\n   int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \\\r\n   int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)\r\n\r\n// wide add\r\n#define dct_wadd(out, a, b) \\\r\n   int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \\\r\n   int32x4_t out##_h = vaddq_s32(a##_h, b##_h)\r\n\r\n// wide sub\r\n#define dct_wsub(out, a, b) \\\r\n   int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \\\r\n   int32x4_t out##_h = vsubq_s32(a##_h, b##_h)\r\n\r\n// butterfly a/b, then shift using \"shiftop\" by \"s\" and pack\r\n#define dct_bfly32o(out0,out1, a,b,shiftop,s) \\\r\n   { \\\r\n      dct_wadd(sum, a, b); \\\r\n      dct_wsub(dif, a, b); \\\r\n      out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \\\r\n      out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \\\r\n   }\r\n\r\n#define dct_pass(shiftop, shift) \\\r\n   { \\\r\n      /* even part */ \\\r\n      int16x8_t sum26 = vaddq_s16(row2, row6); \\\r\n      dct_long_mul(p1e, sum26, rot0_0); \\\r\n      dct_long_mac(t2e, p1e, row6, rot0_1); \\\r\n      dct_long_mac(t3e, p1e, row2, rot0_2); \\\r\n      int16x8_t sum04 = vaddq_s16(row0, row4); \\\r\n      int16x8_t dif04 = vsubq_s16(row0, row4); \\\r\n      dct_widen(t0e, sum04); \\\r\n      dct_widen(t1e, dif04); \\\r\n      dct_wadd(x0, t0e, t3e); \\\r\n      dct_wsub(x3, t0e, t3e); \\\r\n      dct_wadd(x1, t1e, t2e); \\\r\n      dct_wsub(x2, t1e, t2e); \\\r\n      /* odd part */ \\\r\n      int16x8_t sum15 = vaddq_s16(row1, row5); \\\r\n      int16x8_t sum17 = vaddq_s16(row1, row7); \\\r\n      int16x8_t sum35 = vaddq_s16(row3, row5); \\\r\n      int16x8_t sum37 = vaddq_s16(row3, row7); \\\r\n      int16x8_t sumodd = vaddq_s16(sum17, sum35); \\\r\n      dct_long_mul(p5o, sumodd, rot1_0); \\\r\n      dct_long_mac(p1o, p5o, sum17, rot1_1); \\\r\n      dct_long_mac(p2o, p5o, sum35, rot1_2); \\\r\n      dct_long_mul(p3o, sum37, rot2_0); \\\r\n      dct_long_mul(p4o, sum15, rot2_1); \\\r\n      dct_wadd(sump13o, p1o, p3o); \\\r\n      dct_wadd(sump24o, p2o, p4o); \\\r\n      dct_wadd(sump23o, p2o, p3o); \\\r\n      dct_wadd(sump14o, p1o, p4o); \\\r\n      dct_long_mac(x4, sump13o, row7, rot3_0); \\\r\n      dct_long_mac(x5, sump24o, row5, rot3_1); \\\r\n      dct_long_mac(x6, sump23o, row3, rot3_2); \\\r\n      dct_long_mac(x7, sump14o, row1, rot3_3); \\\r\n      dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \\\r\n      dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \\\r\n      dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \\\r\n      dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \\\r\n   }\r\n\r\n   // load\r\n   row0 = vld1q_s16(data + 0*8);\r\n   row1 = vld1q_s16(data + 1*8);\r\n   row2 = vld1q_s16(data + 2*8);\r\n   row3 = vld1q_s16(data + 3*8);\r\n   row4 = vld1q_s16(data + 4*8);\r\n   row5 = vld1q_s16(data + 5*8);\r\n   row6 = vld1q_s16(data + 6*8);\r\n   row7 = vld1q_s16(data + 7*8);\r\n\r\n   // add DC bias\r\n   row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));\r\n\r\n   // column pass\r\n   dct_pass(vrshrn_n_s32, 10);\r\n\r\n   // 16bit 8x8 transpose\r\n   {\r\n// these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.\r\n// whether compilers actually get this is another story, sadly.\r\n#define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }\r\n#define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }\r\n#define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }\r\n\r\n      // pass 1\r\n      dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6\r\n      dct_trn16(row2, row3);\r\n      dct_trn16(row4, row5);\r\n      dct_trn16(row6, row7);\r\n\r\n      // pass 2\r\n      dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4\r\n      dct_trn32(row1, row3);\r\n      dct_trn32(row4, row6);\r\n      dct_trn32(row5, row7);\r\n\r\n      // pass 3\r\n      dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0\r\n      dct_trn64(row1, row5);\r\n      dct_trn64(row2, row6);\r\n      dct_trn64(row3, row7);\r\n\r\n#undef dct_trn16\r\n#undef dct_trn32\r\n#undef dct_trn64\r\n   }\r\n\r\n   // row pass\r\n   // vrshrn_n_s32 only supports shifts up to 16, we need\r\n   // 17. so do a non-rounding shift of 16 first then follow\r\n   // up with a rounding shift by 1.\r\n   dct_pass(vshrn_n_s32, 16);\r\n\r\n   {\r\n      // pack and round\r\n      uint8x8_t p0 = vqrshrun_n_s16(row0, 1);\r\n      uint8x8_t p1 = vqrshrun_n_s16(row1, 1);\r\n      uint8x8_t p2 = vqrshrun_n_s16(row2, 1);\r\n      uint8x8_t p3 = vqrshrun_n_s16(row3, 1);\r\n      uint8x8_t p4 = vqrshrun_n_s16(row4, 1);\r\n      uint8x8_t p5 = vqrshrun_n_s16(row5, 1);\r\n      uint8x8_t p6 = vqrshrun_n_s16(row6, 1);\r\n      uint8x8_t p7 = vqrshrun_n_s16(row7, 1);\r\n\r\n      // again, these can translate into one instruction, but often don't.\r\n#define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }\r\n#define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }\r\n#define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }\r\n\r\n      // sadly can't use interleaved stores here since we only write\r\n      // 8 bytes to each scan line!\r\n\r\n      // 8x8 8-bit transpose pass 1\r\n      dct_trn8_8(p0, p1);\r\n      dct_trn8_8(p2, p3);\r\n      dct_trn8_8(p4, p5);\r\n      dct_trn8_8(p6, p7);\r\n\r\n      // pass 2\r\n      dct_trn8_16(p0, p2);\r\n      dct_trn8_16(p1, p3);\r\n      dct_trn8_16(p4, p6);\r\n      dct_trn8_16(p5, p7);\r\n\r\n      // pass 3\r\n      dct_trn8_32(p0, p4);\r\n      dct_trn8_32(p1, p5);\r\n      dct_trn8_32(p2, p6);\r\n      dct_trn8_32(p3, p7);\r\n\r\n      // store\r\n      vst1_u8(out, p0); out += out_stride;\r\n      vst1_u8(out, p1); out += out_stride;\r\n      vst1_u8(out, p2); out += out_stride;\r\n      vst1_u8(out, p3); out += out_stride;\r\n      vst1_u8(out, p4); out += out_stride;\r\n      vst1_u8(out, p5); out += out_stride;\r\n      vst1_u8(out, p6); out += out_stride;\r\n      vst1_u8(out, p7);\r\n\r\n#undef dct_trn8_8\r\n#undef dct_trn8_16\r\n#undef dct_trn8_32\r\n   }\r\n\r\n#undef dct_long_mul\r\n#undef dct_long_mac\r\n#undef dct_widen\r\n#undef dct_wadd\r\n#undef dct_wsub\r\n#undef dct_bfly32o\r\n#undef dct_pass\r\n}\r\n\r\n#endif // STBI_NEON\r\n\r\n#define STBI__MARKER_none  0xff\r\n// if there's a pending marker from the entropy stream, return that\r\n// otherwise, fetch from the stream and get a marker. if there's no\r\n// marker, return 0xff, which is never a valid marker value\r\nstatic stbi_uc stbi__get_marker(stbi__jpeg *j)\r\n{\r\n   stbi_uc x;\r\n   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }\r\n   x = stbi__get8(j->s);\r\n   if (x != 0xff) return STBI__MARKER_none;\r\n   while (x == 0xff)\r\n      x = stbi__get8(j->s); // consume repeated 0xff fill bytes\r\n   return x;\r\n}\r\n\r\n// in each scan, we'll have scan_n components, and the order\r\n// of the components is specified by order[]\r\n#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)\r\n\r\n// after a restart interval, stbi__jpeg_reset the entropy decoder and\r\n// the dc prediction\r\nstatic void stbi__jpeg_reset(stbi__jpeg *j)\r\n{\r\n   j->code_bits = 0;\r\n   j->code_buffer = 0;\r\n   j->nomore = 0;\r\n   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;\r\n   j->marker = STBI__MARKER_none;\r\n   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;\r\n   j->eob_run = 0;\r\n   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,\r\n   // since we don't even allow 1<<30 pixels\r\n}\r\n\r\nstatic int stbi__parse_entropy_coded_data(stbi__jpeg *z)\r\n{\r\n   stbi__jpeg_reset(z);\r\n   if (!z->progressive) {\r\n      if (z->scan_n == 1) {\r\n         int i,j;\r\n         STBI_SIMD_ALIGN(short, data[64]);\r\n         int n = z->order[0];\r\n         // non-interleaved data, we just need to process one block at a time,\r\n         // in trivial scanline order\r\n         // number of blocks to do just depends on how many actual \"pixels\" this\r\n         // component has, independent of interleaved MCU blocking and such\r\n         int w = (z->img_comp[n].x+7) >> 3;\r\n         int h = (z->img_comp[n].y+7) >> 3;\r\n         for (j=0; j < h; ++j) {\r\n            for (i=0; i < w; ++i) {\r\n               int ha = z->img_comp[n].ha;\r\n               if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;\r\n               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);\r\n               // every data block is an MCU, so countdown the restart interval\r\n               if (--z->todo <= 0) {\r\n                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\r\n                  // if it's NOT a restart, then just bail, so we get corrupt data\r\n                  // rather than no data\r\n                  if (!STBI__RESTART(z->marker)) return 1;\r\n                  stbi__jpeg_reset(z);\r\n               }\r\n            }\r\n         }\r\n         return 1;\r\n      } else { // interleaved\r\n         int i,j,k,x,y;\r\n         STBI_SIMD_ALIGN(short, data[64]);\r\n         for (j=0; j < z->img_mcu_y; ++j) {\r\n            for (i=0; i < z->img_mcu_x; ++i) {\r\n               // scan an interleaved mcu... process scan_n components in order\r\n               for (k=0; k < z->scan_n; ++k) {\r\n                  int n = z->order[k];\r\n                  // scan out an mcu's worth of this component; that's just determined\r\n                  // by the basic H and V specified for the component\r\n                  for (y=0; y < z->img_comp[n].v; ++y) {\r\n                     for (x=0; x < z->img_comp[n].h; ++x) {\r\n                        int x2 = (i*z->img_comp[n].h + x)*8;\r\n                        int y2 = (j*z->img_comp[n].v + y)*8;\r\n                        int ha = z->img_comp[n].ha;\r\n                        if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;\r\n                        z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);\r\n                     }\r\n                  }\r\n               }\r\n               // after all interleaved components, that's an interleaved MCU,\r\n               // so now count down the restart interval\r\n               if (--z->todo <= 0) {\r\n                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\r\n                  if (!STBI__RESTART(z->marker)) return 1;\r\n                  stbi__jpeg_reset(z);\r\n               }\r\n            }\r\n         }\r\n         return 1;\r\n      }\r\n   } else {\r\n      if (z->scan_n == 1) {\r\n         int i,j;\r\n         int n = z->order[0];\r\n         // non-interleaved data, we just need to process one block at a time,\r\n         // in trivial scanline order\r\n         // number of blocks to do just depends on how many actual \"pixels\" this\r\n         // component has, independent of interleaved MCU blocking and such\r\n         int w = (z->img_comp[n].x+7) >> 3;\r\n         int h = (z->img_comp[n].y+7) >> 3;\r\n         for (j=0; j < h; ++j) {\r\n            for (i=0; i < w; ++i) {\r\n               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);\r\n               if (z->spec_start == 0) {\r\n                  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))\r\n                     return 0;\r\n               } else {\r\n                  int ha = z->img_comp[n].ha;\r\n                  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))\r\n                     return 0;\r\n               }\r\n               // every data block is an MCU, so countdown the restart interval\r\n               if (--z->todo <= 0) {\r\n                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\r\n                  if (!STBI__RESTART(z->marker)) return 1;\r\n                  stbi__jpeg_reset(z);\r\n               }\r\n            }\r\n         }\r\n         return 1;\r\n      } else { // interleaved\r\n         int i,j,k,x,y;\r\n         for (j=0; j < z->img_mcu_y; ++j) {\r\n            for (i=0; i < z->img_mcu_x; ++i) {\r\n               // scan an interleaved mcu... process scan_n components in order\r\n               for (k=0; k < z->scan_n; ++k) {\r\n                  int n = z->order[k];\r\n                  // scan out an mcu's worth of this component; that's just determined\r\n                  // by the basic H and V specified for the component\r\n                  for (y=0; y < z->img_comp[n].v; ++y) {\r\n                     for (x=0; x < z->img_comp[n].h; ++x) {\r\n                        int x2 = (i*z->img_comp[n].h + x);\r\n                        int y2 = (j*z->img_comp[n].v + y);\r\n                        short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);\r\n                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))\r\n                           return 0;\r\n                     }\r\n                  }\r\n               }\r\n               // after all interleaved components, that's an interleaved MCU,\r\n               // so now count down the restart interval\r\n               if (--z->todo <= 0) {\r\n                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\r\n                  if (!STBI__RESTART(z->marker)) return 1;\r\n                  stbi__jpeg_reset(z);\r\n               }\r\n            }\r\n         }\r\n         return 1;\r\n      }\r\n   }\r\n}\r\n\r\nstatic void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)\r\n{\r\n   int i;\r\n   for (i=0; i < 64; ++i)\r\n      data[i] *= dequant[i];\r\n}\r\n\r\nstatic void stbi__jpeg_finish(stbi__jpeg *z)\r\n{\r\n   if (z->progressive) {\r\n      // dequantize and idct the data\r\n      int i,j,n;\r\n      for (n=0; n < z->s->img_n; ++n) {\r\n         int w = (z->img_comp[n].x+7) >> 3;\r\n         int h = (z->img_comp[n].y+7) >> 3;\r\n         for (j=0; j < h; ++j) {\r\n            for (i=0; i < w; ++i) {\r\n               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);\r\n               stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);\r\n               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);\r\n            }\r\n         }\r\n      }\r\n   }\r\n}\r\n\r\nstatic int stbi__process_marker(stbi__jpeg *z, int m)\r\n{\r\n   int L;\r\n   switch (m) {\r\n      case STBI__MARKER_none: // no marker found\r\n         return stbi__err(\"expected marker\",\"Corrupt JPEG\");\r\n\r\n      case 0xDD: // DRI - specify restart interval\r\n         if (stbi__get16be(z->s) != 4) return stbi__err(\"bad DRI len\",\"Corrupt JPEG\");\r\n         z->restart_interval = stbi__get16be(z->s);\r\n         return 1;\r\n\r\n      case 0xDB: // DQT - define quantization table\r\n         L = stbi__get16be(z->s)-2;\r\n         while (L > 0) {\r\n            int q = stbi__get8(z->s);\r\n            int p = q >> 4, sixteen = (p != 0);\r\n            int t = q & 15,i;\r\n            if (p != 0 && p != 1) return stbi__err(\"bad DQT type\",\"Corrupt JPEG\");\r\n            if (t > 3) return stbi__err(\"bad DQT table\",\"Corrupt JPEG\");\r\n\r\n            for (i=0; i < 64; ++i)\r\n               z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));\r\n            L -= (sixteen ? 129 : 65);\r\n         }\r\n         return L==0;\r\n\r\n      case 0xC4: // DHT - define huffman table\r\n         L = stbi__get16be(z->s)-2;\r\n         while (L > 0) {\r\n            stbi_uc *v;\r\n            int sizes[16],i,n=0;\r\n            int q = stbi__get8(z->s);\r\n            int tc = q >> 4;\r\n            int th = q & 15;\r\n            if (tc > 1 || th > 3) return stbi__err(\"bad DHT header\",\"Corrupt JPEG\");\r\n            for (i=0; i < 16; ++i) {\r\n               sizes[i] = stbi__get8(z->s);\r\n               n += sizes[i];\r\n            }\r\n            L -= 17;\r\n            if (tc == 0) {\r\n               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;\r\n               v = z->huff_dc[th].values;\r\n            } else {\r\n               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;\r\n               v = z->huff_ac[th].values;\r\n            }\r\n            for (i=0; i < n; ++i)\r\n               v[i] = stbi__get8(z->s);\r\n            if (tc != 0)\r\n               stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);\r\n            L -= n;\r\n         }\r\n         return L==0;\r\n   }\r\n\r\n   // check for comment block or APP blocks\r\n   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {\r\n      L = stbi__get16be(z->s);\r\n      if (L < 2) {\r\n         if (m == 0xFE)\r\n            return stbi__err(\"bad COM len\",\"Corrupt JPEG\");\r\n         else\r\n            return stbi__err(\"bad APP len\",\"Corrupt JPEG\");\r\n      }\r\n      L -= 2;\r\n\r\n      if (m == 0xE0 && L >= 5) { // JFIF APP0 segment\r\n         static const unsigned char tag[5] = {'J','F','I','F','\\0'};\r\n         int ok = 1;\r\n         int i;\r\n         for (i=0; i < 5; ++i)\r\n            if (stbi__get8(z->s) != tag[i])\r\n               ok = 0;\r\n         L -= 5;\r\n         if (ok)\r\n            z->jfif = 1;\r\n      } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment\r\n         static const unsigned char tag[6] = {'A','d','o','b','e','\\0'};\r\n         int ok = 1;\r\n         int i;\r\n         for (i=0; i < 6; ++i)\r\n            if (stbi__get8(z->s) != tag[i])\r\n               ok = 0;\r\n         L -= 6;\r\n         if (ok) {\r\n            stbi__get8(z->s); // version\r\n            stbi__get16be(z->s); // flags0\r\n            stbi__get16be(z->s); // flags1\r\n            z->app14_color_transform = stbi__get8(z->s); // color transform\r\n            L -= 6;\r\n         }\r\n      }\r\n\r\n      stbi__skip(z->s, L);\r\n      return 1;\r\n   }\r\n\r\n   return stbi__err(\"unknown marker\",\"Corrupt JPEG\");\r\n}\r\n\r\n// after we see SOS\r\nstatic int stbi__process_scan_header(stbi__jpeg *z)\r\n{\r\n   int i;\r\n   int Ls = stbi__get16be(z->s);\r\n   z->scan_n = stbi__get8(z->s);\r\n   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err(\"bad SOS component count\",\"Corrupt JPEG\");\r\n   if (Ls != 6+2*z->scan_n) return stbi__err(\"bad SOS len\",\"Corrupt JPEG\");\r\n   for (i=0; i < z->scan_n; ++i) {\r\n      int id = stbi__get8(z->s), which;\r\n      int q = stbi__get8(z->s);\r\n      for (which = 0; which < z->s->img_n; ++which)\r\n         if (z->img_comp[which].id == id)\r\n            break;\r\n      if (which == z->s->img_n) return 0; // no match\r\n      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err(\"bad DC huff\",\"Corrupt JPEG\");\r\n      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err(\"bad AC huff\",\"Corrupt JPEG\");\r\n      z->order[i] = which;\r\n   }\r\n\r\n   {\r\n      int aa;\r\n      z->spec_start = stbi__get8(z->s);\r\n      z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0\r\n      aa = stbi__get8(z->s);\r\n      z->succ_high = (aa >> 4);\r\n      z->succ_low  = (aa & 15);\r\n      if (z->progressive) {\r\n         if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)\r\n            return stbi__err(\"bad SOS\", \"Corrupt JPEG\");\r\n      } else {\r\n         if (z->spec_start != 0) return stbi__err(\"bad SOS\",\"Corrupt JPEG\");\r\n         if (z->succ_high != 0 || z->succ_low != 0) return stbi__err(\"bad SOS\",\"Corrupt JPEG\");\r\n         z->spec_end = 63;\r\n      }\r\n   }\r\n\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)\r\n{\r\n   int i;\r\n   for (i=0; i < ncomp; ++i) {\r\n      if (z->img_comp[i].raw_data) {\r\n         STBI_FREE(z->img_comp[i].raw_data);\r\n         z->img_comp[i].raw_data = NULL;\r\n         z->img_comp[i].data = NULL;\r\n      }\r\n      if (z->img_comp[i].raw_coeff) {\r\n         STBI_FREE(z->img_comp[i].raw_coeff);\r\n         z->img_comp[i].raw_coeff = 0;\r\n         z->img_comp[i].coeff = 0;\r\n      }\r\n      if (z->img_comp[i].linebuf) {\r\n         STBI_FREE(z->img_comp[i].linebuf);\r\n         z->img_comp[i].linebuf = NULL;\r\n      }\r\n   }\r\n   return why;\r\n}\r\n\r\nstatic int stbi__process_frame_header(stbi__jpeg *z, int scan)\r\n{\r\n   stbi__context *s = z->s;\r\n   int Lf,p,i,q, h_max=1,v_max=1,c;\r\n   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err(\"bad SOF len\",\"Corrupt JPEG\"); // JPEG\r\n   p  = stbi__get8(s);            if (p != 8) return stbi__err(\"only 8-bit\",\"JPEG format not supported: 8-bit only\"); // JPEG baseline\r\n   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err(\"no header height\", \"JPEG format not supported: delayed height\"); // Legal, but we don't handle it--but neither does IJG\r\n   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err(\"0 width\",\"Corrupt JPEG\"); // JPEG requires\r\n   c = stbi__get8(s);\r\n   if (c != 3 && c != 1 && c != 4) return stbi__err(\"bad component count\",\"Corrupt JPEG\");\r\n   s->img_n = c;\r\n   for (i=0; i < c; ++i) {\r\n      z->img_comp[i].data = NULL;\r\n      z->img_comp[i].linebuf = NULL;\r\n   }\r\n\r\n   if (Lf != 8+3*s->img_n) return stbi__err(\"bad SOF len\",\"Corrupt JPEG\");\r\n\r\n   z->rgb = 0;\r\n   for (i=0; i < s->img_n; ++i) {\r\n      static unsigned char rgb[3] = { 'R', 'G', 'B' };\r\n      z->img_comp[i].id = stbi__get8(s);\r\n      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])\r\n         ++z->rgb;\r\n      q = stbi__get8(s);\r\n      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err(\"bad H\",\"Corrupt JPEG\");\r\n      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err(\"bad V\",\"Corrupt JPEG\");\r\n      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err(\"bad TQ\",\"Corrupt JPEG\");\r\n   }\r\n\r\n   if (scan != STBI__SCAN_load) return 1;\r\n\r\n   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err(\"too large\", \"Image too large to decode\");\r\n\r\n   for (i=0; i < s->img_n; ++i) {\r\n      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;\r\n      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;\r\n   }\r\n\r\n   // compute interleaved mcu info\r\n   z->img_h_max = h_max;\r\n   z->img_v_max = v_max;\r\n   z->img_mcu_w = h_max * 8;\r\n   z->img_mcu_h = v_max * 8;\r\n   // these sizes can't be more than 17 bits\r\n   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;\r\n   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;\r\n\r\n   for (i=0; i < s->img_n; ++i) {\r\n      // number of effective pixels (e.g. for non-interleaved MCU)\r\n      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;\r\n      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;\r\n      // to simplify generation, we'll allocate enough memory to decode\r\n      // the bogus oversized data from using interleaved MCUs and their\r\n      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't\r\n      // discard the extra data until colorspace conversion\r\n      //\r\n      // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)\r\n      // so these muls can't overflow with 32-bit ints (which we require)\r\n      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;\r\n      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;\r\n      z->img_comp[i].coeff = 0;\r\n      z->img_comp[i].raw_coeff = 0;\r\n      z->img_comp[i].linebuf = NULL;\r\n      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);\r\n      if (z->img_comp[i].raw_data == NULL)\r\n         return stbi__free_jpeg_components(z, i+1, stbi__err(\"outofmem\", \"Out of memory\"));\r\n      // align blocks for idct using mmx/sse\r\n      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);\r\n      if (z->progressive) {\r\n         // w2, h2 are multiples of 8 (see above)\r\n         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;\r\n         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;\r\n         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);\r\n         if (z->img_comp[i].raw_coeff == NULL)\r\n            return stbi__free_jpeg_components(z, i+1, stbi__err(\"outofmem\", \"Out of memory\"));\r\n         z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);\r\n      }\r\n   }\r\n\r\n   return 1;\r\n}\r\n\r\n// use comparisons since in some cases we handle more than one case (e.g. SOF)\r\n#define stbi__DNL(x)         ((x) == 0xdc)\r\n#define stbi__SOI(x)         ((x) == 0xd8)\r\n#define stbi__EOI(x)         ((x) == 0xd9)\r\n#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)\r\n#define stbi__SOS(x)         ((x) == 0xda)\r\n\r\n#define stbi__SOF_progressive(x)   ((x) == 0xc2)\r\n\r\nstatic int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)\r\n{\r\n   int m;\r\n   z->jfif = 0;\r\n   z->app14_color_transform = -1; // valid values are 0,1,2\r\n   z->marker = STBI__MARKER_none; // initialize cached marker to empty\r\n   m = stbi__get_marker(z);\r\n   if (!stbi__SOI(m)) return stbi__err(\"no SOI\",\"Corrupt JPEG\");\r\n   if (scan == STBI__SCAN_type) return 1;\r\n   m = stbi__get_marker(z);\r\n   while (!stbi__SOF(m)) {\r\n      if (!stbi__process_marker(z,m)) return 0;\r\n      m = stbi__get_marker(z);\r\n      while (m == STBI__MARKER_none) {\r\n         // some files have extra padding after their blocks, so ok, we'll scan\r\n         if (stbi__at_eof(z->s)) return stbi__err(\"no SOF\", \"Corrupt JPEG\");\r\n         m = stbi__get_marker(z);\r\n      }\r\n   }\r\n   z->progressive = stbi__SOF_progressive(m);\r\n   if (!stbi__process_frame_header(z, scan)) return 0;\r\n   return 1;\r\n}\r\n\r\n// decode image to YCbCr format\r\nstatic int stbi__decode_jpeg_image(stbi__jpeg *j)\r\n{\r\n   int m;\r\n   for (m = 0; m < 4; m++) {\r\n      j->img_comp[m].raw_data = NULL;\r\n      j->img_comp[m].raw_coeff = NULL;\r\n   }\r\n   j->restart_interval = 0;\r\n   if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;\r\n   m = stbi__get_marker(j);\r\n   while (!stbi__EOI(m)) {\r\n      if (stbi__SOS(m)) {\r\n         if (!stbi__process_scan_header(j)) return 0;\r\n         if (!stbi__parse_entropy_coded_data(j)) return 0;\r\n         if (j->marker == STBI__MARKER_none ) {\r\n            // handle 0s at the end of image data from IP Kamera 9060\r\n            while (!stbi__at_eof(j->s)) {\r\n               int x = stbi__get8(j->s);\r\n               if (x == 255) {\r\n                  j->marker = stbi__get8(j->s);\r\n                  break;\r\n               }\r\n            }\r\n            // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0\r\n         }\r\n      } else if (stbi__DNL(m)) {\r\n         int Ld = stbi__get16be(j->s);\r\n         stbi__uint32 NL = stbi__get16be(j->s);\r\n         if (Ld != 4) stbi__err(\"bad DNL len\", \"Corrupt JPEG\");\r\n         if (NL != j->s->img_y) stbi__err(\"bad DNL height\", \"Corrupt JPEG\");\r\n      } else {\r\n         if (!stbi__process_marker(j, m)) return 0;\r\n      }\r\n      m = stbi__get_marker(j);\r\n   }\r\n   if (j->progressive)\r\n      stbi__jpeg_finish(j);\r\n   return 1;\r\n}\r\n\r\n// static jfif-centered resampling (across block boundaries)\r\n\r\ntypedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,\r\n                                    int w, int hs);\r\n\r\n#define stbi__div4(x) ((stbi_uc) ((x) >> 2))\r\n\r\nstatic stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\r\n{\r\n   STBI_NOTUSED(out);\r\n   STBI_NOTUSED(in_far);\r\n   STBI_NOTUSED(w);\r\n   STBI_NOTUSED(hs);\r\n   return in_near;\r\n}\r\n\r\nstatic stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\r\n{\r\n   // need to generate two samples vertically for every one in input\r\n   int i;\r\n   STBI_NOTUSED(hs);\r\n   for (i=0; i < w; ++i)\r\n      out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);\r\n   return out;\r\n}\r\n\r\nstatic stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\r\n{\r\n   // need to generate two samples horizontally for every one in input\r\n   int i;\r\n   stbi_uc *input = in_near;\r\n\r\n   if (w == 1) {\r\n      // if only one sample, can't do any interpolation\r\n      out[0] = out[1] = input[0];\r\n      return out;\r\n   }\r\n\r\n   out[0] = input[0];\r\n   out[1] = stbi__div4(input[0]*3 + input[1] + 2);\r\n   for (i=1; i < w-1; ++i) {\r\n      int n = 3*input[i]+2;\r\n      out[i*2+0] = stbi__div4(n+input[i-1]);\r\n      out[i*2+1] = stbi__div4(n+input[i+1]);\r\n   }\r\n   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);\r\n   out[i*2+1] = input[w-1];\r\n\r\n   STBI_NOTUSED(in_far);\r\n   STBI_NOTUSED(hs);\r\n\r\n   return out;\r\n}\r\n\r\n#define stbi__div16(x) ((stbi_uc) ((x) >> 4))\r\n\r\nstatic stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\r\n{\r\n   // need to generate 2x2 samples for every one in input\r\n   int i,t0,t1;\r\n   if (w == 1) {\r\n      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);\r\n      return out;\r\n   }\r\n\r\n   t1 = 3*in_near[0] + in_far[0];\r\n   out[0] = stbi__div4(t1+2);\r\n   for (i=1; i < w; ++i) {\r\n      t0 = t1;\r\n      t1 = 3*in_near[i]+in_far[i];\r\n      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);\r\n      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);\r\n   }\r\n   out[w*2-1] = stbi__div4(t1+2);\r\n\r\n   STBI_NOTUSED(hs);\r\n\r\n   return out;\r\n}\r\n\r\n#if defined(STBI_SSE2) || defined(STBI_NEON)\r\nstatic stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\r\n{\r\n   // need to generate 2x2 samples for every one in input\r\n   int i=0,t0,t1;\r\n\r\n   if (w == 1) {\r\n      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);\r\n      return out;\r\n   }\r\n\r\n   t1 = 3*in_near[0] + in_far[0];\r\n   // process groups of 8 pixels for as long as we can.\r\n   // note we can't handle the last pixel in a row in this loop\r\n   // because we need to handle the filter boundary conditions.\r\n   for (; i < ((w-1) & ~7); i += 8) {\r\n#if defined(STBI_SSE2)\r\n      // load and perform the vertical filtering pass\r\n      // this uses 3*x + y = 4*x + (y - x)\r\n      __m128i zero  = _mm_setzero_si128();\r\n      __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));\r\n      __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));\r\n      __m128i farw  = _mm_unpacklo_epi8(farb, zero);\r\n      __m128i nearw = _mm_unpacklo_epi8(nearb, zero);\r\n      __m128i diff  = _mm_sub_epi16(farw, nearw);\r\n      __m128i nears = _mm_slli_epi16(nearw, 2);\r\n      __m128i curr  = _mm_add_epi16(nears, diff); // current row\r\n\r\n      // horizontal filter works the same based on shifted vers of current\r\n      // row. \"prev\" is current row shifted right by 1 pixel; we need to\r\n      // insert the previous pixel value (from t1).\r\n      // \"next\" is current row shifted left by 1 pixel, with first pixel\r\n      // of next block of 8 pixels added in.\r\n      __m128i prv0 = _mm_slli_si128(curr, 2);\r\n      __m128i nxt0 = _mm_srli_si128(curr, 2);\r\n      __m128i prev = _mm_insert_epi16(prv0, t1, 0);\r\n      __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);\r\n\r\n      // horizontal filter, polyphase implementation since it's convenient:\r\n      // even pixels = 3*cur + prev = cur*4 + (prev - cur)\r\n      // odd  pixels = 3*cur + next = cur*4 + (next - cur)\r\n      // note the shared term.\r\n      __m128i bias  = _mm_set1_epi16(8);\r\n      __m128i curs = _mm_slli_epi16(curr, 2);\r\n      __m128i prvd = _mm_sub_epi16(prev, curr);\r\n      __m128i nxtd = _mm_sub_epi16(next, curr);\r\n      __m128i curb = _mm_add_epi16(curs, bias);\r\n      __m128i even = _mm_add_epi16(prvd, curb);\r\n      __m128i odd  = _mm_add_epi16(nxtd, curb);\r\n\r\n      // interleave even and odd pixels, then undo scaling.\r\n      __m128i int0 = _mm_unpacklo_epi16(even, odd);\r\n      __m128i int1 = _mm_unpackhi_epi16(even, odd);\r\n      __m128i de0  = _mm_srli_epi16(int0, 4);\r\n      __m128i de1  = _mm_srli_epi16(int1, 4);\r\n\r\n      // pack and write output\r\n      __m128i outv = _mm_packus_epi16(de0, de1);\r\n      _mm_storeu_si128((__m128i *) (out + i*2), outv);\r\n#elif defined(STBI_NEON)\r\n      // load and perform the vertical filtering pass\r\n      // this uses 3*x + y = 4*x + (y - x)\r\n      uint8x8_t farb  = vld1_u8(in_far + i);\r\n      uint8x8_t nearb = vld1_u8(in_near + i);\r\n      int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));\r\n      int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));\r\n      int16x8_t curr  = vaddq_s16(nears, diff); // current row\r\n\r\n      // horizontal filter works the same based on shifted vers of current\r\n      // row. \"prev\" is current row shifted right by 1 pixel; we need to\r\n      // insert the previous pixel value (from t1).\r\n      // \"next\" is current row shifted left by 1 pixel, with first pixel\r\n      // of next block of 8 pixels added in.\r\n      int16x8_t prv0 = vextq_s16(curr, curr, 7);\r\n      int16x8_t nxt0 = vextq_s16(curr, curr, 1);\r\n      int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);\r\n      int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);\r\n\r\n      // horizontal filter, polyphase implementation since it's convenient:\r\n      // even pixels = 3*cur + prev = cur*4 + (prev - cur)\r\n      // odd  pixels = 3*cur + next = cur*4 + (next - cur)\r\n      // note the shared term.\r\n      int16x8_t curs = vshlq_n_s16(curr, 2);\r\n      int16x8_t prvd = vsubq_s16(prev, curr);\r\n      int16x8_t nxtd = vsubq_s16(next, curr);\r\n      int16x8_t even = vaddq_s16(curs, prvd);\r\n      int16x8_t odd  = vaddq_s16(curs, nxtd);\r\n\r\n      // undo scaling and round, then store with even/odd phases interleaved\r\n      uint8x8x2_t o;\r\n      o.val[0] = vqrshrun_n_s16(even, 4);\r\n      o.val[1] = vqrshrun_n_s16(odd,  4);\r\n      vst2_u8(out + i*2, o);\r\n#endif\r\n\r\n      // \"previous\" value for next iter\r\n      t1 = 3*in_near[i+7] + in_far[i+7];\r\n   }\r\n\r\n   t0 = t1;\r\n   t1 = 3*in_near[i] + in_far[i];\r\n   out[i*2] = stbi__div16(3*t1 + t0 + 8);\r\n\r\n   for (++i; i < w; ++i) {\r\n      t0 = t1;\r\n      t1 = 3*in_near[i]+in_far[i];\r\n      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);\r\n      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);\r\n   }\r\n   out[w*2-1] = stbi__div4(t1+2);\r\n\r\n   STBI_NOTUSED(hs);\r\n\r\n   return out;\r\n}\r\n#endif\r\n\r\nstatic stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\r\n{\r\n   // resample with nearest-neighbor\r\n   int i,j;\r\n   STBI_NOTUSED(in_far);\r\n   for (i=0; i < w; ++i)\r\n      for (j=0; j < hs; ++j)\r\n         out[i*hs+j] = in_near[i];\r\n   return out;\r\n}\r\n\r\n// this is a reduced-precision calculation of YCbCr-to-RGB introduced\r\n// to make sure the code produces the same results in both SIMD and scalar\r\n#define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)\r\nstatic void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)\r\n{\r\n   int i;\r\n   for (i=0; i < count; ++i) {\r\n      int y_fixed = (y[i] << 20) + (1<<19); // rounding\r\n      int r,g,b;\r\n      int cr = pcr[i] - 128;\r\n      int cb = pcb[i] - 128;\r\n      r = y_fixed +  cr* stbi__float2fixed(1.40200f);\r\n      g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);\r\n      b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);\r\n      r >>= 20;\r\n      g >>= 20;\r\n      b >>= 20;\r\n      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }\r\n      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }\r\n      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }\r\n      out[0] = (stbi_uc)r;\r\n      out[1] = (stbi_uc)g;\r\n      out[2] = (stbi_uc)b;\r\n      out[3] = 255;\r\n      out += step;\r\n   }\r\n}\r\n\r\n#if defined(STBI_SSE2) || defined(STBI_NEON)\r\nstatic void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)\r\n{\r\n   int i = 0;\r\n\r\n#ifdef STBI_SSE2\r\n   // step == 3 is pretty ugly on the final interleave, and i'm not convinced\r\n   // it's useful in practice (you wouldn't use it for textures, for example).\r\n   // so just accelerate step == 4 case.\r\n   if (step == 4) {\r\n      // this is a fairly straightforward implementation and not super-optimized.\r\n      __m128i signflip  = _mm_set1_epi8(-0x80);\r\n      __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));\r\n      __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));\r\n      __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));\r\n      __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));\r\n      __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);\r\n      __m128i xw = _mm_set1_epi16(255); // alpha channel\r\n\r\n      for (; i+7 < count; i += 8) {\r\n         // load\r\n         __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));\r\n         __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));\r\n         __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));\r\n         __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128\r\n         __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128\r\n\r\n         // unpack to short (and left-shift cr, cb by 8)\r\n         __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);\r\n         __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);\r\n         __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);\r\n\r\n         // color transform\r\n         __m128i yws = _mm_srli_epi16(yw, 4);\r\n         __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);\r\n         __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);\r\n         __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);\r\n         __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);\r\n         __m128i rws = _mm_add_epi16(cr0, yws);\r\n         __m128i gwt = _mm_add_epi16(cb0, yws);\r\n         __m128i bws = _mm_add_epi16(yws, cb1);\r\n         __m128i gws = _mm_add_epi16(gwt, cr1);\r\n\r\n         // descale\r\n         __m128i rw = _mm_srai_epi16(rws, 4);\r\n         __m128i bw = _mm_srai_epi16(bws, 4);\r\n         __m128i gw = _mm_srai_epi16(gws, 4);\r\n\r\n         // back to byte, set up for transpose\r\n         __m128i brb = _mm_packus_epi16(rw, bw);\r\n         __m128i gxb = _mm_packus_epi16(gw, xw);\r\n\r\n         // transpose to interleave channels\r\n         __m128i t0 = _mm_unpacklo_epi8(brb, gxb);\r\n         __m128i t1 = _mm_unpackhi_epi8(brb, gxb);\r\n         __m128i o0 = _mm_unpacklo_epi16(t0, t1);\r\n         __m128i o1 = _mm_unpackhi_epi16(t0, t1);\r\n\r\n         // store\r\n         _mm_storeu_si128((__m128i *) (out + 0), o0);\r\n         _mm_storeu_si128((__m128i *) (out + 16), o1);\r\n         out += 32;\r\n      }\r\n   }\r\n#endif\r\n\r\n#ifdef STBI_NEON\r\n   // in this version, step=3 support would be easy to add. but is there demand?\r\n   if (step == 4) {\r\n      // this is a fairly straightforward implementation and not super-optimized.\r\n      uint8x8_t signflip = vdup_n_u8(0x80);\r\n      int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));\r\n      int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));\r\n      int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));\r\n      int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));\r\n\r\n      for (; i+7 < count; i += 8) {\r\n         // load\r\n         uint8x8_t y_bytes  = vld1_u8(y + i);\r\n         uint8x8_t cr_bytes = vld1_u8(pcr + i);\r\n         uint8x8_t cb_bytes = vld1_u8(pcb + i);\r\n         int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));\r\n         int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));\r\n\r\n         // expand to s16\r\n         int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));\r\n         int16x8_t crw = vshll_n_s8(cr_biased, 7);\r\n         int16x8_t cbw = vshll_n_s8(cb_biased, 7);\r\n\r\n         // color transform\r\n         int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);\r\n         int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);\r\n         int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);\r\n         int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);\r\n         int16x8_t rws = vaddq_s16(yws, cr0);\r\n         int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);\r\n         int16x8_t bws = vaddq_s16(yws, cb1);\r\n\r\n         // undo scaling, round, convert to byte\r\n         uint8x8x4_t o;\r\n         o.val[0] = vqrshrun_n_s16(rws, 4);\r\n         o.val[1] = vqrshrun_n_s16(gws, 4);\r\n         o.val[2] = vqrshrun_n_s16(bws, 4);\r\n         o.val[3] = vdup_n_u8(255);\r\n\r\n         // store, interleaving r/g/b/a\r\n         vst4_u8(out, o);\r\n         out += 8*4;\r\n      }\r\n   }\r\n#endif\r\n\r\n   for (; i < count; ++i) {\r\n      int y_fixed = (y[i] << 20) + (1<<19); // rounding\r\n      int r,g,b;\r\n      int cr = pcr[i] - 128;\r\n      int cb = pcb[i] - 128;\r\n      r = y_fixed + cr* stbi__float2fixed(1.40200f);\r\n      g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);\r\n      b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);\r\n      r >>= 20;\r\n      g >>= 20;\r\n      b >>= 20;\r\n      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }\r\n      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }\r\n      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }\r\n      out[0] = (stbi_uc)r;\r\n      out[1] = (stbi_uc)g;\r\n      out[2] = (stbi_uc)b;\r\n      out[3] = 255;\r\n      out += step;\r\n   }\r\n}\r\n#endif\r\n\r\n// set up the kernels\r\nstatic void stbi__setup_jpeg(stbi__jpeg *j)\r\n{\r\n   j->idct_block_kernel = stbi__idct_block;\r\n   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;\r\n   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;\r\n\r\n#ifdef STBI_SSE2\r\n   if (stbi__sse2_available()) {\r\n      j->idct_block_kernel = stbi__idct_simd;\r\n      j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;\r\n      j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;\r\n   }\r\n#endif\r\n\r\n#ifdef STBI_NEON\r\n   j->idct_block_kernel = stbi__idct_simd;\r\n   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;\r\n   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;\r\n#endif\r\n}\r\n\r\n// clean up the temporary component buffers\r\nstatic void stbi__cleanup_jpeg(stbi__jpeg *j)\r\n{\r\n   stbi__free_jpeg_components(j, j->s->img_n, 0);\r\n}\r\n\r\ntypedef struct\r\n{\r\n   resample_row_func resample;\r\n   stbi_uc *line0,*line1;\r\n   int hs,vs;   // expansion factor in each axis\r\n   int w_lores; // horizontal pixels pre-expansion\r\n   int ystep;   // how far through vertical expansion we are\r\n   int ypos;    // which pre-expansion row we're on\r\n} stbi__resample;\r\n\r\n// fast 0..255 * 0..255 => 0..255 rounded multiplication\r\nstatic stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)\r\n{\r\n   unsigned int t = x*y + 128;\r\n   return (stbi_uc) ((t + (t >>8)) >> 8);\r\n}\r\n\r\nstatic stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)\r\n{\r\n   int n, decode_n, is_rgb;\r\n   z->s->img_n = 0; // make stbi__cleanup_jpeg safe\r\n\r\n   // validate req_comp\r\n   if (req_comp < 0 || req_comp > 4) return stbi__errpuc(\"bad req_comp\", \"Internal error\");\r\n\r\n   // load a jpeg image from whichever source, but leave in YCbCr format\r\n   if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }\r\n\r\n   // determine actual number of components to generate\r\n   n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;\r\n\r\n   is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));\r\n\r\n   if (z->s->img_n == 3 && n < 3 && !is_rgb)\r\n      decode_n = 1;\r\n   else\r\n      decode_n = z->s->img_n;\r\n\r\n   // resample and color-convert\r\n   {\r\n      int k;\r\n      unsigned int i,j;\r\n      stbi_uc *output;\r\n      stbi_uc *coutput[4];\r\n\r\n      stbi__resample res_comp[4];\r\n\r\n      for (k=0; k < decode_n; ++k) {\r\n         stbi__resample *r = &res_comp[k];\r\n\r\n         // allocate line buffer big enough for upsampling off the edges\r\n         // with upsample factor of 4\r\n         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);\r\n         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc(\"outofmem\", \"Out of memory\"); }\r\n\r\n         r->hs      = z->img_h_max / z->img_comp[k].h;\r\n         r->vs      = z->img_v_max / z->img_comp[k].v;\r\n         r->ystep   = r->vs >> 1;\r\n         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;\r\n         r->ypos    = 0;\r\n         r->line0   = r->line1 = z->img_comp[k].data;\r\n\r\n         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;\r\n         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;\r\n         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;\r\n         else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;\r\n         else                               r->resample = stbi__resample_row_generic;\r\n      }\r\n\r\n      // can't error after this so, this is safe\r\n      output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);\r\n      if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc(\"outofmem\", \"Out of memory\"); }\r\n\r\n      // now go ahead and resample\r\n      for (j=0; j < z->s->img_y; ++j) {\r\n         stbi_uc *out = output + n * z->s->img_x * j;\r\n         for (k=0; k < decode_n; ++k) {\r\n            stbi__resample *r = &res_comp[k];\r\n            int y_bot = r->ystep >= (r->vs >> 1);\r\n            coutput[k] = r->resample(z->img_comp[k].linebuf,\r\n                                     y_bot ? r->line1 : r->line0,\r\n                                     y_bot ? r->line0 : r->line1,\r\n                                     r->w_lores, r->hs);\r\n            if (++r->ystep >= r->vs) {\r\n               r->ystep = 0;\r\n               r->line0 = r->line1;\r\n               if (++r->ypos < z->img_comp[k].y)\r\n                  r->line1 += z->img_comp[k].w2;\r\n            }\r\n         }\r\n         if (n >= 3) {\r\n            stbi_uc *y = coutput[0];\r\n            if (z->s->img_n == 3) {\r\n               if (is_rgb) {\r\n                  for (i=0; i < z->s->img_x; ++i) {\r\n                     out[0] = y[i];\r\n                     out[1] = coutput[1][i];\r\n                     out[2] = coutput[2][i];\r\n                     out[3] = 255;\r\n                     out += n;\r\n                  }\r\n               } else {\r\n                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);\r\n               }\r\n            } else if (z->s->img_n == 4) {\r\n               if (z->app14_color_transform == 0) { // CMYK\r\n                  for (i=0; i < z->s->img_x; ++i) {\r\n                     stbi_uc m = coutput[3][i];\r\n                     out[0] = stbi__blinn_8x8(coutput[0][i], m);\r\n                     out[1] = stbi__blinn_8x8(coutput[1][i], m);\r\n                     out[2] = stbi__blinn_8x8(coutput[2][i], m);\r\n                     out[3] = 255;\r\n                     out += n;\r\n                  }\r\n               } else if (z->app14_color_transform == 2) { // YCCK\r\n                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);\r\n                  for (i=0; i < z->s->img_x; ++i) {\r\n                     stbi_uc m = coutput[3][i];\r\n                     out[0] = stbi__blinn_8x8(255 - out[0], m);\r\n                     out[1] = stbi__blinn_8x8(255 - out[1], m);\r\n                     out[2] = stbi__blinn_8x8(255 - out[2], m);\r\n                     out += n;\r\n                  }\r\n               } else { // YCbCr + alpha?  Ignore the fourth channel for now\r\n                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);\r\n               }\r\n            } else\r\n               for (i=0; i < z->s->img_x; ++i) {\r\n                  out[0] = out[1] = out[2] = y[i];\r\n                  out[3] = 255; // not used if n==3\r\n                  out += n;\r\n               }\r\n         } else {\r\n            if (is_rgb) {\r\n               if (n == 1)\r\n                  for (i=0; i < z->s->img_x; ++i)\r\n                     *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);\r\n               else {\r\n                  for (i=0; i < z->s->img_x; ++i, out += 2) {\r\n                     out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);\r\n                     out[1] = 255;\r\n                  }\r\n               }\r\n            } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {\r\n               for (i=0; i < z->s->img_x; ++i) {\r\n                  stbi_uc m = coutput[3][i];\r\n                  stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);\r\n                  stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);\r\n                  stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);\r\n                  out[0] = stbi__compute_y(r, g, b);\r\n                  out[1] = 255;\r\n                  out += n;\r\n               }\r\n            } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {\r\n               for (i=0; i < z->s->img_x; ++i) {\r\n                  out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);\r\n                  out[1] = 255;\r\n                  out += n;\r\n               }\r\n            } else {\r\n               stbi_uc *y = coutput[0];\r\n               if (n == 1)\r\n                  for (i=0; i < z->s->img_x; ++i) out[i] = y[i];\r\n               else\r\n                  for (i=0; i < z->s->img_x; ++i) *out++ = y[i], *out++ = 255;\r\n            }\r\n         }\r\n      }\r\n      stbi__cleanup_jpeg(z);\r\n      *out_x = z->s->img_x;\r\n      *out_y = z->s->img_y;\r\n      if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output\r\n      return output;\r\n   }\r\n}\r\n\r\nstatic void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\r\n{\r\n   unsigned char* result;\r\n   stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));\r\n   STBI_NOTUSED(ri);\r\n   j->s = s;\r\n   stbi__setup_jpeg(j);\r\n   result = load_jpeg_image(j, x,y,comp,req_comp);\r\n   STBI_FREE(j);\r\n   return result;\r\n}\r\n\r\nstatic int stbi__jpeg_test(stbi__context *s)\r\n{\r\n   int r;\r\n   stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));\r\n   j->s = s;\r\n   stbi__setup_jpeg(j);\r\n   r = stbi__decode_jpeg_header(j, STBI__SCAN_type);\r\n   stbi__rewind(s);\r\n   STBI_FREE(j);\r\n   return r;\r\n}\r\n\r\nstatic int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)\r\n{\r\n   if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {\r\n      stbi__rewind( j->s );\r\n      return 0;\r\n   }\r\n   if (x) *x = j->s->img_x;\r\n   if (y) *y = j->s->img_y;\r\n   if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)\r\n{\r\n   int result;\r\n   stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));\r\n   j->s = s;\r\n   result = stbi__jpeg_info_raw(j, x, y, comp);\r\n   STBI_FREE(j);\r\n   return result;\r\n}\r\n#endif\r\n\r\n// public domain zlib decode    v0.2  Sean Barrett 2006-11-18\r\n//    simple implementation\r\n//      - all input must be provided in an upfront buffer\r\n//      - all output is written to a single output buffer (can malloc/realloc)\r\n//    performance\r\n//      - fast huffman\r\n\r\n#ifndef STBI_NO_ZLIB\r\n\r\n// fast-way is faster to check than jpeg huffman, but slow way is slower\r\n#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables\r\n#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)\r\n\r\n// zlib-style huffman encoding\r\n// (jpegs packs from left, zlib from right, so can't share code)\r\ntypedef struct\r\n{\r\n   stbi__uint16 fast[1 << STBI__ZFAST_BITS];\r\n   stbi__uint16 firstcode[16];\r\n   int maxcode[17];\r\n   stbi__uint16 firstsymbol[16];\r\n   stbi_uc  size[288];\r\n   stbi__uint16 value[288];\r\n} stbi__zhuffman;\r\n\r\nstbi_inline static int stbi__bitreverse16(int n)\r\n{\r\n  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);\r\n  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);\r\n  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);\r\n  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);\r\n  return n;\r\n}\r\n\r\nstbi_inline static int stbi__bit_reverse(int v, int bits)\r\n{\r\n   STBI_ASSERT(bits <= 16);\r\n   // to bit reverse n bits, reverse 16 and shift\r\n   // e.g. 11 bits, bit reverse and shift away 5\r\n   return stbi__bitreverse16(v) >> (16-bits);\r\n}\r\n\r\nstatic int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)\r\n{\r\n   int i,k=0;\r\n   int code, next_code[16], sizes[17];\r\n\r\n   // DEFLATE spec for generating codes\r\n   memset(sizes, 0, sizeof(sizes));\r\n   memset(z->fast, 0, sizeof(z->fast));\r\n   for (i=0; i < num; ++i)\r\n      ++sizes[sizelist[i]];\r\n   sizes[0] = 0;\r\n   for (i=1; i < 16; ++i)\r\n      if (sizes[i] > (1 << i))\r\n         return stbi__err(\"bad sizes\", \"Corrupt PNG\");\r\n   code = 0;\r\n   for (i=1; i < 16; ++i) {\r\n      next_code[i] = code;\r\n      z->firstcode[i] = (stbi__uint16) code;\r\n      z->firstsymbol[i] = (stbi__uint16) k;\r\n      code = (code + sizes[i]);\r\n      if (sizes[i])\r\n         if (code-1 >= (1 << i)) return stbi__err(\"bad codelengths\",\"Corrupt PNG\");\r\n      z->maxcode[i] = code << (16-i); // preshift for inner loop\r\n      code <<= 1;\r\n      k += sizes[i];\r\n   }\r\n   z->maxcode[16] = 0x10000; // sentinel\r\n   for (i=0; i < num; ++i) {\r\n      int s = sizelist[i];\r\n      if (s) {\r\n         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];\r\n         stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);\r\n         z->size [c] = (stbi_uc     ) s;\r\n         z->value[c] = (stbi__uint16) i;\r\n         if (s <= STBI__ZFAST_BITS) {\r\n            int j = stbi__bit_reverse(next_code[s],s);\r\n            while (j < (1 << STBI__ZFAST_BITS)) {\r\n               z->fast[j] = fastv;\r\n               j += (1 << s);\r\n            }\r\n         }\r\n         ++next_code[s];\r\n      }\r\n   }\r\n   return 1;\r\n}\r\n\r\n// zlib-from-memory implementation for PNG reading\r\n//    because PNG allows splitting the zlib stream arbitrarily,\r\n//    and it's annoying structurally to have PNG call ZLIB call PNG,\r\n//    we require PNG read all the IDATs and combine them into a single\r\n//    memory buffer\r\n\r\ntypedef struct\r\n{\r\n   stbi_uc *zbuffer, *zbuffer_end;\r\n   int num_bits;\r\n   stbi__uint32 code_buffer;\r\n\r\n   char *zout;\r\n   char *zout_start;\r\n   char *zout_end;\r\n   int   z_expandable;\r\n\r\n   stbi__zhuffman z_length, z_distance;\r\n} stbi__zbuf;\r\n\r\nstbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)\r\n{\r\n   if (z->zbuffer >= z->zbuffer_end) return 0;\r\n   return *z->zbuffer++;\r\n}\r\n\r\nstatic void stbi__fill_bits(stbi__zbuf *z)\r\n{\r\n   do {\r\n      STBI_ASSERT(z->code_buffer < (1U << z->num_bits));\r\n      z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;\r\n      z->num_bits += 8;\r\n   } while (z->num_bits <= 24);\r\n}\r\n\r\nstbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)\r\n{\r\n   unsigned int k;\r\n   if (z->num_bits < n) stbi__fill_bits(z);\r\n   k = z->code_buffer & ((1 << n) - 1);\r\n   z->code_buffer >>= n;\r\n   z->num_bits -= n;\r\n   return k;\r\n}\r\n\r\nstatic int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)\r\n{\r\n   int b,s,k;\r\n   // not resolved by fast table, so compute it the slow way\r\n   // use jpeg approach, which requires MSbits at top\r\n   k = stbi__bit_reverse(a->code_buffer, 16);\r\n   for (s=STBI__ZFAST_BITS+1; ; ++s)\r\n      if (k < z->maxcode[s])\r\n         break;\r\n   if (s == 16) return -1; // invalid code!\r\n   // code size is s, so:\r\n   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];\r\n   STBI_ASSERT(z->size[b] == s);\r\n   a->code_buffer >>= s;\r\n   a->num_bits -= s;\r\n   return z->value[b];\r\n}\r\n\r\nstbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)\r\n{\r\n   int b,s;\r\n   if (a->num_bits < 16) stbi__fill_bits(a);\r\n   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];\r\n   if (b) {\r\n      s = b >> 9;\r\n      a->code_buffer >>= s;\r\n      a->num_bits -= s;\r\n      return b & 511;\r\n   }\r\n   return stbi__zhuffman_decode_slowpath(a, z);\r\n}\r\n\r\nstatic int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes\r\n{\r\n   char *q;\r\n   int cur, limit, old_limit;\r\n   z->zout = zout;\r\n   if (!z->z_expandable) return stbi__err(\"output buffer limit\",\"Corrupt PNG\");\r\n   cur   = (int) (z->zout     - z->zout_start);\r\n   limit = old_limit = (int) (z->zout_end - z->zout_start);\r\n   while (cur + n > limit)\r\n      limit *= 2;\r\n   q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);\r\n   STBI_NOTUSED(old_limit);\r\n   if (q == NULL) return stbi__err(\"outofmem\", \"Out of memory\");\r\n   z->zout_start = q;\r\n   z->zout       = q + cur;\r\n   z->zout_end   = q + limit;\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__zlength_base[31] = {\r\n   3,4,5,6,7,8,9,10,11,13,\r\n   15,17,19,23,27,31,35,43,51,59,\r\n   67,83,99,115,131,163,195,227,258,0,0 };\r\n\r\nstatic int stbi__zlength_extra[31]=\r\n{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };\r\n\r\nstatic int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,\r\n257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};\r\n\r\nstatic int stbi__zdist_extra[32] =\r\n{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};\r\n\r\nstatic int stbi__parse_huffman_block(stbi__zbuf *a)\r\n{\r\n   char *zout = a->zout;\r\n   for(;;) {\r\n      int z = stbi__zhuffman_decode(a, &a->z_length);\r\n      if (z < 256) {\r\n         if (z < 0) return stbi__err(\"bad huffman code\",\"Corrupt PNG\"); // error in huffman codes\r\n         if (zout >= a->zout_end) {\r\n            if (!stbi__zexpand(a, zout, 1)) return 0;\r\n            zout = a->zout;\r\n         }\r\n         *zout++ = (char) z;\r\n      } else {\r\n         stbi_uc *p;\r\n         int len,dist;\r\n         if (z == 256) {\r\n            a->zout = zout;\r\n            return 1;\r\n         }\r\n         z -= 257;\r\n         len = stbi__zlength_base[z];\r\n         if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);\r\n         z = stbi__zhuffman_decode(a, &a->z_distance);\r\n         if (z < 0) return stbi__err(\"bad huffman code\",\"Corrupt PNG\");\r\n         dist = stbi__zdist_base[z];\r\n         if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);\r\n         if (zout - a->zout_start < dist) return stbi__err(\"bad dist\",\"Corrupt PNG\");\r\n         if (zout + len > a->zout_end) {\r\n            if (!stbi__zexpand(a, zout, len)) return 0;\r\n            zout = a->zout;\r\n         }\r\n         p = (stbi_uc *) (zout - dist);\r\n         if (dist == 1) { // run of one byte; common in images.\r\n            stbi_uc v = *p;\r\n            if (len) { do *zout++ = v; while (--len); }\r\n         } else {\r\n            if (len) { do *zout++ = *p++; while (--len); }\r\n         }\r\n      }\r\n   }\r\n}\r\n\r\nstatic int stbi__compute_huffman_codes(stbi__zbuf *a)\r\n{\r\n   static stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };\r\n   stbi__zhuffman z_codelength;\r\n   stbi_uc lencodes[286+32+137];//padding for maximum single op\r\n   stbi_uc codelength_sizes[19];\r\n   int i,n;\r\n\r\n   int hlit  = stbi__zreceive(a,5) + 257;\r\n   int hdist = stbi__zreceive(a,5) + 1;\r\n   int hclen = stbi__zreceive(a,4) + 4;\r\n   int ntot  = hlit + hdist;\r\n\r\n   memset(codelength_sizes, 0, sizeof(codelength_sizes));\r\n   for (i=0; i < hclen; ++i) {\r\n      int s = stbi__zreceive(a,3);\r\n      codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;\r\n   }\r\n   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;\r\n\r\n   n = 0;\r\n   while (n < ntot) {\r\n      int c = stbi__zhuffman_decode(a, &z_codelength);\r\n      if (c < 0 || c >= 19) return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\r\n      if (c < 16)\r\n         lencodes[n++] = (stbi_uc) c;\r\n      else {\r\n         stbi_uc fill = 0;\r\n         if (c == 16) {\r\n            c = stbi__zreceive(a,2)+3;\r\n            if (n == 0) return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\r\n            fill = lencodes[n-1];\r\n         } else if (c == 17)\r\n            c = stbi__zreceive(a,3)+3;\r\n         else {\r\n            STBI_ASSERT(c == 18);\r\n            c = stbi__zreceive(a,7)+11;\r\n         }\r\n         if (ntot - n < c) return stbi__err(\"bad codelengths\", \"Corrupt PNG\");\r\n         memset(lencodes+n, fill, c);\r\n         n += c;\r\n      }\r\n   }\r\n   if (n != ntot) return stbi__err(\"bad codelengths\",\"Corrupt PNG\");\r\n   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;\r\n   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__parse_uncompressed_block(stbi__zbuf *a)\r\n{\r\n   stbi_uc header[4];\r\n   int len,nlen,k;\r\n   if (a->num_bits & 7)\r\n      stbi__zreceive(a, a->num_bits & 7); // discard\r\n   // drain the bit-packed data into header\r\n   k = 0;\r\n   while (a->num_bits > 0) {\r\n      header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check\r\n      a->code_buffer >>= 8;\r\n      a->num_bits -= 8;\r\n   }\r\n   STBI_ASSERT(a->num_bits == 0);\r\n   // now fill header the normal way\r\n   while (k < 4)\r\n      header[k++] = stbi__zget8(a);\r\n   len  = header[1] * 256 + header[0];\r\n   nlen = header[3] * 256 + header[2];\r\n   if (nlen != (len ^ 0xffff)) return stbi__err(\"zlib corrupt\",\"Corrupt PNG\");\r\n   if (a->zbuffer + len > a->zbuffer_end) return stbi__err(\"read past buffer\",\"Corrupt PNG\");\r\n   if (a->zout + len > a->zout_end)\r\n      if (!stbi__zexpand(a, a->zout, len)) return 0;\r\n   memcpy(a->zout, a->zbuffer, len);\r\n   a->zbuffer += len;\r\n   a->zout += len;\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__parse_zlib_header(stbi__zbuf *a)\r\n{\r\n   int cmf   = stbi__zget8(a);\r\n   int cm    = cmf & 15;\r\n   /* int cinfo = cmf >> 4; */\r\n   int flg   = stbi__zget8(a);\r\n   if ((cmf*256+flg) % 31 != 0) return stbi__err(\"bad zlib header\",\"Corrupt PNG\"); // zlib spec\r\n   if (flg & 32) return stbi__err(\"no preset dict\",\"Corrupt PNG\"); // preset dictionary not allowed in png\r\n   if (cm != 8) return stbi__err(\"bad compression\",\"Corrupt PNG\"); // DEFLATE required for png\r\n   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output\r\n   return 1;\r\n}\r\n\r\nstatic const stbi_uc stbi__zdefault_length[288] =\r\n{\r\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\r\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\r\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\r\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\r\n   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\r\n   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\r\n   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\r\n   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,\r\n   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8\r\n};\r\nstatic const stbi_uc stbi__zdefault_distance[32] =\r\n{\r\n   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5\r\n};\r\n/*\r\nInit algorithm:\r\n{\r\n   int i;   // use <= to match clearly with spec\r\n   for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;\r\n   for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;\r\n   for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;\r\n   for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;\r\n\r\n   for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;\r\n}\r\n*/\r\n\r\nstatic int stbi__parse_zlib(stbi__zbuf *a, int parse_header)\r\n{\r\n   int final, type;\r\n   if (parse_header)\r\n      if (!stbi__parse_zlib_header(a)) return 0;\r\n   a->num_bits = 0;\r\n   a->code_buffer = 0;\r\n   do {\r\n      final = stbi__zreceive(a,1);\r\n      type = stbi__zreceive(a,2);\r\n      if (type == 0) {\r\n         if (!stbi__parse_uncompressed_block(a)) return 0;\r\n      } else if (type == 3) {\r\n         return 0;\r\n      } else {\r\n         if (type == 1) {\r\n            // use fixed code lengths\r\n            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , 288)) return 0;\r\n            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;\r\n         } else {\r\n            if (!stbi__compute_huffman_codes(a)) return 0;\r\n         }\r\n         if (!stbi__parse_huffman_block(a)) return 0;\r\n      }\r\n   } while (!final);\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)\r\n{\r\n   a->zout_start = obuf;\r\n   a->zout       = obuf;\r\n   a->zout_end   = obuf + olen;\r\n   a->z_expandable = exp;\r\n\r\n   return stbi__parse_zlib(a, parse_header);\r\n}\r\n\r\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)\r\n{\r\n   stbi__zbuf a;\r\n   char *p = (char *) stbi__malloc(initial_size);\r\n   if (p == NULL) return NULL;\r\n   a.zbuffer = (stbi_uc *) buffer;\r\n   a.zbuffer_end = (stbi_uc *) buffer + len;\r\n   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {\r\n      if (outlen) *outlen = (int) (a.zout - a.zout_start);\r\n      return a.zout_start;\r\n   } else {\r\n      STBI_FREE(a.zout_start);\r\n      return NULL;\r\n   }\r\n}\r\n\r\nSTBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)\r\n{\r\n   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);\r\n}\r\n\r\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)\r\n{\r\n   stbi__zbuf a;\r\n   char *p = (char *) stbi__malloc(initial_size);\r\n   if (p == NULL) return NULL;\r\n   a.zbuffer = (stbi_uc *) buffer;\r\n   a.zbuffer_end = (stbi_uc *) buffer + len;\r\n   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {\r\n      if (outlen) *outlen = (int) (a.zout - a.zout_start);\r\n      return a.zout_start;\r\n   } else {\r\n      STBI_FREE(a.zout_start);\r\n      return NULL;\r\n   }\r\n}\r\n\r\nSTBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)\r\n{\r\n   stbi__zbuf a;\r\n   a.zbuffer = (stbi_uc *) ibuffer;\r\n   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;\r\n   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))\r\n      return (int) (a.zout - a.zout_start);\r\n   else\r\n      return -1;\r\n}\r\n\r\nSTBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)\r\n{\r\n   stbi__zbuf a;\r\n   char *p = (char *) stbi__malloc(16384);\r\n   if (p == NULL) return NULL;\r\n   a.zbuffer = (stbi_uc *) buffer;\r\n   a.zbuffer_end = (stbi_uc *) buffer+len;\r\n   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {\r\n      if (outlen) *outlen = (int) (a.zout - a.zout_start);\r\n      return a.zout_start;\r\n   } else {\r\n      STBI_FREE(a.zout_start);\r\n      return NULL;\r\n   }\r\n}\r\n\r\nSTBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)\r\n{\r\n   stbi__zbuf a;\r\n   a.zbuffer = (stbi_uc *) ibuffer;\r\n   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;\r\n   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))\r\n      return (int) (a.zout - a.zout_start);\r\n   else\r\n      return -1;\r\n}\r\n#endif\r\n\r\n// public domain \"baseline\" PNG decoder   v0.10  Sean Barrett 2006-11-18\r\n//    simple implementation\r\n//      - only 8-bit samples\r\n//      - no CRC checking\r\n//      - allocates lots of intermediate memory\r\n//        - avoids problem of streaming data between subsystems\r\n//        - avoids explicit window management\r\n//    performance\r\n//      - uses stb_zlib, a PD zlib implementation with fast huffman decoding\r\n\r\n#ifndef STBI_NO_PNG\r\ntypedef struct\r\n{\r\n   stbi__uint32 length;\r\n   stbi__uint32 type;\r\n} stbi__pngchunk;\r\n\r\nstatic stbi__pngchunk stbi__get_chunk_header(stbi__context *s)\r\n{\r\n   stbi__pngchunk c;\r\n   c.length = stbi__get32be(s);\r\n   c.type   = stbi__get32be(s);\r\n   return c;\r\n}\r\n\r\nstatic int stbi__check_png_header(stbi__context *s)\r\n{\r\n   static stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };\r\n   int i;\r\n   for (i=0; i < 8; ++i)\r\n      if (stbi__get8(s) != png_sig[i]) return stbi__err(\"bad png sig\",\"Not a PNG\");\r\n   return 1;\r\n}\r\n\r\ntypedef struct\r\n{\r\n   stbi__context *s;\r\n   stbi_uc *idata, *expanded, *out;\r\n   int depth;\r\n} stbi__png;\r\n\r\n\r\nenum {\r\n   STBI__F_none=0,\r\n   STBI__F_sub=1,\r\n   STBI__F_up=2,\r\n   STBI__F_avg=3,\r\n   STBI__F_paeth=4,\r\n   // synthetic filters used for first scanline to avoid needing a dummy row of 0s\r\n   STBI__F_avg_first,\r\n   STBI__F_paeth_first\r\n};\r\n\r\nstatic stbi_uc first_row_filter[5] =\r\n{\r\n   STBI__F_none,\r\n   STBI__F_sub,\r\n   STBI__F_none,\r\n   STBI__F_avg_first,\r\n   STBI__F_paeth_first\r\n};\r\n\r\nstatic int stbi__paeth(int a, int b, int c)\r\n{\r\n   int p = a + b - c;\r\n   int pa = abs(p-a);\r\n   int pb = abs(p-b);\r\n   int pc = abs(p-c);\r\n   if (pa <= pb && pa <= pc) return a;\r\n   if (pb <= pc) return b;\r\n   return c;\r\n}\r\n\r\nstatic stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };\r\n\r\n// create the png data from post-deflated data\r\nstatic int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)\r\n{\r\n   int bytes = (depth == 16? 2 : 1);\r\n   stbi__context *s = a->s;\r\n   stbi__uint32 i,j,stride = x*out_n*bytes;\r\n   stbi__uint32 img_len, img_width_bytes;\r\n   int k;\r\n   int img_n = s->img_n; // copy it into a local for later\r\n\r\n   int output_bytes = out_n*bytes;\r\n   int filter_bytes = img_n*bytes;\r\n   int width = x;\r\n\r\n   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);\r\n   a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into\r\n   if (!a->out) return stbi__err(\"outofmem\", \"Out of memory\");\r\n\r\n   img_width_bytes = (((img_n * x * depth) + 7) >> 3);\r\n   img_len = (img_width_bytes + 1) * y;\r\n   // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,\r\n   // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),\r\n   // so just check for raw_len < img_len always.\r\n   if (raw_len < img_len) return stbi__err(\"not enough pixels\",\"Corrupt PNG\");\r\n\r\n   for (j=0; j < y; ++j) {\r\n      stbi_uc *cur = a->out + stride*j;\r\n      stbi_uc *prior;\r\n      int filter = *raw++;\r\n\r\n      if (filter > 4)\r\n         return stbi__err(\"invalid filter\",\"Corrupt PNG\");\r\n\r\n      if (depth < 8) {\r\n         STBI_ASSERT(img_width_bytes <= x);\r\n         cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place\r\n         filter_bytes = 1;\r\n         width = img_width_bytes;\r\n      }\r\n      prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above\r\n\r\n      // if first row, use special filter that doesn't sample previous row\r\n      if (j == 0) filter = first_row_filter[filter];\r\n\r\n      // handle first byte explicitly\r\n      for (k=0; k < filter_bytes; ++k) {\r\n         switch (filter) {\r\n            case STBI__F_none       : cur[k] = raw[k]; break;\r\n            case STBI__F_sub        : cur[k] = raw[k]; break;\r\n            case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;\r\n            case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;\r\n            case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;\r\n            case STBI__F_avg_first  : cur[k] = raw[k]; break;\r\n            case STBI__F_paeth_first: cur[k] = raw[k]; break;\r\n         }\r\n      }\r\n\r\n      if (depth == 8) {\r\n         if (img_n != out_n)\r\n            cur[img_n] = 255; // first pixel\r\n         raw += img_n;\r\n         cur += out_n;\r\n         prior += out_n;\r\n      } else if (depth == 16) {\r\n         if (img_n != out_n) {\r\n            cur[filter_bytes]   = 255; // first pixel top byte\r\n            cur[filter_bytes+1] = 255; // first pixel bottom byte\r\n         }\r\n         raw += filter_bytes;\r\n         cur += output_bytes;\r\n         prior += output_bytes;\r\n      } else {\r\n         raw += 1;\r\n         cur += 1;\r\n         prior += 1;\r\n      }\r\n\r\n      // this is a little gross, so that we don't switch per-pixel or per-component\r\n      if (depth < 8 || img_n == out_n) {\r\n         int nk = (width - 1)*filter_bytes;\r\n         #define STBI__CASE(f) \\\r\n             case f:     \\\r\n                for (k=0; k < nk; ++k)\r\n         switch (filter) {\r\n            // \"none\" filter turns into a memcpy here; make that explicit.\r\n            case STBI__F_none:         memcpy(cur, raw, nk); break;\r\n            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;\r\n            STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;\r\n            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;\r\n            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;\r\n            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;\r\n            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;\r\n         }\r\n         #undef STBI__CASE\r\n         raw += nk;\r\n      } else {\r\n         STBI_ASSERT(img_n+1 == out_n);\r\n         #define STBI__CASE(f) \\\r\n             case f:     \\\r\n                for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \\\r\n                   for (k=0; k < filter_bytes; ++k)\r\n         switch (filter) {\r\n            STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;\r\n            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;\r\n            STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;\r\n            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;\r\n            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;\r\n            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;\r\n            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;\r\n         }\r\n         #undef STBI__CASE\r\n\r\n         // the loop above sets the high byte of the pixels' alpha, but for\r\n         // 16 bit png files we also need the low byte set. we'll do that here.\r\n         if (depth == 16) {\r\n            cur = a->out + stride*j; // start at the beginning of the row again\r\n            for (i=0; i < x; ++i,cur+=output_bytes) {\r\n               cur[filter_bytes+1] = 255;\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   // we make a separate pass to expand bits to pixels; for performance,\r\n   // this could run two scanlines behind the above code, so it won't\r\n   // intefere with filtering but will still be in the cache.\r\n   if (depth < 8) {\r\n      for (j=0; j < y; ++j) {\r\n         stbi_uc *cur = a->out + stride*j;\r\n         stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;\r\n         // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit\r\n         // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop\r\n         stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range\r\n\r\n         // note that the final byte might overshoot and write more data than desired.\r\n         // we can allocate enough data that this never writes out of memory, but it\r\n         // could also overwrite the next scanline. can it overwrite non-empty data\r\n         // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.\r\n         // so we need to explicitly clamp the final ones\r\n\r\n         if (depth == 4) {\r\n            for (k=x*img_n; k >= 2; k-=2, ++in) {\r\n               *cur++ = scale * ((*in >> 4)       );\r\n               *cur++ = scale * ((*in     ) & 0x0f);\r\n            }\r\n            if (k > 0) *cur++ = scale * ((*in >> 4)       );\r\n         } else if (depth == 2) {\r\n            for (k=x*img_n; k >= 4; k-=4, ++in) {\r\n               *cur++ = scale * ((*in >> 6)       );\r\n               *cur++ = scale * ((*in >> 4) & 0x03);\r\n               *cur++ = scale * ((*in >> 2) & 0x03);\r\n               *cur++ = scale * ((*in     ) & 0x03);\r\n            }\r\n            if (k > 0) *cur++ = scale * ((*in >> 6)       );\r\n            if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);\r\n            if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);\r\n         } else if (depth == 1) {\r\n            for (k=x*img_n; k >= 8; k-=8, ++in) {\r\n               *cur++ = scale * ((*in >> 7)       );\r\n               *cur++ = scale * ((*in >> 6) & 0x01);\r\n               *cur++ = scale * ((*in >> 5) & 0x01);\r\n               *cur++ = scale * ((*in >> 4) & 0x01);\r\n               *cur++ = scale * ((*in >> 3) & 0x01);\r\n               *cur++ = scale * ((*in >> 2) & 0x01);\r\n               *cur++ = scale * ((*in >> 1) & 0x01);\r\n               *cur++ = scale * ((*in     ) & 0x01);\r\n            }\r\n            if (k > 0) *cur++ = scale * ((*in >> 7)       );\r\n            if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);\r\n            if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);\r\n            if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);\r\n            if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);\r\n            if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);\r\n            if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);\r\n         }\r\n         if (img_n != out_n) {\r\n            int q;\r\n            // insert alpha = 255\r\n            cur = a->out + stride*j;\r\n            if (img_n == 1) {\r\n               for (q=x-1; q >= 0; --q) {\r\n                  cur[q*2+1] = 255;\r\n                  cur[q*2+0] = cur[q];\r\n               }\r\n            } else {\r\n               STBI_ASSERT(img_n == 3);\r\n               for (q=x-1; q >= 0; --q) {\r\n                  cur[q*4+3] = 255;\r\n                  cur[q*4+2] = cur[q*3+2];\r\n                  cur[q*4+1] = cur[q*3+1];\r\n                  cur[q*4+0] = cur[q*3+0];\r\n               }\r\n            }\r\n         }\r\n      }\r\n   } else if (depth == 16) {\r\n      // force the image data from big-endian to platform-native.\r\n      // this is done in a separate pass due to the decoding relying\r\n      // on the data being untouched, but could probably be done\r\n      // per-line during decode if care is taken.\r\n      stbi_uc *cur = a->out;\r\n      stbi__uint16 *cur16 = (stbi__uint16*)cur;\r\n\r\n      for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {\r\n         *cur16 = (cur[0] << 8) | cur[1];\r\n      }\r\n   }\r\n\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)\r\n{\r\n   int bytes = (depth == 16 ? 2 : 1);\r\n   int out_bytes = out_n * bytes;\r\n   stbi_uc *final;\r\n   int p;\r\n   if (!interlaced)\r\n      return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);\r\n\r\n   // de-interlacing\r\n   final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);\r\n   for (p=0; p < 7; ++p) {\r\n      int xorig[] = { 0,4,0,2,0,1,0 };\r\n      int yorig[] = { 0,0,4,0,2,0,1 };\r\n      int xspc[]  = { 8,8,4,4,2,2,1 };\r\n      int yspc[]  = { 8,8,8,4,4,2,2 };\r\n      int i,j,x,y;\r\n      // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1\r\n      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];\r\n      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];\r\n      if (x && y) {\r\n         stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;\r\n         if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {\r\n            STBI_FREE(final);\r\n            return 0;\r\n         }\r\n         for (j=0; j < y; ++j) {\r\n            for (i=0; i < x; ++i) {\r\n               int out_y = j*yspc[p]+yorig[p];\r\n               int out_x = i*xspc[p]+xorig[p];\r\n               memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,\r\n                      a->out + (j*x+i)*out_bytes, out_bytes);\r\n            }\r\n         }\r\n         STBI_FREE(a->out);\r\n         image_data += img_len;\r\n         image_data_len -= img_len;\r\n      }\r\n   }\r\n   a->out = final;\r\n\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)\r\n{\r\n   stbi__context *s = z->s;\r\n   stbi__uint32 i, pixel_count = s->img_x * s->img_y;\r\n   stbi_uc *p = z->out;\r\n\r\n   // compute color-based transparency, assuming we've\r\n   // already got 255 as the alpha value in the output\r\n   STBI_ASSERT(out_n == 2 || out_n == 4);\r\n\r\n   if (out_n == 2) {\r\n      for (i=0; i < pixel_count; ++i) {\r\n         p[1] = (p[0] == tc[0] ? 0 : 255);\r\n         p += 2;\r\n      }\r\n   } else {\r\n      for (i=0; i < pixel_count; ++i) {\r\n         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])\r\n            p[3] = 0;\r\n         p += 4;\r\n      }\r\n   }\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)\r\n{\r\n   stbi__context *s = z->s;\r\n   stbi__uint32 i, pixel_count = s->img_x * s->img_y;\r\n   stbi__uint16 *p = (stbi__uint16*) z->out;\r\n\r\n   // compute color-based transparency, assuming we've\r\n   // already got 65535 as the alpha value in the output\r\n   STBI_ASSERT(out_n == 2 || out_n == 4);\r\n\r\n   if (out_n == 2) {\r\n      for (i = 0; i < pixel_count; ++i) {\r\n         p[1] = (p[0] == tc[0] ? 0 : 65535);\r\n         p += 2;\r\n      }\r\n   } else {\r\n      for (i = 0; i < pixel_count; ++i) {\r\n         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])\r\n            p[3] = 0;\r\n         p += 4;\r\n      }\r\n   }\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)\r\n{\r\n   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;\r\n   stbi_uc *p, *temp_out, *orig = a->out;\r\n\r\n   p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);\r\n   if (p == NULL) return stbi__err(\"outofmem\", \"Out of memory\");\r\n\r\n   // between here and free(out) below, exitting would leak\r\n   temp_out = p;\r\n\r\n   if (pal_img_n == 3) {\r\n      for (i=0; i < pixel_count; ++i) {\r\n         int n = orig[i]*4;\r\n         p[0] = palette[n  ];\r\n         p[1] = palette[n+1];\r\n         p[2] = palette[n+2];\r\n         p += 3;\r\n      }\r\n   } else {\r\n      for (i=0; i < pixel_count; ++i) {\r\n         int n = orig[i]*4;\r\n         p[0] = palette[n  ];\r\n         p[1] = palette[n+1];\r\n         p[2] = palette[n+2];\r\n         p[3] = palette[n+3];\r\n         p += 4;\r\n      }\r\n   }\r\n   STBI_FREE(a->out);\r\n   a->out = temp_out;\r\n\r\n   STBI_NOTUSED(len);\r\n\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__unpremultiply_on_load = 0;\r\nstatic int stbi__de_iphone_flag = 0;\r\n\r\nSTBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)\r\n{\r\n   stbi__unpremultiply_on_load = flag_true_if_should_unpremultiply;\r\n}\r\n\r\nSTBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)\r\n{\r\n   stbi__de_iphone_flag = flag_true_if_should_convert;\r\n}\r\n\r\nstatic void stbi__de_iphone(stbi__png *z)\r\n{\r\n   stbi__context *s = z->s;\r\n   stbi__uint32 i, pixel_count = s->img_x * s->img_y;\r\n   stbi_uc *p = z->out;\r\n\r\n   if (s->img_out_n == 3) {  // convert bgr to rgb\r\n      for (i=0; i < pixel_count; ++i) {\r\n         stbi_uc t = p[0];\r\n         p[0] = p[2];\r\n         p[2] = t;\r\n         p += 3;\r\n      }\r\n   } else {\r\n      STBI_ASSERT(s->img_out_n == 4);\r\n      if (stbi__unpremultiply_on_load) {\r\n         // convert bgr to rgb and unpremultiply\r\n         for (i=0; i < pixel_count; ++i) {\r\n            stbi_uc a = p[3];\r\n            stbi_uc t = p[0];\r\n            if (a) {\r\n               stbi_uc half = a / 2;\r\n               p[0] = (p[2] * 255 + half) / a;\r\n               p[1] = (p[1] * 255 + half) / a;\r\n               p[2] = ( t   * 255 + half) / a;\r\n            } else {\r\n               p[0] = p[2];\r\n               p[2] = t;\r\n            }\r\n            p += 4;\r\n         }\r\n      } else {\r\n         // convert bgr to rgb\r\n         for (i=0; i < pixel_count; ++i) {\r\n            stbi_uc t = p[0];\r\n            p[0] = p[2];\r\n            p[2] = t;\r\n            p += 4;\r\n         }\r\n      }\r\n   }\r\n}\r\n\r\n#define STBI__PNG_TYPE(a,b,c,d)  (((a) << 24) + ((b) << 16) + ((c) << 8) + (d))\r\n\r\nstatic int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)\r\n{\r\n   stbi_uc palette[1024], pal_img_n=0;\r\n   stbi_uc has_trans=0, tc[3];\r\n   stbi__uint16 tc16[3];\r\n   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;\r\n   int first=1,k,interlace=0, color=0, is_iphone=0;\r\n   stbi__context *s = z->s;\r\n\r\n   z->expanded = NULL;\r\n   z->idata = NULL;\r\n   z->out = NULL;\r\n\r\n   if (!stbi__check_png_header(s)) return 0;\r\n\r\n   if (scan == STBI__SCAN_type) return 1;\r\n\r\n   for (;;) {\r\n      stbi__pngchunk c = stbi__get_chunk_header(s);\r\n      switch (c.type) {\r\n         case STBI__PNG_TYPE('C','g','B','I'):\r\n            is_iphone = 1;\r\n            stbi__skip(s, c.length);\r\n            break;\r\n         case STBI__PNG_TYPE('I','H','D','R'): {\r\n            int comp,filter;\r\n            if (!first) return stbi__err(\"multiple IHDR\",\"Corrupt PNG\");\r\n            first = 0;\r\n            if (c.length != 13) return stbi__err(\"bad IHDR len\",\"Corrupt PNG\");\r\n            s->img_x = stbi__get32be(s); if (s->img_x > (1 << 24)) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\r\n            s->img_y = stbi__get32be(s); if (s->img_y > (1 << 24)) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\r\n            z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err(\"1/2/4/8/16-bit only\",\"PNG not supported: 1/2/4/8/16-bit only\");\r\n            color = stbi__get8(s);  if (color > 6)         return stbi__err(\"bad ctype\",\"Corrupt PNG\");\r\n            if (color == 3 && z->depth == 16)                  return stbi__err(\"bad ctype\",\"Corrupt PNG\");\r\n            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err(\"bad ctype\",\"Corrupt PNG\");\r\n            comp  = stbi__get8(s);  if (comp) return stbi__err(\"bad comp method\",\"Corrupt PNG\");\r\n            filter= stbi__get8(s);  if (filter) return stbi__err(\"bad filter method\",\"Corrupt PNG\");\r\n            interlace = stbi__get8(s); if (interlace>1) return stbi__err(\"bad interlace method\",\"Corrupt PNG\");\r\n            if (!s->img_x || !s->img_y) return stbi__err(\"0-pixel image\",\"Corrupt PNG\");\r\n            if (!pal_img_n) {\r\n               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);\r\n               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err(\"too large\", \"Image too large to decode\");\r\n               if (scan == STBI__SCAN_header) return 1;\r\n            } else {\r\n               // if paletted, then pal_n is our final components, and\r\n               // img_n is # components to decompress/filter.\r\n               s->img_n = 1;\r\n               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err(\"too large\",\"Corrupt PNG\");\r\n               // if SCAN_header, have to scan to see if we have a tRNS\r\n            }\r\n            break;\r\n         }\r\n\r\n         case STBI__PNG_TYPE('P','L','T','E'):  {\r\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\r\n            if (c.length > 256*3) return stbi__err(\"invalid PLTE\",\"Corrupt PNG\");\r\n            pal_len = c.length / 3;\r\n            if (pal_len * 3 != c.length) return stbi__err(\"invalid PLTE\",\"Corrupt PNG\");\r\n            for (i=0; i < pal_len; ++i) {\r\n               palette[i*4+0] = stbi__get8(s);\r\n               palette[i*4+1] = stbi__get8(s);\r\n               palette[i*4+2] = stbi__get8(s);\r\n               palette[i*4+3] = 255;\r\n            }\r\n            break;\r\n         }\r\n\r\n         case STBI__PNG_TYPE('t','R','N','S'): {\r\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\r\n            if (z->idata) return stbi__err(\"tRNS after IDAT\",\"Corrupt PNG\");\r\n            if (pal_img_n) {\r\n               if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }\r\n               if (pal_len == 0) return stbi__err(\"tRNS before PLTE\",\"Corrupt PNG\");\r\n               if (c.length > pal_len) return stbi__err(\"bad tRNS len\",\"Corrupt PNG\");\r\n               pal_img_n = 4;\r\n               for (i=0; i < c.length; ++i)\r\n                  palette[i*4+3] = stbi__get8(s);\r\n            } else {\r\n               if (!(s->img_n & 1)) return stbi__err(\"tRNS with alpha\",\"Corrupt PNG\");\r\n               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err(\"bad tRNS len\",\"Corrupt PNG\");\r\n               has_trans = 1;\r\n               if (z->depth == 16) {\r\n                  for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is\r\n               } else {\r\n                  for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger\r\n               }\r\n            }\r\n            break;\r\n         }\r\n\r\n         case STBI__PNG_TYPE('I','D','A','T'): {\r\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\r\n            if (pal_img_n && !pal_len) return stbi__err(\"no PLTE\",\"Corrupt PNG\");\r\n            if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }\r\n            if ((int)(ioff + c.length) < (int)ioff) return 0;\r\n            if (ioff + c.length > idata_limit) {\r\n               stbi__uint32 idata_limit_old = idata_limit;\r\n               stbi_uc *p;\r\n               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;\r\n               while (ioff + c.length > idata_limit)\r\n                  idata_limit *= 2;\r\n               STBI_NOTUSED(idata_limit_old);\r\n               p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err(\"outofmem\", \"Out of memory\");\r\n               z->idata = p;\r\n            }\r\n            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err(\"outofdata\",\"Corrupt PNG\");\r\n            ioff += c.length;\r\n            break;\r\n         }\r\n\r\n         case STBI__PNG_TYPE('I','E','N','D'): {\r\n            stbi__uint32 raw_len, bpl;\r\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\r\n            if (scan != STBI__SCAN_load) return 1;\r\n            if (z->idata == NULL) return stbi__err(\"no IDAT\",\"Corrupt PNG\");\r\n            // initial guess for decoded data size to avoid unnecessary reallocs\r\n            bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component\r\n            raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;\r\n            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);\r\n            if (z->expanded == NULL) return 0; // zlib should set error\r\n            STBI_FREE(z->idata); z->idata = NULL;\r\n            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)\r\n               s->img_out_n = s->img_n+1;\r\n            else\r\n               s->img_out_n = s->img_n;\r\n            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;\r\n            if (has_trans) {\r\n               if (z->depth == 16) {\r\n                  if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;\r\n               } else {\r\n                  if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;\r\n               }\r\n            }\r\n            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)\r\n               stbi__de_iphone(z);\r\n            if (pal_img_n) {\r\n               // pal_img_n == 3 or 4\r\n               s->img_n = pal_img_n; // record the actual colors we had\r\n               s->img_out_n = pal_img_n;\r\n               if (req_comp >= 3) s->img_out_n = req_comp;\r\n               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))\r\n                  return 0;\r\n            } else if (has_trans) {\r\n               // non-paletted image with tRNS -> source image has (constant) alpha\r\n               ++s->img_n;\r\n            }\r\n            STBI_FREE(z->expanded); z->expanded = NULL;\r\n            return 1;\r\n         }\r\n\r\n         default:\r\n            // if critical, fail\r\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\r\n            if ((c.type & (1 << 29)) == 0) {\r\n               #ifndef STBI_NO_FAILURE_STRINGS\r\n               // not threadsafe\r\n               static char invalid_chunk[] = \"XXXX PNG chunk not known\";\r\n               invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);\r\n               invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);\r\n               invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);\r\n               invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);\r\n               #endif\r\n               return stbi__err(invalid_chunk, \"PNG not supported: unknown PNG chunk type\");\r\n            }\r\n            stbi__skip(s, c.length);\r\n            break;\r\n      }\r\n      // end of PNG chunk, read and skip CRC\r\n      stbi__get32be(s);\r\n   }\r\n}\r\n\r\nstatic void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)\r\n{\r\n   void *result=NULL;\r\n   if (req_comp < 0 || req_comp > 4) return stbi__errpuc(\"bad req_comp\", \"Internal error\");\r\n   if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {\r\n      if (p->depth < 8)\r\n         ri->bits_per_channel = 8;\r\n      else\r\n         ri->bits_per_channel = p->depth;\r\n      result = p->out;\r\n      p->out = NULL;\r\n      if (req_comp && req_comp != p->s->img_out_n) {\r\n         if (ri->bits_per_channel == 8)\r\n            result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);\r\n         else\r\n            result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);\r\n         p->s->img_out_n = req_comp;\r\n         if (result == NULL) return result;\r\n      }\r\n      *x = p->s->img_x;\r\n      *y = p->s->img_y;\r\n      if (n) *n = p->s->img_n;\r\n   }\r\n   STBI_FREE(p->out);      p->out      = NULL;\r\n   STBI_FREE(p->expanded); p->expanded = NULL;\r\n   STBI_FREE(p->idata);    p->idata    = NULL;\r\n\r\n   return result;\r\n}\r\n\r\nstatic void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\r\n{\r\n   stbi__png p;\r\n   p.s = s;\r\n   return stbi__do_png(&p, x,y,comp,req_comp, ri);\r\n}\r\n\r\nstatic int stbi__png_test(stbi__context *s)\r\n{\r\n   int r;\r\n   r = stbi__check_png_header(s);\r\n   stbi__rewind(s);\r\n   return r;\r\n}\r\n\r\nstatic int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)\r\n{\r\n   if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {\r\n      stbi__rewind( p->s );\r\n      return 0;\r\n   }\r\n   if (x) *x = p->s->img_x;\r\n   if (y) *y = p->s->img_y;\r\n   if (comp) *comp = p->s->img_n;\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)\r\n{\r\n   stbi__png p;\r\n   p.s = s;\r\n   return stbi__png_info_raw(&p, x, y, comp);\r\n}\r\n#endif\r\n\r\n// Microsoft/Windows BMP image\r\n\r\n#ifndef STBI_NO_BMP\r\nstatic int stbi__bmp_test_raw(stbi__context *s)\r\n{\r\n   int r;\r\n   int sz;\r\n   if (stbi__get8(s) != 'B') return 0;\r\n   if (stbi__get8(s) != 'M') return 0;\r\n   stbi__get32le(s); // discard filesize\r\n   stbi__get16le(s); // discard reserved\r\n   stbi__get16le(s); // discard reserved\r\n   stbi__get32le(s); // discard data offset\r\n   sz = stbi__get32le(s);\r\n   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);\r\n   return r;\r\n}\r\n\r\nstatic int stbi__bmp_test(stbi__context *s)\r\n{\r\n   int r = stbi__bmp_test_raw(s);\r\n   stbi__rewind(s);\r\n   return r;\r\n}\r\n\r\n\r\n// returns 0..31 for the highest set bit\r\nstatic int stbi__high_bit(unsigned int z)\r\n{\r\n   int n=0;\r\n   if (z == 0) return -1;\r\n   if (z >= 0x10000) n += 16, z >>= 16;\r\n   if (z >= 0x00100) n +=  8, z >>=  8;\r\n   if (z >= 0x00010) n +=  4, z >>=  4;\r\n   if (z >= 0x00004) n +=  2, z >>=  2;\r\n   if (z >= 0x00002) n +=  1, z >>=  1;\r\n   return n;\r\n}\r\n\r\nstatic int stbi__bitcount(unsigned int a)\r\n{\r\n   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2\r\n   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4\r\n   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits\r\n   a = (a + (a >> 8)); // max 16 per 8 bits\r\n   a = (a + (a >> 16)); // max 32 per 8 bits\r\n   return a & 0xff;\r\n}\r\n\r\nstatic int stbi__shiftsigned(int v, int shift, int bits)\r\n{\r\n   int result;\r\n   int z=0;\r\n\r\n   if (shift < 0) v <<= -shift;\r\n   else v >>= shift;\r\n   result = v;\r\n\r\n   z = bits;\r\n   while (z < 8) {\r\n      result += v >> z;\r\n      z += bits;\r\n   }\r\n   return result;\r\n}\r\n\r\ntypedef struct\r\n{\r\n   int bpp, offset, hsz;\r\n   unsigned int mr,mg,mb,ma, all_a;\r\n} stbi__bmp_data;\r\n\r\nstatic void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)\r\n{\r\n   int hsz;\r\n   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc(\"not BMP\", \"Corrupt BMP\");\r\n   stbi__get32le(s); // discard filesize\r\n   stbi__get16le(s); // discard reserved\r\n   stbi__get16le(s); // discard reserved\r\n   info->offset = stbi__get32le(s);\r\n   info->hsz = hsz = stbi__get32le(s);\r\n   info->mr = info->mg = info->mb = info->ma = 0;\r\n\r\n   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc(\"unknown BMP\", \"BMP type not supported: unknown\");\r\n   if (hsz == 12) {\r\n      s->img_x = stbi__get16le(s);\r\n      s->img_y = stbi__get16le(s);\r\n   } else {\r\n      s->img_x = stbi__get32le(s);\r\n      s->img_y = stbi__get32le(s);\r\n   }\r\n   if (stbi__get16le(s) != 1) return stbi__errpuc(\"bad BMP\", \"bad BMP\");\r\n   info->bpp = stbi__get16le(s);\r\n   if (info->bpp == 1) return stbi__errpuc(\"monochrome\", \"BMP type not supported: 1-bit\");\r\n   if (hsz != 12) {\r\n      int compress = stbi__get32le(s);\r\n      if (compress == 1 || compress == 2) return stbi__errpuc(\"BMP RLE\", \"BMP type not supported: RLE\");\r\n      stbi__get32le(s); // discard sizeof\r\n      stbi__get32le(s); // discard hres\r\n      stbi__get32le(s); // discard vres\r\n      stbi__get32le(s); // discard colorsused\r\n      stbi__get32le(s); // discard max important\r\n      if (hsz == 40 || hsz == 56) {\r\n         if (hsz == 56) {\r\n            stbi__get32le(s);\r\n            stbi__get32le(s);\r\n            stbi__get32le(s);\r\n            stbi__get32le(s);\r\n         }\r\n         if (info->bpp == 16 || info->bpp == 32) {\r\n            if (compress == 0) {\r\n               if (info->bpp == 32) {\r\n                  info->mr = 0xffu << 16;\r\n                  info->mg = 0xffu <<  8;\r\n                  info->mb = 0xffu <<  0;\r\n                  info->ma = 0xffu << 24;\r\n                  info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0\r\n               } else {\r\n                  info->mr = 31u << 10;\r\n                  info->mg = 31u <<  5;\r\n                  info->mb = 31u <<  0;\r\n               }\r\n            } else if (compress == 3) {\r\n               info->mr = stbi__get32le(s);\r\n               info->mg = stbi__get32le(s);\r\n               info->mb = stbi__get32le(s);\r\n               // not documented, but generated by photoshop and handled by mspaint\r\n               if (info->mr == info->mg && info->mg == info->mb) {\r\n                  // ?!?!?\r\n                  return stbi__errpuc(\"bad BMP\", \"bad BMP\");\r\n               }\r\n            } else\r\n               return stbi__errpuc(\"bad BMP\", \"bad BMP\");\r\n         }\r\n      } else {\r\n         int i;\r\n         if (hsz != 108 && hsz != 124)\r\n            return stbi__errpuc(\"bad BMP\", \"bad BMP\");\r\n         info->mr = stbi__get32le(s);\r\n         info->mg = stbi__get32le(s);\r\n         info->mb = stbi__get32le(s);\r\n         info->ma = stbi__get32le(s);\r\n         stbi__get32le(s); // discard color space\r\n         for (i=0; i < 12; ++i)\r\n            stbi__get32le(s); // discard color space parameters\r\n         if (hsz == 124) {\r\n            stbi__get32le(s); // discard rendering intent\r\n            stbi__get32le(s); // discard offset of profile data\r\n            stbi__get32le(s); // discard size of profile data\r\n            stbi__get32le(s); // discard reserved\r\n         }\r\n      }\r\n   }\r\n   return (void *) 1;\r\n}\r\n\r\n\r\nstatic void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\r\n{\r\n   stbi_uc *out;\r\n   unsigned int mr=0,mg=0,mb=0,ma=0, all_a;\r\n   stbi_uc pal[256][4];\r\n   int psize=0,i,j,width;\r\n   int flip_vertically, pad, target;\r\n   stbi__bmp_data info;\r\n   STBI_NOTUSED(ri);\r\n\r\n   info.all_a = 255;\r\n   if (stbi__bmp_parse_header(s, &info) == NULL)\r\n      return NULL; // error code already set\r\n\r\n   flip_vertically = ((int) s->img_y) > 0;\r\n   s->img_y = abs((int) s->img_y);\r\n\r\n   mr = info.mr;\r\n   mg = info.mg;\r\n   mb = info.mb;\r\n   ma = info.ma;\r\n   all_a = info.all_a;\r\n\r\n   if (info.hsz == 12) {\r\n      if (info.bpp < 24)\r\n         psize = (info.offset - 14 - 24) / 3;\r\n   } else {\r\n      if (info.bpp < 16)\r\n         psize = (info.offset - 14 - info.hsz) >> 2;\r\n   }\r\n\r\n   s->img_n = ma ? 4 : 3;\r\n   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4\r\n      target = req_comp;\r\n   else\r\n      target = s->img_n; // if they want monochrome, we'll post-convert\r\n\r\n   // sanity-check size\r\n   if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))\r\n      return stbi__errpuc(\"too large\", \"Corrupt BMP\");\r\n\r\n   out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);\r\n   if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n   if (info.bpp < 16) {\r\n      int z=0;\r\n      if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc(\"invalid\", \"Corrupt BMP\"); }\r\n      for (i=0; i < psize; ++i) {\r\n         pal[i][2] = stbi__get8(s);\r\n         pal[i][1] = stbi__get8(s);\r\n         pal[i][0] = stbi__get8(s);\r\n         if (info.hsz != 12) stbi__get8(s);\r\n         pal[i][3] = 255;\r\n      }\r\n      stbi__skip(s, info.offset - 14 - info.hsz - psize * (info.hsz == 12 ? 3 : 4));\r\n      if (info.bpp == 4) width = (s->img_x + 1) >> 1;\r\n      else if (info.bpp == 8) width = s->img_x;\r\n      else { STBI_FREE(out); return stbi__errpuc(\"bad bpp\", \"Corrupt BMP\"); }\r\n      pad = (-width)&3;\r\n      for (j=0; j < (int) s->img_y; ++j) {\r\n         for (i=0; i < (int) s->img_x; i += 2) {\r\n            int v=stbi__get8(s),v2=0;\r\n            if (info.bpp == 4) {\r\n               v2 = v & 15;\r\n               v >>= 4;\r\n            }\r\n            out[z++] = pal[v][0];\r\n            out[z++] = pal[v][1];\r\n            out[z++] = pal[v][2];\r\n            if (target == 4) out[z++] = 255;\r\n            if (i+1 == (int) s->img_x) break;\r\n            v = (info.bpp == 8) ? stbi__get8(s) : v2;\r\n            out[z++] = pal[v][0];\r\n            out[z++] = pal[v][1];\r\n            out[z++] = pal[v][2];\r\n            if (target == 4) out[z++] = 255;\r\n         }\r\n         stbi__skip(s, pad);\r\n      }\r\n   } else {\r\n      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;\r\n      int z = 0;\r\n      int easy=0;\r\n      stbi__skip(s, info.offset - 14 - info.hsz);\r\n      if (info.bpp == 24) width = 3 * s->img_x;\r\n      else if (info.bpp == 16) width = 2*s->img_x;\r\n      else /* bpp = 32 and pad = 0 */ width=0;\r\n      pad = (-width) & 3;\r\n      if (info.bpp == 24) {\r\n         easy = 1;\r\n      } else if (info.bpp == 32) {\r\n         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)\r\n            easy = 2;\r\n      }\r\n      if (!easy) {\r\n         if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc(\"bad masks\", \"Corrupt BMP\"); }\r\n         // right shift amt to put high bit in position #7\r\n         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);\r\n         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);\r\n         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);\r\n         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);\r\n      }\r\n      for (j=0; j < (int) s->img_y; ++j) {\r\n         if (easy) {\r\n            for (i=0; i < (int) s->img_x; ++i) {\r\n               unsigned char a;\r\n               out[z+2] = stbi__get8(s);\r\n               out[z+1] = stbi__get8(s);\r\n               out[z+0] = stbi__get8(s);\r\n               z += 3;\r\n               a = (easy == 2 ? stbi__get8(s) : 255);\r\n               all_a |= a;\r\n               if (target == 4) out[z++] = a;\r\n            }\r\n         } else {\r\n            int bpp = info.bpp;\r\n            for (i=0; i < (int) s->img_x; ++i) {\r\n               stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));\r\n               int a;\r\n               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));\r\n               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));\r\n               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));\r\n               a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);\r\n               all_a |= a;\r\n               if (target == 4) out[z++] = STBI__BYTECAST(a);\r\n            }\r\n         }\r\n         stbi__skip(s, pad);\r\n      }\r\n   }\r\n\r\n   // if alpha channel is all 0s, replace with all 255s\r\n   if (target == 4 && all_a == 0)\r\n      for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)\r\n         out[i] = 255;\r\n\r\n   if (flip_vertically) {\r\n      stbi_uc t;\r\n      for (j=0; j < (int) s->img_y>>1; ++j) {\r\n         stbi_uc *p1 = out +      j     *s->img_x*target;\r\n         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;\r\n         for (i=0; i < (int) s->img_x*target; ++i) {\r\n            t = p1[i], p1[i] = p2[i], p2[i] = t;\r\n         }\r\n      }\r\n   }\r\n\r\n   if (req_comp && req_comp != target) {\r\n      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);\r\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\r\n   }\r\n\r\n   *x = s->img_x;\r\n   *y = s->img_y;\r\n   if (comp) *comp = s->img_n;\r\n   return out;\r\n}\r\n#endif\r\n\r\n// Targa Truevision - TGA\r\n// by Jonathan Dummer\r\n#ifndef STBI_NO_TGA\r\n// returns STBI_rgb or whatever, 0 on error\r\nstatic int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)\r\n{\r\n   // only RGB or RGBA (incl. 16bit) or grey allowed\r\n   if(is_rgb16) *is_rgb16 = 0;\r\n   switch(bits_per_pixel) {\r\n      case 8:  return STBI_grey;\r\n      case 16: if(is_grey) return STBI_grey_alpha;\r\n            // else: fall-through\r\n      case 15: if(is_rgb16) *is_rgb16 = 1;\r\n            return STBI_rgb;\r\n      case 24: // fall-through\r\n      case 32: return bits_per_pixel/8;\r\n      default: return 0;\r\n   }\r\n}\r\n\r\nstatic int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)\r\n{\r\n    int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;\r\n    int sz, tga_colormap_type;\r\n    stbi__get8(s);                   // discard Offset\r\n    tga_colormap_type = stbi__get8(s); // colormap type\r\n    if( tga_colormap_type > 1 ) {\r\n        stbi__rewind(s);\r\n        return 0;      // only RGB or indexed allowed\r\n    }\r\n    tga_image_type = stbi__get8(s); // image type\r\n    if ( tga_colormap_type == 1 ) { // colormapped (paletted) image\r\n        if (tga_image_type != 1 && tga_image_type != 9) {\r\n            stbi__rewind(s);\r\n            return 0;\r\n        }\r\n        stbi__skip(s,4);       // skip index of first colormap entry and number of entries\r\n        sz = stbi__get8(s);    //   check bits per palette color entry\r\n        if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {\r\n            stbi__rewind(s);\r\n            return 0;\r\n        }\r\n        stbi__skip(s,4);       // skip image x and y origin\r\n        tga_colormap_bpp = sz;\r\n    } else { // \"normal\" image w/o colormap - only RGB or grey allowed, +/- RLE\r\n        if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {\r\n            stbi__rewind(s);\r\n            return 0; // only RGB or grey allowed, +/- RLE\r\n        }\r\n        stbi__skip(s,9); // skip colormap specification and image x/y origin\r\n        tga_colormap_bpp = 0;\r\n    }\r\n    tga_w = stbi__get16le(s);\r\n    if( tga_w < 1 ) {\r\n        stbi__rewind(s);\r\n        return 0;   // test width\r\n    }\r\n    tga_h = stbi__get16le(s);\r\n    if( tga_h < 1 ) {\r\n        stbi__rewind(s);\r\n        return 0;   // test height\r\n    }\r\n    tga_bits_per_pixel = stbi__get8(s); // bits per pixel\r\n    stbi__get8(s); // ignore alpha bits\r\n    if (tga_colormap_bpp != 0) {\r\n        if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {\r\n            // when using a colormap, tga_bits_per_pixel is the size of the indexes\r\n            // I don't think anything but 8 or 16bit indexes makes sense\r\n            stbi__rewind(s);\r\n            return 0;\r\n        }\r\n        tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);\r\n    } else {\r\n        tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);\r\n    }\r\n    if(!tga_comp) {\r\n      stbi__rewind(s);\r\n      return 0;\r\n    }\r\n    if (x) *x = tga_w;\r\n    if (y) *y = tga_h;\r\n    if (comp) *comp = tga_comp;\r\n    return 1;                   // seems to have passed everything\r\n}\r\n\r\nstatic int stbi__tga_test(stbi__context *s)\r\n{\r\n   int res = 0;\r\n   int sz, tga_color_type;\r\n   stbi__get8(s);      //   discard Offset\r\n   tga_color_type = stbi__get8(s);   //   color type\r\n   if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed\r\n   sz = stbi__get8(s);   //   image type\r\n   if ( tga_color_type == 1 ) { // colormapped (paletted) image\r\n      if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9\r\n      stbi__skip(s,4);       // skip index of first colormap entry and number of entries\r\n      sz = stbi__get8(s);    //   check bits per palette color entry\r\n      if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;\r\n      stbi__skip(s,4);       // skip image x and y origin\r\n   } else { // \"normal\" image w/o colormap\r\n      if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE\r\n      stbi__skip(s,9); // skip colormap specification and image x/y origin\r\n   }\r\n   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width\r\n   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height\r\n   sz = stbi__get8(s);   //   bits per pixel\r\n   if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index\r\n   if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;\r\n\r\n   res = 1; // if we got this far, everything's good and we can return 1 instead of 0\r\n\r\nerrorEnd:\r\n   stbi__rewind(s);\r\n   return res;\r\n}\r\n\r\n// read 16bit value and convert to 24bit RGB\r\nstatic void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)\r\n{\r\n   stbi__uint16 px = (stbi__uint16)stbi__get16le(s);\r\n   stbi__uint16 fiveBitMask = 31;\r\n   // we have 3 channels with 5bits each\r\n   int r = (px >> 10) & fiveBitMask;\r\n   int g = (px >> 5) & fiveBitMask;\r\n   int b = px & fiveBitMask;\r\n   // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later\r\n   out[0] = (stbi_uc)((r * 255)/31);\r\n   out[1] = (stbi_uc)((g * 255)/31);\r\n   out[2] = (stbi_uc)((b * 255)/31);\r\n\r\n   // some people claim that the most significant bit might be used for alpha\r\n   // (possibly if an alpha-bit is set in the \"image descriptor byte\")\r\n   // but that only made 16bit test images completely translucent..\r\n   // so let's treat all 15 and 16bit TGAs as RGB with no alpha.\r\n}\r\n\r\nstatic void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\r\n{\r\n   //   read in the TGA header stuff\r\n   int tga_offset = stbi__get8(s);\r\n   int tga_indexed = stbi__get8(s);\r\n   int tga_image_type = stbi__get8(s);\r\n   int tga_is_RLE = 0;\r\n   int tga_palette_start = stbi__get16le(s);\r\n   int tga_palette_len = stbi__get16le(s);\r\n   int tga_palette_bits = stbi__get8(s);\r\n   int tga_x_origin = stbi__get16le(s);\r\n   int tga_y_origin = stbi__get16le(s);\r\n   int tga_width = stbi__get16le(s);\r\n   int tga_height = stbi__get16le(s);\r\n   int tga_bits_per_pixel = stbi__get8(s);\r\n   int tga_comp, tga_rgb16=0;\r\n   int tga_inverted = stbi__get8(s);\r\n   // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)\r\n   //   image data\r\n   unsigned char *tga_data;\r\n   unsigned char *tga_palette = NULL;\r\n   int i, j;\r\n   unsigned char raw_data[4] = {0};\r\n   int RLE_count = 0;\r\n   int RLE_repeating = 0;\r\n   int read_next_pixel = 1;\r\n   STBI_NOTUSED(ri);\r\n\r\n   //   do a tiny bit of precessing\r\n   if ( tga_image_type >= 8 )\r\n   {\r\n      tga_image_type -= 8;\r\n      tga_is_RLE = 1;\r\n   }\r\n   tga_inverted = 1 - ((tga_inverted >> 5) & 1);\r\n\r\n   //   If I'm paletted, then I'll use the number of bits from the palette\r\n   if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);\r\n   else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);\r\n\r\n   if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency\r\n      return stbi__errpuc(\"bad format\", \"Can't find out TGA pixelformat\");\r\n\r\n   //   tga info\r\n   *x = tga_width;\r\n   *y = tga_height;\r\n   if (comp) *comp = tga_comp;\r\n\r\n   if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))\r\n      return stbi__errpuc(\"too large\", \"Corrupt TGA\");\r\n\r\n   tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);\r\n   if (!tga_data) return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n\r\n   // skip to the data's starting position (offset usually = 0)\r\n   stbi__skip(s, tga_offset );\r\n\r\n   if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {\r\n      for (i=0; i < tga_height; ++i) {\r\n         int row = tga_inverted ? tga_height -i - 1 : i;\r\n         stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;\r\n         stbi__getn(s, tga_row, tga_width * tga_comp);\r\n      }\r\n   } else  {\r\n      //   do I need to load a palette?\r\n      if ( tga_indexed)\r\n      {\r\n         //   any data to skip? (offset usually = 0)\r\n         stbi__skip(s, tga_palette_start );\r\n         //   load the palette\r\n         tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);\r\n         if (!tga_palette) {\r\n            STBI_FREE(tga_data);\r\n            return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n         }\r\n         if (tga_rgb16) {\r\n            stbi_uc *pal_entry = tga_palette;\r\n            STBI_ASSERT(tga_comp == STBI_rgb);\r\n            for (i=0; i < tga_palette_len; ++i) {\r\n               stbi__tga_read_rgb16(s, pal_entry);\r\n               pal_entry += tga_comp;\r\n            }\r\n         } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {\r\n               STBI_FREE(tga_data);\r\n               STBI_FREE(tga_palette);\r\n               return stbi__errpuc(\"bad palette\", \"Corrupt TGA\");\r\n         }\r\n      }\r\n      //   load the data\r\n      for (i=0; i < tga_width * tga_height; ++i)\r\n      {\r\n         //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?\r\n         if ( tga_is_RLE )\r\n         {\r\n            if ( RLE_count == 0 )\r\n            {\r\n               //   yep, get the next byte as a RLE command\r\n               int RLE_cmd = stbi__get8(s);\r\n               RLE_count = 1 + (RLE_cmd & 127);\r\n               RLE_repeating = RLE_cmd >> 7;\r\n               read_next_pixel = 1;\r\n            } else if ( !RLE_repeating )\r\n            {\r\n               read_next_pixel = 1;\r\n            }\r\n         } else\r\n         {\r\n            read_next_pixel = 1;\r\n         }\r\n         //   OK, if I need to read a pixel, do it now\r\n         if ( read_next_pixel )\r\n         {\r\n            //   load however much data we did have\r\n            if ( tga_indexed )\r\n            {\r\n               // read in index, then perform the lookup\r\n               int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);\r\n               if ( pal_idx >= tga_palette_len ) {\r\n                  // invalid index\r\n                  pal_idx = 0;\r\n               }\r\n               pal_idx *= tga_comp;\r\n               for (j = 0; j < tga_comp; ++j) {\r\n                  raw_data[j] = tga_palette[pal_idx+j];\r\n               }\r\n            } else if(tga_rgb16) {\r\n               STBI_ASSERT(tga_comp == STBI_rgb);\r\n               stbi__tga_read_rgb16(s, raw_data);\r\n            } else {\r\n               //   read in the data raw\r\n               for (j = 0; j < tga_comp; ++j) {\r\n                  raw_data[j] = stbi__get8(s);\r\n               }\r\n            }\r\n            //   clear the reading flag for the next pixel\r\n            read_next_pixel = 0;\r\n         } // end of reading a pixel\r\n\r\n         // copy data\r\n         for (j = 0; j < tga_comp; ++j)\r\n           tga_data[i*tga_comp+j] = raw_data[j];\r\n\r\n         //   in case we're in RLE mode, keep counting down\r\n         --RLE_count;\r\n      }\r\n      //   do I need to invert the image?\r\n      if ( tga_inverted )\r\n      {\r\n         for (j = 0; j*2 < tga_height; ++j)\r\n         {\r\n            int index1 = j * tga_width * tga_comp;\r\n            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;\r\n            for (i = tga_width * tga_comp; i > 0; --i)\r\n            {\r\n               unsigned char temp = tga_data[index1];\r\n               tga_data[index1] = tga_data[index2];\r\n               tga_data[index2] = temp;\r\n               ++index1;\r\n               ++index2;\r\n            }\r\n         }\r\n      }\r\n      //   clear my palette, if I had one\r\n      if ( tga_palette != NULL )\r\n      {\r\n         STBI_FREE( tga_palette );\r\n      }\r\n   }\r\n\r\n   // swap RGB - if the source data was RGB16, it already is in the right order\r\n   if (tga_comp >= 3 && !tga_rgb16)\r\n   {\r\n      unsigned char* tga_pixel = tga_data;\r\n      for (i=0; i < tga_width * tga_height; ++i)\r\n      {\r\n         unsigned char temp = tga_pixel[0];\r\n         tga_pixel[0] = tga_pixel[2];\r\n         tga_pixel[2] = temp;\r\n         tga_pixel += tga_comp;\r\n      }\r\n   }\r\n\r\n   // convert to target component count\r\n   if (req_comp && req_comp != tga_comp)\r\n      tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);\r\n\r\n   //   the things I do to get rid of an error message, and yet keep\r\n   //   Microsoft's C compilers happy... [8^(\r\n   tga_palette_start = tga_palette_len = tga_palette_bits =\r\n         tga_x_origin = tga_y_origin = 0;\r\n   //   OK, done\r\n   return tga_data;\r\n}\r\n#endif\r\n\r\n// *************************************************************************************************\r\n// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB\r\n\r\n#ifndef STBI_NO_PSD\r\nstatic int stbi__psd_test(stbi__context *s)\r\n{\r\n   int r = (stbi__get32be(s) == 0x38425053);\r\n   stbi__rewind(s);\r\n   return r;\r\n}\r\n\r\nstatic int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)\r\n{\r\n   int count, nleft, len;\r\n\r\n   count = 0;\r\n   while ((nleft = pixelCount - count) > 0) {\r\n      len = stbi__get8(s);\r\n      if (len == 128) {\r\n         // No-op.\r\n      } else if (len < 128) {\r\n         // Copy next len+1 bytes literally.\r\n         len++;\r\n         if (len > nleft) return 0; // corrupt data\r\n         count += len;\r\n         while (len) {\r\n            *p = stbi__get8(s);\r\n            p += 4;\r\n            len--;\r\n         }\r\n      } else if (len > 128) {\r\n         stbi_uc   val;\r\n         // Next -len+1 bytes in the dest are replicated from next source byte.\r\n         // (Interpret len as a negative 8-bit int.)\r\n         len = 257 - len;\r\n         if (len > nleft) return 0; // corrupt data\r\n         val = stbi__get8(s);\r\n         count += len;\r\n         while (len) {\r\n            *p = val;\r\n            p += 4;\r\n            len--;\r\n         }\r\n      }\r\n   }\r\n\r\n   return 1;\r\n}\r\n\r\nstatic void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)\r\n{\r\n   int pixelCount;\r\n   int channelCount, compression;\r\n   int channel, i;\r\n   int bitdepth;\r\n   int w,h;\r\n   stbi_uc *out;\r\n   STBI_NOTUSED(ri);\r\n\r\n   // Check identifier\r\n   if (stbi__get32be(s) != 0x38425053)   // \"8BPS\"\r\n      return stbi__errpuc(\"not PSD\", \"Corrupt PSD image\");\r\n\r\n   // Check file type version.\r\n   if (stbi__get16be(s) != 1)\r\n      return stbi__errpuc(\"wrong version\", \"Unsupported version of PSD image\");\r\n\r\n   // Skip 6 reserved bytes.\r\n   stbi__skip(s, 6 );\r\n\r\n   // Read the number of channels (R, G, B, A, etc).\r\n   channelCount = stbi__get16be(s);\r\n   if (channelCount < 0 || channelCount > 16)\r\n      return stbi__errpuc(\"wrong channel count\", \"Unsupported number of channels in PSD image\");\r\n\r\n   // Read the rows and columns of the image.\r\n   h = stbi__get32be(s);\r\n   w = stbi__get32be(s);\r\n\r\n   // Make sure the depth is 8 bits.\r\n   bitdepth = stbi__get16be(s);\r\n   if (bitdepth != 8 && bitdepth != 16)\r\n      return stbi__errpuc(\"unsupported bit depth\", \"PSD bit depth is not 8 or 16 bit\");\r\n\r\n   // Make sure the color mode is RGB.\r\n   // Valid options are:\r\n   //   0: Bitmap\r\n   //   1: Grayscale\r\n   //   2: Indexed color\r\n   //   3: RGB color\r\n   //   4: CMYK color\r\n   //   7: Multichannel\r\n   //   8: Duotone\r\n   //   9: Lab color\r\n   if (stbi__get16be(s) != 3)\r\n      return stbi__errpuc(\"wrong color format\", \"PSD is not in RGB color format\");\r\n\r\n   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)\r\n   stbi__skip(s,stbi__get32be(s) );\r\n\r\n   // Skip the image resources.  (resolution, pen tool paths, etc)\r\n   stbi__skip(s, stbi__get32be(s) );\r\n\r\n   // Skip the reserved data.\r\n   stbi__skip(s, stbi__get32be(s) );\r\n\r\n   // Find out if the data is compressed.\r\n   // Known values:\r\n   //   0: no compression\r\n   //   1: RLE compressed\r\n   compression = stbi__get16be(s);\r\n   if (compression > 1)\r\n      return stbi__errpuc(\"bad compression\", \"PSD has an unknown compression format\");\r\n\r\n   // Check size\r\n   if (!stbi__mad3sizes_valid(4, w, h, 0))\r\n      return stbi__errpuc(\"too large\", \"Corrupt PSD\");\r\n\r\n   // Create the destination image.\r\n\r\n   if (!compression && bitdepth == 16 && bpc == 16) {\r\n      out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);\r\n      ri->bits_per_channel = 16;\r\n   } else\r\n      out = (stbi_uc *) stbi__malloc(4 * w*h);\r\n\r\n   if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n   pixelCount = w*h;\r\n\r\n   // Initialize the data to zero.\r\n   //memset( out, 0, pixelCount * 4 );\r\n\r\n   // Finally, the image data.\r\n   if (compression) {\r\n      // RLE as used by .PSD and .TIFF\r\n      // Loop until you get the number of unpacked bytes you are expecting:\r\n      //     Read the next source byte into n.\r\n      //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.\r\n      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.\r\n      //     Else if n is 128, noop.\r\n      // Endloop\r\n\r\n      // The RLE-compressed data is preceeded by a 2-byte data count for each row in the data,\r\n      // which we're going to just skip.\r\n      stbi__skip(s, h * channelCount * 2 );\r\n\r\n      // Read the RLE data by channel.\r\n      for (channel = 0; channel < 4; channel++) {\r\n         stbi_uc *p;\r\n\r\n         p = out+channel;\r\n         if (channel >= channelCount) {\r\n            // Fill this channel with default data.\r\n            for (i = 0; i < pixelCount; i++, p += 4)\r\n               *p = (channel == 3 ? 255 : 0);\r\n         } else {\r\n            // Read the RLE data.\r\n            if (!stbi__psd_decode_rle(s, p, pixelCount)) {\r\n               STBI_FREE(out);\r\n               return stbi__errpuc(\"corrupt\", \"bad RLE data\");\r\n            }\r\n         }\r\n      }\r\n\r\n   } else {\r\n      // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)\r\n      // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.\r\n\r\n      // Read the data by channel.\r\n      for (channel = 0; channel < 4; channel++) {\r\n         if (channel >= channelCount) {\r\n            // Fill this channel with default data.\r\n            if (bitdepth == 16 && bpc == 16) {\r\n               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;\r\n               stbi__uint16 val = channel == 3 ? 65535 : 0;\r\n               for (i = 0; i < pixelCount; i++, q += 4)\r\n                  *q = val;\r\n            } else {\r\n               stbi_uc *p = out+channel;\r\n               stbi_uc val = channel == 3 ? 255 : 0;\r\n               for (i = 0; i < pixelCount; i++, p += 4)\r\n                  *p = val;\r\n            }\r\n         } else {\r\n            if (ri->bits_per_channel == 16) {    // output bpc\r\n               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;\r\n               for (i = 0; i < pixelCount; i++, q += 4)\r\n                  *q = (stbi__uint16) stbi__get16be(s);\r\n            } else {\r\n               stbi_uc *p = out+channel;\r\n               if (bitdepth == 16) {  // input bpc\r\n                  for (i = 0; i < pixelCount; i++, p += 4)\r\n                     *p = (stbi_uc) (stbi__get16be(s) >> 8);\r\n               } else {\r\n                  for (i = 0; i < pixelCount; i++, p += 4)\r\n                     *p = stbi__get8(s);\r\n               }\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   // remove weird white matte from PSD\r\n   if (channelCount >= 4) {\r\n      if (ri->bits_per_channel == 16) {\r\n         for (i=0; i < w*h; ++i) {\r\n            stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;\r\n            if (pixel[3] != 0 && pixel[3] != 65535) {\r\n               float a = pixel[3] / 65535.0f;\r\n               float ra = 1.0f / a;\r\n               float inv_a = 65535.0f * (1 - ra);\r\n               pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);\r\n               pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);\r\n               pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);\r\n            }\r\n         }\r\n      } else {\r\n         for (i=0; i < w*h; ++i) {\r\n            unsigned char *pixel = out + 4*i;\r\n            if (pixel[3] != 0 && pixel[3] != 255) {\r\n               float a = pixel[3] / 255.0f;\r\n               float ra = 1.0f / a;\r\n               float inv_a = 255.0f * (1 - ra);\r\n               pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);\r\n               pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);\r\n               pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   // convert to desired output format\r\n   if (req_comp && req_comp != 4) {\r\n      if (ri->bits_per_channel == 16)\r\n         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);\r\n      else\r\n         out = stbi__convert_format(out, 4, req_comp, w, h);\r\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\r\n   }\r\n\r\n   if (comp) *comp = 4;\r\n   *y = h;\r\n   *x = w;\r\n\r\n   return out;\r\n}\r\n#endif\r\n\r\n// *************************************************************************************************\r\n// Softimage PIC loader\r\n// by Tom Seddon\r\n//\r\n// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format\r\n// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/\r\n\r\n#ifndef STBI_NO_PIC\r\nstatic int stbi__pic_is4(stbi__context *s,const char *str)\r\n{\r\n   int i;\r\n   for (i=0; i<4; ++i)\r\n      if (stbi__get8(s) != (stbi_uc)str[i])\r\n         return 0;\r\n\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__pic_test_core(stbi__context *s)\r\n{\r\n   int i;\r\n\r\n   if (!stbi__pic_is4(s,\"\\x53\\x80\\xF6\\x34\"))\r\n      return 0;\r\n\r\n   for(i=0;i<84;++i)\r\n      stbi__get8(s);\r\n\r\n   if (!stbi__pic_is4(s,\"PICT\"))\r\n      return 0;\r\n\r\n   return 1;\r\n}\r\n\r\ntypedef struct\r\n{\r\n   stbi_uc size,type,channel;\r\n} stbi__pic_packet;\r\n\r\nstatic stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)\r\n{\r\n   int mask=0x80, i;\r\n\r\n   for (i=0; i<4; ++i, mask>>=1) {\r\n      if (channel & mask) {\r\n         if (stbi__at_eof(s)) return stbi__errpuc(\"bad file\",\"PIC file too short\");\r\n         dest[i]=stbi__get8(s);\r\n      }\r\n   }\r\n\r\n   return dest;\r\n}\r\n\r\nstatic void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)\r\n{\r\n   int mask=0x80,i;\r\n\r\n   for (i=0;i<4; ++i, mask>>=1)\r\n      if (channel&mask)\r\n         dest[i]=src[i];\r\n}\r\n\r\nstatic stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)\r\n{\r\n   int act_comp=0,num_packets=0,y,chained;\r\n   stbi__pic_packet packets[10];\r\n\r\n   // this will (should...) cater for even some bizarre stuff like having data\r\n    // for the same channel in multiple packets.\r\n   do {\r\n      stbi__pic_packet *packet;\r\n\r\n      if (num_packets==sizeof(packets)/sizeof(packets[0]))\r\n         return stbi__errpuc(\"bad format\",\"too many packets\");\r\n\r\n      packet = &packets[num_packets++];\r\n\r\n      chained = stbi__get8(s);\r\n      packet->size    = stbi__get8(s);\r\n      packet->type    = stbi__get8(s);\r\n      packet->channel = stbi__get8(s);\r\n\r\n      act_comp |= packet->channel;\r\n\r\n      if (stbi__at_eof(s))          return stbi__errpuc(\"bad file\",\"file too short (reading packets)\");\r\n      if (packet->size != 8)  return stbi__errpuc(\"bad format\",\"packet isn't 8bpp\");\r\n   } while (chained);\r\n\r\n   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?\r\n\r\n   for(y=0; y<height; ++y) {\r\n      int packet_idx;\r\n\r\n      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {\r\n         stbi__pic_packet *packet = &packets[packet_idx];\r\n         stbi_uc *dest = result+y*width*4;\r\n\r\n         switch (packet->type) {\r\n            default:\r\n               return stbi__errpuc(\"bad format\",\"packet has bad compression type\");\r\n\r\n            case 0: {//uncompressed\r\n               int x;\r\n\r\n               for(x=0;x<width;++x, dest+=4)\r\n                  if (!stbi__readval(s,packet->channel,dest))\r\n                     return 0;\r\n               break;\r\n            }\r\n\r\n            case 1://Pure RLE\r\n               {\r\n                  int left=width, i;\r\n\r\n                  while (left>0) {\r\n                     stbi_uc count,value[4];\r\n\r\n                     count=stbi__get8(s);\r\n                     if (stbi__at_eof(s))   return stbi__errpuc(\"bad file\",\"file too short (pure read count)\");\r\n\r\n                     if (count > left)\r\n                        count = (stbi_uc) left;\r\n\r\n                     if (!stbi__readval(s,packet->channel,value))  return 0;\r\n\r\n                     for(i=0; i<count; ++i,dest+=4)\r\n                        stbi__copyval(packet->channel,dest,value);\r\n                     left -= count;\r\n                  }\r\n               }\r\n               break;\r\n\r\n            case 2: {//Mixed RLE\r\n               int left=width;\r\n               while (left>0) {\r\n                  int count = stbi__get8(s), i;\r\n                  if (stbi__at_eof(s))  return stbi__errpuc(\"bad file\",\"file too short (mixed read count)\");\r\n\r\n                  if (count >= 128) { // Repeated\r\n                     stbi_uc value[4];\r\n\r\n                     if (count==128)\r\n                        count = stbi__get16be(s);\r\n                     else\r\n                        count -= 127;\r\n                     if (count > left)\r\n                        return stbi__errpuc(\"bad file\",\"scanline overrun\");\r\n\r\n                     if (!stbi__readval(s,packet->channel,value))\r\n                        return 0;\r\n\r\n                     for(i=0;i<count;++i, dest += 4)\r\n                        stbi__copyval(packet->channel,dest,value);\r\n                  } else { // Raw\r\n                     ++count;\r\n                     if (count>left) return stbi__errpuc(\"bad file\",\"scanline overrun\");\r\n\r\n                     for(i=0;i<count;++i, dest+=4)\r\n                        if (!stbi__readval(s,packet->channel,dest))\r\n                           return 0;\r\n                  }\r\n                  left-=count;\r\n               }\r\n               break;\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   return result;\r\n}\r\n\r\nstatic void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)\r\n{\r\n   stbi_uc *result;\r\n   int i, x,y, internal_comp;\r\n   STBI_NOTUSED(ri);\r\n\r\n   if (!comp) comp = &internal_comp;\r\n\r\n   for (i=0; i<92; ++i)\r\n      stbi__get8(s);\r\n\r\n   x = stbi__get16be(s);\r\n   y = stbi__get16be(s);\r\n   if (stbi__at_eof(s))  return stbi__errpuc(\"bad file\",\"file too short (pic header)\");\r\n   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc(\"too large\", \"PIC image too large to decode\");\r\n\r\n   stbi__get32be(s); //skip `ratio'\r\n   stbi__get16be(s); //skip `fields'\r\n   stbi__get16be(s); //skip `pad'\r\n\r\n   // intermediate buffer is RGBA\r\n   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);\r\n   memset(result, 0xff, x*y*4);\r\n\r\n   if (!stbi__pic_load_core(s,x,y,comp, result)) {\r\n      STBI_FREE(result);\r\n      result=0;\r\n   }\r\n   *px = x;\r\n   *py = y;\r\n   if (req_comp == 0) req_comp = *comp;\r\n   result=stbi__convert_format(result,4,req_comp,x,y);\r\n\r\n   return result;\r\n}\r\n\r\nstatic int stbi__pic_test(stbi__context *s)\r\n{\r\n   int r = stbi__pic_test_core(s);\r\n   stbi__rewind(s);\r\n   return r;\r\n}\r\n#endif\r\n\r\n// *************************************************************************************************\r\n// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb\r\n\r\n#ifndef STBI_NO_GIF\r\ntypedef struct\r\n{\r\n   stbi__int16 prefix;\r\n   stbi_uc first;\r\n   stbi_uc suffix;\r\n} stbi__gif_lzw;\r\n\r\ntypedef struct\r\n{\r\n   int w,h;\r\n   stbi_uc *out, *old_out;             // output buffer (always 4 components)\r\n   int flags, bgindex, ratio, transparent, eflags, delay;\r\n   stbi_uc  pal[256][4];\r\n   stbi_uc lpal[256][4];\r\n   stbi__gif_lzw codes[4096];\r\n   stbi_uc *color_table;\r\n   int parse, step;\r\n   int lflags;\r\n   int start_x, start_y;\r\n   int max_x, max_y;\r\n   int cur_x, cur_y;\r\n   int line_size;\r\n} stbi__gif;\r\n\r\nstatic int stbi__gif_test_raw(stbi__context *s)\r\n{\r\n   int sz;\r\n   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;\r\n   sz = stbi__get8(s);\r\n   if (sz != '9' && sz != '7') return 0;\r\n   if (stbi__get8(s) != 'a') return 0;\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__gif_test(stbi__context *s)\r\n{\r\n   int r = stbi__gif_test_raw(s);\r\n   stbi__rewind(s);\r\n   return r;\r\n}\r\n\r\nstatic void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)\r\n{\r\n   int i;\r\n   for (i=0; i < num_entries; ++i) {\r\n      pal[i][2] = stbi__get8(s);\r\n      pal[i][1] = stbi__get8(s);\r\n      pal[i][0] = stbi__get8(s);\r\n      pal[i][3] = transp == i ? 0 : 255;\r\n   }\r\n}\r\n\r\nstatic int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)\r\n{\r\n   stbi_uc version;\r\n   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')\r\n      return stbi__err(\"not GIF\", \"Corrupt GIF\");\r\n\r\n   version = stbi__get8(s);\r\n   if (version != '7' && version != '9')    return stbi__err(\"not GIF\", \"Corrupt GIF\");\r\n   if (stbi__get8(s) != 'a')                return stbi__err(\"not GIF\", \"Corrupt GIF\");\r\n\r\n   stbi__g_failure_reason = \"\";\r\n   g->w = stbi__get16le(s);\r\n   g->h = stbi__get16le(s);\r\n   g->flags = stbi__get8(s);\r\n   g->bgindex = stbi__get8(s);\r\n   g->ratio = stbi__get8(s);\r\n   g->transparent = -1;\r\n\r\n   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments\r\n\r\n   if (is_info) return 1;\r\n\r\n   if (g->flags & 0x80)\r\n      stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);\r\n\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)\r\n{\r\n   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));\r\n   if (!stbi__gif_header(s, g, comp, 1)) {\r\n      STBI_FREE(g);\r\n      stbi__rewind( s );\r\n      return 0;\r\n   }\r\n   if (x) *x = g->w;\r\n   if (y) *y = g->h;\r\n   STBI_FREE(g);\r\n   return 1;\r\n}\r\n\r\nstatic void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)\r\n{\r\n   stbi_uc *p, *c;\r\n\r\n   // recurse to decode the prefixes, since the linked-list is backwards,\r\n   // and working backwards through an interleaved image would be nasty\r\n   if (g->codes[code].prefix >= 0)\r\n      stbi__out_gif_code(g, g->codes[code].prefix);\r\n\r\n   if (g->cur_y >= g->max_y) return;\r\n\r\n   p = &g->out[g->cur_x + g->cur_y];\r\n   c = &g->color_table[g->codes[code].suffix * 4];\r\n\r\n   if (c[3] >= 128) {\r\n      p[0] = c[2];\r\n      p[1] = c[1];\r\n      p[2] = c[0];\r\n      p[3] = c[3];\r\n   }\r\n   g->cur_x += 4;\r\n\r\n   if (g->cur_x >= g->max_x) {\r\n      g->cur_x = g->start_x;\r\n      g->cur_y += g->step;\r\n\r\n      while (g->cur_y >= g->max_y && g->parse > 0) {\r\n         g->step = (1 << g->parse) * g->line_size;\r\n         g->cur_y = g->start_y + (g->step >> 1);\r\n         --g->parse;\r\n      }\r\n   }\r\n}\r\n\r\nstatic stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)\r\n{\r\n   stbi_uc lzw_cs;\r\n   stbi__int32 len, init_code;\r\n   stbi__uint32 first;\r\n   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;\r\n   stbi__gif_lzw *p;\r\n\r\n   lzw_cs = stbi__get8(s);\r\n   if (lzw_cs > 12) return NULL;\r\n   clear = 1 << lzw_cs;\r\n   first = 1;\r\n   codesize = lzw_cs + 1;\r\n   codemask = (1 << codesize) - 1;\r\n   bits = 0;\r\n   valid_bits = 0;\r\n   for (init_code = 0; init_code < clear; init_code++) {\r\n      g->codes[init_code].prefix = -1;\r\n      g->codes[init_code].first = (stbi_uc) init_code;\r\n      g->codes[init_code].suffix = (stbi_uc) init_code;\r\n   }\r\n\r\n   // support no starting clear code\r\n   avail = clear+2;\r\n   oldcode = -1;\r\n\r\n   len = 0;\r\n   for(;;) {\r\n      if (valid_bits < codesize) {\r\n         if (len == 0) {\r\n            len = stbi__get8(s); // start new block\r\n            if (len == 0)\r\n               return g->out;\r\n         }\r\n         --len;\r\n         bits |= (stbi__int32) stbi__get8(s) << valid_bits;\r\n         valid_bits += 8;\r\n      } else {\r\n         stbi__int32 code = bits & codemask;\r\n         bits >>= codesize;\r\n         valid_bits -= codesize;\r\n         // @OPTIMIZE: is there some way we can accelerate the non-clear path?\r\n         if (code == clear) {  // clear code\r\n            codesize = lzw_cs + 1;\r\n            codemask = (1 << codesize) - 1;\r\n            avail = clear + 2;\r\n            oldcode = -1;\r\n            first = 0;\r\n         } else if (code == clear + 1) { // end of stream code\r\n            stbi__skip(s, len);\r\n            while ((len = stbi__get8(s)) > 0)\r\n               stbi__skip(s,len);\r\n            return g->out;\r\n         } else if (code <= avail) {\r\n            if (first) return stbi__errpuc(\"no clear code\", \"Corrupt GIF\");\r\n\r\n            if (oldcode >= 0) {\r\n               p = &g->codes[avail++];\r\n               if (avail > 4096)        return stbi__errpuc(\"too many codes\", \"Corrupt GIF\");\r\n               p->prefix = (stbi__int16) oldcode;\r\n               p->first = g->codes[oldcode].first;\r\n               p->suffix = (code == avail) ? p->first : g->codes[code].first;\r\n            } else if (code == avail)\r\n               return stbi__errpuc(\"illegal code in raster\", \"Corrupt GIF\");\r\n\r\n            stbi__out_gif_code(g, (stbi__uint16) code);\r\n\r\n            if ((avail & codemask) == 0 && avail <= 0x0FFF) {\r\n               codesize++;\r\n               codemask = (1 << codesize) - 1;\r\n            }\r\n\r\n            oldcode = code;\r\n         } else {\r\n            return stbi__errpuc(\"illegal code in raster\", \"Corrupt GIF\");\r\n         }\r\n      }\r\n   }\r\n}\r\n\r\nstatic void stbi__fill_gif_background(stbi__gif *g, int x0, int y0, int x1, int y1)\r\n{\r\n   int x, y;\r\n   stbi_uc *c = g->pal[g->bgindex];\r\n   for (y = y0; y < y1; y += 4 * g->w) {\r\n      for (x = x0; x < x1; x += 4) {\r\n         stbi_uc *p  = &g->out[y + x];\r\n         p[0] = c[2];\r\n         p[1] = c[1];\r\n         p[2] = c[0];\r\n         p[3] = 0;\r\n      }\r\n   }\r\n}\r\n\r\n// this function is designed to support animated gifs, although stb_image doesn't support it\r\nstatic stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp)\r\n{\r\n   int i;\r\n   stbi_uc *prev_out = 0;\r\n\r\n   if (g->out == 0 && !stbi__gif_header(s, g, comp,0))\r\n      return 0; // stbi__g_failure_reason set by stbi__gif_header\r\n\r\n   if (!stbi__mad3sizes_valid(g->w, g->h, 4, 0))\r\n      return stbi__errpuc(\"too large\", \"GIF too large\");\r\n\r\n   prev_out = g->out;\r\n   g->out = (stbi_uc *) stbi__malloc_mad3(4, g->w, g->h, 0);\r\n   if (g->out == 0) return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n\r\n   switch ((g->eflags & 0x1C) >> 2) {\r\n      case 0: // unspecified (also always used on 1st frame)\r\n         stbi__fill_gif_background(g, 0, 0, 4 * g->w, 4 * g->w * g->h);\r\n         break;\r\n      case 1: // do not dispose\r\n         if (prev_out) memcpy(g->out, prev_out, 4 * g->w * g->h);\r\n         g->old_out = prev_out;\r\n         break;\r\n      case 2: // dispose to background\r\n         if (prev_out) memcpy(g->out, prev_out, 4 * g->w * g->h);\r\n         stbi__fill_gif_background(g, g->start_x, g->start_y, g->max_x, g->max_y);\r\n         break;\r\n      case 3: // dispose to previous\r\n         if (g->old_out) {\r\n            for (i = g->start_y; i < g->max_y; i += 4 * g->w)\r\n               memcpy(&g->out[i + g->start_x], &g->old_out[i + g->start_x], g->max_x - g->start_x);\r\n         }\r\n         break;\r\n   }\r\n\r\n   for (;;) {\r\n      switch (stbi__get8(s)) {\r\n         case 0x2C: /* Image Descriptor */\r\n         {\r\n            int prev_trans = -1;\r\n            stbi__int32 x, y, w, h;\r\n            stbi_uc *o;\r\n\r\n            x = stbi__get16le(s);\r\n            y = stbi__get16le(s);\r\n            w = stbi__get16le(s);\r\n            h = stbi__get16le(s);\r\n            if (((x + w) > (g->w)) || ((y + h) > (g->h)))\r\n               return stbi__errpuc(\"bad Image Descriptor\", \"Corrupt GIF\");\r\n\r\n            g->line_size = g->w * 4;\r\n            g->start_x = x * 4;\r\n            g->start_y = y * g->line_size;\r\n            g->max_x   = g->start_x + w * 4;\r\n            g->max_y   = g->start_y + h * g->line_size;\r\n            g->cur_x   = g->start_x;\r\n            g->cur_y   = g->start_y;\r\n\r\n            g->lflags = stbi__get8(s);\r\n\r\n            if (g->lflags & 0x40) {\r\n               g->step = 8 * g->line_size; // first interlaced spacing\r\n               g->parse = 3;\r\n            } else {\r\n               g->step = g->line_size;\r\n               g->parse = 0;\r\n            }\r\n\r\n            if (g->lflags & 0x80) {\r\n               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);\r\n               g->color_table = (stbi_uc *) g->lpal;\r\n            } else if (g->flags & 0x80) {\r\n               if (g->transparent >= 0 && (g->eflags & 0x01)) {\r\n                  prev_trans = g->pal[g->transparent][3];\r\n                  g->pal[g->transparent][3] = 0;\r\n               }\r\n               g->color_table = (stbi_uc *) g->pal;\r\n            } else\r\n               return stbi__errpuc(\"missing color table\", \"Corrupt GIF\");\r\n\r\n            o = stbi__process_gif_raster(s, g);\r\n            if (o == NULL) return NULL;\r\n\r\n            if (prev_trans != -1)\r\n               g->pal[g->transparent][3] = (stbi_uc) prev_trans;\r\n\r\n            return o;\r\n         }\r\n\r\n         case 0x21: // Comment Extension.\r\n         {\r\n            int len;\r\n            if (stbi__get8(s) == 0xF9) { // Graphic Control Extension.\r\n               len = stbi__get8(s);\r\n               if (len == 4) {\r\n                  g->eflags = stbi__get8(s);\r\n                  g->delay = stbi__get16le(s);\r\n                  g->transparent = stbi__get8(s);\r\n               } else {\r\n                  stbi__skip(s, len);\r\n                  break;\r\n               }\r\n            }\r\n            while ((len = stbi__get8(s)) != 0)\r\n               stbi__skip(s, len);\r\n            break;\r\n         }\r\n\r\n         case 0x3B: // gif stream termination code\r\n            return (stbi_uc *) s; // using '1' causes warning on some compilers\r\n\r\n         default:\r\n            return stbi__errpuc(\"unknown code\", \"Corrupt GIF\");\r\n      }\r\n   }\r\n\r\n   STBI_NOTUSED(req_comp);\r\n}\r\n\r\nstatic void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\r\n{\r\n   stbi_uc *u = 0;\r\n   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));\r\n   memset(g, 0, sizeof(*g));\r\n   STBI_NOTUSED(ri);\r\n\r\n   u = stbi__gif_load_next(s, g, comp, req_comp);\r\n   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker\r\n   if (u) {\r\n      *x = g->w;\r\n      *y = g->h;\r\n      if (req_comp && req_comp != 4)\r\n         u = stbi__convert_format(u, 4, req_comp, g->w, g->h);\r\n   }\r\n   else if (g->out)\r\n      STBI_FREE(g->out);\r\n   STBI_FREE(g);\r\n   return u;\r\n}\r\n\r\nstatic int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)\r\n{\r\n   return stbi__gif_info_raw(s,x,y,comp);\r\n}\r\n#endif\r\n\r\n// *************************************************************************************************\r\n// Radiance RGBE HDR loader\r\n// originally by Nicolas Schulz\r\n#ifndef STBI_NO_HDR\r\nstatic int stbi__hdr_test_core(stbi__context *s, const char *signature)\r\n{\r\n   int i;\r\n   for (i=0; signature[i]; ++i)\r\n      if (stbi__get8(s) != signature[i])\r\n          return 0;\r\n   stbi__rewind(s);\r\n   return 1;\r\n}\r\n\r\nstatic int stbi__hdr_test(stbi__context* s)\r\n{\r\n   int r = stbi__hdr_test_core(s, \"#?RADIANCE\\n\");\r\n   stbi__rewind(s);\r\n   if(!r) {\r\n       r = stbi__hdr_test_core(s, \"#?RGBE\\n\");\r\n       stbi__rewind(s);\r\n   }\r\n   return r;\r\n}\r\n\r\n#define STBI__HDR_BUFLEN  1024\r\nstatic char *stbi__hdr_gettoken(stbi__context *z, char *buffer)\r\n{\r\n   int len=0;\r\n   char c = '\\0';\r\n\r\n   c = (char) stbi__get8(z);\r\n\r\n   while (!stbi__at_eof(z) && c != '\\n') {\r\n      buffer[len++] = c;\r\n      if (len == STBI__HDR_BUFLEN-1) {\r\n         // flush to end of line\r\n         while (!stbi__at_eof(z) && stbi__get8(z) != '\\n')\r\n            ;\r\n         break;\r\n      }\r\n      c = (char) stbi__get8(z);\r\n   }\r\n\r\n   buffer[len] = 0;\r\n   return buffer;\r\n}\r\n\r\nstatic void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)\r\n{\r\n   if ( input[3] != 0 ) {\r\n      float f1;\r\n      // Exponent\r\n      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));\r\n      if (req_comp <= 2)\r\n         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;\r\n      else {\r\n         output[0] = input[0] * f1;\r\n         output[1] = input[1] * f1;\r\n         output[2] = input[2] * f1;\r\n      }\r\n      if (req_comp == 2) output[1] = 1;\r\n      if (req_comp == 4) output[3] = 1;\r\n   } else {\r\n      switch (req_comp) {\r\n         case 4: output[3] = 1; /* fallthrough */\r\n         case 3: output[0] = output[1] = output[2] = 0;\r\n                 break;\r\n         case 2: output[1] = 1; /* fallthrough */\r\n         case 1: output[0] = 0;\r\n                 break;\r\n      }\r\n   }\r\n}\r\n\r\nstatic float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\r\n{\r\n   char buffer[STBI__HDR_BUFLEN];\r\n   char *token;\r\n   int valid = 0;\r\n   int width, height;\r\n   stbi_uc *scanline;\r\n   float *hdr_data;\r\n   int len;\r\n   unsigned char count, value;\r\n   int i, j, k, c1,c2, z;\r\n   const char *headerToken;\r\n   STBI_NOTUSED(ri);\r\n\r\n   // Check identifier\r\n   headerToken = stbi__hdr_gettoken(s,buffer);\r\n   if (strcmp(headerToken, \"#?RADIANCE\") != 0 && strcmp(headerToken, \"#?RGBE\") != 0)\r\n      return stbi__errpf(\"not HDR\", \"Corrupt HDR image\");\r\n\r\n   // Parse header\r\n   for(;;) {\r\n      token = stbi__hdr_gettoken(s,buffer);\r\n      if (token[0] == 0) break;\r\n      if (strcmp(token, \"FORMAT=32-bit_rle_rgbe\") == 0) valid = 1;\r\n   }\r\n\r\n   if (!valid)    return stbi__errpf(\"unsupported format\", \"Unsupported HDR format\");\r\n\r\n   // Parse width and height\r\n   // can't use sscanf() if we're not using stdio!\r\n   token = stbi__hdr_gettoken(s,buffer);\r\n   if (strncmp(token, \"-Y \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\r\n   token += 3;\r\n   height = (int) strtol(token, &token, 10);\r\n   while (*token == ' ') ++token;\r\n   if (strncmp(token, \"+X \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\r\n   token += 3;\r\n   width = (int) strtol(token, NULL, 10);\r\n\r\n   *x = width;\r\n   *y = height;\r\n\r\n   if (comp) *comp = 3;\r\n   if (req_comp == 0) req_comp = 3;\r\n\r\n   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))\r\n      return stbi__errpf(\"too large\", \"HDR image is too large\");\r\n\r\n   // Read data\r\n   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);\r\n   if (!hdr_data)\r\n      return stbi__errpf(\"outofmem\", \"Out of memory\");\r\n\r\n   // Load image data\r\n   // image data is stored as some number of sca\r\n   if ( width < 8 || width >= 32768) {\r\n      // Read flat data\r\n      for (j=0; j < height; ++j) {\r\n         for (i=0; i < width; ++i) {\r\n            stbi_uc rgbe[4];\r\n           main_decode_loop:\r\n            stbi__getn(s, rgbe, 4);\r\n            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);\r\n         }\r\n      }\r\n   } else {\r\n      // Read RLE-encoded data\r\n      scanline = NULL;\r\n\r\n      for (j = 0; j < height; ++j) {\r\n         c1 = stbi__get8(s);\r\n         c2 = stbi__get8(s);\r\n         len = stbi__get8(s);\r\n         if (c1 != 2 || c2 != 2 || (len & 0x80)) {\r\n            // not run-length encoded, so we have to actually use THIS data as a decoded\r\n            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)\r\n            stbi_uc rgbe[4];\r\n            rgbe[0] = (stbi_uc) c1;\r\n            rgbe[1] = (stbi_uc) c2;\r\n            rgbe[2] = (stbi_uc) len;\r\n            rgbe[3] = (stbi_uc) stbi__get8(s);\r\n            stbi__hdr_convert(hdr_data, rgbe, req_comp);\r\n            i = 1;\r\n            j = 0;\r\n            STBI_FREE(scanline);\r\n            goto main_decode_loop; // yes, this makes no sense\r\n         }\r\n         len <<= 8;\r\n         len |= stbi__get8(s);\r\n         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"invalid decoded scanline length\", \"corrupt HDR\"); }\r\n         if (scanline == NULL) {\r\n            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);\r\n            if (!scanline) {\r\n               STBI_FREE(hdr_data);\r\n               return stbi__errpf(\"outofmem\", \"Out of memory\");\r\n            }\r\n         }\r\n\r\n         for (k = 0; k < 4; ++k) {\r\n            int nleft;\r\n            i = 0;\r\n            while ((nleft = width - i) > 0) {\r\n               count = stbi__get8(s);\r\n               if (count > 128) {\r\n                  // Run\r\n                  value = stbi__get8(s);\r\n                  count -= 128;\r\n                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\r\n                  for (z = 0; z < count; ++z)\r\n                     scanline[i++ * 4 + k] = value;\r\n               } else {\r\n                  // Dump\r\n                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\r\n                  for (z = 0; z < count; ++z)\r\n                     scanline[i++ * 4 + k] = stbi__get8(s);\r\n               }\r\n            }\r\n         }\r\n         for (i=0; i < width; ++i)\r\n            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);\r\n      }\r\n      if (scanline)\r\n         STBI_FREE(scanline);\r\n   }\r\n\r\n   return hdr_data;\r\n}\r\n\r\nstatic int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)\r\n{\r\n   char buffer[STBI__HDR_BUFLEN];\r\n   char *token;\r\n   int valid = 0;\r\n   int dummy;\r\n\r\n   if (!x) x = &dummy;\r\n   if (!y) y = &dummy;\r\n   if (!comp) comp = &dummy;\r\n\r\n   if (stbi__hdr_test(s) == 0) {\r\n       stbi__rewind( s );\r\n       return 0;\r\n   }\r\n\r\n   for(;;) {\r\n      token = stbi__hdr_gettoken(s,buffer);\r\n      if (token[0] == 0) break;\r\n      if (strcmp(token, \"FORMAT=32-bit_rle_rgbe\") == 0) valid = 1;\r\n   }\r\n\r\n   if (!valid) {\r\n       stbi__rewind( s );\r\n       return 0;\r\n   }\r\n   token = stbi__hdr_gettoken(s,buffer);\r\n   if (strncmp(token, \"-Y \", 3)) {\r\n       stbi__rewind( s );\r\n       return 0;\r\n   }\r\n   token += 3;\r\n   *y = (int) strtol(token, &token, 10);\r\n   while (*token == ' ') ++token;\r\n   if (strncmp(token, \"+X \", 3)) {\r\n       stbi__rewind( s );\r\n       return 0;\r\n   }\r\n   token += 3;\r\n   *x = (int) strtol(token, NULL, 10);\r\n   *comp = 3;\r\n   return 1;\r\n}\r\n#endif // STBI_NO_HDR\r\n\r\n#ifndef STBI_NO_BMP\r\nstatic int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)\r\n{\r\n   void *p;\r\n   stbi__bmp_data info;\r\n\r\n   info.all_a = 255;\r\n   p = stbi__bmp_parse_header(s, &info);\r\n   stbi__rewind( s );\r\n   if (p == NULL)\r\n      return 0;\r\n   if (x) *x = s->img_x;\r\n   if (y) *y = s->img_y;\r\n   if (comp) *comp = info.ma ? 4 : 3;\r\n   return 1;\r\n}\r\n#endif\r\n\r\n#ifndef STBI_NO_PSD\r\nstatic int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)\r\n{\r\n   int channelCount, dummy;\r\n   if (!x) x = &dummy;\r\n   if (!y) y = &dummy;\r\n   if (!comp) comp = &dummy;\r\n   if (stbi__get32be(s) != 0x38425053) {\r\n       stbi__rewind( s );\r\n       return 0;\r\n   }\r\n   if (stbi__get16be(s) != 1) {\r\n       stbi__rewind( s );\r\n       return 0;\r\n   }\r\n   stbi__skip(s, 6);\r\n   channelCount = stbi__get16be(s);\r\n   if (channelCount < 0 || channelCount > 16) {\r\n       stbi__rewind( s );\r\n       return 0;\r\n   }\r\n   *y = stbi__get32be(s);\r\n   *x = stbi__get32be(s);\r\n   if (stbi__get16be(s) != 8) {\r\n       stbi__rewind( s );\r\n       return 0;\r\n   }\r\n   if (stbi__get16be(s) != 3) {\r\n       stbi__rewind( s );\r\n       return 0;\r\n   }\r\n   *comp = 4;\r\n   return 1;\r\n}\r\n#endif\r\n\r\n#ifndef STBI_NO_PIC\r\nstatic int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)\r\n{\r\n   int act_comp=0,num_packets=0,chained,dummy;\r\n   stbi__pic_packet packets[10];\r\n\r\n   if (!x) x = &dummy;\r\n   if (!y) y = &dummy;\r\n   if (!comp) comp = &dummy;\r\n\r\n   if (!stbi__pic_is4(s,\"\\x53\\x80\\xF6\\x34\")) {\r\n      stbi__rewind(s);\r\n      return 0;\r\n   }\r\n\r\n   stbi__skip(s, 88);\r\n\r\n   *x = stbi__get16be(s);\r\n   *y = stbi__get16be(s);\r\n   if (stbi__at_eof(s)) {\r\n      stbi__rewind( s);\r\n      return 0;\r\n   }\r\n   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {\r\n      stbi__rewind( s );\r\n      return 0;\r\n   }\r\n\r\n   stbi__skip(s, 8);\r\n\r\n   do {\r\n      stbi__pic_packet *packet;\r\n\r\n      if (num_packets==sizeof(packets)/sizeof(packets[0]))\r\n         return 0;\r\n\r\n      packet = &packets[num_packets++];\r\n      chained = stbi__get8(s);\r\n      packet->size    = stbi__get8(s);\r\n      packet->type    = stbi__get8(s);\r\n      packet->channel = stbi__get8(s);\r\n      act_comp |= packet->channel;\r\n\r\n      if (stbi__at_eof(s)) {\r\n          stbi__rewind( s );\r\n          return 0;\r\n      }\r\n      if (packet->size != 8) {\r\n          stbi__rewind( s );\r\n          return 0;\r\n      }\r\n   } while (chained);\r\n\r\n   *comp = (act_comp & 0x10 ? 4 : 3);\r\n\r\n   return 1;\r\n}\r\n#endif\r\n\r\n// *************************************************************************************************\r\n// Portable Gray Map and Portable Pixel Map loader\r\n// by Ken Miller\r\n//\r\n// PGM: http://netpbm.sourceforge.net/doc/pgm.html\r\n// PPM: http://netpbm.sourceforge.net/doc/ppm.html\r\n//\r\n// Known limitations:\r\n//    Does not support comments in the header section\r\n//    Does not support ASCII image data (formats P2 and P3)\r\n//    Does not support 16-bit-per-channel\r\n\r\n#ifndef STBI_NO_PNM\r\n\r\nstatic int      stbi__pnm_test(stbi__context *s)\r\n{\r\n   char p, t;\r\n   p = (char) stbi__get8(s);\r\n   t = (char) stbi__get8(s);\r\n   if (p != 'P' || (t != '5' && t != '6')) {\r\n       stbi__rewind( s );\r\n       return 0;\r\n   }\r\n   return 1;\r\n}\r\n\r\nstatic void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\r\n{\r\n   stbi_uc *out;\r\n   STBI_NOTUSED(ri);\r\n\r\n   if (!stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n))\r\n      return 0;\r\n\r\n   *x = s->img_x;\r\n   *y = s->img_y;\r\n   if (comp) *comp = s->img_n;\r\n\r\n   if (!stbi__mad3sizes_valid(s->img_n, s->img_x, s->img_y, 0))\r\n      return stbi__errpuc(\"too large\", \"PNM too large\");\r\n\r\n   out = (stbi_uc *) stbi__malloc_mad3(s->img_n, s->img_x, s->img_y, 0);\r\n   if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\r\n   stbi__getn(s, out, s->img_n * s->img_x * s->img_y);\r\n\r\n   if (req_comp && req_comp != s->img_n) {\r\n      out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);\r\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\r\n   }\r\n   return out;\r\n}\r\n\r\nstatic int      stbi__pnm_isspace(char c)\r\n{\r\n   return c == ' ' || c == '\\t' || c == '\\n' || c == '\\v' || c == '\\f' || c == '\\r';\r\n}\r\n\r\nstatic void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)\r\n{\r\n   for (;;) {\r\n      while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))\r\n         *c = (char) stbi__get8(s);\r\n\r\n      if (stbi__at_eof(s) || *c != '#')\r\n         break;\r\n\r\n      while (!stbi__at_eof(s) && *c != '\\n' && *c != '\\r' )\r\n         *c = (char) stbi__get8(s);\r\n   }\r\n}\r\n\r\nstatic int      stbi__pnm_isdigit(char c)\r\n{\r\n   return c >= '0' && c <= '9';\r\n}\r\n\r\nstatic int      stbi__pnm_getinteger(stbi__context *s, char *c)\r\n{\r\n   int value = 0;\r\n\r\n   while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {\r\n      value = value*10 + (*c - '0');\r\n      *c = (char) stbi__get8(s);\r\n   }\r\n\r\n   return value;\r\n}\r\n\r\nstatic int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)\r\n{\r\n   int maxv, dummy;\r\n   char c, p, t;\r\n\r\n   if (!x) x = &dummy;\r\n   if (!y) y = &dummy;\r\n   if (!comp) comp = &dummy;\r\n\r\n   stbi__rewind(s);\r\n\r\n   // Get identifier\r\n   p = (char) stbi__get8(s);\r\n   t = (char) stbi__get8(s);\r\n   if (p != 'P' || (t != '5' && t != '6')) {\r\n       stbi__rewind(s);\r\n       return 0;\r\n   }\r\n\r\n   *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm\r\n\r\n   c = (char) stbi__get8(s);\r\n   stbi__pnm_skip_whitespace(s, &c);\r\n\r\n   *x = stbi__pnm_getinteger(s, &c); // read width\r\n   stbi__pnm_skip_whitespace(s, &c);\r\n\r\n   *y = stbi__pnm_getinteger(s, &c); // read height\r\n   stbi__pnm_skip_whitespace(s, &c);\r\n\r\n   maxv = stbi__pnm_getinteger(s, &c);  // read max value\r\n\r\n   if (maxv > 255)\r\n      return stbi__err(\"max value > 255\", \"PPM image not 8-bit\");\r\n   else\r\n      return 1;\r\n}\r\n#endif\r\n\r\nstatic int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)\r\n{\r\n   #ifndef STBI_NO_JPEG\r\n   if (stbi__jpeg_info(s, x, y, comp)) return 1;\r\n   #endif\r\n\r\n   #ifndef STBI_NO_PNG\r\n   if (stbi__png_info(s, x, y, comp))  return 1;\r\n   #endif\r\n\r\n   #ifndef STBI_NO_GIF\r\n   if (stbi__gif_info(s, x, y, comp))  return 1;\r\n   #endif\r\n\r\n   #ifndef STBI_NO_BMP\r\n   if (stbi__bmp_info(s, x, y, comp))  return 1;\r\n   #endif\r\n\r\n   #ifndef STBI_NO_PSD\r\n   if (stbi__psd_info(s, x, y, comp))  return 1;\r\n   #endif\r\n\r\n   #ifndef STBI_NO_PIC\r\n   if (stbi__pic_info(s, x, y, comp))  return 1;\r\n   #endif\r\n\r\n   #ifndef STBI_NO_PNM\r\n   if (stbi__pnm_info(s, x, y, comp))  return 1;\r\n   #endif\r\n\r\n   #ifndef STBI_NO_HDR\r\n   if (stbi__hdr_info(s, x, y, comp))  return 1;\r\n   #endif\r\n\r\n   // test tga last because it's a crappy test!\r\n   #ifndef STBI_NO_TGA\r\n   if (stbi__tga_info(s, x, y, comp))\r\n       return 1;\r\n   #endif\r\n   return stbi__err(\"unknown image type\", \"Image not of any known type, or corrupt\");\r\n}\r\n\r\n#ifndef STBI_NO_STDIO\r\nSTBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)\r\n{\r\n    FILE *f = stbi__fopen(filename, \"rb\");\r\n    int result;\r\n    if (!f) return stbi__err(\"can't fopen\", \"Unable to open file\");\r\n    result = stbi_info_from_file(f, x, y, comp);\r\n    fclose(f);\r\n    return result;\r\n}\r\n\r\nSTBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)\r\n{\r\n   int r;\r\n   stbi__context s;\r\n   long pos = ftell(f);\r\n   stbi__start_file(&s, f);\r\n   r = stbi__info_main(&s,x,y,comp);\r\n   fseek(f,pos,SEEK_SET);\r\n   return r;\r\n}\r\n#endif // !STBI_NO_STDIO\r\n\r\nSTBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)\r\n{\r\n   stbi__context s;\r\n   stbi__start_mem(&s,buffer,len);\r\n   return stbi__info_main(&s,x,y,comp);\r\n}\r\n\r\nSTBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)\r\n{\r\n   stbi__context s;\r\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);\r\n   return stbi__info_main(&s,x,y,comp);\r\n}\r\n\r\n#endif // STB_IMAGE_IMPLEMENTATION\r\n\r\n/*\r\n   revision history:\r\n      2.16  (2017-07-23) all functions have 16-bit variants;\r\n                         STBI_NO_STDIO works again;\r\n                         compilation fixes;\r\n                         fix rounding in unpremultiply;\r\n                         optimize vertical flip;\r\n                         disable raw_len validation;\r\n                         documentation fixes\r\n      2.15  (2017-03-18) fix png-1,2,4 bug; now all Imagenet JPGs decode;\r\n                         warning fixes; disable run-time SSE detection on gcc;\r\n                         uniform handling of optional \"return\" values;\r\n                         thread-safe initialization of zlib tables\r\n      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs\r\n      2.13  (2016-11-29) add 16-bit API, only supported for PNG right now\r\n      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes\r\n      2.11  (2016-04-02) allocate large structures on the stack\r\n                         remove white matting for transparent PSD\r\n                         fix reported channel count for PNG & BMP\r\n                         re-enable SSE2 in non-gcc 64-bit\r\n                         support RGB-formatted JPEG\r\n                         read 16-bit PNGs (only as 8-bit)\r\n      2.10  (2016-01-22) avoid warning introduced in 2.09 by STBI_REALLOC_SIZED\r\n      2.09  (2016-01-16) allow comments in PNM files\r\n                         16-bit-per-pixel TGA (not bit-per-component)\r\n                         info() for TGA could break due to .hdr handling\r\n                         info() for BMP to shares code instead of sloppy parse\r\n                         can use STBI_REALLOC_SIZED if allocator doesn't support realloc\r\n                         code cleanup\r\n      2.08  (2015-09-13) fix to 2.07 cleanup, reading RGB PSD as RGBA\r\n      2.07  (2015-09-13) fix compiler warnings\r\n                         partial animated GIF support\r\n                         limited 16-bpc PSD support\r\n                         #ifdef unused functions\r\n                         bug with < 92 byte PIC,PNM,HDR,TGA\r\n      2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value\r\n      2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning\r\n      2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit\r\n      2.03  (2015-04-12) extra corruption checking (mmozeiko)\r\n                         stbi_set_flip_vertically_on_load (nguillemot)\r\n                         fix NEON support; fix mingw support\r\n      2.02  (2015-01-19) fix incorrect assert, fix warning\r\n      2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2\r\n      2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG\r\n      2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)\r\n                         progressive JPEG (stb)\r\n                         PGM/PPM support (Ken Miller)\r\n                         STBI_MALLOC,STBI_REALLOC,STBI_FREE\r\n                         GIF bugfix -- seemingly never worked\r\n                         STBI_NO_*, STBI_ONLY_*\r\n      1.48  (2014-12-14) fix incorrectly-named assert()\r\n      1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)\r\n                         optimize PNG (ryg)\r\n                         fix bug in interlaced PNG with user-specified channel count (stb)\r\n      1.46  (2014-08-26)\r\n              fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG\r\n      1.45  (2014-08-16)\r\n              fix MSVC-ARM internal compiler error by wrapping malloc\r\n      1.44  (2014-08-07)\r\n              various warning fixes from Ronny Chevalier\r\n      1.43  (2014-07-15)\r\n              fix MSVC-only compiler problem in code changed in 1.42\r\n      1.42  (2014-07-09)\r\n              don't define _CRT_SECURE_NO_WARNINGS (affects user code)\r\n              fixes to stbi__cleanup_jpeg path\r\n              added STBI_ASSERT to avoid requiring assert.h\r\n      1.41  (2014-06-25)\r\n              fix search&replace from 1.36 that messed up comments/error messages\r\n      1.40  (2014-06-22)\r\n              fix gcc struct-initialization warning\r\n      1.39  (2014-06-15)\r\n              fix to TGA optimization when req_comp != number of components in TGA;\r\n              fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)\r\n              add support for BMP version 5 (more ignored fields)\r\n      1.38  (2014-06-06)\r\n              suppress MSVC warnings on integer casts truncating values\r\n              fix accidental rename of 'skip' field of I/O\r\n      1.37  (2014-06-04)\r\n              remove duplicate typedef\r\n      1.36  (2014-06-03)\r\n              convert to header file single-file library\r\n              if de-iphone isn't set, load iphone images color-swapped instead of returning NULL\r\n      1.35  (2014-05-27)\r\n              various warnings\r\n              fix broken STBI_SIMD path\r\n              fix bug where stbi_load_from_file no longer left file pointer in correct place\r\n              fix broken non-easy path for 32-bit BMP (possibly never used)\r\n              TGA optimization by Arseny Kapoulkine\r\n      1.34  (unknown)\r\n              use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case\r\n      1.33  (2011-07-14)\r\n              make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements\r\n      1.32  (2011-07-13)\r\n              support for \"info\" function for all supported filetypes (SpartanJ)\r\n      1.31  (2011-06-20)\r\n              a few more leak fixes, bug in PNG handling (SpartanJ)\r\n      1.30  (2011-06-11)\r\n              added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)\r\n              removed deprecated format-specific test/load functions\r\n              removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway\r\n              error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)\r\n              fix inefficiency in decoding 32-bit BMP (David Woo)\r\n      1.29  (2010-08-16)\r\n              various warning fixes from Aurelien Pocheville\r\n      1.28  (2010-08-01)\r\n              fix bug in GIF palette transparency (SpartanJ)\r\n      1.27  (2010-08-01)\r\n              cast-to-stbi_uc to fix warnings\r\n      1.26  (2010-07-24)\r\n              fix bug in file buffering for PNG reported by SpartanJ\r\n      1.25  (2010-07-17)\r\n              refix trans_data warning (Won Chun)\r\n      1.24  (2010-07-12)\r\n              perf improvements reading from files on platforms with lock-heavy fgetc()\r\n              minor perf improvements for jpeg\r\n              deprecated type-specific functions so we'll get feedback if they're needed\r\n              attempt to fix trans_data warning (Won Chun)\r\n      1.23    fixed bug in iPhone support\r\n      1.22  (2010-07-10)\r\n              removed image *writing* support\r\n              stbi_info support from Jetro Lauha\r\n              GIF support from Jean-Marc Lienher\r\n              iPhone PNG-extensions from James Brown\r\n              warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)\r\n      1.21    fix use of 'stbi_uc' in header (reported by jon blow)\r\n      1.20    added support for Softimage PIC, by Tom Seddon\r\n      1.19    bug in interlaced PNG corruption check (found by ryg)\r\n      1.18  (2008-08-02)\r\n              fix a threading bug (local mutable static)\r\n      1.17    support interlaced PNG\r\n      1.16    major bugfix - stbi__convert_format converted one too many pixels\r\n      1.15    initialize some fields for thread safety\r\n      1.14    fix threadsafe conversion bug\r\n              header-file-only version (#define STBI_HEADER_FILE_ONLY before including)\r\n      1.13    threadsafe\r\n      1.12    const qualifiers in the API\r\n      1.11    Support installable IDCT, colorspace conversion routines\r\n      1.10    Fixes for 64-bit (don't use \"unsigned long\")\r\n              optimized upsampling by Fabian \"ryg\" Giesen\r\n      1.09    Fix format-conversion for PSD code (bad global variables!)\r\n      1.08    Thatcher Ulrich's PSD code integrated by Nicolas Schulz\r\n      1.07    attempt to fix C++ warning/errors again\r\n      1.06    attempt to fix C++ warning/errors again\r\n      1.05    fix TGA loading to return correct *comp and use good luminance calc\r\n      1.04    default float alpha is 1, not 255; use 'void *' for stbi_image_free\r\n      1.03    bugfixes to STBI_NO_STDIO, STBI_NO_HDR\r\n      1.02    support for (subset of) HDR files, float interface for preferred access to them\r\n      1.01    fix bug: possible bug in handling right-side up bmps... not sure\r\n              fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all\r\n      1.00    interface to zlib that skips zlib header\r\n      0.99    correct handling of alpha in palette\r\n      0.98    TGA loader by lonesock; dynamically add loaders (untested)\r\n      0.97    jpeg errors on too large a file; also catch another malloc failure\r\n      0.96    fix detection of invalid v value - particleman@mollyrocket forum\r\n      0.95    during header scan, seek to markers in case of padding\r\n      0.94    STBI_NO_STDIO to disable stdio usage; rename all #defines the same\r\n      0.93    handle jpegtran output; verbose errors\r\n      0.92    read 4,8,16,24,32-bit BMP files of several formats\r\n      0.91    output 24-bit Windows 3.0 BMP files\r\n      0.90    fix a few more warnings; bump version number to approach 1.0\r\n      0.61    bugfixes due to Marc LeBlanc, Christopher Lloyd\r\n      0.60    fix compiling as c++\r\n      0.59    fix warnings: merge Dave Moore's -Wall fixes\r\n      0.58    fix bug: zlib uncompressed mode len/nlen was wrong endian\r\n      0.57    fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available\r\n      0.56    fix bug: zlib uncompressed mode len vs. nlen\r\n      0.55    fix bug: restart_interval not initialized to 0\r\n      0.54    allow NULL for 'int *comp'\r\n      0.53    fix bug in png 3->4; speedup png decoding\r\n      0.52    png handles req_comp=3,4 directly; minor cleanup; jpeg comments\r\n      0.51    obey req_comp requests, 1-component jpegs return as 1-component,\r\n              on 'test' only check type, not whether we support this variant\r\n      0.50  (2006-11-19)\r\n              first released version\r\n*/\r\n\r\n\r\n/*\r\n------------------------------------------------------------------------------\r\nThis software is available under 2 licenses -- choose whichever you prefer.\r\n------------------------------------------------------------------------------\r\nALTERNATIVE A - MIT License\r\nCopyright (c) 2017 Sean Barrett\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of\r\nthis software and associated documentation files (the \"Software\"), to deal in\r\nthe Software without restriction, including without limitation the rights to\r\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\nof the Software, and to permit persons to whom the Software is furnished to do\r\nso, subject to the following conditions:\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n------------------------------------------------------------------------------\r\nALTERNATIVE B - Public Domain (www.unlicense.org)\r\nThis is free and unencumbered software released into the public domain.\r\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\r\nsoftware, either in source code form or as a compiled binary, for any purpose,\r\ncommercial or non-commercial, and by any means.\r\nIn jurisdictions that recognize copyright laws, the author or authors of this\r\nsoftware dedicate any and all copyright interest in the software to the public\r\ndomain. We make this dedication for the benefit of the public at large and to\r\nthe detriment of our heirs and successors. We intend this dedication to be an\r\novert act of relinquishment in perpetuity of all present and future rights to\r\nthis software under copyright law.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\r\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n------------------------------------------------------------------------------\r\n*/","#include <platform.h>\r\n\r\n#define STB_IMAGE_IMPLEMENTATION\r\n#include <3rdparty/stb_image.h>\r\n\r\nnamespace engine\r\n{\r\n\tTexture2D* getTexture(Resources* resources, int id)\r\n\t{\r\n\t\tif (!resources->loaded[id])\r\n\t\t{\r\n\t\t\tint width, height, nrChannels;\r\n\t\t\tunsigned char *data = stbi_load(ResourcePaths[id], &width, &height, &nrChannels, 0);\r\n\r\n\t\t\tif (data)\r\n\t\t\t{\r\n\t\t\t\tresources->textures[id] = resources->loadTexturePtr(width, height, nrChannels, data);\r\n\t\t\t\tstbi_image_free(data);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tprintf(\"failed to load image %s \\n\", ResourcePaths[id]);\r\n\r\n\t\t\t\tunsigned char pixels[3] = // Placeholder texture\r\n\t\t\t\t{\r\n\t\t\t\t\t255, 0, 255,\r\n\t\t\t\t};\r\n\t\t\t\tresources->textures[id] = resources->loadTexturePtr(1, 1, 3, pixels);\r\n\t\t\t}\r\n\r\n\t\t\tresources->loaded[id] = true;\r\n\t\t}\r\n\t\treturn &resources->textures[id];\r\n\t}\r\n}\r\n","// dear imgui, v1.53\r\n// (main code and documentation)\r\n\r\n// Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code.\r\n// Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.\r\n// Get latest version at https://github.com/ocornut/imgui\r\n// Releases change-log at https://github.com/ocornut/imgui/releases\r\n// Gallery (please post your screenshots/video there!): https://github.com/ocornut/imgui/issues/1269\r\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\r\n// This library is free but I need your support to sustain development and maintenance.\r\n// If you work for a company, please consider financial support, see Readme. For individuals: https://www.patreon.com/imgui\r\n\r\n/*\r\n\r\n Index\r\n - MISSION STATEMENT\r\n - END-USER GUIDE\r\n - PROGRAMMER GUIDE (read me!)\r\n   - Read first\r\n   - How to update to a newer version of Dear ImGui\r\n   - Getting started with integrating Dear ImGui in your code/engine\r\n - API BREAKING CHANGES (read me when you update!)\r\n - ISSUES & TODO LIST\r\n - FREQUENTLY ASKED QUESTIONS (FAQ), TIPS\r\n   - How can I help?\r\n   - What is ImTextureID and how do I display an image?\r\n   - I integrated Dear ImGui in my engine and the text or lines are blurry..\r\n   - I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around..\r\n   - How can I have multiple widgets with the same label? Can I have widget without a label? (Yes). A primer on labels/IDs.\r\n   - How can I tell when Dear ImGui wants my mouse/keyboard inputs VS when I can pass them to my application?\r\n   - How can I load a different font than the default?\r\n   - How can I easily use icons in my application?\r\n   - How can I load multiple fonts?\r\n   - How can I display and input non-latin characters such as Chinese, Japanese, Korean, Cyrillic?\r\n   - How can I preserve my Dear ImGui context across reloading a DLL? (loss of the global/static variables)\r\n   - How can I use the drawing facilities without an ImGui window? (using ImDrawList API)\r\n - ISSUES & TODO-LIST\r\n - CODE\r\n\r\n\r\n MISSION STATEMENT\r\n =================\r\n\r\n - Easy to use to create code-driven and data-driven tools\r\n - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools\r\n - Easy to hack and improve\r\n - Minimize screen real-estate usage\r\n - Minimize setup and maintenance\r\n - Minimize state storage on user side\r\n - Portable, minimize dependencies, run on target (consoles, phones, etc.)\r\n - Efficient runtime and memory consumption (NB- we do allocate when \"growing\" content e.g. creating a window, opening a tree node \r\n   for the first time, etc. but a typical frame won't allocate anything)\r\n\r\n Designed for developers and content-creators, not the typical end-user! Some of the weaknesses includes:\r\n - Doesn't look fancy, doesn't animate\r\n - Limited layout features, intricate layouts are typically crafted in code\r\n\r\n\r\n END-USER GUIDE\r\n ==============\r\n\r\n - Double-click on title bar to collapse window.\r\n - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().\r\n - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).\r\n - Click and drag on any empty space to move window.\r\n - TAB/SHIFT+TAB to cycle through keyboard editable fields.\r\n - CTRL+Click on a slider or drag box to input value as text.\r\n - Use mouse wheel to scroll.\r\n - Text editor:\r\n   - Hold SHIFT or use mouse to select text.\r\n   - CTRL+Left/Right to word jump.\r\n   - CTRL+Shift+Left/Right to select words.\r\n   - CTRL+A our Double-Click to select all.\r\n   - CTRL+X,CTRL+C,CTRL+V to use OS clipboard/\r\n   - CTRL+Z,CTRL+Y to undo/redo.\r\n   - ESCAPE to revert text to its original value.\r\n   - You can apply arithmetic operators +,*,/ on numerical values. Use +- to subtract (because - would set a negative value!)\r\n   - Controls are automatically adjusted for OSX to match standard OSX text editing operations.\r\n\r\n\r\n PROGRAMMER GUIDE\r\n ================\r\n\r\n READ FIRST\r\n\r\n - Read the FAQ below this section!\r\n - Your code creates the UI, if your code doesn't run the UI is gone! == very dynamic UI, no construction/destructions steps, less data retention\r\n   on your side, no state duplication, less sync, less bugs.\r\n - Call and read ImGui::ShowDemoWindow() for demo code demonstrating most features.\r\n - You can learn about immediate-mode gui principles at http://www.johno.se/book/imgui.html or watch http://mollyrocket.com/861\r\n\r\n HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\r\n\r\n - Overwrite all the sources files except for imconfig.h (if you have made modification to your copy of imconfig.h)\r\n - Read the \"API BREAKING CHANGES\" section (below). This is where we list occasional API breaking changes. \r\n   If a function/type has been renamed / or marked obsolete, try to fix the name in your code before it is permanently removed from the public API.\r\n   If you have a problem with a missing function/symbols, search for its name in the code, there will likely be a comment about it. \r\n   Please report any issue to the GitHub page!\r\n - Try to keep your copy of dear imgui reasonably up to date.\r\n\r\n GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\r\n\r\n - Add the Dear ImGui source files to your projects, using your preferred build system. \r\n   It is recommended you build the .cpp files as part of your project and not as a library.\r\n - You can later customize the imconfig.h file to tweak some compilation time behavior, such as integrating imgui types with your own maths types.\r\n - See examples/ folder for standalone sample applications.\r\n - You may be able to grab and copy a ready made imgui_impl_*** file from the examples/.\r\n - When using Dear ImGui, your programming IDE is your friend: follow the declaration of variables, functions and types to find comments about them.\r\n\r\n - Init: retrieve the ImGuiIO structure with ImGui::GetIO() and fill the fields marked 'Settings': at minimum you need to set io.DisplaySize\r\n   (application resolution). Later on you will fill your keyboard mapping, clipboard handlers, and other advanced features but for a basic \r\n   integration you don't need to worry about it all.\r\n - Init: call io.Fonts->GetTexDataAsRGBA32(...), it will build the font atlas texture, then load the texture pixels into graphics memory.\r\n - Every frame:\r\n    - In your main loop as early a possible, fill the IO fields marked 'Input' (e.g. mouse position, buttons, keyboard info, etc.)\r\n    - Call ImGui::NewFrame() to begin the frame\r\n    - You can use any ImGui function you want between NewFrame() and Render()\r\n    - Call ImGui::Render() as late as you can to end the frame and finalize render data. it will call your io.RenderDrawListFn handler.\r\n       (Even if you don't render, call Render() and ignore the callback, or call EndFrame() instead. Otherwhise some features will break)\r\n - All rendering information are stored into command-lists until ImGui::Render() is called.\r\n - Dear ImGui never touches or knows about your GPU state. the only function that knows about GPU is the RenderDrawListFn handler that you provide.\r\n - Effectively it means you can create widgets at any time in your code, regardless of considerations of being in \"update\" vs \"render\" phases \r\n   of your own application.\r\n - Refer to the examples applications in the examples/ folder for instruction on how to setup your code.\r\n - A minimal application skeleton may be:\r\n\r\n     // Application init\r\n     ImGuiIO& io = ImGui::GetIO();\r\n     io.DisplaySize.x = 1920.0f;\r\n     io.DisplaySize.y = 1280.0f;\r\n     io.RenderDrawListsFn = MyRenderFunction;  // Setup a render function, or set to NULL and call GetDrawData() after Render() to access render data.\r\n     // TODO: Fill others settings of the io structure later.\r\n\r\n     // Load texture atlas (there is a default font so you don't need to care about choosing a font yet)\r\n     unsigned char* pixels;\r\n     int width, height;\r\n     io.Fonts->GetTexDataAsRGBA32(pixels, &width, &height);\r\n     // TODO: At this points you've got the texture data and you need to upload that your your graphic system:\r\n     MyTexture* texture = MyEngine::CreateTextureFromMemoryPixels(pixels, width, height, TEXTURE_TYPE_RGBA)\r\n     // TODO: Store your texture pointer/identifier (whatever your engine uses) in 'io.Fonts->TexID'. This will be passed back to your via the renderer.\r\n     io.Fonts->TexID = (void*)texture;\r\n\r\n     // Application main loop\r\n     while (true)\r\n     {\r\n        // Setup low-level inputs (e.g. on Win32, GetKeyboardState(), or write to those fields from your Windows message loop handlers, etc.)\r\n        ImGuiIO& io = ImGui::GetIO();\r\n        io.DeltaTime = 1.0f/60.0f;\r\n        io.MousePos = mouse_pos;\r\n        io.MouseDown[0] = mouse_button_0;\r\n        io.MouseDown[1] = mouse_button_1;\r\n\r\n        // Call NewFrame(), after this point you can use ImGui::* functions anytime\r\n        ImGui::NewFrame();\r\n\r\n        // Most of your application code here\r\n        MyGameUpdate(); // may use any ImGui functions, e.g. ImGui::Begin(\"My window\"); ImGui::Text(\"Hello, world!\"); ImGui::End();\r\n        MyGameRender(); // may use any ImGui functions as well!\r\n     \r\n        // Render & swap video buffers\r\n        ImGui::Render();\r\n        SwapBuffers();\r\n     }\r\n\r\n - A minimal render function skeleton may be:\r\n\r\n    void void MyRenderFunction(ImDrawData* draw_data)(ImDrawData* draw_data)\r\n    {\r\n       // TODO: Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled\r\n       // TODO: Setup viewport, orthographic projection matrix\r\n       // TODO: Setup shader: vertex { float2 pos, float2 uv, u32 color }, fragment shader sample color from 1 texture, multiply by vertex color.\r\n       for (int n = 0; n < draw_data->CmdListsCount; n++)\r\n       {\r\n          const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by ImGui\r\n          const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by ImGui\r\n          for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)\r\n          {\r\n             const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];\r\n             if (pcmd->UserCallback)\r\n             {\r\n                 pcmd->UserCallback(cmd_list, pcmd);\r\n             }\r\n             else\r\n             {\r\n                 // The texture for the draw call is specified by pcmd->TextureId. \r\n                 // The vast majority of draw calls with use the imgui texture atlas, which value you have set yourself during initialization. \r\n                 MyEngineBindTexture(pcmd->TextureId);\r\n\r\n                 // We are using scissoring to clip some objects. All low-level graphics API supports it.\r\n                 // If your engine doesn't support scissoring yet, you will get some small glitches (some elements outside their bounds) which you can fix later.\r\n                 MyEngineScissor((int)pcmd->ClipRect.x, (int)pcmd->ClipRect.y, (int)(pcmd->ClipRect.z - pcmd->ClipRect.x), (int)(pcmd->ClipRect.w - pcmd->ClipRect.y));\r\n\r\n                 // Render 'pcmd->ElemCount/3' indexed triangles.\r\n                 // By default the indices ImDrawIdx are 16-bits, you can change them to 32-bits if your engine doesn't support 16-bits indices.\r\n                 MyEngineDrawIndexedTriangles(pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer, vtx_buffer);\r\n             }\r\n             idx_buffer += pcmd->ElemCount;\r\n          }\r\n       }\r\n    }\r\n\r\n - The examples/ folders contains many functional implementation of the pseudo-code above.\r\n - When calling NewFrame(), the 'io.WantCaptureMouse'/'io.WantCaptureKeyboard'/'io.WantTextInput' flags are updated. \r\n   They tell you if ImGui intends to use your inputs. So for example, if 'io.WantCaptureMouse' is set you would typically want to hide \r\n   mouse inputs from the rest of your application. Read the FAQ below for more information about those flags.\r\n\r\n\r\n\r\n API BREAKING CHANGES\r\n ====================\r\n\r\n Occasionally introducing changes that are breaking the API. The breakage are generally minor and easy to fix.\r\n Here is a change-log of API breaking changes, if you are using one of the functions listed, expect to have to fix some code.\r\n Also read releases logs https://github.com/ocornut/imgui/releases for more details.\r\n\r\n - 2017/12/24 (1.53) - renamed the emblematic ShowTestWindow() function to ShowDemoWindow(). Kept redirection function (will obsolete).\r\n - 2017/12/21 (1.53) - ImDrawList: renamed style.AntiAliasedShapes to style.AntiAliasedFill for consistency and as a way to explicitly break code that manipulate those flag at runtime. You can now manipulate ImDrawList::Flags\r\n - 2017/12/21 (1.53) - ImDrawList: removed 'bool anti_aliased = true' final parameter of ImDrawList::AddPolyline() and ImDrawList::AddConvexPolyFilled(). Prefer manipulating ImDrawList::Flags if you need to toggle them during the frame.\r\n - 2017/12/14 (1.53) - using the ImGuiWindowFlags_NoScrollWithMouse flag on a child window forwards the mouse wheel event to the parent window, unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set.\r\n - 2017/12/13 (1.53) - renamed GetItemsLineHeightWithSpacing() to GetFrameHeightWithSpacing(). Kept redirection function (will obsolete).\r\n - 2017/12/13 (1.53) - obsoleted IsRootWindowFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootWindow). Kept redirection function (will obsolete).\r\n                     - obsoleted IsRootWindowOrAnyChildFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows). Kept redirection function (will obsolete).\r\n - 2017/12/12 (1.53) - renamed ImGuiTreeNodeFlags_AllowOverlapMode to ImGuiTreeNodeFlags_AllowItemOverlap. Kept redirection enum (will obsolete).\r\n - 2017/12/10 (1.53) - removed SetNextWindowContentWidth(), prefer using SetNextWindowContentSize(). Kept redirection function (will obsolete).\r\n - 2017/11/27 (1.53) - renamed ImGuiTextBuffer::append() helper to appendf(), appendv() to appendfv(). If you copied the 'Log' demo in your code, it uses appendv() so that needs to be renamed.\r\n - 2017/11/18 (1.53) - Style, Begin: removed ImGuiWindowFlags_ShowBorders window flag. Borders are now fully set up in the ImGuiStyle structure (see e.g. style.FrameBorderSize, style.WindowBorderSize). Use ImGui::ShowStyleEditor() to look them up.\r\n                       Please note that the style system will keep evolving (hopefully stabilizing in Q1 2018), and so custom styles will probably subtly break over time. It is recommended you use the StyleColorsClassic(), StyleColorsDark(), StyleColorsLight() functions.\r\n - 2017/11/18 (1.53) - Style: removed ImGuiCol_ComboBg in favor of combo boxes using ImGuiCol_PopupBg for consistency.\r\n - 2017/11/18 (1.53) - Style: renamed ImGuiCol_ChildWindowBg to ImGuiCol_ChildBg.\r\n - 2017/11/18 (1.53) - Style: renamed style.ChildWindowRounding to style.ChildRounding, ImGuiStyleVar_ChildWindowRounding to ImGuiStyleVar_ChildRounding.\r\n - 2017/11/02 (1.53) - obsoleted IsRootWindowOrAnyChildHovered() in favor of using IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows);\r\n - 2017/10/24 (1.52) - renamed IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCS to IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS for consistency.\r\n - 2017/10/20 (1.52) - changed IsWindowHovered() default parameters behavior to return false if an item is active in another window (e.g. click-dragging item from another window to this window). You can use the newly introduced IsWindowHovered() flags to requests this specific behavior if you need it.\r\n - 2017/10/20 (1.52) - marked IsItemHoveredRect()/IsMouseHoveringWindow() as obsolete, in favor of using the newly introduced flags for IsItemHovered() and IsWindowHovered(). See https://github.com/ocornut/imgui/issues/1382 for details.\r\n                       removed the IsItemRectHovered()/IsWindowRectHovered() names introduced in 1.51 since they were merely more consistent names for the two functions we are now obsoleting.\r\n - 2017/10/17 (1.52) - marked the old 5-parameters version of Begin() as obsolete (still available). Use SetNextWindowSize()+Begin() instead!\r\n - 2017/10/11 (1.52) - renamed AlignFirstTextHeightToWidgets() to AlignTextToFramePadding(). Kept inline redirection function (will obsolete).\r\n - 2017/09/25 (1.52) - removed SetNextWindowPosCenter() because SetNextWindowPos() now has the optional pivot information to do the same and more. Kept redirection function (will obsolete). \r\n - 2017/08/25 (1.52) - io.MousePos needs to be set to ImVec2(-FLT_MAX,-FLT_MAX) when mouse is unavailable/missing. Previously ImVec2(-1,-1) was enough but we now accept negative mouse coordinates. In your binding if you need to support unavailable mouse, make sure to replace \"io.MousePos = ImVec2(-1,-1)\" with \"io.MousePos = ImVec2(-FLT_MAX,-FLT_MAX)\".\r\n - 2017/08/22 (1.51) - renamed IsItemHoveredRect() to IsItemRectHovered(). Kept inline redirection function (will obsolete). -> (1.52) use IsItemHovered(ImGuiHoveredFlags_RectOnly)! \r\n                     - renamed IsMouseHoveringAnyWindow() to IsAnyWindowHovered() for consistency. Kept inline redirection function (will obsolete).\r\n                     - renamed IsMouseHoveringWindow() to IsWindowRectHovered() for consistency. Kept inline redirection function (will obsolete).\r\n - 2017/08/20 (1.51) - renamed GetStyleColName() to GetStyleColorName() for consistency.\r\n - 2017/08/20 (1.51) - added PushStyleColor(ImGuiCol idx, ImU32 col) overload, which _might_ cause an \"ambiguous call\" compilation error if you are using ImColor() with implicit cast. Cast to ImU32 or ImVec4 explicily to fix.\r\n - 2017/08/15 (1.51) - marked the weird IMGUI_ONCE_UPON_A_FRAME helper macro as obsolete. prefer using the more explicit ImGuiOnceUponAFrame.\r\n - 2017/08/15 (1.51) - changed parameter order for BeginPopupContextWindow() from (const char*,int buttons,bool also_over_items) to (const char*,int buttons,bool also_over_items). Note that most calls relied on default parameters completely.\r\n - 2017/08/13 (1.51) - renamed ImGuiCol_Columns*** to ImGuiCol_Separator***. Kept redirection enums (will obsolete).\r\n - 2017/08/11 (1.51) - renamed ImGuiSetCond_*** types and flags to ImGuiCond_***. Kept redirection enums (will obsolete).\r\n - 2017/08/09 (1.51) - removed ValueColor() helpers, they are equivalent to calling Text(label) + SameLine() + ColorButton().\r\n - 2017/08/08 (1.51) - removed ColorEditMode() and ImGuiColorEditMode in favor of ImGuiColorEditFlags and parameters to the various Color*() functions. The SetColorEditOptions() allows to initialize default but the user can still change them with right-click context menu.\r\n                     - changed prototype of 'ColorEdit4(const char* label, float col[4], bool show_alpha = true)' to 'ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0)', where passing flags = 0x01 is a safe no-op (hello dodgy backward compatibility!). - check and run the demo window, under \"Color/Picker Widgets\", to understand the various new options.\r\n                     - changed prototype of rarely used 'ColorButton(ImVec4 col, bool small_height = false, bool outline_border = true)' to 'ColorButton(const char* desc_id, ImVec4 col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0,0))'\r\n - 2017/07/20 (1.51) - removed IsPosHoveringAnyWindow(ImVec2), which was partly broken and misleading. ASSERT + redirect user to io.WantCaptureMouse\r\n - 2017/05/26 (1.50) - removed ImFontConfig::MergeGlyphCenterV in favor of a more multipurpose ImFontConfig::GlyphOffset.\r\n - 2017/05/01 (1.50) - renamed ImDrawList::PathFill() (rarely used directly) to ImDrawList::PathFillConvex() for clarity.\r\n - 2016/11/06 (1.50) - BeginChild(const char*) now applies the stack id to the provided label, consistently with other functions as it should always have been. It shouldn't affect you unless (extremely unlikely) you were appending multiple times to a same child from different locations of the stack id. If that's the case, generate an id with GetId() and use it instead of passing string to BeginChild().\r\n - 2016/10/15 (1.50) - avoid 'void* user_data' parameter to io.SetClipboardTextFn/io.GetClipboardTextFn pointers. We pass io.ClipboardUserData to it.\r\n - 2016/09/25 (1.50) - style.WindowTitleAlign is now a ImVec2 (ImGuiAlign enum was removed). set to (0.5f,0.5f) for horizontal+vertical centering, (0.0f,0.0f) for upper-left, etc.\r\n - 2016/07/30 (1.50) - SameLine(x) with x>0.0f is now relative to left of column/group if any, and not always to left of window. This was sort of always the intent and hopefully breakage should be minimal.\r\n - 2016/05/12 (1.49) - title bar (using ImGuiCol_TitleBg/ImGuiCol_TitleBgActive colors) isn't rendered over a window background (ImGuiCol_WindowBg color) anymore. \r\n                       If your TitleBg/TitleBgActive alpha was 1.0f or you are using the default theme it will not affect you. \r\n                       However if your TitleBg/TitleBgActive alpha was <1.0f you need to tweak your custom theme to readjust for the fact that we don't draw a WindowBg background behind the title bar.\r\n                       This helper function will convert an old TitleBg/TitleBgActive color into a new one with the same visual output, given the OLD color and the OLD WindowBg color.\r\n                           ImVec4 ConvertTitleBgCol(const ImVec4& win_bg_col, const ImVec4& title_bg_col)\r\n                           {\r\n                               float new_a = 1.0f - ((1.0f - win_bg_col.w) * (1.0f - title_bg_col.w)), k = title_bg_col.w / new_a;\r\n                               return ImVec4((win_bg_col.x * win_bg_col.w + title_bg_col.x) * k, (win_bg_col.y * win_bg_col.w + title_bg_col.y) * k, (win_bg_col.z * win_bg_col.w + title_bg_col.z) * k, new_a);\r\n                           }\r\n                       If this is confusing, pick the RGB value from title bar from an old screenshot and apply this as TitleBg/TitleBgActive. Or you may just create TitleBgActive from a tweaked TitleBg color.\r\n - 2016/05/07 (1.49) - removed confusing set of GetInternalState(), GetInternalStateSize(), SetInternalState() functions. Now using CreateContext(), DestroyContext(), GetCurrentContext(), SetCurrentContext().\r\n - 2016/05/02 (1.49) - renamed SetNextTreeNodeOpened() to SetNextTreeNodeOpen(), no redirection.\r\n - 2016/05/01 (1.49) - obsoleted old signature of CollapsingHeader(const char* label, const char* str_id = NULL, bool display_frame = true, bool default_open = false) as extra parameters were badly designed and rarely used. You can replace the \"default_open = true\" flag in new API with CollapsingHeader(label, ImGuiTreeNodeFlags_DefaultOpen).\r\n - 2016/04/26 (1.49) - changed ImDrawList::PushClipRect(ImVec4 rect) to ImDraw::PushClipRect(Imvec2 min,ImVec2 max,bool intersect_with_current_clip_rect=false). Note that higher-level ImGui::PushClipRect() is preferable because it will clip at logic/widget level, whereas ImDrawList::PushClipRect() only affect your renderer.\r\n - 2016/04/03 (1.48) - removed style.WindowFillAlphaDefault setting which was redundant. Bake default BG alpha inside style.Colors[ImGuiCol_WindowBg] and all other Bg color values. (ref github issue #337).\r\n - 2016/04/03 (1.48) - renamed ImGuiCol_TooltipBg to ImGuiCol_PopupBg, used by popups/menus and tooltips. popups/menus were previously using ImGuiCol_WindowBg. (ref github issue #337)\r\n - 2016/03/21 (1.48) - renamed GetWindowFont() to GetFont(), GetWindowFontSize() to GetFontSize(). Kept inline redirection function (will obsolete).\r\n - 2016/03/02 (1.48) - InputText() completion/history/always callbacks: if you modify the text buffer manually (without using DeleteChars()/InsertChars() helper) you need to maintain the BufTextLen field. added an assert.\r\n - 2016/01/23 (1.48) - fixed not honoring exact width passed to PushItemWidth(), previously it would add extra FramePadding.x*2 over that width. if you had manual pixel-perfect alignment in place it might affect you.\r\n - 2015/12/27 (1.48) - fixed ImDrawList::AddRect() which used to render a rectangle 1 px too large on each axis.\r\n - 2015/12/04 (1.47) - renamed Color() helpers to ValueColor() - dangerously named, rarely used and probably to be made obsolete.\r\n - 2015/08/29 (1.45) - with the addition of horizontal scrollbar we made various fixes to inconsistencies with dealing with cursor position.\r\n                       GetCursorPos()/SetCursorPos() functions now include the scrolled amount. It shouldn't affect the majority of users, but take note that SetCursorPosX(100.0f) puts you at +100 from the starting x position which may include scrolling, not at +100 from the window left side.\r\n                       GetContentRegionMax()/GetWindowContentRegionMin()/GetWindowContentRegionMax() functions allow include the scrolled amount. Typically those were used in cases where no scrolling would happen so it may not be a problem, but watch out!\r\n - 2015/08/29 (1.45) - renamed style.ScrollbarWidth to style.ScrollbarSize\r\n - 2015/08/05 (1.44) - split imgui.cpp into extra files: imgui_demo.cpp imgui_draw.cpp imgui_internal.h that you need to add to your project.\r\n - 2015/07/18 (1.44) - fixed angles in ImDrawList::PathArcTo(), PathArcToFast() (introduced in 1.43) being off by an extra PI for no justifiable reason\r\n - 2015/07/14 (1.43) - add new ImFontAtlas::AddFont() API. For the old AddFont***, moved the 'font_no' parameter of ImFontAtlas::AddFont** functions to the ImFontConfig structure.\r\n                       you need to render your textured triangles with bilinear filtering to benefit from sub-pixel positioning of text.\r\n - 2015/07/08 (1.43) - switched rendering data to use indexed rendering. this is saving a fair amount of CPU/GPU and enables us to get anti-aliasing for a marginal cost.\r\n                       this necessary change will break your rendering function! the fix should be very easy. sorry for that :(\r\n                     - if you are using a vanilla copy of one of the imgui_impl_XXXX.cpp provided in the example, you just need to update your copy and you can ignore the rest.\r\n                     - the signature of the io.RenderDrawListsFn handler has changed!\r\n                            ImGui_XXXX_RenderDrawLists(ImDrawList** const cmd_lists, int cmd_lists_count)\r\n                       became:\r\n                            ImGui_XXXX_RenderDrawLists(ImDrawData* draw_data).\r\n                              argument   'cmd_lists'        -> 'draw_data->CmdLists'\r\n                              argument   'cmd_lists_count'  -> 'draw_data->CmdListsCount'\r\n                              ImDrawList 'commands'         -> 'CmdBuffer'\r\n                              ImDrawList 'vtx_buffer'       -> 'VtxBuffer'\r\n                              ImDrawList  n/a               -> 'IdxBuffer' (new)\r\n                              ImDrawCmd  'vtx_count'        -> 'ElemCount'\r\n                              ImDrawCmd  'clip_rect'        -> 'ClipRect'\r\n                              ImDrawCmd  'user_callback'    -> 'UserCallback'\r\n                              ImDrawCmd  'texture_id'       -> 'TextureId'\r\n                     - each ImDrawList now contains both a vertex buffer and an index buffer. For each command, render ElemCount/3 triangles using indices from the index buffer.\r\n                     - if you REALLY cannot render indexed primitives, you can call the draw_data->DeIndexAllBuffers() method to de-index the buffers. This is slow and a waste of CPU/GPU. Prefer using indexed rendering!\r\n                     - refer to code in the examples/ folder or ask on the GitHub if you are unsure of how to upgrade. please upgrade!\r\n - 2015/07/10 (1.43) - changed SameLine() parameters from int to float.\r\n - 2015/07/02 (1.42) - renamed SetScrollPosHere() to SetScrollFromCursorPos(). Kept inline redirection function (will obsolete).\r\n - 2015/07/02 (1.42) - renamed GetScrollPosY() to GetScrollY(). Necessary to reduce confusion along with other scrolling functions, because positions (e.g. cursor position) are not equivalent to scrolling amount.\r\n - 2015/06/14 (1.41) - changed ImageButton() default bg_col parameter from (0,0,0,1) (black) to (0,0,0,0) (transparent) - makes a difference when texture have transparence\r\n - 2015/06/14 (1.41) - changed Selectable() API from (label, selected, size) to (label, selected, flags, size). Size override should have been rarely be used. Sorry!\r\n - 2015/05/31 (1.40) - renamed GetWindowCollapsed() to IsWindowCollapsed() for consistency. Kept inline redirection function (will obsolete).\r\n - 2015/05/31 (1.40) - renamed IsRectClipped() to IsRectVisible() for consistency. Note that return value is opposite! Kept inline redirection function (will obsolete).\r\n - 2015/05/27 (1.40) - removed the third 'repeat_if_held' parameter from Button() - sorry! it was rarely used and inconsistent. Use PushButtonRepeat(true) / PopButtonRepeat() to enable repeat on desired buttons.\r\n - 2015/05/11 (1.40) - changed BeginPopup() API, takes a string identifier instead of a bool. ImGui needs to manage the open/closed state of popups. Call OpenPopup() to actually set the \"open\" state of a popup. BeginPopup() returns true if the popup is opened.\r\n - 2015/05/03 (1.40) - removed style.AutoFitPadding, using style.WindowPadding makes more sense (the default values were already the same).\r\n - 2015/04/13 (1.38) - renamed IsClipped() to IsRectClipped(). Kept inline redirection function until 1.50.\r\n - 2015/04/09 (1.38) - renamed ImDrawList::AddArc() to ImDrawList::AddArcFast() for compatibility with future API\r\n - 2015/04/03 (1.38) - removed ImGuiCol_CheckHovered, ImGuiCol_CheckActive, replaced with the more general ImGuiCol_FrameBgHovered, ImGuiCol_FrameBgActive.\r\n - 2014/04/03 (1.38) - removed support for passing -FLT_MAX..+FLT_MAX as the range for a SliderFloat(). Use DragFloat() or Inputfloat() instead.\r\n - 2015/03/17 (1.36) - renamed GetItemBoxMin()/GetItemBoxMax()/IsMouseHoveringBox() to GetItemRectMin()/GetItemRectMax()/IsMouseHoveringRect(). Kept inline redirection function until 1.50.\r\n - 2015/03/15 (1.36) - renamed style.TreeNodeSpacing to style.IndentSpacing, ImGuiStyleVar_TreeNodeSpacing to ImGuiStyleVar_IndentSpacing\r\n - 2015/03/13 (1.36) - renamed GetWindowIsFocused() to IsWindowFocused(). Kept inline redirection function until 1.50.\r\n - 2015/03/08 (1.35) - renamed style.ScrollBarWidth to style.ScrollbarWidth (casing)\r\n - 2015/02/27 (1.34) - renamed OpenNextNode(bool) to SetNextTreeNodeOpened(bool, ImGuiSetCond). Kept inline redirection function until 1.50.\r\n - 2015/02/27 (1.34) - renamed ImGuiSetCondition_*** to ImGuiSetCond_***, and _FirstUseThisSession becomes _Once.\r\n - 2015/02/11 (1.32) - changed text input callback ImGuiTextEditCallback return type from void-->int. reserved for future use, return 0 for now.\r\n - 2015/02/10 (1.32) - renamed GetItemWidth() to CalcItemWidth() to clarify its evolving behavior\r\n - 2015/02/08 (1.31) - renamed GetTextLineSpacing() to GetTextLineHeightWithSpacing()\r\n - 2015/02/01 (1.31) - removed IO.MemReallocFn (unused)\r\n - 2015/01/19 (1.30) - renamed ImGuiStorage::GetIntPtr()/GetFloatPtr() to GetIntRef()/GetIntRef() because Ptr was conflicting with actual pointer storage functions.\r\n - 2015/01/11 (1.30) - big font/image API change! now loads TTF file. allow for multiple fonts. no need for a PNG loader.\r\n              (1.30) - removed GetDefaultFontData(). uses io.Fonts->GetTextureData*() API to retrieve uncompressed pixels.\r\n                       this sequence:\r\n                           const void* png_data;\r\n                           unsigned int png_size;\r\n                           ImGui::GetDefaultFontData(NULL, NULL, &png_data, &png_size);\r\n                           // <Copy to GPU>\r\n                       became:\r\n                           unsigned char* pixels;\r\n                           int width, height;\r\n                           io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);\r\n                           // <Copy to GPU>\r\n                           io.Fonts->TexID = (your_texture_identifier);\r\n                       you now have much more flexibility to load multiple TTF fonts and manage the texture buffer for internal needs.\r\n                       it is now recommended that you sample the font texture with bilinear interpolation.\r\n              (1.30) - added texture identifier in ImDrawCmd passed to your render function (we can now render images). make sure to set io.Fonts->TexID.\r\n              (1.30) - removed IO.PixelCenterOffset (unnecessary, can be handled in user projection matrix)\r\n              (1.30) - removed ImGui::IsItemFocused() in favor of ImGui::IsItemActive() which handles all widgets\r\n - 2014/12/10 (1.18) - removed SetNewWindowDefaultPos() in favor of new generic API SetNextWindowPos(pos, ImGuiSetCondition_FirstUseEver)\r\n - 2014/11/28 (1.17) - moved IO.Font*** options to inside the IO.Font-> structure (FontYOffset, FontTexUvForWhite, FontBaseScale, FontFallbackGlyph)\r\n - 2014/11/26 (1.17) - reworked syntax of IMGUI_ONCE_UPON_A_FRAME helper macro to increase compiler compatibility\r\n - 2014/11/07 (1.15) - renamed IsHovered() to IsItemHovered()\r\n - 2014/10/02 (1.14) - renamed IMGUI_INCLUDE_IMGUI_USER_CPP to IMGUI_INCLUDE_IMGUI_USER_INL and imgui_user.cpp to imgui_user.inl (more IDE friendly)\r\n - 2014/09/25 (1.13) - removed 'text_end' parameter from IO.SetClipboardTextFn (the string is now always zero-terminated for simplicity)\r\n - 2014/09/24 (1.12) - renamed SetFontScale() to SetWindowFontScale()\r\n - 2014/09/24 (1.12) - moved IM_MALLOC/IM_REALLOC/IM_FREE preprocessor defines to IO.MemAllocFn/IO.MemReallocFn/IO.MemFreeFn\r\n - 2014/08/30 (1.09) - removed IO.FontHeight (now computed automatically)\r\n - 2014/08/30 (1.09) - moved IMGUI_FONT_TEX_UV_FOR_WHITE preprocessor define to IO.FontTexUvForWhite\r\n - 2014/08/28 (1.09) - changed the behavior of IO.PixelCenterOffset following various rendering fixes\r\n\r\n\r\n ISSUES & TODO-LIST\r\n ==================\r\n See TODO.txt\r\n\r\n\r\n FREQUENTLY ASKED QUESTIONS (FAQ), TIPS\r\n ======================================\r\n\r\n Q: How can I help?\r\n A: - If you are experienced enough with Dear ImGui and with C/C++, look at the todo list and see how you want/can help!\r\n    - Become a Patron/donate! Convince your company to become a Patron or provide serious funding for development time! See http://www.patreon.com/imgui\r\n\r\n Q: What is ImTextureID and how do I display an image?\r\n A: ImTextureID is a void* used to pass renderer-agnostic texture references around until it hits your render function.\r\n    Dear ImGui knows nothing about what those bits represent, it just passes them around. It is up to you to decide what you want the void* to carry!\r\n    It could be an identifier to your OpenGL texture (cast GLuint to void*), a pointer to your custom engine material (cast MyMaterial* to void*), etc.\r\n    At the end of the chain, your renderer takes this void* to cast it back into whatever it needs to select a current texture to render.\r\n    Refer to examples applications, where each renderer (in a imgui_impl_xxxx.cpp file) is treating ImTextureID as a different thing.\r\n    (c++ tip: OpenGL uses integers to identify textures. You can safely store an integer into a void*, just cast it to void*, don't take it's address!)\r\n    To display a custom image/texture within an ImGui window, you may use ImGui::Image(), ImGui::ImageButton(), ImDrawList::AddImage() functions.\r\n    Dear ImGui will generate the geometry and draw calls using the ImTextureID that you passed and which your renderer can use.\r\n    It is your responsibility to get textures uploaded to your GPU.\r\n\r\n Q: I integrated Dear ImGui in my engine and the text or lines are blurry..\r\n A: In your Render function, try translating your projection matrix by (0.5f,0.5f) or (0.375f,0.375f).\r\n    Also make sure your orthographic projection matrix and io.DisplaySize matches your actual framebuffer dimension.\r\n\r\n Q: I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around..\r\n A: You are probably mishandling the clipping rectangles in your render function. \r\n    Rectangles provided by ImGui are defined as (x1=left,y1=top,x2=right,y2=bottom) and NOT as (x1,y1,width,height).\r\n\r\n Q: Can I have multiple widgets with the same label? Can I have widget without a label?\r\n A: Yes. A primer on the use of labels/IDs in Dear ImGui..\r\n\r\n   - Elements that are not clickable, such as Text() items don't need an ID.\r\n\r\n   - Interactive widgets require state to be carried over multiple frames (most typically Dear ImGui often needs to remember what is \r\n     the \"active\" widget). to do so they need a unique ID. unique ID are typically derived from a string label, an integer index or a pointer.\r\n\r\n       Button(\"OK\");        // Label = \"OK\",     ID = hash of \"OK\"\r\n       Button(\"Cancel\");    // Label = \"Cancel\", ID = hash of \"Cancel\"\r\n\r\n   - ID are uniquely scoped within windows, tree nodes, etc. so no conflict can happen if you have two buttons called \"OK\"\r\n     in two different windows or in two different locations of a tree.\r\n\r\n   - If you have a same ID twice in the same location, you'll have a conflict:\r\n\r\n       Button(\"OK\");\r\n       Button(\"OK\");           // ID collision! Both buttons will be treated as the same.\r\n\r\n     Fear not! this is easy to solve and there are many ways to solve it!\r\n\r\n   - When passing a label you can optionally specify extra unique ID information within string itself. \r\n     This helps solving the simpler collision cases. Use \"##\" to pass a complement to the ID that won't be visible to the end-user:\r\n\r\n       Button(\"Play\");         // Label = \"Play\",   ID = hash of \"Play\"\r\n       Button(\"Play##foo1\");   // Label = \"Play\",   ID = hash of \"Play##foo1\" (different from above)\r\n       Button(\"Play##foo2\");   // Label = \"Play\",   ID = hash of \"Play##foo2\" (different from above)\r\n\r\n   - If you want to completely hide the label, but still need an ID:\r\n\r\n       Checkbox(\"##On\", &b);   // Label = \"\",       ID = hash of \"##On\" (no label!)\r\n\r\n   - Occasionally/rarely you might want change a label while preserving a constant ID. This allows you to animate labels.\r\n     For example you may want to include varying information in a window title bar (and windows are uniquely identified by their ID.. obviously)\r\n     Use \"###\" to pass a label that isn't part of ID:\r\n\r\n       Button(\"Hello###ID\";   // Label = \"Hello\",  ID = hash of \"ID\"\r\n       Button(\"World###ID\";   // Label = \"World\",  ID = hash of \"ID\" (same as above)\r\n\r\n       sprintf(buf, \"My game (%f FPS)###MyGame\");\r\n       Begin(buf);            // Variable label,   ID = hash of \"MyGame\"\r\n\r\n   - Use PushID() / PopID() to create scopes and avoid ID conflicts within the same Window.\r\n     This is the most convenient way of distinguishing ID if you are iterating and creating many UI elements.\r\n     You can push a pointer, a string or an integer value. Remember that ID are formed from the concatenation of everything in the ID stack!\r\n\r\n       for (int i = 0; i < 100; i++)\r\n       {\r\n         PushID(i);\r\n         Button(\"Click\");   // Label = \"Click\",  ID = hash of integer + \"label\" (unique)\r\n         PopID();\r\n       }\r\n\r\n       for (int i = 0; i < 100; i++)\r\n       {\r\n         MyObject* obj = Objects[i];\r\n         PushID(obj);\r\n         Button(\"Click\");   // Label = \"Click\",  ID = hash of pointer + \"label\" (unique)\r\n         PopID();\r\n       }\r\n\r\n       for (int i = 0; i < 100; i++)\r\n       {\r\n         MyObject* obj = Objects[i];\r\n         PushID(obj->Name);\r\n         Button(\"Click\");   // Label = \"Click\",  ID = hash of string + \"label\" (unique)\r\n         PopID();\r\n       }\r\n\r\n   - More example showing that you can stack multiple prefixes into the ID stack:\r\n\r\n       Button(\"Click\");     // Label = \"Click\",  ID = hash of \"Click\"\r\n       PushID(\"node\");\r\n       Button(\"Click\");     // Label = \"Click\",  ID = hash of \"node\" + \"Click\"\r\n         PushID(my_ptr);\r\n           Button(\"Click\"); // Label = \"Click\",  ID = hash of \"node\" + ptr + \"Click\"\r\n         PopID();\r\n       PopID();\r\n\r\n   - Tree nodes implicitly creates a scope for you by calling PushID().\r\n\r\n       Button(\"Click\");     // Label = \"Click\",  ID = hash of \"Click\"\r\n       if (TreeNode(\"node\"))\r\n       {\r\n         Button(\"Click\");   // Label = \"Click\",  ID = hash of \"node\" + \"Click\"\r\n         TreePop();\r\n       }\r\n\r\n   - When working with trees, ID are used to preserve the open/close state of each tree node.\r\n     Depending on your use cases you may want to use strings, indices or pointers as ID.\r\n      e.g. when displaying a single object that may change over time (dynamic 1-1 relationship), using a static string as ID will preserve your\r\n       node open/closed state when the targeted object change.\r\n      e.g. when displaying a list of objects, using indices or pointers as ID will preserve the node open/closed state differently. \r\n       experiment and see what makes more sense!\r\n\r\n Q: How can I tell when Dear ImGui wants my mouse/keyboard inputs VS when I can pass them to my application?\r\n A: You can read the 'io.WantCaptureMouse'/'io.WantCaptureKeyboard'/'ioWantTextInput' flags from the ImGuiIO structure. \r\n    - When 'io.WantCaptureMouse' or 'io.WantCaptureKeyboard' flags are set you may want to discard/hide the inputs from the rest of your application.\r\n    - When 'io.WantTextInput' is set to may want to notify your OS to popup an on-screen keyboard, if available (e.g. on a mobile phone, or console OS).\r\n    Preferably read the flags after calling ImGui::NewFrame() to avoid them lagging by one frame. But reading those flags before calling NewFrame() is\r\n    also generally ok, as the bool toggles fairly rarely and you don't generally expect to interact with either Dear ImGui or your application during\r\n    the same frame when that transition occurs. Dear ImGui is tracking dragging and widget activity that may occur outside the boundary of a window, \r\n    so 'io.WantCaptureMouse' is more accurate and correct than checking if a window is hovered. \r\n    (Advanced note: text input releases focus on Return 'KeyDown', so the following Return 'KeyUp' event that your application receive will typically \r\n     have 'io.WantCaptureKeyboard=false'. Depending on your application logic it may or not be inconvenient. You might want to track which key-downs\r\n     were for Dear ImGui, e.g. with an array of bool, and filter out the corresponding key-ups.)\r\n\r\n Q: How can I load a different font than the default? (default is an embedded version of ProggyClean.ttf, rendered at size 13)\r\n A: Use the font atlas to load the TTF/OTF file you want:\r\n\r\n      ImGuiIO& io = ImGui::GetIO();\r\n      io.Fonts->AddFontFromFileTTF(\"myfontfile.ttf\", size_in_pixels);\r\n      io.Fonts->GetTexDataAsRGBA32() or GetTexDataAsAlpha8()\r\n\r\n Q: How can I easily use icons in my application?\r\n A: The most convenient and practical way is to merge an icon font such as FontAwesome inside you main font. Then you can refer to icons within your \r\n    strings. Read 'How can I load multiple fonts?' and the file 'extra_fonts/README.txt' for instructions and useful header files.\r\n\r\n Q: How can I load multiple fonts?\r\n A: Use the font atlas to pack them into a single texture:\r\n    (Read extra_fonts/README.txt and the code in ImFontAtlas for more details.)\r\n\r\n      ImGuiIO& io = ImGui::GetIO();\r\n      ImFont* font0 = io.Fonts->AddFontDefault();\r\n      ImFont* font1 = io.Fonts->AddFontFromFileTTF(\"myfontfile.ttf\", size_in_pixels);\r\n      ImFont* font2 = io.Fonts->AddFontFromFileTTF(\"myfontfile2.ttf\", size_in_pixels);\r\n      io.Fonts->GetTexDataAsRGBA32() or GetTexDataAsAlpha8()\r\n      // the first loaded font gets used by default\r\n      // use ImGui::PushFont()/ImGui::PopFont() to change the font at runtime\r\n\r\n      // Options\r\n      ImFontConfig config;\r\n      config.OversampleH = 3;\r\n      config.OversampleV = 1;\r\n      config.GlyphOffset.y -= 2.0f;      // Move everything by 2 pixels up\r\n      config.GlyphExtraSpacing.x = 1.0f; // Increase spacing between characters\r\n      io.Fonts->LoadFromFileTTF(\"myfontfile.ttf\", size_pixels, &config);\r\n\r\n      // Combine multiple fonts into one (e.g. for icon fonts)\r\n      ImWchar ranges[] = { 0xf000, 0xf3ff, 0 };\r\n      ImFontConfig config;\r\n      config.MergeMode = true;\r\n      io.Fonts->AddFontDefault();\r\n      io.Fonts->LoadFromFileTTF(\"fontawesome-webfont.ttf\", 16.0f, &config, ranges); // Merge icon font\r\n      io.Fonts->LoadFromFileTTF(\"myfontfile.ttf\", size_pixels, NULL, &config, io.Fonts->GetGlyphRangesJapanese()); // Merge japanese glyphs\r\n\r\n Q: How can I display and input non-Latin characters such as Chinese, Japanese, Korean, Cyrillic?\r\n A: When loading a font, pass custom Unicode ranges to specify the glyphs to load. \r\n\r\n      // Add default Japanese ranges\r\n      io.Fonts->AddFontFromFileTTF(\"myfontfile.ttf\", size_in_pixels, NULL, io.Fonts->GetGlyphRangesJapanese());\r\n   \r\n      // Or create your own custom ranges (e.g. for a game you can feed your entire game script and only build the characters the game need)\r\n      ImVector<ImWchar> ranges;\r\n      ImFontAtlas::GlyphRangesBuilder builder;\r\n      builder.AddText(\"Hello world\");                        // Add a string (here \"Hello world\" contains 7 unique characters)\r\n      builder.AddChar(0x7262);                               // Add a specific character\r\n      builder.AddRanges(io.Fonts->GetGlyphRangesJapanese()); // Add one of the default ranges\r\n      builder.BuildRanges(&ranges);                          // Build the final result (ordered ranges with all the unique characters submitted)\r\n      io.Fonts->AddFontFromFileTTF(\"myfontfile.ttf\", size_in_pixels, NULL, ranges.Data);\r\n\r\n    All your strings needs to use UTF-8 encoding. In C++11 you can encode a string literal in UTF-8 by using the u8\"hello\" syntax. \r\n    Specifying literal in your source code using a local code page (such as CP-923 for Japanese or CP-1251 for Cyrillic) will NOT work!\r\n    Otherwise you can convert yourself to UTF-8 or load text data from file already saved as UTF-8.\r\n\r\n    Text input: it is up to your application to pass the right character code to io.AddInputCharacter(). The applications in examples/ are doing that.\r\n    For languages using IME, on Windows you can copy the Hwnd of your application to io.ImeWindowHandle.\r\n    The default implementation of io.ImeSetInputScreenPosFn() on Windows will set your IME position correctly.\r\n\r\n Q: How can I preserve my Dear ImGui context across reloading a DLL? (loss of the global/static variables)\r\n A: Create your own context 'ctx = CreateContext()' + 'SetCurrentContext(ctx)' and your own font atlas 'ctx->GetIO().Fonts = new ImFontAtlas()' \r\n    so you don't rely on the default globals.\r\n\r\n Q: How can I use the drawing facilities without an ImGui window? (using ImDrawList API)\r\n A: The easiest way is to create a dummy window. Call Begin() with NoTitleBar|NoResize|NoMove|NoScrollbar|NoSavedSettings|NoInputs flag, \r\n    zero background alpha, then retrieve the ImDrawList* via GetWindowDrawList() and draw to it in any way you like.\r\n    You can also perfectly create a standalone ImDrawList instance _but_ you need ImGui to be initialized because ImDrawList pulls from ImGui \r\n    data to retrieve the coordinates of the white pixel.\r\n\r\n - tip: you can call Begin() multiple times with the same name during the same frame, it will keep appending to the same window. \r\n   this is also useful to set yourself in the context of another window (to get/set other settings)\r\n - tip: you can create widgets without a Begin()/End() block, they will go in an implicit window called \"Debug\".\r\n - tip: the ImGuiOnceUponAFrame helper will allow run the block of code only once a frame. You can use it to quickly add custom UI in the middle\r\n   of a deep nested inner loop in your code.\r\n - tip: you can call Render() multiple times (e.g for VR renders).\r\n - tip: call and read the ShowDemoWindow() code in imgui_demo.cpp for more example of how to use ImGui!\r\n\r\n*/\r\n\r\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\r\n#define _CRT_SECURE_NO_WARNINGS\r\n#endif\r\n\r\n#include \"imgui.h\"\r\n#define IMGUI_DEFINE_MATH_OPERATORS\r\n#include \"imgui_internal.h\"\r\n\r\n#include <ctype.h>      // toupper, isprint\r\n#include <stdlib.h>     // NULL, malloc, free, qsort, atoi\r\n#include <stdio.h>      // vsnprintf, sscanf, printf\r\n#include <limits.h>     // INT_MIN, INT_MAX\r\n#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier\r\n#include <stddef.h>     // intptr_t\r\n#else\r\n#include <stdint.h>     // intptr_t\r\n#endif\r\n\r\n#ifdef _MSC_VER\r\n#pragma warning (disable: 4127) // condition expression is constant\r\n#pragma warning (disable: 4505) // unreferenced local function has been removed (stb stuff)\r\n#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\r\n#endif\r\n\r\n// Clang warnings with -Weverything\r\n#ifdef __clang__\r\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"        // warning : unknown warning group '-Wformat-pedantic *'        // not all warnings are known by all clang versions.. so ignoring warnings triggers new warnings on some configuration. great!\r\n#pragma clang diagnostic ignored \"-Wold-style-cast\"         // warning : use of old-style cast                              // yes, they are more terse.\r\n#pragma clang diagnostic ignored \"-Wfloat-equal\"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants (typically 0.0f) is ok.\r\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"      // warning : format string is not a string literal              // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.\r\n#pragma clang diagnostic ignored \"-Wexit-time-destructors\"  // warning : declaration requires an exit-time destructor       // exit-time destruction order is undefined. if MemFree() leads to users code that has been disabled before exit it might cause problems. ImGui coding style welcomes static/globals.\r\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"    // warning : declaration requires a global destructor           // similar to above, not sure what the exact difference it.\r\n#pragma clang diagnostic ignored \"-Wsign-conversion\"        // warning : implicit conversion changes signedness             //\r\n#pragma clang diagnostic ignored \"-Wformat-pedantic\"        // warning : format specifies type 'void *' but the argument has type 'xxxx *' // unreasonable, would lead to casting every %p arg to void*. probably enabled by -pedantic. \r\n#pragma clang diagnostic ignored \"-Wint-to-void-pointer-cast\" // warning : cast to 'void *' from smaller integer type 'int' //\r\n#elif defined(__GNUC__)\r\n#pragma GCC diagnostic ignored \"-Wunused-function\"          // warning: 'xxxx' defined but not used\r\n#pragma GCC diagnostic ignored \"-Wint-to-pointer-cast\"      // warning: cast to pointer from integer of different size\r\n#pragma GCC diagnostic ignored \"-Wformat\"                   // warning: format '%p' expects argument of type 'void*', but argument 6 has type 'ImGuiWindow*'\r\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"         // warning: implicit conversion from 'float' to 'double' when passing argument to function\r\n#pragma GCC diagnostic ignored \"-Wconversion\"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value\r\n#pragma GCC diagnostic ignored \"-Wcast-qual\"                // warning: cast from type 'xxxx' to type 'xxxx' casts away qualifiers\r\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"        // warning: format not a string literal, format string not checked\r\n#endif\r\n\r\n//-------------------------------------------------------------------------\r\n// Forward Declarations\r\n//-------------------------------------------------------------------------\r\n\r\nstatic bool             IsKeyPressedMap(ImGuiKey key, bool repeat = true);\r\n\r\nstatic ImFont*          GetDefaultFont();\r\nstatic void             SetCurrentFont(ImFont* font);\r\nstatic void             SetCurrentWindow(ImGuiWindow* window);\r\nstatic void             SetWindowScrollY(ImGuiWindow* window, float new_scroll_y);\r\nstatic void             SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond);\r\nstatic void             SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond);\r\nstatic void             SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond);\r\nstatic ImGuiWindow*     FindHoveredWindow(ImVec2 pos);\r\nstatic ImGuiWindow*     CreateNewWindow(const char* name, ImVec2 size, ImGuiWindowFlags flags);\r\nstatic void             ClearSetNextWindowData();\r\nstatic void             CheckStacksSize(ImGuiWindow* window, bool write);\r\nstatic ImVec2           CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window);\r\n\r\nstatic void             AddDrawListToRenderList(ImVector<ImDrawList*>& out_render_list, ImDrawList* draw_list);\r\nstatic void             AddWindowToRenderList(ImVector<ImDrawList*>& out_render_list, ImGuiWindow* window);\r\nstatic void             AddWindowToSortedBuffer(ImVector<ImGuiWindow*>& out_sorted_windows, ImGuiWindow* window);\r\n\r\nstatic ImGuiWindowSettings* AddWindowSettings(const char* name);\r\n\r\nstatic void             LoadIniSettingsFromDisk(const char* ini_filename);\r\nstatic void             LoadIniSettingsFromMemory(const char* buf);\r\nstatic void             SaveIniSettingsToDisk(const char* ini_filename);\r\nstatic void             SaveIniSettingsToMemory(ImVector<char>& out_buf);\r\nstatic void             MarkIniSettingsDirty(ImGuiWindow* window);\r\n\r\nstatic ImRect           GetVisibleRect();\r\n\r\nstatic void             CloseInactivePopups(ImGuiWindow* ref_window);\r\nstatic void             ClosePopupToLevel(int remaining);\r\nstatic ImGuiWindow*     GetFrontMostModalRootWindow();\r\n\r\nstatic bool             InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data);\r\nstatic int              InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end);\r\nstatic ImVec2           InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining = NULL, ImVec2* out_offset = NULL, bool stop_on_new_line = false);\r\n\r\nstatic inline void      DataTypeFormatString(ImGuiDataType data_type, void* data_ptr, const char* display_format, char* buf, int buf_size);\r\nstatic inline void      DataTypeFormatString(ImGuiDataType data_type, void* data_ptr, int decimal_precision, char* buf, int buf_size);\r\nstatic void             DataTypeApplyOp(ImGuiDataType data_type, int op, void* value1, const void* value2);\r\nstatic bool             DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* data_ptr, const char* scalar_format);\r\n\r\nnamespace ImGui\r\n{\r\nstatic void             FocusPreviousWindow();\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// Platform dependent default implementations\r\n//-----------------------------------------------------------------------------\r\n\r\nstatic const char*      GetClipboardTextFn_DefaultImpl(void* user_data);\r\nstatic void             SetClipboardTextFn_DefaultImpl(void* user_data, const char* text);\r\nstatic void             ImeSetInputScreenPosFn_DefaultImpl(int x, int y);\r\n\r\n//-----------------------------------------------------------------------------\r\n// Context\r\n//-----------------------------------------------------------------------------\r\n\r\n// Default font atlas storage.\r\n// New contexts always point by default to this font atlas. It can be changed by reassigning the GetIO().Fonts variable.\r\nstatic ImFontAtlas      GImDefaultFontAtlas;\r\n\r\n// Default context storage + current context pointer.\r\n// Implicitely used by all ImGui functions. Always assumed to be != NULL. Change to a different context by calling ImGui::SetCurrentContext()\r\n// If you are hot-reloading this code in a DLL you will lose the static/global variables. Create your own context+font atlas instead of relying on those default (see FAQ entry \"How can I preserve my ImGui context across reloading a DLL?\").\r\n// ImGui is currently not thread-safe because of this variable. If you want thread-safety to allow N threads to access N different contexts, you might work around it by:\r\n// - Having multiple instances of the ImGui code compiled inside different namespace (easiest/safest, if you have a finite number of contexts)\r\n// - or: Changing this variable to be TLS. You may #define GImGui in imconfig.h for further custom hackery. Future development aim to make this context pointer explicit to all calls. Also read https://github.com/ocornut/imgui/issues/586\r\n#ifndef GImGui\r\nstatic ImGuiContext     GImDefaultContext;\r\nImGuiContext*           GImGui = &GImDefaultContext;\r\n#endif\r\n\r\n//-----------------------------------------------------------------------------\r\n// User facing structures\r\n//-----------------------------------------------------------------------------\r\n\r\nImGuiStyle::ImGuiStyle()\r\n{\r\n    Alpha                   = 1.0f;             // Global alpha applies to everything in ImGui\r\n    WindowPadding           = ImVec2(8,8);      // Padding within a window\r\n    WindowRounding          = 7.0f;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows\r\n    WindowBorderSize        = 0.0f;             // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.\r\n    WindowMinSize           = ImVec2(32,32);    // Minimum window size\r\n    WindowTitleAlign        = ImVec2(0.0f,0.5f);// Alignment for title bar text\r\n    ChildRounding           = 0.0f;             // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows\r\n    ChildBorderSize         = 1.0f;             // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.\r\n    PopupRounding           = 0.0f;             // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows\r\n    PopupBorderSize         = 1.0f;             // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.\r\n    FramePadding            = ImVec2(4,3);      // Padding within a framed rectangle (used by most widgets)\r\n    FrameRounding           = 0.0f;             // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).\r\n    FrameBorderSize         = 0.0f;             // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.\r\n    ItemSpacing             = ImVec2(8,4);      // Horizontal and vertical spacing between widgets/lines\r\n    ItemInnerSpacing        = ImVec2(4,4);      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)\r\n    TouchExtraPadding       = ImVec2(0,0);      // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!\r\n    IndentSpacing           = 21.0f;            // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).\r\n    ColumnsMinSpacing       = 6.0f;             // Minimum horizontal spacing between two columns\r\n    ScrollbarSize           = 16.0f;            // Width of the vertical scrollbar, Height of the horizontal scrollbar\r\n    ScrollbarRounding       = 9.0f;             // Radius of grab corners rounding for scrollbar\r\n    GrabMinSize             = 10.0f;            // Minimum width/height of a grab box for slider/scrollbar\r\n    GrabRounding            = 0.0f;             // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.\r\n    ButtonTextAlign         = ImVec2(0.5f,0.5f);// Alignment of button text when button is larger than text.\r\n    DisplayWindowPadding    = ImVec2(22,22);    // Window positions are clamped to be visible within the display area by at least this amount. Only covers regular windows.\r\n    DisplaySafeAreaPadding  = ImVec2(4,4);      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.\r\n    AntiAliasedLines        = true;             // Enable anti-aliasing on lines/borders. Disable if you are really short on CPU/GPU.\r\n    AntiAliasedFill         = true;             // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)\r\n    CurveTessellationTol    = 1.25f;            // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.\r\n\r\n    ImGui::StyleColorsClassic(this);\r\n}\r\n\r\n// To scale your entire UI (e.g. if you want your app to use High DPI or generally be DPI aware) you may use this helper function. Scaling the fonts is done separately and is up to you.\r\n// Important: This operation is lossy because we round all sizes to integer. If you need to change your scale multiples, call this over a freshly initialized ImGuiStyle structure rather than scaling multiple times.\r\nvoid ImGuiStyle::ScaleAllSizes(float scale_factor)\r\n{\r\n    WindowPadding = ImFloor(WindowPadding * scale_factor);\r\n    WindowRounding = ImFloor(WindowRounding * scale_factor);\r\n    WindowMinSize = ImFloor(WindowMinSize * scale_factor);\r\n    ChildRounding = ImFloor(ChildRounding * scale_factor);\r\n    PopupRounding = ImFloor(PopupRounding * scale_factor);\r\n    FramePadding = ImFloor(FramePadding * scale_factor);\r\n    FrameRounding = ImFloor(FrameRounding * scale_factor);\r\n    ItemSpacing = ImFloor(ItemSpacing * scale_factor);\r\n    ItemInnerSpacing = ImFloor(ItemInnerSpacing * scale_factor);\r\n    TouchExtraPadding = ImFloor(TouchExtraPadding * scale_factor);\r\n    IndentSpacing = ImFloor(IndentSpacing * scale_factor);\r\n    ColumnsMinSpacing = ImFloor(ColumnsMinSpacing * scale_factor);\r\n    ScrollbarSize = ImFloor(ScrollbarSize * scale_factor);\r\n    ScrollbarRounding = ImFloor(ScrollbarRounding * scale_factor);\r\n    GrabMinSize = ImFloor(GrabMinSize * scale_factor);\r\n    GrabRounding = ImFloor(GrabRounding * scale_factor);\r\n    DisplayWindowPadding = ImFloor(DisplayWindowPadding * scale_factor);\r\n    DisplaySafeAreaPadding = ImFloor(DisplaySafeAreaPadding * scale_factor);\r\n}\r\n\r\nImGuiIO::ImGuiIO()\r\n{\r\n    // Most fields are initialized with zero\r\n    memset(this, 0, sizeof(*this));\r\n\r\n    // Settings\r\n    DisplaySize = ImVec2(-1.0f, -1.0f);\r\n    DeltaTime = 1.0f/60.0f;\r\n    IniSavingRate = 5.0f;\r\n    IniFilename = \"imgui.ini\";\r\n    LogFilename = \"imgui_log.txt\";\r\n    MouseDoubleClickTime = 0.30f;\r\n    MouseDoubleClickMaxDist = 6.0f;\r\n    for (int i = 0; i < ImGuiKey_COUNT; i++)\r\n        KeyMap[i] = -1;\r\n    KeyRepeatDelay = 0.250f;\r\n    KeyRepeatRate = 0.050f;\r\n    UserData = NULL;\r\n\r\n    Fonts = &GImDefaultFontAtlas;\r\n    FontGlobalScale = 1.0f;\r\n    FontDefault = NULL;\r\n    FontAllowUserScaling = false;\r\n    DisplayFramebufferScale = ImVec2(1.0f, 1.0f);\r\n    DisplayVisibleMin = DisplayVisibleMax = ImVec2(0.0f, 0.0f);\r\n\r\n    // Advanced/subtle behaviors\r\n#ifdef __APPLE__\r\n    OptMacOSXBehaviors = true;  // Set Mac OS X style defaults based on __APPLE__ compile time flag\r\n#else\r\n    OptMacOSXBehaviors = false;\r\n#endif\r\n    OptCursorBlink = true;\r\n                                \r\n    // Settings (User Functions)\r\n    RenderDrawListsFn = NULL;\r\n    MemAllocFn = malloc;\r\n    MemFreeFn = free;\r\n    GetClipboardTextFn = GetClipboardTextFn_DefaultImpl;   // Platform dependent default implementations\r\n    SetClipboardTextFn = SetClipboardTextFn_DefaultImpl;\r\n    ClipboardUserData = NULL;\r\n    ImeSetInputScreenPosFn = ImeSetInputScreenPosFn_DefaultImpl;\r\n    ImeWindowHandle = NULL;\r\n\r\n    // Input (NB: we already have memset zero the entire structure)\r\n    MousePos = ImVec2(-FLT_MAX, -FLT_MAX);\r\n    MousePosPrev = ImVec2(-FLT_MAX, -FLT_MAX);\r\n    MouseDragThreshold = 6.0f;\r\n    for (int i = 0; i < IM_ARRAYSIZE(MouseDownDuration); i++) MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;\r\n    for (int i = 0; i < IM_ARRAYSIZE(KeysDownDuration); i++) KeysDownDuration[i] = KeysDownDurationPrev[i] = -1.0f;\r\n}\r\n\r\n// Pass in translated ASCII characters for text input.\r\n// - with glfw you can get those from the callback set in glfwSetCharCallback()\r\n// - on Windows you can get those using ToAscii+keyboard state, or via the WM_CHAR message\r\nvoid ImGuiIO::AddInputCharacter(ImWchar c)\r\n{\r\n    const int n = ImStrlenW(InputCharacters);\r\n    if (n + 1 < IM_ARRAYSIZE(InputCharacters))\r\n    {\r\n        InputCharacters[n] = c;\r\n        InputCharacters[n+1] = '\\0';\r\n    }\r\n}\r\n\r\nvoid ImGuiIO::AddInputCharactersUTF8(const char* utf8_chars)\r\n{\r\n    // We can't pass more wchars than ImGuiIO::InputCharacters[] can hold so don't convert more\r\n    const int wchars_buf_len = sizeof(ImGuiIO::InputCharacters) / sizeof(ImWchar);\r\n    ImWchar wchars[wchars_buf_len];\r\n    ImTextStrFromUtf8(wchars, wchars_buf_len, utf8_chars, NULL);\r\n    for (int i = 0; i < wchars_buf_len && wchars[i] != 0; i++)\r\n        AddInputCharacter(wchars[i]);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// HELPERS\r\n//-----------------------------------------------------------------------------\r\n\r\n#define IM_F32_TO_INT8_UNBOUND(_VAL)    ((int)((_VAL) * 255.0f + ((_VAL)>=0 ? 0.5f : -0.5f)))   // Unsaturated, for display purpose \r\n#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255\r\n\r\n// Play it nice with Windows users. Notepad in 2015 still doesn't display text data with Unix-style \\n.\r\n#ifdef _WIN32\r\n#define IM_NEWLINE \"\\r\\n\"\r\n#else\r\n#define IM_NEWLINE \"\\n\"\r\n#endif\r\n\r\nImVec2 ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p)\r\n{\r\n    ImVec2 ap = p - a;\r\n    ImVec2 ab_dir = b - a;\r\n    float ab_len = sqrtf(ab_dir.x * ab_dir.x + ab_dir.y * ab_dir.y);\r\n    ab_dir *= 1.0f / ab_len;\r\n    float dot = ap.x * ab_dir.x + ap.y * ab_dir.y;\r\n    if (dot < 0.0f)\r\n        return a;\r\n    if (dot > ab_len)\r\n        return b;\r\n    return a + ab_dir * dot;\r\n}\r\n\r\nbool ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)\r\n{\r\n    bool b1 = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0f;\r\n    bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;\r\n    bool b3 = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0f;\r\n    return ((b1 == b2) && (b2 == b3));\r\n}\r\n\r\nvoid ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w)\r\n{\r\n    ImVec2 v0 = b - a;\r\n    ImVec2 v1 = c - a;\r\n    ImVec2 v2 = p - a;\r\n    const float denom = v0.x * v1.y - v1.x * v0.y;\r\n    out_v = (v2.x * v1.y - v1.x * v2.y) / denom;\r\n    out_w = (v0.x * v2.y - v2.x * v0.y) / denom;\r\n    out_u = 1.0f - out_v - out_w;\r\n}\r\n\r\nImVec2 ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)\r\n{\r\n    ImVec2 proj_ab = ImLineClosestPoint(a, b, p);\r\n    ImVec2 proj_bc = ImLineClosestPoint(b, c, p);\r\n    ImVec2 proj_ca = ImLineClosestPoint(c, a, p);\r\n    float dist2_ab = ImLengthSqr(p - proj_ab);\r\n    float dist2_bc = ImLengthSqr(p - proj_bc);\r\n    float dist2_ca = ImLengthSqr(p - proj_ca);\r\n    float m = ImMin(dist2_ab, ImMin(dist2_bc, dist2_ca));\r\n    if (m == dist2_ab)\r\n        return proj_ab;\r\n    if (m == dist2_bc)\r\n        return proj_bc;\r\n    return proj_ca;\r\n}\r\n\r\nint ImStricmp(const char* str1, const char* str2)\r\n{\r\n    int d;\r\n    while ((d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; }\r\n    return d;\r\n}\r\n\r\nint ImStrnicmp(const char* str1, const char* str2, size_t count)\r\n{\r\n    int d = 0;\r\n    while (count > 0 && (d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; count--; }\r\n    return d;\r\n}\r\n\r\nvoid ImStrncpy(char* dst, const char* src, size_t count)\r\n{\r\n    if (count < 1) return;\r\n    strncpy(dst, src, count);\r\n    dst[count-1] = 0;\r\n}\r\n\r\nchar* ImStrdup(const char *str)\r\n{\r\n    size_t len = strlen(str) + 1;\r\n    void* buf = ImGui::MemAlloc(len);\r\n    return (char*)memcpy(buf, (const void*)str, len);\r\n}\r\n\r\nchar* ImStrchrRange(const char* str, const char* str_end, char c)\r\n{\r\n    for ( ; str < str_end; str++)\r\n        if (*str == c) \r\n            return (char*)str; \r\n    return NULL;\r\n}\r\n\r\nint ImStrlenW(const ImWchar* str)\r\n{\r\n    int n = 0;\r\n    while (*str++) n++;\r\n    return n;\r\n}\r\n\r\nconst ImWchar* ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin) // find beginning-of-line\r\n{\r\n    while (buf_mid_line > buf_begin && buf_mid_line[-1] != '\\n')\r\n        buf_mid_line--;\r\n    return buf_mid_line;\r\n}\r\n\r\nconst char* ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end)\r\n{\r\n    if (!needle_end)\r\n        needle_end = needle + strlen(needle);\r\n\r\n    const char un0 = (char)toupper(*needle);\r\n    while ((!haystack_end && *haystack) || (haystack_end && haystack < haystack_end))\r\n    {\r\n        if (toupper(*haystack) == un0)\r\n        {\r\n            const char* b = needle + 1;\r\n            for (const char* a = haystack + 1; b < needle_end; a++, b++)\r\n                if (toupper(*a) != toupper(*b))\r\n                    break;\r\n            if (b == needle_end)\r\n                return haystack;\r\n        }\r\n        haystack++;\r\n    }\r\n    return NULL;\r\n}\r\n\r\nstatic const char* ImAtoi(const char* src, int* output)\r\n{\r\n    int negative = 0;\r\n    if (*src == '-') { negative = 1; src++; }\r\n    if (*src == '+') { src++; }\r\n    int v = 0;\r\n    while (*src >= '0' && *src <= '9')\r\n        v = (v * 10) + (*src++ - '0');\r\n    *output = negative ? -v : v;\r\n    return src;\r\n}\r\n\r\n// A) MSVC version appears to return -1 on overflow, whereas glibc appears to return total count (which may be >= buf_size). \r\n// Ideally we would test for only one of those limits at runtime depending on the behavior the vsnprintf(), but trying to deduct it at compile time sounds like a pandora can of worm.\r\n// B) When buf==NULL vsnprintf() will return the output size.\r\n#ifndef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS\r\nint ImFormatString(char* buf, size_t buf_size, const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    int w = vsnprintf(buf, buf_size, fmt, args);\r\n    va_end(args);\r\n    if (buf == NULL)\r\n        return w;\r\n    if (w == -1 || w >= (int)buf_size)\r\n        w = (int)buf_size - 1;\r\n    buf[w] = 0;\r\n    return w;\r\n}\r\n\r\nint ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args)\r\n{\r\n    int w = vsnprintf(buf, buf_size, fmt, args);\r\n    if (buf == NULL)\r\n        return w;\r\n    if (w == -1 || w >= (int)buf_size)\r\n        w = (int)buf_size - 1;\r\n    buf[w] = 0;\r\n    return w;\r\n}\r\n#endif // #ifdef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS\r\n\r\n// Pass data_size==0 for zero-terminated strings\r\n// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.\r\nImU32 ImHash(const void* data, int data_size, ImU32 seed)\r\n{\r\n    static ImU32 crc32_lut[256] = { 0 };\r\n    if (!crc32_lut[1])\r\n    {\r\n        const ImU32 polynomial = 0xEDB88320;\r\n        for (ImU32 i = 0; i < 256; i++)\r\n        {\r\n            ImU32 crc = i;\r\n            for (ImU32 j = 0; j < 8; j++)\r\n                crc = (crc >> 1) ^ (ImU32(-int(crc & 1)) & polynomial);\r\n            crc32_lut[i] = crc;\r\n        }\r\n    }\r\n\r\n    seed = ~seed;\r\n    ImU32 crc = seed;\r\n    const unsigned char* current = (const unsigned char*)data;\r\n\r\n    if (data_size > 0)\r\n    {\r\n        // Known size\r\n        while (data_size--)\r\n            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ *current++];\r\n    }\r\n    else\r\n    {\r\n        // Zero-terminated string\r\n        while (unsigned char c = *current++)\r\n        {\r\n            // We support a syntax of \"label###id\" where only \"###id\" is included in the hash, and only \"label\" gets displayed.\r\n            // Because this syntax is rarely used we are optimizing for the common case.\r\n            // - If we reach ### in the string we discard the hash so far and reset to the seed.\r\n            // - We don't do 'current += 2; continue;' after handling ### to keep the code smaller.\r\n            if (c == '#' && current[0] == '#' && current[1] == '#')\r\n                crc = seed;\r\n            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];\r\n        }\r\n    }\r\n    return ~crc;\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// ImText* helpers\r\n//-----------------------------------------------------------------------------\r\n\r\n// Convert UTF-8 to 32-bits character, process single character input.\r\n// Based on stb_from_utf8() from github.com/nothings/stb/\r\n// We handle UTF-8 decoding error by skipping forward.\r\nint ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end)\r\n{\r\n    unsigned int c = (unsigned int)-1;\r\n    const unsigned char* str = (const unsigned char*)in_text;\r\n    if (!(*str & 0x80))\r\n    {\r\n        c = (unsigned int)(*str++);\r\n        *out_char = c;\r\n        return 1;\r\n    }\r\n    if ((*str & 0xe0) == 0xc0)\r\n    {\r\n        *out_char = 0xFFFD; // will be invalid but not end of string\r\n        if (in_text_end && in_text_end - (const char*)str < 2) return 1;\r\n        if (*str < 0xc2) return 2;\r\n        c = (unsigned int)((*str++ & 0x1f) << 6);\r\n        if ((*str & 0xc0) != 0x80) return 2;\r\n        c += (*str++ & 0x3f);\r\n        *out_char = c;\r\n        return 2;\r\n    }\r\n    if ((*str & 0xf0) == 0xe0)\r\n    {\r\n        *out_char = 0xFFFD; // will be invalid but not end of string\r\n        if (in_text_end && in_text_end - (const char*)str < 3) return 1;\r\n        if (*str == 0xe0 && (str[1] < 0xa0 || str[1] > 0xbf)) return 3;\r\n        if (*str == 0xed && str[1] > 0x9f) return 3; // str[1] < 0x80 is checked below\r\n        c = (unsigned int)((*str++ & 0x0f) << 12);\r\n        if ((*str & 0xc0) != 0x80) return 3;\r\n        c += (unsigned int)((*str++ & 0x3f) << 6);\r\n        if ((*str & 0xc0) != 0x80) return 3;\r\n        c += (*str++ & 0x3f);\r\n        *out_char = c;\r\n        return 3;\r\n    }\r\n    if ((*str & 0xf8) == 0xf0)\r\n    {\r\n        *out_char = 0xFFFD; // will be invalid but not end of string\r\n        if (in_text_end && in_text_end - (const char*)str < 4) return 1;\r\n        if (*str > 0xf4) return 4;\r\n        if (*str == 0xf0 && (str[1] < 0x90 || str[1] > 0xbf)) return 4;\r\n        if (*str == 0xf4 && str[1] > 0x8f) return 4; // str[1] < 0x80 is checked below\r\n        c = (unsigned int)((*str++ & 0x07) << 18);\r\n        if ((*str & 0xc0) != 0x80) return 4;\r\n        c += (unsigned int)((*str++ & 0x3f) << 12);\r\n        if ((*str & 0xc0) != 0x80) return 4;\r\n        c += (unsigned int)((*str++ & 0x3f) << 6);\r\n        if ((*str & 0xc0) != 0x80) return 4;\r\n        c += (*str++ & 0x3f);\r\n        // utf-8 encodings of values used in surrogate pairs are invalid\r\n        if ((c & 0xFFFFF800) == 0xD800) return 4;\r\n        *out_char = c;\r\n        return 4;\r\n    }\r\n    *out_char = 0;\r\n    return 0;\r\n}\r\n\r\nint ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining)\r\n{\r\n    ImWchar* buf_out = buf;\r\n    ImWchar* buf_end = buf + buf_size;\r\n    while (buf_out < buf_end-1 && (!in_text_end || in_text < in_text_end) && *in_text)\r\n    {\r\n        unsigned int c;\r\n        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);\r\n        if (c == 0)\r\n            break;\r\n        if (c < 0x10000)    // FIXME: Losing characters that don't fit in 2 bytes\r\n            *buf_out++ = (ImWchar)c;\r\n    }\r\n    *buf_out = 0;\r\n    if (in_text_remaining)\r\n        *in_text_remaining = in_text;\r\n    return (int)(buf_out - buf);\r\n}\r\n\r\nint ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end)\r\n{\r\n    int char_count = 0;\r\n    while ((!in_text_end || in_text < in_text_end) && *in_text)\r\n    {\r\n        unsigned int c;\r\n        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);\r\n        if (c == 0)\r\n            break;\r\n        if (c < 0x10000)\r\n            char_count++;\r\n    }\r\n    return char_count;\r\n}\r\n\r\n// Based on stb_to_utf8() from github.com/nothings/stb/\r\nstatic inline int ImTextCharToUtf8(char* buf, int buf_size, unsigned int c)\r\n{\r\n    if (c < 0x80)\r\n    {\r\n        buf[0] = (char)c;\r\n        return 1;\r\n    }\r\n    if (c < 0x800)\r\n    {\r\n        if (buf_size < 2) return 0;\r\n        buf[0] = (char)(0xc0 + (c >> 6));\r\n        buf[1] = (char)(0x80 + (c & 0x3f));\r\n        return 2;\r\n    }\r\n    if (c >= 0xdc00 && c < 0xe000)\r\n    {\r\n        return 0;\r\n    }\r\n    if (c >= 0xd800 && c < 0xdc00)\r\n    {\r\n        if (buf_size < 4) return 0;\r\n        buf[0] = (char)(0xf0 + (c >> 18));\r\n        buf[1] = (char)(0x80 + ((c >> 12) & 0x3f));\r\n        buf[2] = (char)(0x80 + ((c >> 6) & 0x3f));\r\n        buf[3] = (char)(0x80 + ((c ) & 0x3f));\r\n        return 4;\r\n    }\r\n    //else if (c < 0x10000)\r\n    {\r\n        if (buf_size < 3) return 0;\r\n        buf[0] = (char)(0xe0 + (c >> 12));\r\n        buf[1] = (char)(0x80 + ((c>> 6) & 0x3f));\r\n        buf[2] = (char)(0x80 + ((c ) & 0x3f));\r\n        return 3;\r\n    }\r\n}\r\n\r\nstatic inline int ImTextCountUtf8BytesFromChar(unsigned int c)\r\n{\r\n    if (c < 0x80) return 1;\r\n    if (c < 0x800) return 2;\r\n    if (c >= 0xdc00 && c < 0xe000) return 0;\r\n    if (c >= 0xd800 && c < 0xdc00) return 4;\r\n    return 3;\r\n}\r\n\r\nint ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end)\r\n{\r\n    char* buf_out = buf;\r\n    const char* buf_end = buf + buf_size;\r\n    while (buf_out < buf_end-1 && (!in_text_end || in_text < in_text_end) && *in_text)\r\n    {\r\n        unsigned int c = (unsigned int)(*in_text++);\r\n        if (c < 0x80)\r\n            *buf_out++ = (char)c;\r\n        else\r\n            buf_out += ImTextCharToUtf8(buf_out, (int)(buf_end-buf_out-1), c);\r\n    }\r\n    *buf_out = 0;\r\n    return (int)(buf_out - buf);\r\n}\r\n\r\nint ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end)\r\n{\r\n    int bytes_count = 0;\r\n    while ((!in_text_end || in_text < in_text_end) && *in_text)\r\n    {\r\n        unsigned int c = (unsigned int)(*in_text++);\r\n        if (c < 0x80)\r\n            bytes_count++;\r\n        else\r\n            bytes_count += ImTextCountUtf8BytesFromChar(c);\r\n    }\r\n    return bytes_count;\r\n}\r\n\r\nImVec4 ImGui::ColorConvertU32ToFloat4(ImU32 in)\r\n{\r\n    float s = 1.0f/255.0f;\r\n    return ImVec4(\r\n        ((in >> IM_COL32_R_SHIFT) & 0xFF) * s,\r\n        ((in >> IM_COL32_G_SHIFT) & 0xFF) * s,\r\n        ((in >> IM_COL32_B_SHIFT) & 0xFF) * s,\r\n        ((in >> IM_COL32_A_SHIFT) & 0xFF) * s);\r\n}\r\n\r\nImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4& in)\r\n{\r\n    ImU32 out;\r\n    out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;\r\n    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;\r\n    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;\r\n    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;\r\n    return out;\r\n}\r\n\r\nImU32 ImGui::GetColorU32(ImGuiCol idx, float alpha_mul)  \r\n{ \r\n    ImGuiStyle& style = GImGui->Style;\r\n    ImVec4 c = style.Colors[idx]; \r\n    c.w *= style.Alpha * alpha_mul; \r\n    return ColorConvertFloat4ToU32(c); \r\n}\r\n\r\nImU32 ImGui::GetColorU32(const ImVec4& col)\r\n{ \r\n    ImGuiStyle& style = GImGui->Style;\r\n    ImVec4 c = col; \r\n    c.w *= style.Alpha; \r\n    return ColorConvertFloat4ToU32(c); \r\n}\r\n\r\nconst ImVec4& ImGui::GetStyleColorVec4(ImGuiCol idx)\r\n{ \r\n    ImGuiStyle& style = GImGui->Style;\r\n    return style.Colors[idx];\r\n}\r\n\r\nImU32 ImGui::GetColorU32(ImU32 col)\r\n{ \r\n    float style_alpha = GImGui->Style.Alpha;\r\n    if (style_alpha >= 1.0f)\r\n        return col;\r\n    int a = (col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT;\r\n    a = (int)(a * style_alpha); // We don't need to clamp 0..255 because Style.Alpha is in 0..1 range.\r\n    return (col & ~IM_COL32_A_MASK) | (a << IM_COL32_A_SHIFT);\r\n}\r\n\r\n// Convert rgb floats ([0-1],[0-1],[0-1]) to hsv floats ([0-1],[0-1],[0-1]), from Foley & van Dam p592\r\n// Optimized http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv\r\nvoid ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)\r\n{\r\n    float K = 0.f;\r\n    if (g < b)\r\n    {\r\n        ImSwap(g, b);\r\n        K = -1.f;\r\n    }\r\n    if (r < g)\r\n    {\r\n        ImSwap(r, g);\r\n        K = -2.f / 6.f - K;\r\n    }\r\n\r\n    const float chroma = r - (g < b ? g : b);\r\n    out_h = fabsf(K + (g - b) / (6.f * chroma + 1e-20f));\r\n    out_s = chroma / (r + 1e-20f);\r\n    out_v = r;\r\n}\r\n\r\n// Convert hsv floats ([0-1],[0-1],[0-1]) to rgb floats ([0-1],[0-1],[0-1]), from Foley & van Dam p593\r\n// also http://en.wikipedia.org/wiki/HSL_and_HSV\r\nvoid ImGui::ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b)\r\n{\r\n    if (s == 0.0f)\r\n    {\r\n        // gray\r\n        out_r = out_g = out_b = v;\r\n        return;\r\n    }\r\n\r\n    h = fmodf(h, 1.0f) / (60.0f/360.0f);\r\n    int   i = (int)h;\r\n    float f = h - (float)i;\r\n    float p = v * (1.0f - s);\r\n    float q = v * (1.0f - s * f);\r\n    float t = v * (1.0f - s * (1.0f - f));\r\n\r\n    switch (i)\r\n    {\r\n    case 0: out_r = v; out_g = t; out_b = p; break;\r\n    case 1: out_r = q; out_g = v; out_b = p; break;\r\n    case 2: out_r = p; out_g = v; out_b = t; break;\r\n    case 3: out_r = p; out_g = q; out_b = v; break;\r\n    case 4: out_r = t; out_g = p; out_b = v; break;\r\n    case 5: default: out_r = v; out_g = p; out_b = q; break;\r\n    }\r\n}\r\n\r\nFILE* ImFileOpen(const char* filename, const char* mode)\r\n{\r\n#if defined(_WIN32) && !defined(__CYGWIN__)\r\n    // We need a fopen() wrapper because MSVC/Windows fopen doesn't handle UTF-8 filenames. Converting both strings from UTF-8 to wchar format (using a single allocation, because we can)\r\n    const int filename_wsize = ImTextCountCharsFromUtf8(filename, NULL) + 1;\r\n    const int mode_wsize = ImTextCountCharsFromUtf8(mode, NULL) + 1;\r\n    ImVector<ImWchar> buf;\r\n    buf.resize(filename_wsize + mode_wsize);\r\n    ImTextStrFromUtf8(&buf[0], filename_wsize, filename, NULL);\r\n    ImTextStrFromUtf8(&buf[filename_wsize], mode_wsize, mode, NULL);\r\n    return _wfopen((wchar_t*)&buf[0], (wchar_t*)&buf[filename_wsize]);\r\n#else\r\n    return fopen(filename, mode);\r\n#endif\r\n}\r\n\r\n// Load file content into memory\r\n// Memory allocated with ImGui::MemAlloc(), must be freed by user using ImGui::MemFree()\r\nvoid* ImFileLoadToMemory(const char* filename, const char* file_open_mode, int* out_file_size, int padding_bytes)\r\n{\r\n    IM_ASSERT(filename && file_open_mode);\r\n    if (out_file_size)\r\n        *out_file_size = 0;\r\n\r\n    FILE* f;\r\n    if ((f = ImFileOpen(filename, file_open_mode)) == NULL)\r\n        return NULL;\r\n\r\n    long file_size_signed;\r\n    if (fseek(f, 0, SEEK_END) || (file_size_signed = ftell(f)) == -1 || fseek(f, 0, SEEK_SET))\r\n    {\r\n        fclose(f);\r\n        return NULL;\r\n    }\r\n\r\n    int file_size = (int)file_size_signed;\r\n    void* file_data = ImGui::MemAlloc(file_size + padding_bytes);\r\n    if (file_data == NULL)\r\n    {\r\n        fclose(f);\r\n        return NULL;\r\n    }\r\n    if (fread(file_data, 1, (size_t)file_size, f) != (size_t)file_size)\r\n    {\r\n        fclose(f);\r\n        ImGui::MemFree(file_data);\r\n        return NULL;\r\n    }\r\n    if (padding_bytes > 0)\r\n        memset((void *)(((char*)file_data) + file_size), 0, padding_bytes);\r\n\r\n    fclose(f);\r\n    if (out_file_size)\r\n        *out_file_size = file_size;\r\n\r\n    return file_data;\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// ImGuiStorage\r\n// Helper: Key->value storage\r\n//-----------------------------------------------------------------------------\r\n\r\n// std::lower_bound but without the bullshit\r\nstatic ImVector<ImGuiStorage::Pair>::iterator LowerBound(ImVector<ImGuiStorage::Pair>& data, ImGuiID key)\r\n{\r\n    ImVector<ImGuiStorage::Pair>::iterator first = data.begin();\r\n    ImVector<ImGuiStorage::Pair>::iterator last = data.end();\r\n    size_t count = (size_t)(last - first);\r\n    while (count > 0)\r\n    {\r\n        size_t count2 = count >> 1;\r\n        ImVector<ImGuiStorage::Pair>::iterator mid = first + count2;\r\n        if (mid->key < key)\r\n        {\r\n            first = ++mid;\r\n            count -= count2 + 1;\r\n        }\r\n        else\r\n        {\r\n            count = count2;\r\n        }\r\n    }\r\n    return first;\r\n}\r\n\r\n// For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.\r\nvoid ImGuiStorage::BuildSortByKey()\r\n{\r\n    struct StaticFunc \r\n    { \r\n        static int PairCompareByID(const void* lhs, const void* rhs) \r\n        {\r\n            // We can't just do a subtraction because qsort uses signed integers and subtracting our ID doesn't play well with that.\r\n            if (((const Pair*)lhs)->key > ((const Pair*)rhs)->key) return +1;\r\n            if (((const Pair*)lhs)->key < ((const Pair*)rhs)->key) return -1;\r\n            return 0;\r\n        }\r\n    };\r\n    if (Data.Size > 1)\r\n        qsort(Data.Data, (size_t)Data.Size, sizeof(Pair), StaticFunc::PairCompareByID);\r\n}\r\n\r\nint ImGuiStorage::GetInt(ImGuiID key, int default_val) const\r\n{\r\n    ImVector<Pair>::iterator it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);\r\n    if (it == Data.end() || it->key != key)\r\n        return default_val;\r\n    return it->val_i;\r\n}\r\n\r\nbool ImGuiStorage::GetBool(ImGuiID key, bool default_val) const\r\n{\r\n    return GetInt(key, default_val ? 1 : 0) != 0;\r\n}\r\n\r\nfloat ImGuiStorage::GetFloat(ImGuiID key, float default_val) const\r\n{\r\n    ImVector<Pair>::iterator it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);\r\n    if (it == Data.end() || it->key != key)\r\n        return default_val;\r\n    return it->val_f;\r\n}\r\n\r\nvoid* ImGuiStorage::GetVoidPtr(ImGuiID key) const\r\n{\r\n    ImVector<Pair>::iterator it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);\r\n    if (it == Data.end() || it->key != key)\r\n        return NULL;\r\n    return it->val_p;\r\n}\r\n\r\n// References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.\r\nint* ImGuiStorage::GetIntRef(ImGuiID key, int default_val)\r\n{\r\n    ImVector<Pair>::iterator it = LowerBound(Data, key);\r\n    if (it == Data.end() || it->key != key)\r\n        it = Data.insert(it, Pair(key, default_val));\r\n    return &it->val_i;\r\n}\r\n\r\nbool* ImGuiStorage::GetBoolRef(ImGuiID key, bool default_val)\r\n{\r\n    return (bool*)GetIntRef(key, default_val ? 1 : 0);\r\n}\r\n\r\nfloat* ImGuiStorage::GetFloatRef(ImGuiID key, float default_val)\r\n{\r\n    ImVector<Pair>::iterator it = LowerBound(Data, key);\r\n    if (it == Data.end() || it->key != key)\r\n        it = Data.insert(it, Pair(key, default_val));\r\n    return &it->val_f;\r\n}\r\n\r\nvoid** ImGuiStorage::GetVoidPtrRef(ImGuiID key, void* default_val)\r\n{\r\n    ImVector<Pair>::iterator it = LowerBound(Data, key);\r\n    if (it == Data.end() || it->key != key)\r\n        it = Data.insert(it, Pair(key, default_val));\r\n    return &it->val_p;\r\n}\r\n\r\n// FIXME-OPT: Need a way to reuse the result of lower_bound when doing GetInt()/SetInt() - not too bad because it only happens on explicit interaction (maximum one a frame)\r\nvoid ImGuiStorage::SetInt(ImGuiID key, int val)\r\n{\r\n    ImVector<Pair>::iterator it = LowerBound(Data, key);\r\n    if (it == Data.end() || it->key != key)\r\n    {\r\n        Data.insert(it, Pair(key, val));\r\n        return;\r\n    }\r\n    it->val_i = val;\r\n}\r\n\r\nvoid ImGuiStorage::SetBool(ImGuiID key, bool val)\r\n{\r\n    SetInt(key, val ? 1 : 0);\r\n}\r\n\r\nvoid ImGuiStorage::SetFloat(ImGuiID key, float val)\r\n{\r\n    ImVector<Pair>::iterator it = LowerBound(Data, key);\r\n    if (it == Data.end() || it->key != key)\r\n    {\r\n        Data.insert(it, Pair(key, val));\r\n        return;\r\n    }\r\n    it->val_f = val;\r\n}\r\n\r\nvoid ImGuiStorage::SetVoidPtr(ImGuiID key, void* val)\r\n{\r\n    ImVector<Pair>::iterator it = LowerBound(Data, key);\r\n    if (it == Data.end() || it->key != key)\r\n    {\r\n        Data.insert(it, Pair(key, val));\r\n        return;\r\n    }\r\n    it->val_p = val;\r\n}\r\n\r\nvoid ImGuiStorage::SetAllInt(int v)\r\n{\r\n    for (int i = 0; i < Data.Size; i++)\r\n        Data[i].val_i = v;\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// ImGuiTextFilter\r\n//-----------------------------------------------------------------------------\r\n\r\n// Helper: Parse and apply text filters. In format \"aaaaa[,bbbb][,ccccc]\"\r\nImGuiTextFilter::ImGuiTextFilter(const char* default_filter)\r\n{\r\n    if (default_filter)\r\n    {\r\n        ImStrncpy(InputBuf, default_filter, IM_ARRAYSIZE(InputBuf));\r\n        Build();\r\n    }\r\n    else\r\n    {\r\n        InputBuf[0] = 0;\r\n        CountGrep = 0;\r\n    }\r\n}\r\n\r\nbool ImGuiTextFilter::Draw(const char* label, float width)\r\n{\r\n    if (width != 0.0f)\r\n        ImGui::PushItemWidth(width);\r\n    bool value_changed = ImGui::InputText(label, InputBuf, IM_ARRAYSIZE(InputBuf));\r\n    if (width != 0.0f)\r\n        ImGui::PopItemWidth();\r\n    if (value_changed)\r\n        Build();\r\n    return value_changed;\r\n}\r\n\r\nvoid ImGuiTextFilter::TextRange::split(char separator, ImVector<TextRange>& out)\r\n{\r\n    out.resize(0);\r\n    const char* wb = b;\r\n    const char* we = wb;\r\n    while (we < e)\r\n    {\r\n        if (*we == separator)\r\n        {\r\n            out.push_back(TextRange(wb, we));\r\n            wb = we + 1;\r\n        }\r\n        we++;\r\n    }\r\n    if (wb != we)\r\n        out.push_back(TextRange(wb, we));\r\n}\r\n\r\nvoid ImGuiTextFilter::Build()\r\n{\r\n    Filters.resize(0);\r\n    TextRange input_range(InputBuf, InputBuf+strlen(InputBuf));\r\n    input_range.split(',', Filters);\r\n\r\n    CountGrep = 0;\r\n    for (int i = 0; i != Filters.Size; i++)\r\n    {\r\n        Filters[i].trim_blanks();\r\n        if (Filters[i].empty())\r\n            continue;\r\n        if (Filters[i].front() != '-')\r\n            CountGrep += 1;\r\n    }\r\n}\r\n\r\nbool ImGuiTextFilter::PassFilter(const char* text, const char* text_end) const\r\n{\r\n    if (Filters.empty())\r\n        return true;\r\n\r\n    if (text == NULL)\r\n        text = \"\";\r\n\r\n    for (int i = 0; i != Filters.Size; i++)\r\n    {\r\n        const TextRange& f = Filters[i];\r\n        if (f.empty())\r\n            continue;\r\n        if (f.front() == '-')\r\n        {\r\n            // Subtract\r\n            if (ImStristr(text, text_end, f.begin()+1, f.end()) != NULL)\r\n                return false;\r\n        }\r\n        else\r\n        {\r\n            // Grep\r\n            if (ImStristr(text, text_end, f.begin(), f.end()) != NULL)\r\n                return true;\r\n        }\r\n    }\r\n\r\n    // Implicit * grep\r\n    if (CountGrep == 0)\r\n        return true;\r\n\r\n    return false;\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// ImGuiTextBuffer\r\n//-----------------------------------------------------------------------------\r\n\r\n// On some platform vsnprintf() takes va_list by reference and modifies it.\r\n// va_copy is the 'correct' way to copy a va_list but Visual Studio prior to 2013 doesn't have it.\r\n#ifndef va_copy\r\n#define va_copy(dest, src) (dest = src)\r\n#endif\r\n\r\n// Helper: Text buffer for logging/accumulating text\r\nvoid ImGuiTextBuffer::appendfv(const char* fmt, va_list args)\r\n{\r\n    va_list args_copy;\r\n    va_copy(args_copy, args);\r\n\r\n    int len = ImFormatStringV(NULL, 0, fmt, args);         // FIXME-OPT: could do a first pass write attempt, likely successful on first pass.\r\n    if (len <= 0)\r\n        return;\r\n\r\n    const int write_off = Buf.Size;\r\n    const int needed_sz = write_off + len;\r\n    if (write_off + len >= Buf.Capacity)\r\n    {\r\n        int double_capacity = Buf.Capacity * 2;\r\n        Buf.reserve(needed_sz > double_capacity ? needed_sz : double_capacity);\r\n    }\r\n\r\n    Buf.resize(needed_sz);\r\n    ImFormatStringV(&Buf[write_off - 1], len + 1, fmt, args_copy);\r\n}\r\n\r\nvoid ImGuiTextBuffer::appendf(const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    appendfv(fmt, args);\r\n    va_end(args);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// ImGuiSimpleColumns (internal use only)\r\n//-----------------------------------------------------------------------------\r\n\r\nImGuiSimpleColumns::ImGuiSimpleColumns()\r\n{\r\n    Count = 0;\r\n    Spacing = Width = NextWidth = 0.0f;\r\n    memset(Pos, 0, sizeof(Pos));\r\n    memset(NextWidths, 0, sizeof(NextWidths));\r\n}\r\n\r\nvoid ImGuiSimpleColumns::Update(int count, float spacing, bool clear)\r\n{\r\n    IM_ASSERT(Count <= IM_ARRAYSIZE(Pos));\r\n    Count = count;\r\n    Width = NextWidth = 0.0f;\r\n    Spacing = spacing;\r\n    if (clear) memset(NextWidths, 0, sizeof(NextWidths));\r\n    for (int i = 0; i < Count; i++)\r\n    {\r\n        if (i > 0 && NextWidths[i] > 0.0f)\r\n            Width += Spacing;\r\n        Pos[i] = (float)(int)Width;\r\n        Width += NextWidths[i];\r\n        NextWidths[i] = 0.0f;\r\n    }\r\n}\r\n\r\nfloat ImGuiSimpleColumns::DeclColumns(float w0, float w1, float w2) // not using va_arg because they promote float to double\r\n{\r\n    NextWidth = 0.0f;\r\n    NextWidths[0] = ImMax(NextWidths[0], w0);\r\n    NextWidths[1] = ImMax(NextWidths[1], w1);\r\n    NextWidths[2] = ImMax(NextWidths[2], w2);\r\n    for (int i = 0; i < 3; i++)\r\n        NextWidth += NextWidths[i] + ((i > 0 && NextWidths[i] > 0.0f) ? Spacing : 0.0f);\r\n    return ImMax(Width, NextWidth);\r\n}\r\n\r\nfloat ImGuiSimpleColumns::CalcExtraSpace(float avail_w)\r\n{\r\n    return ImMax(0.0f, avail_w - Width);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// ImGuiListClipper\r\n//-----------------------------------------------------------------------------\r\n\r\nstatic void SetCursorPosYAndSetupDummyPrevLine(float pos_y, float line_height)\r\n{\r\n    // Set cursor position and a few other things so that SetScrollHere() and Columns() can work when seeking cursor. \r\n    // FIXME: It is problematic that we have to do that here, because custom/equivalent end-user code would stumble on the same issue. Consider moving within SetCursorXXX functions?\r\n    ImGui::SetCursorPosY(pos_y);\r\n    ImGuiWindow* window = ImGui::GetCurrentWindow();\r\n    window->DC.CursorPosPrevLine.y = window->DC.CursorPos.y - line_height;      // Setting those fields so that SetScrollHere() can properly function after the end of our clipper usage.\r\n    window->DC.PrevLineHeight = (line_height - GImGui->Style.ItemSpacing.y);    // If we end up needing more accurate data (to e.g. use SameLine) we may as well make the clipper have a fourth step to let user process and display the last item in their list.\r\n    if (window->DC.ColumnsSet)\r\n        window->DC.ColumnsSet->CellMinY = window->DC.CursorPos.y;           // Setting this so that cell Y position are set properly\r\n}\r\n\r\n// Use case A: Begin() called from constructor with items_height<0, then called again from Sync() in StepNo 1\r\n// Use case B: Begin() called from constructor with items_height>0\r\n// FIXME-LEGACY: Ideally we should remove the Begin/End functions but they are part of the legacy API we still support. This is why some of the code in Step() calling Begin() and reassign some fields, spaghetti style.\r\nvoid ImGuiListClipper::Begin(int count, float items_height)\r\n{\r\n    StartPosY = ImGui::GetCursorPosY();\r\n    ItemsHeight = items_height;\r\n    ItemsCount = count;\r\n    StepNo = 0;\r\n    DisplayEnd = DisplayStart = -1;\r\n    if (ItemsHeight > 0.0f)\r\n    {\r\n        ImGui::CalcListClipping(ItemsCount, ItemsHeight, &DisplayStart, &DisplayEnd); // calculate how many to clip/display\r\n        if (DisplayStart > 0)\r\n            SetCursorPosYAndSetupDummyPrevLine(StartPosY + DisplayStart * ItemsHeight, ItemsHeight); // advance cursor\r\n        StepNo = 2;\r\n    }\r\n}\r\n\r\nvoid ImGuiListClipper::End()\r\n{\r\n    if (ItemsCount < 0)\r\n        return;\r\n    // In theory here we should assert that ImGui::GetCursorPosY() == StartPosY + DisplayEnd * ItemsHeight, but it feels saner to just seek at the end and not assert/crash the user.\r\n    if (ItemsCount < INT_MAX)\r\n        SetCursorPosYAndSetupDummyPrevLine(StartPosY + ItemsCount * ItemsHeight, ItemsHeight); // advance cursor\r\n    ItemsCount = -1;\r\n    StepNo = 3;\r\n}\r\n\r\nbool ImGuiListClipper::Step()\r\n{\r\n    if (ItemsCount == 0 || ImGui::GetCurrentWindowRead()->SkipItems)\r\n    {\r\n        ItemsCount = -1; \r\n        return false; \r\n    }\r\n    if (StepNo == 0) // Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height.\r\n    {\r\n        DisplayStart = 0;\r\n        DisplayEnd = 1;\r\n        StartPosY = ImGui::GetCursorPosY();\r\n        StepNo = 1;\r\n        return true;\r\n    }\r\n    if (StepNo == 1) // Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element.\r\n    {\r\n        if (ItemsCount == 1) { ItemsCount = -1; return false; }\r\n        float items_height = ImGui::GetCursorPosY() - StartPosY;\r\n        IM_ASSERT(items_height > 0.0f);   // If this triggers, it means Item 0 hasn't moved the cursor vertically\r\n        Begin(ItemsCount-1, items_height);\r\n        DisplayStart++;\r\n        DisplayEnd++;\r\n        StepNo = 3;\r\n        return true;\r\n    }\r\n    if (StepNo == 2) // Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user still call Step(). Does nothing and switch to Step 3.\r\n    {\r\n        IM_ASSERT(DisplayStart >= 0 && DisplayEnd >= 0);\r\n        StepNo = 3;\r\n        return true;\r\n    }\r\n    if (StepNo == 3) // Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.\r\n        End();\r\n    return false;\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// ImGuiWindow\r\n//-----------------------------------------------------------------------------\r\n\r\nImGuiWindow::ImGuiWindow(ImGuiContext* context, const char* name)\r\n{\r\n    Name = ImStrdup(name);\r\n    ID = ImHash(name, 0);\r\n    IDStack.push_back(ID);\r\n    Flags = 0;\r\n    PosFloat = Pos = ImVec2(0.0f, 0.0f);\r\n    Size = SizeFull = ImVec2(0.0f, 0.0f);\r\n    SizeContents = SizeContentsExplicit = ImVec2(0.0f, 0.0f);\r\n    WindowPadding = ImVec2(0.0f, 0.0f);\r\n    WindowRounding = 0.0f;\r\n    WindowBorderSize = 0.0f;\r\n    MoveId = GetID(\"#MOVE\");\r\n    Scroll = ImVec2(0.0f, 0.0f);\r\n    ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);\r\n    ScrollTargetCenterRatio = ImVec2(0.5f, 0.5f);\r\n    ScrollbarX = ScrollbarY = false;\r\n    ScrollbarSizes = ImVec2(0.0f, 0.0f);\r\n    Active = WasActive = false;\r\n    WriteAccessed = false;\r\n    Collapsed = false;\r\n    SkipItems = false;\r\n    Appearing = false;\r\n    CloseButton = false;\r\n    BeginOrderWithinParent = -1;\r\n    BeginOrderWithinContext = -1;\r\n    BeginCount = 0;\r\n    PopupId = 0;\r\n    AutoFitFramesX = AutoFitFramesY = -1;\r\n    AutoFitOnlyGrows = false;\r\n    AutoFitChildAxises = 0x00;\r\n    AutoPosLastDirection = ImGuiDir_None;\r\n    HiddenFrames = 0;\r\n    SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = ImGuiCond_Always | ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing;\r\n    SetWindowPosVal = SetWindowPosPivot = ImVec2(FLT_MAX, FLT_MAX);\r\n\r\n    LastFrameActive = -1;\r\n    ItemWidthDefault = 0.0f;\r\n    FontWindowScale = 1.0f;\r\n\r\n    DrawList = IM_NEW(ImDrawList)(&context->DrawListSharedData);\r\n    DrawList->_OwnerName = Name;\r\n    ParentWindow = NULL;\r\n    RootWindow = NULL;\r\n    RootNonPopupWindow = NULL;\r\n\r\n    FocusIdxAllCounter = FocusIdxTabCounter = -1;\r\n    FocusIdxAllRequestCurrent = FocusIdxTabRequestCurrent = INT_MAX;\r\n    FocusIdxAllRequestNext = FocusIdxTabRequestNext = INT_MAX;\r\n}\r\n\r\nImGuiWindow::~ImGuiWindow()\r\n{\r\n    IM_DELETE(DrawList);\r\n    IM_DELETE(Name);\r\n}\r\n\r\nImGuiID ImGuiWindow::GetID(const char* str, const char* str_end)\r\n{\r\n    ImGuiID seed = IDStack.back();\r\n    ImGuiID id = ImHash(str, str_end ? (int)(str_end - str) : 0, seed);\r\n    ImGui::KeepAliveID(id);\r\n    return id;\r\n}\r\n\r\nImGuiID ImGuiWindow::GetID(const void* ptr)\r\n{\r\n    ImGuiID seed = IDStack.back();\r\n    ImGuiID id = ImHash(&ptr, sizeof(void*), seed);\r\n    ImGui::KeepAliveID(id);\r\n    return id;\r\n}\r\n\r\nImGuiID ImGuiWindow::GetIDNoKeepAlive(const char* str, const char* str_end)\r\n{\r\n    ImGuiID seed = IDStack.back();\r\n    return ImHash(str, str_end ? (int)(str_end - str) : 0, seed);\r\n}\r\n\r\n// This is only used in rare/specific situations to manufacture an ID out of nowhere.\r\nImGuiID ImGuiWindow::GetIDFromRectangle(const ImRect& r_abs)\r\n{\r\n    ImGuiID seed = IDStack.back();\r\n    const int r_rel[4] = { (int)(r_abs.Min.x - Pos.x), (int)(r_abs.Min.y - Pos.y), (int)(r_abs.Max.x - Pos.x), (int)(r_abs.Max.y - Pos.y) };\r\n    ImGuiID id = ImHash(&r_rel, sizeof(r_rel), seed);\r\n    ImGui::KeepAliveID(id);\r\n    return id;\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// Internal API exposed in imgui_internal.h\r\n//-----------------------------------------------------------------------------\r\n\r\nstatic void SetCurrentWindow(ImGuiWindow* window)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.CurrentWindow = window;\r\n    if (window)\r\n        g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();\r\n}\r\n\r\nvoid ImGui::SetActiveID(ImGuiID id, ImGuiWindow* window)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.ActiveIdIsJustActivated = (g.ActiveId != id);\r\n    if (g.ActiveIdIsJustActivated)\r\n        g.ActiveIdTimer = 0.0f;\r\n    g.ActiveId = id;\r\n    g.ActiveIdAllowOverlap = false;\r\n    g.ActiveIdIsAlive |= (id != 0);\r\n    g.ActiveIdWindow = window;\r\n}\r\n\r\nvoid ImGui::ClearActiveID()\r\n{\r\n    SetActiveID(0, NULL);\r\n}\r\n\r\nvoid ImGui::SetHoveredID(ImGuiID id)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.HoveredId = id;\r\n    g.HoveredIdAllowOverlap = false;\r\n    g.HoveredIdTimer = (id != 0 && g.HoveredIdPreviousFrame == id) ? (g.HoveredIdTimer + g.IO.DeltaTime) : 0.0f;\r\n}\r\n\r\nvoid ImGui::KeepAliveID(ImGuiID id)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.ActiveId == id)\r\n        g.ActiveIdIsAlive = true;\r\n}\r\n\r\nstatic inline bool IsWindowContentHoverable(ImGuiWindow* window, ImGuiHoveredFlags flags)\r\n{\r\n    // An active popup disable hovering on other windows (apart from its own children)\r\n    // FIXME-OPT: This could be cached/stored within the window.\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.NavWindow)\r\n        if (ImGuiWindow* focused_root_window = g.NavWindow->RootWindow)\r\n            if (focused_root_window->WasActive && focused_root_window != window->RootWindow)\r\n            {\r\n                // For the purpose of those flags we differentiate \"standard popup\" from \"modal popup\"\r\n                // NB: The order of those two tests is important because Modal windows are also Popups.\r\n                if (focused_root_window->Flags & ImGuiWindowFlags_Modal)\r\n                    return false;\r\n                if ((focused_root_window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiHoveredFlags_AllowWhenBlockedByPopup))\r\n                    return false;\r\n            }\r\n\r\n    return true;\r\n}\r\n\r\n// Advance cursor given item size for layout.\r\nvoid ImGui::ItemSize(const ImVec2& size, float text_offset_y)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    // Always align ourselves on pixel boundaries\r\n    const float line_height = ImMax(window->DC.CurrentLineHeight, size.y);\r\n    const float text_base_offset = ImMax(window->DC.CurrentLineTextBaseOffset, text_offset_y);\r\n    //if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(size.x, line_height), IM_COL32(255,0,0,200)); // [DEBUG]\r\n    window->DC.CursorPosPrevLine = ImVec2(window->DC.CursorPos.x + size.x, window->DC.CursorPos.y);\r\n    window->DC.CursorPos = ImVec2((float)(int)(window->Pos.x + window->DC.IndentX + window->DC.ColumnsOffsetX), (float)(int)(window->DC.CursorPos.y + line_height + g.Style.ItemSpacing.y));\r\n    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);\r\n    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y - g.Style.ItemSpacing.y);\r\n    //if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]\r\n\r\n    window->DC.PrevLineHeight = line_height;\r\n    window->DC.PrevLineTextBaseOffset = text_base_offset;\r\n    window->DC.CurrentLineHeight = window->DC.CurrentLineTextBaseOffset = 0.0f;\r\n\r\n    // Horizontal layout mode\r\n    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)\r\n        SameLine();\r\n}\r\n\r\nvoid ImGui::ItemSize(const ImRect& bb, float text_offset_y)\r\n{\r\n    ItemSize(bb.GetSize(), text_offset_y);\r\n}\r\n\r\n// Declare item bounding box for clipping and interaction.\r\n// Note that the size can be different than the one provided to ItemSize(). Typically, widgets that spread over available surface\r\n// declares their minimum size requirement to ItemSize() and then use a larger region for drawing/interaction, which is passed to ItemAdd().\r\nbool ImGui::ItemAdd(const ImRect& bb, ImGuiID id)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    const bool is_clipped = IsClippedEx(bb, id, false);\r\n    window->DC.LastItemId = id;\r\n    window->DC.LastItemRect = bb;\r\n    window->DC.LastItemRectHoveredRect = false;\r\n    if (is_clipped)\r\n        return false;\r\n    //if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG]\r\n\r\n    // We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)\r\n    window->DC.LastItemRectHoveredRect = IsMouseHoveringRect(bb.Min, bb.Max);\r\n    return true;\r\n}\r\n\r\n// This is roughly matching the behavior of internal-facing ItemHoverable()\r\n// - we allow hovering to be true when ActiveId==window->MoveID, so that clicking on non-interactive items such as a Text() item still returns true with IsItemHovered()\r\n// - this should work even for non-interactive items that have no ID, so we cannot use LastItemId\r\nbool ImGui::IsItemHovered(ImGuiHoveredFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    // Test for bounding box overlap, as updated as ItemAdd()\r\n    if (!window->DC.LastItemRectHoveredRect)\r\n        return false;\r\n    IM_ASSERT((flags & (ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows)) == 0);   // Flags not supported by this function\r\n\r\n    // Test if we are hovering the right window (our window could be behind another window)\r\n    // [2017/10/16] Reverted commit 344d48be3 and testing RootWindow instead. I believe it is correct to NOT test for RootWindow but this leaves us unable to use IsItemHovered() after EndChild() itself.\r\n    // Until a solution is found I believe reverting to the test from 2017/09/27 is safe since this was the test that has been running for a long while.\r\n    //if (g.HoveredWindow != window)\r\n    //    return false;\r\n    if (g.HoveredRootWindow != window->RootWindow && !(flags & ImGuiHoveredFlags_AllowWhenOverlapped))\r\n        return false;\r\n\r\n    // Test if another item is active (e.g. being dragged)\r\n    if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))\r\n        if (g.ActiveId != 0 && g.ActiveId != window->DC.LastItemId && !g.ActiveIdAllowOverlap && g.ActiveId != window->MoveId)\r\n            return false;\r\n\r\n    // Test if interactions on this window are blocked by an active popup or modal \r\n    if (!IsWindowContentHoverable(window, flags))\r\n        return false;\r\n\r\n    // Test if the item is disabled\r\n    if (window->DC.ItemFlags & ImGuiItemFlags_Disabled)\r\n        return false;\r\n    \r\n    // Special handling for the 1st item after Begin() which represent the title bar. When the window is collapsed (SkipItems==true) that last item will never be overwritten so we need to detect tht case.\r\n    if (window->DC.LastItemId == window->MoveId && window->WriteAccessed)\r\n        return false;\r\n    return true;\r\n}\r\n\r\n// Internal facing ItemHoverable() used when submitting widgets. Differs slightly from IsItemHovered().\r\nbool ImGui::ItemHoverable(const ImRect& bb, ImGuiID id)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)\r\n        return false;\r\n\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    if (g.HoveredWindow != window)\r\n        return false;\r\n    if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)\r\n        return false;\r\n    if (!IsMouseHoveringRect(bb.Min, bb.Max))\r\n        return false;\r\n    if (!IsWindowContentHoverable(window, ImGuiHoveredFlags_Default))\r\n        return false;\r\n    if (window->DC.ItemFlags & ImGuiItemFlags_Disabled)\r\n        return false;\r\n\r\n    SetHoveredID(id);\r\n    return true;\r\n}\r\n\r\nbool ImGui::IsClippedEx(const ImRect& bb, ImGuiID id, bool clip_even_when_logged)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    if (!bb.Overlaps(window->ClipRect))\r\n        if (id == 0 || id != g.ActiveId)\r\n            if (clip_even_when_logged || !g.LogEnabled)\r\n                return true;\r\n    return false;\r\n}\r\n\r\nbool ImGui::FocusableItemRegister(ImGuiWindow* window, ImGuiID id, bool tab_stop)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    const bool allow_keyboard_focus = (window->DC.ItemFlags & (ImGuiItemFlags_AllowKeyboardFocus | ImGuiItemFlags_Disabled)) == ImGuiItemFlags_AllowKeyboardFocus;\r\n    window->FocusIdxAllCounter++;\r\n    if (allow_keyboard_focus)\r\n        window->FocusIdxTabCounter++;\r\n\r\n    // Process keyboard input at this point: TAB/Shift-TAB to tab out of the currently focused item.\r\n    // Note that we can always TAB out of a widget that doesn't allow tabbing in.\r\n    if (tab_stop && (g.ActiveId == id) && window->FocusIdxAllRequestNext == INT_MAX && window->FocusIdxTabRequestNext == INT_MAX && !g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab))\r\n        window->FocusIdxTabRequestNext = window->FocusIdxTabCounter + (g.IO.KeyShift ? (allow_keyboard_focus ? -1 : 0) : +1); // Modulo on index will be applied at the end of frame once we've got the total counter of items.\r\n\r\n    if (window->FocusIdxAllCounter == window->FocusIdxAllRequestCurrent)\r\n        return true;\r\n\r\n    if (allow_keyboard_focus)\r\n        if (window->FocusIdxTabCounter == window->FocusIdxTabRequestCurrent)\r\n            return true;\r\n\r\n    return false;\r\n}\r\n\r\nvoid ImGui::FocusableItemUnregister(ImGuiWindow* window)\r\n{\r\n    window->FocusIdxAllCounter--;\r\n    window->FocusIdxTabCounter--;\r\n}\r\n\r\nImVec2 ImGui::CalcItemSize(ImVec2 size, float default_x, float default_y)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImVec2 content_max;\r\n    if (size.x < 0.0f || size.y < 0.0f)\r\n        content_max = g.CurrentWindow->Pos + GetContentRegionMax();\r\n    if (size.x <= 0.0f)\r\n        size.x = (size.x == 0.0f) ? default_x : ImMax(content_max.x - g.CurrentWindow->DC.CursorPos.x, 4.0f) + size.x;\r\n    if (size.y <= 0.0f)\r\n        size.y = (size.y == 0.0f) ? default_y : ImMax(content_max.y - g.CurrentWindow->DC.CursorPos.y, 4.0f) + size.y;\r\n    return size;\r\n}\r\n\r\nfloat ImGui::CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x)\r\n{\r\n    if (wrap_pos_x < 0.0f)\r\n        return 0.0f;\r\n\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    if (wrap_pos_x == 0.0f)\r\n        wrap_pos_x = GetContentRegionMax().x + window->Pos.x;\r\n    else if (wrap_pos_x > 0.0f)\r\n        wrap_pos_x += window->Pos.x - window->Scroll.x; // wrap_pos_x is provided is window local space\r\n\r\n    return ImMax(wrap_pos_x - pos.x, 1.0f);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n\r\nvoid* ImGui::MemAlloc(size_t sz)\r\n{\r\n    GImGui->IO.MetricsAllocs++;\r\n    return GImGui->IO.MemAllocFn(sz);\r\n}\r\n\r\nvoid ImGui::MemFree(void* ptr)\r\n{\r\n    if (ptr) GImGui->IO.MetricsAllocs--;\r\n    return GImGui->IO.MemFreeFn(ptr);\r\n}\r\n\r\nconst char* ImGui::GetClipboardText()\r\n{\r\n    return GImGui->IO.GetClipboardTextFn ? GImGui->IO.GetClipboardTextFn(GImGui->IO.ClipboardUserData) : \"\";\r\n}\r\n\r\nvoid ImGui::SetClipboardText(const char* text)\r\n{\r\n    if (GImGui->IO.SetClipboardTextFn)\r\n        GImGui->IO.SetClipboardTextFn(GImGui->IO.ClipboardUserData, text);\r\n}\r\n\r\nconst char* ImGui::GetVersion()\r\n{\r\n    return IMGUI_VERSION;\r\n}\r\n\r\n// Internal state access - if you want to share ImGui state between modules (e.g. DLL) or allocate it yourself\r\n// Note that we still point to some static data and members (such as GFontAtlas), so the state instance you end up using will point to the static data within its module\r\nImGuiContext* ImGui::GetCurrentContext()\r\n{\r\n    return GImGui;\r\n}\r\n\r\nvoid ImGui::SetCurrentContext(ImGuiContext* ctx)\r\n{\r\n#ifdef IMGUI_SET_CURRENT_CONTEXT_FUNC\r\n    IMGUI_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you may want to have control over this.\r\n#else\r\n    GImGui = ctx;\r\n#endif\r\n}\r\n\r\nImGuiContext* ImGui::CreateContext(void* (*malloc_fn)(size_t), void (*free_fn)(void*))\r\n{\r\n    if (!malloc_fn) malloc_fn = malloc;\r\n    ImGuiContext* ctx = (ImGuiContext*)malloc_fn(sizeof(ImGuiContext));\r\n    IM_PLACEMENT_NEW(ctx) ImGuiContext();\r\n    ctx->IO.MemAllocFn = malloc_fn;\r\n    ctx->IO.MemFreeFn = free_fn ? free_fn : free;\r\n    return ctx;\r\n}\r\n\r\nvoid ImGui::DestroyContext(ImGuiContext* ctx)\r\n{\r\n    void (*free_fn)(void*) = ctx->IO.MemFreeFn;\r\n    ctx->~ImGuiContext();\r\n    free_fn(ctx);\r\n    if (GImGui == ctx)\r\n        SetCurrentContext(NULL);\r\n}\r\n\r\nImGuiIO& ImGui::GetIO()\r\n{\r\n    return GImGui->IO;\r\n}\r\n\r\nImGuiStyle& ImGui::GetStyle()\r\n{\r\n    return GImGui->Style;\r\n}\r\n\r\n// Same value as passed to your RenderDrawListsFn() function. valid after Render() and until the next call to NewFrame()\r\nImDrawData* ImGui::GetDrawData()\r\n{\r\n    return GImGui->RenderDrawData.Valid ? &GImGui->RenderDrawData : NULL;\r\n}\r\n\r\nfloat ImGui::GetTime()\r\n{\r\n    return GImGui->Time;\r\n}\r\n\r\nint ImGui::GetFrameCount()\r\n{\r\n    return GImGui->FrameCount;\r\n}\r\n\r\nImDrawList* ImGui::GetOverlayDrawList()\r\n{\r\n    return &GImGui->OverlayDrawList;\r\n}\r\n\r\nImDrawListSharedData* ImGui::GetDrawListSharedData()\r\n{\r\n    return &GImGui->DrawListSharedData;\r\n}\r\n\r\nvoid ImGui::NewFrame()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    // Check user data\r\n    // (We pass an error message in the assert expression as a trick to get it visible to programmers who are not using a debugger, as most assert handlers display their argument)\r\n    IM_ASSERT(g.IO.DeltaTime >= 0.0f                                    && \"Need a positive DeltaTime (zero is tolerated but will cause some timing issues)\");\r\n    IM_ASSERT(g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f  && \"Invalid DisplaySize value\");\r\n    IM_ASSERT(g.IO.Fonts->Fonts.Size > 0                                && \"Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?\");\r\n    IM_ASSERT(g.IO.Fonts->Fonts[0]->IsLoaded()                          && \"Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?\");\r\n    IM_ASSERT(g.Style.CurveTessellationTol > 0.0f                       && \"Invalid style setting\");\r\n    IM_ASSERT(g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f            && \"Invalid style setting. Alpha cannot be negative (allows us to avoid a few clamps in color computations)\");\r\n    IM_ASSERT((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount)  && \"Forgot to call Render() or EndFrame() at the end of the previous frame?\");\r\n\r\n    // Initialize on first frame\r\n    if (!g.Initialized)\r\n        Initialize();\r\n\r\n    SetCurrentFont(GetDefaultFont());\r\n    IM_ASSERT(g.Font->IsLoaded());\r\n    g.DrawListSharedData.ClipRectFullscreen = ImVec4(0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y);\r\n    g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;\r\n\r\n    g.Time += g.IO.DeltaTime;\r\n    g.FrameCount += 1;\r\n    g.TooltipOverrideCount = 0;\r\n    g.WindowsActiveCount = 0;\r\n    g.OverlayDrawList.Clear();\r\n    g.OverlayDrawList.PushTextureID(g.IO.Fonts->TexID);\r\n    g.OverlayDrawList.PushClipRectFullScreen();\r\n    g.OverlayDrawList.Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);\r\n\r\n    // Mark rendering data as invalid to prevent user who may have a handle on it to use it\r\n    g.RenderDrawData.Valid = false;\r\n    g.RenderDrawData.CmdLists = NULL;\r\n    g.RenderDrawData.CmdListsCount = g.RenderDrawData.TotalVtxCount = g.RenderDrawData.TotalIdxCount = 0;\r\n\r\n    // Clear reference to active widget if the widget isn't alive anymore\r\n    if (!g.HoveredIdPreviousFrame)\r\n        g.HoveredIdTimer = 0.0f;\r\n    g.HoveredIdPreviousFrame = g.HoveredId;\r\n    g.HoveredId = 0;\r\n    g.HoveredIdAllowOverlap = false;\r\n    if (!g.ActiveIdIsAlive && g.ActiveIdPreviousFrame == g.ActiveId && g.ActiveId != 0)\r\n        ClearActiveID();\r\n    if (g.ActiveId)\r\n        g.ActiveIdTimer += g.IO.DeltaTime;\r\n    g.ActiveIdPreviousFrame = g.ActiveId;\r\n    g.ActiveIdIsAlive = false;\r\n    g.ActiveIdIsJustActivated = false;\r\n    if (g.ScalarAsInputTextId && g.ActiveId != g.ScalarAsInputTextId)\r\n        g.ScalarAsInputTextId = 0;\r\n\r\n    // Elapse drag & drop payload\r\n    if (g.DragDropActive && g.DragDropPayload.DataFrameCount + 1 < g.FrameCount)\r\n    {\r\n        ClearDragDrop();\r\n        g.DragDropPayloadBufHeap.clear();\r\n        memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));\r\n    }\r\n    g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;\r\n    g.DragDropAcceptIdCurr = 0;\r\n    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;\r\n\r\n    // Update keyboard input state\r\n    memcpy(g.IO.KeysDownDurationPrev, g.IO.KeysDownDuration, sizeof(g.IO.KeysDownDuration));\r\n    for (int i = 0; i < IM_ARRAYSIZE(g.IO.KeysDown); i++)\r\n        g.IO.KeysDownDuration[i] = g.IO.KeysDown[i] ? (g.IO.KeysDownDuration[i] < 0.0f ? 0.0f : g.IO.KeysDownDuration[i] + g.IO.DeltaTime) : -1.0f;\r\n\r\n    // Update mouse input state\r\n    // If mouse just appeared or disappeared (usually denoted by -FLT_MAX component, but in reality we test for -256000.0f) we cancel out movement in MouseDelta\r\n    if (IsMousePosValid(&g.IO.MousePos) && IsMousePosValid(&g.IO.MousePosPrev))\r\n        g.IO.MouseDelta = g.IO.MousePos - g.IO.MousePosPrev;\r\n    else\r\n        g.IO.MouseDelta = ImVec2(0.0f, 0.0f);\r\n    g.IO.MousePosPrev = g.IO.MousePos;\r\n    for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)\r\n    {\r\n        g.IO.MouseClicked[i] = g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] < 0.0f;\r\n        g.IO.MouseReleased[i] = !g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] >= 0.0f;\r\n        g.IO.MouseDownDurationPrev[i] = g.IO.MouseDownDuration[i];\r\n        g.IO.MouseDownDuration[i] = g.IO.MouseDown[i] ? (g.IO.MouseDownDuration[i] < 0.0f ? 0.0f : g.IO.MouseDownDuration[i] + g.IO.DeltaTime) : -1.0f;\r\n        g.IO.MouseDoubleClicked[i] = false;\r\n        if (g.IO.MouseClicked[i])\r\n        {\r\n            if (g.Time - g.IO.MouseClickedTime[i] < g.IO.MouseDoubleClickTime)\r\n            {\r\n                if (ImLengthSqr(g.IO.MousePos - g.IO.MouseClickedPos[i]) < g.IO.MouseDoubleClickMaxDist * g.IO.MouseDoubleClickMaxDist)\r\n                    g.IO.MouseDoubleClicked[i] = true;\r\n                g.IO.MouseClickedTime[i] = -FLT_MAX;    // so the third click isn't turned into a double-click\r\n            }\r\n            else\r\n            {\r\n                g.IO.MouseClickedTime[i] = g.Time;\r\n            }\r\n            g.IO.MouseClickedPos[i] = g.IO.MousePos;\r\n            g.IO.MouseDragMaxDistanceAbs[i] = ImVec2(0.0f, 0.0f);\r\n            g.IO.MouseDragMaxDistanceSqr[i] = 0.0f;\r\n        }\r\n        else if (g.IO.MouseDown[i])\r\n        {\r\n            ImVec2 mouse_delta = g.IO.MousePos - g.IO.MouseClickedPos[i];\r\n            g.IO.MouseDragMaxDistanceAbs[i].x = ImMax(g.IO.MouseDragMaxDistanceAbs[i].x, mouse_delta.x < 0.0f ? -mouse_delta.x : mouse_delta.x);\r\n            g.IO.MouseDragMaxDistanceAbs[i].y = ImMax(g.IO.MouseDragMaxDistanceAbs[i].y, mouse_delta.y < 0.0f ? -mouse_delta.y : mouse_delta.y);\r\n            g.IO.MouseDragMaxDistanceSqr[i] = ImMax(g.IO.MouseDragMaxDistanceSqr[i], ImLengthSqr(mouse_delta));\r\n        }\r\n    }\r\n\r\n    // Calculate frame-rate for the user, as a purely luxurious feature\r\n    g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];\r\n    g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;\r\n    g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % IM_ARRAYSIZE(g.FramerateSecPerFrame);\r\n    g.IO.Framerate = 1.0f / (g.FramerateSecPerFrameAccum / (float)IM_ARRAYSIZE(g.FramerateSecPerFrame));\r\n\r\n    // Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering). Only valid for root windows.\r\n    if (g.MovingWindowMoveId && g.MovingWindowMoveId == g.ActiveId)\r\n    {\r\n        KeepAliveID(g.MovingWindowMoveId);\r\n        IM_ASSERT(g.MovingWindow && g.MovingWindow->RootWindow);\r\n        IM_ASSERT(g.MovingWindow->MoveId == g.MovingWindowMoveId);\r\n        if (g.IO.MouseDown[0])\r\n        {\r\n            ImVec2 pos = g.IO.MousePos - g.ActiveIdClickOffset;\r\n            if (g.MovingWindow->RootWindow->PosFloat.x != pos.x || g.MovingWindow->RootWindow->PosFloat.y != pos.y)\r\n                MarkIniSettingsDirty(g.MovingWindow->RootWindow);\r\n            g.MovingWindow->RootWindow->PosFloat = pos;\r\n            FocusWindow(g.MovingWindow);\r\n        }\r\n        else\r\n        {\r\n            ClearActiveID();\r\n            g.MovingWindow = NULL;\r\n            g.MovingWindowMoveId = 0;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        g.MovingWindow = NULL;\r\n        g.MovingWindowMoveId = 0;\r\n    }\r\n\r\n    // Delay saving settings so we don't spam disk too much\r\n    if (g.SettingsDirtyTimer > 0.0f)\r\n    {\r\n        g.SettingsDirtyTimer -= g.IO.DeltaTime;\r\n        if (g.SettingsDirtyTimer <= 0.0f)\r\n            SaveIniSettingsToDisk(g.IO.IniFilename);\r\n    }\r\n\r\n    // Find the window we are hovering\r\n    // - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.\r\n    // - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point.\r\n    // - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.\r\n    g.HoveredWindow = (g.MovingWindow && !(g.MovingWindow->Flags & ImGuiWindowFlags_NoInputs)) ? g.MovingWindow : FindHoveredWindow(g.IO.MousePos);\r\n    g.HoveredRootWindow = g.HoveredWindow ? g.HoveredWindow->RootWindow : NULL;\r\n\r\n    ImGuiWindow* modal_window = GetFrontMostModalRootWindow();\r\n    if (modal_window != NULL)\r\n    {\r\n        g.ModalWindowDarkeningRatio = ImMin(g.ModalWindowDarkeningRatio + g.IO.DeltaTime * 6.0f, 1.0f);\r\n        if (g.HoveredRootWindow && !IsWindowChildOf(g.HoveredRootWindow, modal_window))\r\n            g.HoveredRootWindow = g.HoveredWindow = NULL;\r\n    }\r\n    else\r\n    {\r\n        g.ModalWindowDarkeningRatio = 0.0f;\r\n    }\r\n\r\n    // Update the WantCaptureMouse/WantCAptureKeyboard flags, so user can capture/discard the inputs away from the rest of their application.\r\n    // When clicking outside of a window we assume the click is owned by the application and won't request capture. We need to track click ownership.\r\n    int mouse_earliest_button_down = -1;\r\n    bool mouse_any_down = false;\r\n    for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)\r\n    {\r\n        if (g.IO.MouseClicked[i])\r\n            g.IO.MouseDownOwned[i] = (g.HoveredWindow != NULL) || (!g.OpenPopupStack.empty());\r\n        mouse_any_down |= g.IO.MouseDown[i];\r\n        if (g.IO.MouseDown[i])\r\n            if (mouse_earliest_button_down == -1 || g.IO.MouseClickedTime[i] < g.IO.MouseClickedTime[mouse_earliest_button_down])\r\n                mouse_earliest_button_down = i;\r\n    }\r\n    bool mouse_avail_to_imgui = (mouse_earliest_button_down == -1) || g.IO.MouseDownOwned[mouse_earliest_button_down];\r\n    if (g.WantCaptureMouseNextFrame != -1)\r\n        g.IO.WantCaptureMouse = (g.WantCaptureMouseNextFrame != 0);\r\n    else\r\n        g.IO.WantCaptureMouse = (mouse_avail_to_imgui && (g.HoveredWindow != NULL || mouse_any_down)) || (!g.OpenPopupStack.empty());\r\n    if (g.WantCaptureKeyboardNextFrame != -1)\r\n        g.IO.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);\r\n    else\r\n        g.IO.WantCaptureKeyboard = (g.ActiveId != 0) || (modal_window != NULL);\r\n    g.IO.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : 0;\r\n    g.MouseCursor = ImGuiMouseCursor_Arrow;\r\n    g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame = -1;\r\n    g.OsImePosRequest = ImVec2(1.0f, 1.0f); // OS Input Method Editor showing on top-left of our window by default\r\n\r\n    // If mouse was first clicked outside of ImGui bounds we also cancel out hovering.\r\n    // FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)\r\n    bool mouse_dragging_extern_payload = g.DragDropActive && (g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) != 0;\r\n    if (!mouse_avail_to_imgui && !mouse_dragging_extern_payload)\r\n        g.HoveredWindow = g.HoveredRootWindow = NULL;\r\n\r\n    // Scale & Scrolling\r\n    if (g.HoveredWindow && g.IO.MouseWheel != 0.0f && !g.HoveredWindow->Collapsed)\r\n    {\r\n        ImGuiWindow* window = g.HoveredWindow;\r\n        if (g.IO.KeyCtrl && g.IO.FontAllowUserScaling)\r\n        {\r\n            // Zoom / Scale window\r\n            const float new_font_scale = ImClamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);\r\n            const float scale = new_font_scale / window->FontWindowScale;\r\n            window->FontWindowScale = new_font_scale;\r\n\r\n            const ImVec2 offset = window->Size * (1.0f - scale) * (g.IO.MousePos - window->Pos) / window->Size;\r\n            window->Pos += offset;\r\n            window->PosFloat += offset;\r\n            window->Size *= scale;\r\n            window->SizeFull *= scale;\r\n        }\r\n        else if (!g.IO.KeyCtrl)\r\n        {\r\n            // Mouse wheel Scrolling\r\n            // If a child window has the ImGuiWindowFlags_NoScrollWithMouse flag, we give a chance to scroll its parent (unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set).\r\n            ImGuiWindow* scroll_window = window;\r\n            while ((scroll_window->Flags & ImGuiWindowFlags_ChildWindow) && (scroll_window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(scroll_window->Flags & ImGuiWindowFlags_NoScrollbar) && !(scroll_window->Flags & ImGuiWindowFlags_NoInputs) && scroll_window->ParentWindow)\r\n                scroll_window = scroll_window->ParentWindow;\r\n\r\n            if (!(scroll_window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(scroll_window->Flags & ImGuiWindowFlags_NoInputs))\r\n            {\r\n                float scroll_amount = 5 * scroll_window->CalcFontSize();\r\n                scroll_amount = (float)(int)ImMin(scroll_amount, (scroll_window->ContentsRegionRect.GetHeight() + scroll_window->WindowPadding.y * 2.0f) * 0.67f);\r\n                SetWindowScrollY(scroll_window, scroll_window->Scroll.y - g.IO.MouseWheel * scroll_amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Pressing TAB activate widget focus\r\n    if (g.ActiveId == 0 && g.NavWindow != NULL && g.NavWindow->Active && IsKeyPressedMap(ImGuiKey_Tab, false))\r\n        g.NavWindow->FocusIdxTabRequestNext = 0;\r\n\r\n    // Mark all windows as not visible\r\n    for (int i = 0; i != g.Windows.Size; i++)\r\n    {\r\n        ImGuiWindow* window = g.Windows[i];\r\n        window->WasActive = window->Active;\r\n        window->Active = false;\r\n        window->WriteAccessed = false;\r\n    }\r\n\r\n    // Closing the focused window restore focus to the first active root window in descending z-order\r\n    if (g.NavWindow && !g.NavWindow->WasActive)\r\n        FocusPreviousWindow();\r\n\r\n    // No window should be open at the beginning of the frame.\r\n    // But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.\r\n    g.CurrentWindowStack.resize(0);\r\n    g.CurrentPopupStack.resize(0);\r\n    CloseInactivePopups(g.NavWindow);\r\n\r\n    // Create implicit window - we will only render it if the user has added something to it.\r\n    // We don't use \"Debug\" to avoid colliding with user trying to create a \"Debug\" window with custom flags.\r\n    SetNextWindowSize(ImVec2(400,400), ImGuiCond_FirstUseEver);\r\n    Begin(\"Debug##Default\");\r\n}\r\n\r\nstatic void* SettingsHandlerWindow_ReadOpen(ImGuiContext&, const char* name)\r\n{\r\n    ImGuiWindowSettings* settings = ImGui::FindWindowSettings(ImHash(name, 0));\r\n    if (!settings)\r\n        settings = AddWindowSettings(name);\r\n    return (void*)settings;\r\n}\r\n\r\nstatic void SettingsHandlerWindow_ReadLine(ImGuiContext&, void* entry, const char* line)\r\n{\r\n    ImGuiWindowSettings* settings = (ImGuiWindowSettings*)entry;\r\n    float x, y; \r\n    int i;\r\n    if (sscanf(line, \"Pos=%f,%f\", &x, &y) == 2)         settings->Pos = ImVec2(x, y);\r\n    else if (sscanf(line, \"Size=%f,%f\", &x, &y) == 2)   settings->Size = ImMax(ImVec2(x, y), GImGui->Style.WindowMinSize);\r\n    else if (sscanf(line, \"Collapsed=%d\", &i) == 1)     settings->Collapsed = (i != 0);\r\n}\r\n\r\nstatic void SettingsHandlerWindow_WriteAll(ImGuiContext& g, ImGuiTextBuffer* buf)\r\n{\r\n    // Gather data from windows that were active during this session\r\n    for (int i = 0; i != g.Windows.Size; i++)\r\n    {\r\n        ImGuiWindow* window = g.Windows[i];\r\n        if (window->Flags & ImGuiWindowFlags_NoSavedSettings)\r\n            continue;\r\n        ImGuiWindowSettings* settings = ImGui::FindWindowSettings(window->ID);\r\n        if (!settings)\r\n            settings = AddWindowSettings(window->Name);\r\n        settings->Pos = window->Pos;\r\n        settings->Size = window->SizeFull;\r\n        settings->Collapsed = window->Collapsed;\r\n    }\r\n\r\n    // Write a buffer\r\n    // If a window wasn't opened in this session we preserve its settings\r\n    buf->reserve(buf->size() + g.SettingsWindows.Size * 96); // ballpark reserve\r\n    for (int i = 0; i != g.SettingsWindows.Size; i++)\r\n    {\r\n        const ImGuiWindowSettings* settings = &g.SettingsWindows[i];\r\n        if (settings->Pos.x == FLT_MAX)\r\n            continue;\r\n        const char* name = settings->Name;\r\n        if (const char* p = strstr(name, \"###\"))  // Skip to the \"###\" marker if any. We don't skip past to match the behavior of GetID()\r\n            name = p;\r\n        buf->appendf(\"[Window][%s]\\n\", name);\r\n        buf->appendf(\"Pos=%d,%d\\n\", (int)settings->Pos.x, (int)settings->Pos.y);\r\n        buf->appendf(\"Size=%d,%d\\n\", (int)settings->Size.x, (int)settings->Size.y);\r\n        buf->appendf(\"Collapsed=%d\\n\", settings->Collapsed);\r\n        buf->appendf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid ImGui::Initialize()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.LogClipboard = IM_NEW(ImGuiTextBuffer)();\r\n\r\n    // Add .ini handle for ImGuiWindow type\r\n    ImGuiSettingsHandler ini_handler;\r\n    ini_handler.TypeName = \"Window\";\r\n    ini_handler.TypeHash = ImHash(\"Window\", 0, 0);\r\n    ini_handler.ReadOpenFn = SettingsHandlerWindow_ReadOpen;\r\n    ini_handler.ReadLineFn = SettingsHandlerWindow_ReadLine;\r\n    ini_handler.WriteAllFn = SettingsHandlerWindow_WriteAll;\r\n    g.SettingsHandlers.push_front(ini_handler);\r\n\r\n    // Load .ini file\r\n    IM_ASSERT(g.SettingsWindows.empty());\r\n    LoadIniSettingsFromDisk(g.IO.IniFilename);\r\n    g.Initialized = true;\r\n}\r\n\r\n// This function is merely here to free heap allocations.\r\nvoid ImGui::Shutdown()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    // The fonts atlas can be used prior to calling NewFrame(), so we clear it even if g.Initialized is FALSE (which would happen if we never called NewFrame)\r\n    if (g.IO.Fonts) // Testing for NULL to allow user to NULLify in case of running Shutdown() on multiple contexts. Bit hacky.\r\n        g.IO.Fonts->Clear();\r\n\r\n    // Cleanup of other data are conditional on actually having initialize ImGui.\r\n    if (!g.Initialized)\r\n        return;\r\n\r\n    SaveIniSettingsToDisk(g.IO.IniFilename);\r\n\r\n    for (int i = 0; i < g.Windows.Size; i++)\r\n        IM_DELETE(g.Windows[i]);\r\n    g.Windows.clear();\r\n    g.WindowsSortBuffer.clear();\r\n    g.CurrentWindow = NULL;\r\n    g.CurrentWindowStack.clear();\r\n    g.WindowsById.Clear();\r\n    g.NavWindow = NULL;\r\n    g.HoveredWindow = NULL;\r\n    g.HoveredRootWindow = NULL;\r\n    g.ActiveIdWindow = NULL;\r\n    g.MovingWindow = NULL;\r\n    for (int i = 0; i < g.SettingsWindows.Size; i++)\r\n        IM_DELETE(g.SettingsWindows[i].Name);\r\n    g.ColorModifiers.clear();\r\n    g.StyleModifiers.clear();\r\n    g.FontStack.clear();\r\n    g.OpenPopupStack.clear();\r\n    g.CurrentPopupStack.clear();\r\n    g.SetNextWindowSizeConstraintCallback = NULL;\r\n    g.SetNextWindowSizeConstraintCallbackUserData = NULL;\r\n    for (int i = 0; i < IM_ARRAYSIZE(g.RenderDrawLists); i++)\r\n        g.RenderDrawLists[i].clear();\r\n    g.OverlayDrawList.ClearFreeMemory();\r\n    g.PrivateClipboard.clear();\r\n    g.InputTextState.Text.clear();\r\n    g.InputTextState.InitialText.clear();\r\n    g.InputTextState.TempTextBuffer.clear();\r\n\r\n    g.SettingsWindows.clear();\r\n    g.SettingsHandlers.clear();\r\n\r\n    if (g.LogFile && g.LogFile != stdout)\r\n    {\r\n        fclose(g.LogFile);\r\n        g.LogFile = NULL;\r\n    }\r\n    if (g.LogClipboard)\r\n        IM_DELETE(g.LogClipboard);\r\n\r\n    g.Initialized = false;\r\n}\r\n\r\nImGuiWindowSettings* ImGui::FindWindowSettings(ImGuiID id)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    for (int i = 0; i != g.SettingsWindows.Size; i++)\r\n        if (g.SettingsWindows[i].Id == id)\r\n            return &g.SettingsWindows[i];\r\n    return NULL;\r\n}\r\n\r\nstatic ImGuiWindowSettings* AddWindowSettings(const char* name)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.SettingsWindows.push_back(ImGuiWindowSettings());\r\n    ImGuiWindowSettings* settings = &g.SettingsWindows.back();\r\n    settings->Name = ImStrdup(name);\r\n    settings->Id = ImHash(name, 0);\r\n    return settings;\r\n}\r\n\r\nstatic void LoadIniSettingsFromDisk(const char* ini_filename)\r\n{\r\n    if (!ini_filename)\r\n        return;\r\n    char* file_data = (char*)ImFileLoadToMemory(ini_filename, \"rb\", NULL, +1);\r\n    if (!file_data)\r\n        return;\r\n    LoadIniSettingsFromMemory(file_data);\r\n    ImGui::MemFree(file_data);\r\n}\r\n\r\nImGuiSettingsHandler* ImGui::FindSettingsHandler(ImGuiID type_hash)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)\r\n        if (g.SettingsHandlers[handler_n].TypeHash == type_hash)\r\n            return &g.SettingsHandlers[handler_n];\r\n    return NULL;\r\n}\r\n\r\n// Zero-tolerance, no error reporting, cheap .ini parsing\r\nstatic void LoadIniSettingsFromMemory(const char* buf_readonly)\r\n{\r\n    // For convenience and to make the code simpler, we'll write zero terminators inside the buffer. So let's create a writable copy.\r\n    char* buf = ImStrdup(buf_readonly);\r\n    char* buf_end = buf + strlen(buf);\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    void* entry_data = NULL;\r\n    const ImGuiSettingsHandler* entry_handler = NULL;\r\n\r\n    char* line_end = NULL;\r\n    for (char* line = buf; line < buf_end; line = line_end + 1)\r\n    {\r\n        // Skip new lines markers, then find end of the line\r\n        while (*line == '\\n' || *line == '\\r')\r\n            line++;\r\n        line_end = line;\r\n        while (line_end < buf_end && *line_end != '\\n' && *line_end != '\\r')\r\n            line_end++;\r\n        line_end[0] = 0;\r\n\r\n        if (line[0] == '[' && line_end > line && line_end[-1] == ']')\r\n        {\r\n            // Parse \"[Type][Name]\". Note that 'Name' can itself contains [] characters, which is acceptable with the current format and parsing code.\r\n            line_end[-1] = 0;\r\n            const char* name_end = line_end - 1; \r\n            const char* type_start = line + 1;\r\n            char* type_end = ImStrchrRange(type_start, name_end, ']');\r\n            const char* name_start = type_end ? ImStrchrRange(type_end + 1, name_end, '[') : NULL;\r\n            if (!type_end || !name_start)\r\n            {\r\n                name_start = type_start; // Import legacy entries that have no type\r\n                type_start = \"Window\";\r\n            }\r\n            else\r\n            {\r\n                *type_end = 0; // Overwrite first ']' \r\n                name_start++;  // Skip second '['\r\n            }\r\n            const ImGuiID type_hash = ImHash(type_start, 0, 0);\r\n            entry_handler = ImGui::FindSettingsHandler(type_hash);\r\n            entry_data = entry_handler ? entry_handler->ReadOpenFn(g, name_start) : NULL;\r\n        }\r\n        else if (entry_handler != NULL && entry_data != NULL)\r\n        {\r\n            // Let type handler parse the line\r\n            entry_handler->ReadLineFn(g, entry_data, line);\r\n        }\r\n    }\r\n    ImGui::MemFree(buf);\r\n}\r\n\r\nstatic void SaveIniSettingsToDisk(const char* ini_filename)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.SettingsDirtyTimer = 0.0f;\r\n    if (!ini_filename)\r\n        return;\r\n\r\n    ImVector<char> buf;\r\n    SaveIniSettingsToMemory(buf);\r\n\r\n    FILE* f = ImFileOpen(ini_filename, \"wt\");\r\n    if (!f)\r\n        return;\r\n    fwrite(buf.Data, sizeof(char), (size_t)buf.Size, f);\r\n    fclose(f);\r\n}\r\n\r\nstatic void SaveIniSettingsToMemory(ImVector<char>& out_buf)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.SettingsDirtyTimer = 0.0f;\r\n\r\n    ImGuiTextBuffer buf;\r\n    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)\r\n        g.SettingsHandlers[handler_n].WriteAllFn(g, &buf);\r\n\r\n    buf.Buf.pop_back(); // Remove extra zero-terminator used by ImGuiTextBuffer\r\n    out_buf.swap(buf.Buf);\r\n}\r\n\r\nvoid ImGui::MarkIniSettingsDirty()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.SettingsDirtyTimer <= 0.0f)\r\n        g.SettingsDirtyTimer = g.IO.IniSavingRate;\r\n}\r\n\r\nstatic void MarkIniSettingsDirty(ImGuiWindow* window)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (!(window->Flags & ImGuiWindowFlags_NoSavedSettings))\r\n        if (g.SettingsDirtyTimer <= 0.0f)\r\n            g.SettingsDirtyTimer = g.IO.IniSavingRate;\r\n}\r\n\r\n// FIXME: Add a more explicit sort order in the window structure.\r\nstatic int ChildWindowComparer(const void* lhs, const void* rhs)\r\n{\r\n    const ImGuiWindow* a = *(const ImGuiWindow**)lhs;\r\n    const ImGuiWindow* b = *(const ImGuiWindow**)rhs;\r\n    if (int d = (a->Flags & ImGuiWindowFlags_Popup) - (b->Flags & ImGuiWindowFlags_Popup))\r\n        return d;\r\n    if (int d = (a->Flags & ImGuiWindowFlags_Tooltip) - (b->Flags & ImGuiWindowFlags_Tooltip))\r\n        return d;\r\n    return (a->BeginOrderWithinParent - b->BeginOrderWithinParent);\r\n}\r\n\r\nstatic void AddWindowToSortedBuffer(ImVector<ImGuiWindow*>& out_sorted_windows, ImGuiWindow* window)\r\n{\r\n    out_sorted_windows.push_back(window);\r\n    if (window->Active)\r\n    {\r\n        int count = window->DC.ChildWindows.Size;\r\n        if (count > 1)\r\n            qsort(window->DC.ChildWindows.begin(), (size_t)count, sizeof(ImGuiWindow*), ChildWindowComparer);\r\n        for (int i = 0; i < count; i++)\r\n        {\r\n            ImGuiWindow* child = window->DC.ChildWindows[i];\r\n            if (child->Active)\r\n                AddWindowToSortedBuffer(out_sorted_windows, child);\r\n        }\r\n    }\r\n}\r\n\r\nstatic void AddDrawListToRenderList(ImVector<ImDrawList*>& out_render_list, ImDrawList* draw_list)\r\n{\r\n    if (draw_list->CmdBuffer.empty())\r\n        return;\r\n\r\n    // Remove trailing command if unused\r\n    ImDrawCmd& last_cmd = draw_list->CmdBuffer.back();\r\n    if (last_cmd.ElemCount == 0 && last_cmd.UserCallback == NULL)\r\n    {\r\n        draw_list->CmdBuffer.pop_back();\r\n        if (draw_list->CmdBuffer.empty())\r\n            return;\r\n    }\r\n\r\n    // Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc. May trigger for you if you are using PrimXXX functions incorrectly.\r\n    IM_ASSERT(draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);\r\n    IM_ASSERT(draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);\r\n    IM_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);\r\n\r\n    // Check that draw_list doesn't use more vertices than indexable in a single draw call (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)\r\n    // If this assert triggers because you are drawing lots of stuff manually:\r\n    // A) Make sure you are coarse clipping, because ImDrawList let all your vertices pass. You can use thre Metrics window to inspect draw list contents.\r\n    // B) If you need/want meshes with more than 64K vertices, uncomment the '#define ImDrawIdx unsigned int' line in imconfig.h to set the index size to 4 bytes. \r\n    //    You'll need to handle the 4-bytes indices to your renderer. For example, the OpenGL example code detect index size at compile-time by doing:\r\n    //      glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);\r\n    //    Your own engine or render API may use different parameters or function calls to specify index sizes. 2 and 4 bytes indices are generally supported by most API.\r\n    // C) If for some reason you cannot use 4 bytes indices or don't want to, a workaround is to call BeginChild()/EndChild() before reaching the 64K limit to split your draw commands in multiple draw lists.\r\n    if (sizeof(ImDrawIdx) == 2)\r\n        IM_ASSERT(draw_list->_VtxCurrentIdx < (1 << 16) && \"Too many vertices in ImDrawList using 16-bit indices. Read comment above\");\r\n\r\n    out_render_list.push_back(draw_list);\r\n    GImGui->IO.MetricsRenderVertices += draw_list->VtxBuffer.Size;\r\n    GImGui->IO.MetricsRenderIndices += draw_list->IdxBuffer.Size;\r\n}\r\n\r\nstatic void AddWindowToRenderList(ImVector<ImDrawList*>& out_render_list, ImGuiWindow* window)\r\n{\r\n    AddDrawListToRenderList(out_render_list, window->DrawList);\r\n    for (int i = 0; i < window->DC.ChildWindows.Size; i++)\r\n    {\r\n        ImGuiWindow* child = window->DC.ChildWindows[i];\r\n        if (!child->Active) // clipped children may have been marked not active\r\n            continue;\r\n        if ((child->Flags & ImGuiWindowFlags_Popup) && child->HiddenFrames > 0)\r\n            continue;\r\n        AddWindowToRenderList(out_render_list, child);\r\n    }\r\n}\r\n\r\nstatic void AddWindowToRenderListSelectLayer(ImGuiWindow* window)\r\n{\r\n    // FIXME: Generalize this with a proper layering system so e.g. user can draw in specific layers, below text, ..\r\n    ImGuiContext& g = *GImGui;\r\n    g.IO.MetricsActiveWindows++;\r\n    if (window->Flags & ImGuiWindowFlags_Popup)\r\n        AddWindowToRenderList(g.RenderDrawLists[1], window);\r\n    else if (window->Flags & ImGuiWindowFlags_Tooltip)\r\n        AddWindowToRenderList(g.RenderDrawLists[2], window);\r\n    else\r\n        AddWindowToRenderList(g.RenderDrawLists[0], window);\r\n}\r\n\r\n// When using this function it is sane to ensure that float are perfectly rounded to integer values, to that e.g. (int)(max.x-min.x) in user's render produce correct result.\r\nvoid ImGui::PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);\r\n    window->ClipRect = window->DrawList->_ClipRectStack.back();\r\n}\r\n\r\nvoid ImGui::PopClipRect()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DrawList->PopClipRect();\r\n    window->ClipRect = window->DrawList->_ClipRectStack.back();\r\n}\r\n\r\n// This is normally called by Render(). You may want to call it directly if you want to avoid calling Render() but the gain will be very minimal.\r\nvoid ImGui::EndFrame()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(g.Initialized);                       // Forgot to call ImGui::NewFrame()\r\n    if (g.FrameCountEnded == g.FrameCount)          // Don't process EndFrame() multiple times.\r\n        return;\r\n\r\n    // Notify OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)\r\n    if (g.IO.ImeSetInputScreenPosFn && ImLengthSqr(g.OsImePosRequest - g.OsImePosSet) > 0.0001f)\r\n    {\r\n        g.IO.ImeSetInputScreenPosFn((int)g.OsImePosRequest.x, (int)g.OsImePosRequest.y);\r\n        g.OsImePosSet = g.OsImePosRequest;\r\n    }\r\n\r\n    // Hide implicit \"Debug\" window if it hasn't been used\r\n    IM_ASSERT(g.CurrentWindowStack.Size == 1);    // Mismatched Begin()/End() calls\r\n    if (g.CurrentWindow && !g.CurrentWindow->WriteAccessed)\r\n        g.CurrentWindow->Active = false;\r\n    ImGui::End();\r\n\r\n    if (g.ActiveId == 0 && g.HoveredId == 0)\r\n    {\r\n        if (!g.NavWindow || !g.NavWindow->Appearing) // Unless we just made a window/popup appear\r\n        {\r\n            // Click to focus window and start moving (after we're done with all our widgets)\r\n            if (g.IO.MouseClicked[0])\r\n            {\r\n                if (g.HoveredRootWindow != NULL)\r\n                {\r\n                    FocusWindow(g.HoveredWindow);\r\n                    if (!(g.HoveredWindow->Flags & ImGuiWindowFlags_NoMove) && !(g.HoveredRootWindow->Flags & ImGuiWindowFlags_NoMove))\r\n                    {\r\n                        g.MovingWindow = g.HoveredWindow;\r\n                        g.MovingWindowMoveId = g.MovingWindow->MoveId;\r\n                        SetActiveID(g.MovingWindowMoveId, g.HoveredRootWindow);\r\n                        g.ActiveIdClickOffset = g.IO.MousePos - g.MovingWindow->RootWindow->Pos;\r\n                    }\r\n                }\r\n                else if (g.NavWindow != NULL && GetFrontMostModalRootWindow() == NULL)\r\n                {\r\n                    // Clicking on void disable focus\r\n                    FocusWindow(NULL);\r\n                }\r\n            }\r\n\r\n            // With right mouse button we close popups without changing focus\r\n            // (The left mouse button path calls FocusWindow which will lead NewFrame->CloseInactivePopups to trigger)\r\n            if (g.IO.MouseClicked[1])\r\n            {\r\n                // Find the top-most window between HoveredWindow and the front most Modal Window.\r\n                // This is where we can trim the popup stack.\r\n                ImGuiWindow* modal = GetFrontMostModalRootWindow();\r\n                bool hovered_window_above_modal = false;\r\n                if (modal == NULL)\r\n                    hovered_window_above_modal = true;\r\n                for (int i = g.Windows.Size - 1; i >= 0 && hovered_window_above_modal == false; i--)\r\n                {\r\n                    ImGuiWindow* window = g.Windows[i];\r\n                    if (window == modal)\r\n                        break;\r\n                    if (window == g.HoveredWindow)\r\n                        hovered_window_above_modal = true;\r\n                }\r\n                CloseInactivePopups(hovered_window_above_modal ? g.HoveredWindow : modal);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sort the window list so that all child windows are after their parent\r\n    // We cannot do that on FocusWindow() because childs may not exist yet\r\n    g.WindowsSortBuffer.resize(0);\r\n    g.WindowsSortBuffer.reserve(g.Windows.Size);\r\n    for (int i = 0; i != g.Windows.Size; i++)\r\n    {\r\n        ImGuiWindow* window = g.Windows[i];\r\n        if (window->Active && (window->Flags & ImGuiWindowFlags_ChildWindow))       // if a child is active its parent will add it\r\n            continue;\r\n        AddWindowToSortedBuffer(g.WindowsSortBuffer, window);\r\n    }\r\n\r\n    IM_ASSERT(g.Windows.Size == g.WindowsSortBuffer.Size);  // we done something wrong\r\n    g.Windows.swap(g.WindowsSortBuffer);\r\n\r\n    // Clear Input data for next frame\r\n    g.IO.MouseWheel = 0.0f;\r\n    memset(g.IO.InputCharacters, 0, sizeof(g.IO.InputCharacters));\r\n\r\n    g.FrameCountEnded = g.FrameCount;\r\n}\r\n\r\nvoid ImGui::Render()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(g.Initialized);   // Forgot to call ImGui::NewFrame()\r\n\r\n    if (g.FrameCountEnded != g.FrameCount)\r\n        ImGui::EndFrame();\r\n    g.FrameCountRendered = g.FrameCount;\r\n\r\n    // Skip render altogether if alpha is 0.0\r\n    // Note that vertex buffers have been created and are wasted, so it is best practice that you don't create windows in the first place, or consistently respond to Begin() returning false.\r\n    if (g.Style.Alpha > 0.0f)\r\n    {\r\n        // Gather windows to render\r\n        g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = g.IO.MetricsActiveWindows = 0;\r\n        for (int i = 0; i < IM_ARRAYSIZE(g.RenderDrawLists); i++)\r\n            g.RenderDrawLists[i].resize(0);\r\n        for (int i = 0; i != g.Windows.Size; i++)\r\n        {\r\n            ImGuiWindow* window = g.Windows[i];\r\n            if (window->Active && window->HiddenFrames <= 0 && (window->Flags & (ImGuiWindowFlags_ChildWindow)) == 0)\r\n                AddWindowToRenderListSelectLayer(window);\r\n        }\r\n\r\n        // Flatten layers\r\n        int n = g.RenderDrawLists[0].Size;\r\n        int flattened_size = n;\r\n        for (int i = 1; i < IM_ARRAYSIZE(g.RenderDrawLists); i++)\r\n            flattened_size += g.RenderDrawLists[i].Size;\r\n        g.RenderDrawLists[0].resize(flattened_size);\r\n        for (int i = 1; i < IM_ARRAYSIZE(g.RenderDrawLists); i++)\r\n        {\r\n            ImVector<ImDrawList*>& layer = g.RenderDrawLists[i];\r\n            if (layer.empty())\r\n                continue;\r\n            memcpy(&g.RenderDrawLists[0][n], &layer[0], layer.Size * sizeof(ImDrawList*));\r\n            n += layer.Size;\r\n        }\r\n\r\n        // Draw software mouse cursor if requested\r\n        if (g.IO.MouseDrawCursor)\r\n        {\r\n            const ImGuiMouseCursorData& cursor_data = g.MouseCursorData[g.MouseCursor];\r\n            const ImVec2 pos = g.IO.MousePos - cursor_data.HotOffset;\r\n            const ImVec2 size = cursor_data.Size;\r\n            const ImTextureID tex_id = g.IO.Fonts->TexID;\r\n            g.OverlayDrawList.PushTextureID(tex_id);\r\n            g.OverlayDrawList.AddImage(tex_id, pos+ImVec2(1,0), pos+ImVec2(1,0) + size, cursor_data.TexUvMin[1], cursor_data.TexUvMax[1], IM_COL32(0,0,0,48));        // Shadow\r\n            g.OverlayDrawList.AddImage(tex_id, pos+ImVec2(2,0), pos+ImVec2(2,0) + size, cursor_data.TexUvMin[1], cursor_data.TexUvMax[1], IM_COL32(0,0,0,48));        // Shadow\r\n            g.OverlayDrawList.AddImage(tex_id, pos,             pos + size,             cursor_data.TexUvMin[1], cursor_data.TexUvMax[1], IM_COL32(0,0,0,255));       // Black border\r\n            g.OverlayDrawList.AddImage(tex_id, pos,             pos + size,             cursor_data.TexUvMin[0], cursor_data.TexUvMax[0], IM_COL32(255,255,255,255)); // White fill\r\n            g.OverlayDrawList.PopTextureID();\r\n        }\r\n        if (!g.OverlayDrawList.VtxBuffer.empty())\r\n            AddDrawListToRenderList(g.RenderDrawLists[0], &g.OverlayDrawList);\r\n\r\n        // Setup draw data\r\n        g.RenderDrawData.Valid = true;\r\n        g.RenderDrawData.CmdLists = (g.RenderDrawLists[0].Size > 0) ? &g.RenderDrawLists[0][0] : NULL;\r\n        g.RenderDrawData.CmdListsCount = g.RenderDrawLists[0].Size;\r\n        g.RenderDrawData.TotalVtxCount = g.IO.MetricsRenderVertices;\r\n        g.RenderDrawData.TotalIdxCount = g.IO.MetricsRenderIndices;\r\n\r\n        // Render. If user hasn't set a callback then they may retrieve the draw data via GetDrawData()\r\n        if (g.RenderDrawData.CmdListsCount > 0 && g.IO.RenderDrawListsFn != NULL)\r\n            g.IO.RenderDrawListsFn(&g.RenderDrawData);\r\n    }\r\n}\r\n\r\nconst char* ImGui::FindRenderedTextEnd(const char* text, const char* text_end)\r\n{\r\n    const char* text_display_end = text;\r\n    if (!text_end)\r\n        text_end = (const char*)-1;\r\n\r\n    while (text_display_end < text_end && *text_display_end != '\\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))\r\n        text_display_end++;\r\n    return text_display_end;\r\n}\r\n\r\n// Pass text data straight to log (without being displayed)\r\nvoid ImGui::LogText(const char* fmt, ...)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (!g.LogEnabled)\r\n        return;\r\n\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    if (g.LogFile)\r\n    {\r\n        vfprintf(g.LogFile, fmt, args);\r\n    }\r\n    else\r\n    {\r\n        g.LogClipboard->appendfv(fmt, args);\r\n    }\r\n    va_end(args);\r\n}\r\n\r\n// Internal version that takes a position to decide on newline placement and pad items according to their depth.\r\n// We split text into individual lines to add current tree level padding\r\nstatic void LogRenderedText(const ImVec2* ref_pos, const char* text, const char* text_end = NULL)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    if (!text_end)\r\n        text_end = ImGui::FindRenderedTextEnd(text, text_end);\r\n\r\n    const bool log_new_line = ref_pos && (ref_pos->y > window->DC.LogLinePosY + 1);\r\n    if (ref_pos)\r\n        window->DC.LogLinePosY = ref_pos->y;\r\n\r\n    const char* text_remaining = text;\r\n    if (g.LogStartDepth > window->DC.TreeDepth)  // Re-adjust padding if we have popped out of our starting depth\r\n        g.LogStartDepth = window->DC.TreeDepth;\r\n    const int tree_depth = (window->DC.TreeDepth - g.LogStartDepth);\r\n    for (;;)\r\n    {\r\n        // Split the string. Each new line (after a '\\n') is followed by spacing corresponding to the current depth of our log entry.\r\n        const char* line_end = text_remaining;\r\n        while (line_end < text_end)\r\n            if (*line_end == '\\n')\r\n                break;\r\n            else\r\n                line_end++;\r\n        if (line_end >= text_end)\r\n            line_end = NULL;\r\n\r\n        const bool is_first_line = (text == text_remaining);\r\n        bool is_last_line = false;\r\n        if (line_end == NULL)\r\n        {\r\n            is_last_line = true;\r\n            line_end = text_end;\r\n        }\r\n        if (line_end != NULL && !(is_last_line && (line_end - text_remaining)==0))\r\n        {\r\n            const int char_count = (int)(line_end - text_remaining);\r\n            if (log_new_line || !is_first_line)\r\n                ImGui::LogText(IM_NEWLINE \"%*s%.*s\", tree_depth*4, \"\", char_count, text_remaining);\r\n            else\r\n                ImGui::LogText(\" %.*s\", char_count, text_remaining);\r\n        }\r\n\r\n        if (is_last_line)\r\n            break;\r\n        text_remaining = line_end + 1;\r\n    }\r\n}\r\n\r\n// Internal ImGui functions to render text\r\n// RenderText***() functions calls ImDrawList::AddText() calls ImBitmapFont::RenderText()\r\nvoid ImGui::RenderText(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    // Hide anything after a '##' string\r\n    const char* text_display_end;\r\n    if (hide_text_after_hash)\r\n    {\r\n        text_display_end = FindRenderedTextEnd(text, text_end);\r\n    }\r\n    else\r\n    {\r\n        if (!text_end)\r\n            text_end = text + strlen(text); // FIXME-OPT\r\n        text_display_end = text_end;\r\n    }\r\n\r\n    const int text_len = (int)(text_display_end - text);\r\n    if (text_len > 0)\r\n    {\r\n        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end);\r\n        if (g.LogEnabled)\r\n            LogRenderedText(&pos, text, text_display_end);\r\n    }\r\n}\r\n\r\nvoid ImGui::RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    if (!text_end)\r\n        text_end = text + strlen(text); // FIXME-OPT\r\n\r\n    const int text_len = (int)(text_end - text);\r\n    if (text_len > 0)\r\n    {\r\n        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_end, wrap_width);\r\n        if (g.LogEnabled)\r\n            LogRenderedText(&pos, text, text_end);\r\n    }\r\n}\r\n\r\n// Default clip_rect uses (pos_min,pos_max)\r\n// Handle clipping on CPU immediately (vs typically let the GPU clip the triangles that are overlapping the clipping rectangle edges)\r\nvoid ImGui::RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)\r\n{\r\n    // Hide anything after a '##' string\r\n    const char* text_display_end = FindRenderedTextEnd(text, text_end);\r\n    const int text_len = (int)(text_display_end - text);\r\n    if (text_len == 0)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    // Perform CPU side clipping for single clipped element to avoid using scissor state\r\n    ImVec2 pos = pos_min;\r\n    const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_display_end, false, 0.0f);\r\n\r\n    const ImVec2* clip_min = clip_rect ? &clip_rect->Min : &pos_min;\r\n    const ImVec2* clip_max = clip_rect ? &clip_rect->Max : &pos_max;\r\n    bool need_clipping = (pos.x + text_size.x >= clip_max->x) || (pos.y + text_size.y >= clip_max->y);\r\n    if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min\r\n        need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);\r\n\r\n    // Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.\r\n    if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);\r\n    if (align.y > 0.0f) pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);\r\n\r\n    // Render\r\n    if (need_clipping)\r\n    {\r\n        ImVec4 fine_clip_rect(clip_min->x, clip_min->y, clip_max->x, clip_max->y);\r\n        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);\r\n    }\r\n    else\r\n    {\r\n        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, NULL);\r\n    }\r\n    if (g.LogEnabled)\r\n        LogRenderedText(&pos, text, text_display_end);\r\n}\r\n\r\n// Render a rectangle shaped with optional rounding and borders\r\nvoid ImGui::RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);\r\n    const float border_size = g.Style.FrameBorderSize;\r\n    if (border && border_size > 0.0f)\r\n    {\r\n        window->DrawList->AddRect(p_min+ImVec2(1,1), p_max+ImVec2(1,1), GetColorU32(ImGuiCol_BorderShadow), rounding, ImDrawCornerFlags_All, border_size);\r\n        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, ImDrawCornerFlags_All, border_size);\r\n    }\r\n}\r\n\r\nvoid ImGui::RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    const float border_size = g.Style.FrameBorderSize;\r\n    if (border_size > 0.0f)\r\n    {\r\n        window->DrawList->AddRect(p_min+ImVec2(1,1), p_max+ImVec2(1,1), GetColorU32(ImGuiCol_BorderShadow), rounding, ImDrawCornerFlags_All, border_size);\r\n        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, ImDrawCornerFlags_All, border_size);\r\n    }\r\n}\r\n\r\n// Render a triangle to denote expanded/collapsed state\r\nvoid ImGui::RenderTriangle(ImVec2 p_min, ImGuiDir dir, float scale)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    const float h = g.FontSize * 1.00f;\r\n    float r = h * 0.40f * scale;\r\n    ImVec2 center = p_min + ImVec2(h * 0.50f, h * 0.50f * scale);\r\n\r\n    ImVec2 a, b, c;\r\n    switch (dir)\r\n    {\r\n    case ImGuiDir_Up:\r\n    case ImGuiDir_Down:\r\n        if (dir == ImGuiDir_Up) r = -r;\r\n        center.y -= r * 0.25f;\r\n        a = ImVec2(0,1) * r;\r\n        b = ImVec2(-0.866f,-0.5f) * r;\r\n        c = ImVec2(+0.866f,-0.5f) * r;\r\n        break;\r\n    case ImGuiDir_Left:\r\n    case ImGuiDir_Right:\r\n        if (dir == ImGuiDir_Left) r = -r;\r\n        center.x -= r * 0.25f;\r\n        a = ImVec2(1,0) * r;\r\n        b = ImVec2(-0.500f,+0.866f) * r;\r\n        c = ImVec2(-0.500f,-0.866f) * r;\r\n        break;\r\n    case ImGuiDir_None: \r\n    case ImGuiDir_Count_: \r\n        IM_ASSERT(0);\r\n        break;\r\n    }\r\n\r\n    window->DrawList->AddTriangleFilled(center + a, center + b, center + c, GetColorU32(ImGuiCol_Text));\r\n}\r\n\r\nvoid ImGui::RenderBullet(ImVec2 pos)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    window->DrawList->AddCircleFilled(pos, GImGui->FontSize*0.20f, GetColorU32(ImGuiCol_Text), 8);\r\n}\r\n\r\nvoid ImGui::RenderCheckMark(ImVec2 pos, ImU32 col, float sz)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    float thickness = ImMax(sz / 5.0f, 1.0f);\r\n    sz -= thickness*0.5f;\r\n    pos += ImVec2(thickness*0.25f, thickness*0.25f);\r\n\r\n    float third = sz / 3.0f;\r\n    float bx = pos.x + third;\r\n    float by = pos.y + sz - third*0.5f;\r\n    window->DrawList->PathLineTo(ImVec2(bx - third, by - third));\r\n    window->DrawList->PathLineTo(ImVec2(bx, by));\r\n    window->DrawList->PathLineTo(ImVec2(bx + third*2, by - third*2));\r\n    window->DrawList->PathStroke(col, false, thickness);\r\n}\r\n\r\n// Calculate text size. Text can be multi-line. Optionally ignore text after a ## marker.\r\n// CalcTextSize(\"\") should return ImVec2(0.0f, GImGui->FontSize)\r\nImVec2 ImGui::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    const char* text_display_end;\r\n    if (hide_text_after_double_hash)\r\n        text_display_end = FindRenderedTextEnd(text, text_end);      // Hide anything after a '##' string\r\n    else\r\n        text_display_end = text_end;\r\n\r\n    ImFont* font = g.Font;\r\n    const float font_size = g.FontSize;\r\n    if (text == text_display_end)\r\n        return ImVec2(0.0f, font_size);\r\n    ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);\r\n\r\n    // Cancel out character spacing for the last character of a line (it is baked into glyph->AdvanceX field)\r\n    const float font_scale = font_size / font->FontSize;\r\n    const float character_spacing_x = 1.0f * font_scale;\r\n    if (text_size.x > 0.0f)\r\n        text_size.x -= character_spacing_x;\r\n    text_size.x = (float)(int)(text_size.x + 0.95f);\r\n\r\n    return text_size;\r\n}\r\n\r\n// Helper to calculate coarse clipping of large list of evenly sized items.\r\n// NB: Prefer using the ImGuiListClipper higher-level helper if you can! Read comments and instructions there on how those use this sort of pattern.\r\n// NB: 'items_count' is only used to clamp the result, if you don't know your count you can use INT_MAX\r\nvoid ImGui::CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    if (g.LogEnabled)\r\n    {\r\n        // If logging is active, do not perform any clipping\r\n        *out_items_display_start = 0;\r\n        *out_items_display_end = items_count;\r\n        return;\r\n    }\r\n    if (window->SkipItems)\r\n    {\r\n        *out_items_display_start = *out_items_display_end = 0;\r\n        return;\r\n    }\r\n\r\n    const ImVec2 pos = window->DC.CursorPos;\r\n    int start = (int)((window->ClipRect.Min.y - pos.y) / items_height);\r\n    int end = (int)((window->ClipRect.Max.y - pos.y) / items_height);\r\n    start = ImClamp(start, 0, items_count);\r\n    end = ImClamp(end + 1, start, items_count);\r\n    *out_items_display_start = start;\r\n    *out_items_display_end = end;\r\n}\r\n\r\n// Find window given position, search front-to-back\r\n// FIXME: Note that we have a lag here because WindowRectClipped is updated in Begin() so windows moved by user via SetWindowPos() and not SetNextWindowPos() will have that rectangle lagging by a frame at the time FindHoveredWindow() is called, aka before the next Begin(). Moving window thankfully isn't affected.\r\nstatic ImGuiWindow* FindHoveredWindow(ImVec2 pos)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    for (int i = g.Windows.Size - 1; i >= 0; i--)\r\n    {\r\n        ImGuiWindow* window = g.Windows[i];\r\n        if (!window->Active)\r\n            continue;\r\n        if (window->Flags & ImGuiWindowFlags_NoInputs)\r\n            continue;\r\n\r\n        // Using the clipped AABB, a child window will typically be clipped by its parent (not always)\r\n        ImRect bb(window->WindowRectClipped.Min - g.Style.TouchExtraPadding, window->WindowRectClipped.Max + g.Style.TouchExtraPadding);\r\n        if (bb.Contains(pos))\r\n            return window;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Test if mouse cursor is hovering given rectangle\r\n// NB- Rectangle is clipped by our current clip setting\r\n// NB- Expand the rectangle to be generous on imprecise inputs systems (g.Style.TouchExtraPadding)\r\nbool ImGui::IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    // Clip\r\n    ImRect rect_clipped(r_min, r_max);\r\n    if (clip)\r\n        rect_clipped.ClipWith(window->ClipRect);\r\n\r\n    // Expand for touch input\r\n    const ImRect rect_for_touch(rect_clipped.Min - g.Style.TouchExtraPadding, rect_clipped.Max + g.Style.TouchExtraPadding);\r\n    return rect_for_touch.Contains(g.IO.MousePos);\r\n}\r\n\r\nbool ImGui::IsAnyWindowHovered()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.HoveredWindow != NULL;\r\n}\r\n\r\nbool ImGui::IsAnyWindowFocused()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.NavWindow != NULL;\r\n}\r\n\r\nstatic bool IsKeyPressedMap(ImGuiKey key, bool repeat)\r\n{\r\n    const int key_index = GImGui->IO.KeyMap[key];\r\n    return (key_index >= 0) ? ImGui::IsKeyPressed(key_index, repeat) : false;\r\n}\r\n\r\nint ImGui::GetKeyIndex(ImGuiKey imgui_key)\r\n{\r\n    IM_ASSERT(imgui_key >= 0 && imgui_key < ImGuiKey_COUNT);\r\n    return GImGui->IO.KeyMap[imgui_key];\r\n}\r\n\r\n// Note that imgui doesn't know the semantic of each entry of io.KeyDown[]. Use your own indices/enums according to how your backend/engine stored them into KeyDown[]!\r\nbool ImGui::IsKeyDown(int user_key_index)\r\n{\r\n    if (user_key_index < 0) return false;\r\n    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(GImGui->IO.KeysDown));\r\n    return GImGui->IO.KeysDown[user_key_index];\r\n}\r\n\r\nint ImGui::CalcTypematicPressedRepeatAmount(float t, float t_prev, float repeat_delay, float repeat_rate)\r\n{\r\n    if (t == 0.0f)\r\n        return 1;\r\n    if (t <= repeat_delay || repeat_rate <= 0.0f)\r\n        return 0;\r\n    const int count = (int)((t - repeat_delay) / repeat_rate) - (int)((t_prev - repeat_delay) / repeat_rate);\r\n    return (count > 0) ? count : 0;\r\n}\r\n\r\nint ImGui::GetKeyPressedAmount(int key_index, float repeat_delay, float repeat_rate)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (key_index < 0) return false;\r\n    IM_ASSERT(key_index >= 0 && key_index < IM_ARRAYSIZE(g.IO.KeysDown));\r\n    const float t = g.IO.KeysDownDuration[key_index];\r\n    return CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, repeat_delay, repeat_rate);\r\n}\r\n\r\nbool ImGui::IsKeyPressed(int user_key_index, bool repeat)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (user_key_index < 0) return false;\r\n    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));\r\n    const float t = g.IO.KeysDownDuration[user_key_index];\r\n    if (t == 0.0f)\r\n        return true;\r\n    if (repeat && t > g.IO.KeyRepeatDelay)\r\n        return GetKeyPressedAmount(user_key_index, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;\r\n    return false;\r\n}\r\n\r\nbool ImGui::IsKeyReleased(int user_key_index)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (user_key_index < 0) return false;\r\n    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));\r\n    if (g.IO.KeysDownDurationPrev[user_key_index] >= 0.0f && !g.IO.KeysDown[user_key_index])\r\n        return true;\r\n    return false;\r\n}\r\n\r\nbool ImGui::IsMouseDown(int button)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\r\n    return g.IO.MouseDown[button];\r\n}\r\n\r\nbool ImGui::IsMouseClicked(int button, bool repeat)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\r\n    const float t = g.IO.MouseDownDuration[button];\r\n    if (t == 0.0f)\r\n        return true;\r\n\r\n    if (repeat && t > g.IO.KeyRepeatDelay)\r\n    {\r\n        float delay = g.IO.KeyRepeatDelay, rate = g.IO.KeyRepeatRate;\r\n        if ((fmodf(t - delay, rate) > rate*0.5f) != (fmodf(t - delay - g.IO.DeltaTime, rate) > rate*0.5f))\r\n            return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nbool ImGui::IsMouseReleased(int button)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\r\n    return g.IO.MouseReleased[button];\r\n}\r\n\r\nbool ImGui::IsMouseDoubleClicked(int button)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\r\n    return g.IO.MouseDoubleClicked[button];\r\n}\r\n\r\nbool ImGui::IsMouseDragging(int button, float lock_threshold)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\r\n    if (!g.IO.MouseDown[button])\r\n        return false;\r\n    if (lock_threshold < 0.0f)\r\n        lock_threshold = g.IO.MouseDragThreshold;\r\n    return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;\r\n}\r\n\r\nImVec2 ImGui::GetMousePos()\r\n{\r\n    return GImGui->IO.MousePos;\r\n}\r\n\r\n// NB: prefer to call right after BeginPopup(). At the time Selectable/MenuItem is activated, the popup is already closed!\r\nImVec2 ImGui::GetMousePosOnOpeningCurrentPopup()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.CurrentPopupStack.Size > 0)\r\n        return g.OpenPopupStack[g.CurrentPopupStack.Size-1].MousePosOnOpen;\r\n    return g.IO.MousePos;\r\n}\r\n\r\n// We typically use ImVec2(-FLT_MAX,-FLT_MAX) to denote an invalid mouse position\r\nbool ImGui::IsMousePosValid(const ImVec2* mouse_pos)\r\n{\r\n    if (mouse_pos == NULL)\r\n        mouse_pos = &GImGui->IO.MousePos;\r\n    const float MOUSE_INVALID = -256000.0f;\r\n    return mouse_pos->x >= MOUSE_INVALID && mouse_pos->y >= MOUSE_INVALID;\r\n}\r\n\r\nImVec2 ImGui::GetMouseDragDelta(int button, float lock_threshold)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\r\n    if (lock_threshold < 0.0f)\r\n        lock_threshold = g.IO.MouseDragThreshold;\r\n    if (g.IO.MouseDown[button])\r\n        if (g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold)\r\n            return g.IO.MousePos - g.IO.MouseClickedPos[button];     // Assume we can only get active with left-mouse button (at the moment).\r\n    return ImVec2(0.0f, 0.0f);\r\n}\r\n\r\nvoid ImGui::ResetMouseDragDelta(int button)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));\r\n    // NB: We don't need to reset g.IO.MouseDragMaxDistanceSqr\r\n    g.IO.MouseClickedPos[button] = g.IO.MousePos;\r\n}\r\n\r\nImGuiMouseCursor ImGui::GetMouseCursor()\r\n{\r\n    return GImGui->MouseCursor;\r\n}\r\n\r\nvoid ImGui::SetMouseCursor(ImGuiMouseCursor cursor_type)\r\n{\r\n    GImGui->MouseCursor = cursor_type;\r\n}\r\n\r\nvoid ImGui::CaptureKeyboardFromApp(bool capture)\r\n{\r\n    GImGui->WantCaptureKeyboardNextFrame = capture ? 1 : 0;\r\n}\r\n\r\nvoid ImGui::CaptureMouseFromApp(bool capture)\r\n{\r\n    GImGui->WantCaptureMouseNextFrame = capture ? 1 : 0;\r\n}\r\n\r\nbool ImGui::IsItemActive()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.ActiveId)\r\n    {\r\n        ImGuiWindow* window = g.CurrentWindow;\r\n        return g.ActiveId == window->DC.LastItemId;\r\n    }\r\n    return false;\r\n}\r\n\r\nbool ImGui::IsItemClicked(int mouse_button)\r\n{\r\n    return IsMouseClicked(mouse_button) && IsItemHovered(ImGuiHoveredFlags_Default);\r\n}\r\n\r\nbool ImGui::IsAnyItemHovered()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;\r\n}\r\n\r\nbool ImGui::IsAnyItemActive()\r\n{\r\n    return GImGui->ActiveId != 0;\r\n}\r\n\r\nbool ImGui::IsItemVisible()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->ClipRect.Overlaps(window->DC.LastItemRect);\r\n}\r\n\r\n// Allow last item to be overlapped by a subsequent item. Both may be activated during the same frame before the later one takes priority.\r\nvoid ImGui::SetItemAllowOverlap()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.HoveredId == g.CurrentWindow->DC.LastItemId)\r\n        g.HoveredIdAllowOverlap = true;\r\n    if (g.ActiveId == g.CurrentWindow->DC.LastItemId)\r\n        g.ActiveIdAllowOverlap = true;\r\n}\r\n\r\nImVec2 ImGui::GetItemRectMin()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->DC.LastItemRect.Min;\r\n}\r\n\r\nImVec2 ImGui::GetItemRectMax()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->DC.LastItemRect.Max;\r\n}\r\n\r\nImVec2 ImGui::GetItemRectSize()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->DC.LastItemRect.GetSize();\r\n}\r\n\r\nImVec2 ImGui::CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge, float outward)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    ImRect rect = window->DC.LastItemRect;\r\n    rect.Expand(outward);\r\n    return rect.GetClosestPoint(pos, on_edge);\r\n}\r\n\r\nstatic ImRect GetVisibleRect()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.IO.DisplayVisibleMin.x != g.IO.DisplayVisibleMax.x && g.IO.DisplayVisibleMin.y != g.IO.DisplayVisibleMax.y)\r\n        return ImRect(g.IO.DisplayVisibleMin, g.IO.DisplayVisibleMax);\r\n    return ImRect(0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y);\r\n}\r\n\r\n// Not exposed publicly as BeginTooltip() because bool parameters are evil. Let's see if other needs arise first.\r\nvoid ImGui::BeginTooltipEx(ImGuiWindowFlags extra_flags, bool override_previous_tooltip)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    char window_name[16];\r\n    ImFormatString(window_name, IM_ARRAYSIZE(window_name), \"##Tooltip_%02d\", g.TooltipOverrideCount);\r\n    if (override_previous_tooltip)\r\n        if (ImGuiWindow* window = FindWindowByName(window_name))\r\n            if (window->Active)\r\n            {\r\n                // Hide previous tooltips. We can't easily \"reset\" the content of a window so we create a new one.\r\n                window->HiddenFrames = 1;\r\n                ImFormatString(window_name, IM_ARRAYSIZE(window_name), \"##Tooltip_%02d\", ++g.TooltipOverrideCount);\r\n            }\r\n    ImGuiWindowFlags flags = ImGuiWindowFlags_Tooltip|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoMove|ImGuiWindowFlags_NoResize|ImGuiWindowFlags_NoSavedSettings|ImGuiWindowFlags_AlwaysAutoResize;\r\n    Begin(window_name, NULL, flags | extra_flags);\r\n}\r\n\r\nvoid ImGui::SetTooltipV(const char* fmt, va_list args)\r\n{\r\n    BeginTooltipEx(0, true);\r\n    TextV(fmt, args);\r\n    EndTooltip();\r\n}\r\n\r\nvoid ImGui::SetTooltip(const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    SetTooltipV(fmt, args);\r\n    va_end(args);\r\n}\r\n\r\nvoid ImGui::BeginTooltip()\r\n{\r\n    BeginTooltipEx(0, false);\r\n}\r\n\r\nvoid ImGui::EndTooltip()\r\n{\r\n    IM_ASSERT(GetCurrentWindowRead()->Flags & ImGuiWindowFlags_Tooltip);   // Mismatched BeginTooltip()/EndTooltip() calls\r\n    ImGui::End();\r\n}\r\n\r\n// Mark popup as open (toggle toward open state).\r\n// Popups are closed when user click outside, or activate a pressable item, or CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block.\r\n// Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).\r\n// One open popup per level of the popup hierarchy (NB: when assigning we reset the Window member of ImGuiPopupRef to NULL)\r\nvoid ImGui::OpenPopupEx(ImGuiID id, bool reopen_existing)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* parent_window = g.CurrentWindow;\r\n    int current_stack_size = g.CurrentPopupStack.Size;\r\n    ImGuiPopupRef popup_ref = ImGuiPopupRef(id, parent_window, parent_window->GetID(\"##Menus\"), g.IO.MousePos); // Tagged as new ref because constructor sets Window to NULL.\r\n    if (g.OpenPopupStack.Size < current_stack_size + 1)\r\n        g.OpenPopupStack.push_back(popup_ref);\r\n    else if (reopen_existing || g.OpenPopupStack[current_stack_size].PopupId != id)\r\n    {\r\n        g.OpenPopupStack.resize(current_stack_size+1);\r\n        g.OpenPopupStack[current_stack_size] = popup_ref;\r\n\r\n        // When reopening a popup we first refocus its parent, otherwise if its parent is itself a popup it would get closed by CloseInactivePopups().\r\n        // This is equivalent to what ClosePopupToLevel() does.\r\n        if (g.OpenPopupStack[current_stack_size].PopupId == id)\r\n            FocusWindow(parent_window);\r\n    }\r\n}\r\n\r\nvoid ImGui::OpenPopup(const char* str_id)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    OpenPopupEx(g.CurrentWindow->GetID(str_id), false);\r\n}\r\n\r\nstatic void CloseInactivePopups(ImGuiWindow* ref_window)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.OpenPopupStack.empty())\r\n        return;\r\n\r\n    // When popups are stacked, clicking on a lower level popups puts focus back to it and close popups above it.\r\n    // Don't close our own child popup windows.\r\n    int n = 0;\r\n    if (ref_window)\r\n    {\r\n        for (n = 0; n < g.OpenPopupStack.Size; n++)\r\n        {\r\n            ImGuiPopupRef& popup = g.OpenPopupStack[n];\r\n            if (!popup.Window)\r\n                continue;\r\n            IM_ASSERT((popup.Window->Flags & ImGuiWindowFlags_Popup) != 0);\r\n            if (popup.Window->Flags & ImGuiWindowFlags_ChildWindow)\r\n                continue;\r\n\r\n            // Trim the stack if popups are not direct descendant of the reference window (which is often the NavWindow)\r\n            bool has_focus = false;\r\n            for (int m = n; m < g.OpenPopupStack.Size && !has_focus; m++)\r\n                has_focus = (g.OpenPopupStack[m].Window && g.OpenPopupStack[m].Window->RootWindow == ref_window->RootWindow);\r\n            if (!has_focus)\r\n                break;\r\n        }\r\n    }\r\n    if (n < g.OpenPopupStack.Size) // This test is not required but it allows to set a convenient breakpoint on the block below\r\n        ClosePopupToLevel(n);\r\n}\r\n\r\nstatic ImGuiWindow* GetFrontMostModalRootWindow()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    for (int n = g.OpenPopupStack.Size-1; n >= 0; n--)\r\n        if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)\r\n            if (popup->Flags & ImGuiWindowFlags_Modal)\r\n                return popup;\r\n    return NULL;\r\n}\r\n\r\nstatic void ClosePopupToLevel(int remaining)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (remaining > 0)\r\n        ImGui::FocusWindow(g.OpenPopupStack[remaining-1].Window);\r\n    else\r\n        ImGui::FocusWindow(g.OpenPopupStack[0].ParentWindow);\r\n    g.OpenPopupStack.resize(remaining);\r\n}\r\n\r\nvoid ImGui::ClosePopup(ImGuiID id)\r\n{\r\n    if (!IsPopupOpen(id))\r\n        return;\r\n    ImGuiContext& g = *GImGui;\r\n    ClosePopupToLevel(g.OpenPopupStack.Size - 1);\r\n}\r\n\r\n// Close the popup we have begin-ed into.\r\nvoid ImGui::CloseCurrentPopup()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    int popup_idx = g.CurrentPopupStack.Size - 1;\r\n    if (popup_idx < 0 || popup_idx >= g.OpenPopupStack.Size || g.CurrentPopupStack[popup_idx].PopupId != g.OpenPopupStack[popup_idx].PopupId)\r\n        return;\r\n    while (popup_idx > 0 && g.OpenPopupStack[popup_idx].Window && (g.OpenPopupStack[popup_idx].Window->Flags & ImGuiWindowFlags_ChildMenu))\r\n        popup_idx--;\r\n    ClosePopupToLevel(popup_idx);\r\n}\r\n\r\nstatic inline void ClearSetNextWindowData()\r\n{\r\n    // FIXME-OPT\r\n    ImGuiContext& g = *GImGui;\r\n    g.SetNextWindowPosCond = g.SetNextWindowSizeCond = g.SetNextWindowContentSizeCond = g.SetNextWindowCollapsedCond = 0;\r\n    g.SetNextWindowSizeConstraint = g.SetNextWindowFocus = false;\r\n}\r\n\r\nbool ImGui::BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (!IsPopupOpen(id))\r\n    {\r\n        ClearSetNextWindowData(); // We behave like Begin() and need to consume those values\r\n        return false;\r\n    }\r\n\r\n    char name[20];\r\n    if (extra_flags & ImGuiWindowFlags_ChildMenu)\r\n        ImFormatString(name, IM_ARRAYSIZE(name), \"##Menu_%02d\", g.CurrentPopupStack.Size);    // Recycle windows based on depth\r\n    else\r\n        ImFormatString(name, IM_ARRAYSIZE(name), \"##Popup_%08x\", id); // Not recycling, so we can close/open during the same frame\r\n\r\n    bool is_open = Begin(name, NULL, extra_flags | ImGuiWindowFlags_Popup);\r\n    if (!is_open) // NB: Begin can return false when the popup is completely clipped (e.g. zero size display)\r\n        EndPopup();\r\n\r\n    return is_open;\r\n}\r\n\r\nbool ImGui::BeginPopup(const char* str_id)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.OpenPopupStack.Size <= g.CurrentPopupStack.Size) // Early out for performance\r\n    {\r\n        ClearSetNextWindowData(); // We behave like Begin() and need to consume those values\r\n        return false;\r\n    }\r\n    return BeginPopupEx(g.CurrentWindow->GetID(str_id), ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);\r\n}\r\n\r\nbool ImGui::IsPopupOpen(ImGuiID id)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].PopupId == id;\r\n}\r\n\r\nbool ImGui::IsPopupOpen(const char* str_id)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].PopupId == g.CurrentWindow->GetID(str_id);\r\n}\r\n\r\nbool ImGui::BeginPopupModal(const char* name, bool* p_open, ImGuiWindowFlags extra_flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    const ImGuiID id = window->GetID(name);\r\n    if (!IsPopupOpen(id))\r\n    {\r\n        ClearSetNextWindowData(); // We behave like Begin() and need to consume those values\r\n        return false;\r\n    }\r\n\r\n    // Center modal windows by default\r\n    if ((window->SetWindowPosAllowFlags & g.SetNextWindowPosCond) == 0)\r\n        SetNextWindowPos(g.IO.DisplaySize * 0.5f, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));\r\n\r\n    ImGuiWindowFlags flags = extra_flags|ImGuiWindowFlags_Popup|ImGuiWindowFlags_Modal|ImGuiWindowFlags_NoCollapse|ImGuiWindowFlags_NoSavedSettings;\r\n    bool is_open = Begin(name, p_open, flags);\r\n    if (!is_open || (p_open && !*p_open)) // NB: is_open can be 'false' when the popup is completely clipped (e.g. zero size display)\r\n    {\r\n        EndPopup();\r\n        if (is_open)\r\n            ClosePopup(id);\r\n        return false;\r\n    }\r\n\r\n    return is_open;\r\n}\r\n\r\nvoid ImGui::EndPopup()\r\n{\r\n    ImGuiContext& g = *GImGui; (void)g;\r\n    IM_ASSERT(g.CurrentWindow->Flags & ImGuiWindowFlags_Popup);  // Mismatched BeginPopup()/EndPopup() calls\r\n    IM_ASSERT(g.CurrentPopupStack.Size > 0);\r\n    End();\r\n}\r\n\r\nbool ImGui::OpenPopupOnItemClick(const char* str_id, int mouse_button)\r\n{\r\n    ImGuiWindow* window = GImGui->CurrentWindow;\r\n    if (IsMouseClicked(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))\r\n    {\r\n        ImGuiID id = str_id ? window->GetID(str_id) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!\r\n        IM_ASSERT(id != 0);                                                  // However, you cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)\r\n        OpenPopupEx(id, true);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n// This is a helper to handle the simplest case of associating one named popup to one given widget.\r\n// You may want to handle this on user side if you have specific needs (e.g. tweaking IsItemHovered() parameters).\r\n// You can pass a NULL str_id to use the identifier of the last item.\r\nbool ImGui::BeginPopupContextItem(const char* str_id, int mouse_button)\r\n{\r\n    ImGuiWindow* window = GImGui->CurrentWindow;\r\n    ImGuiID id = str_id ? window->GetID(str_id) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!\r\n    IM_ASSERT(id != 0);                                                  // However, you cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)\r\n    if (IsMouseClicked(mouse_button))\r\n        if (IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))\r\n            OpenPopupEx(id, true);\r\n    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);\r\n}\r\n\r\nbool ImGui::BeginPopupContextWindow(const char* str_id, int mouse_button, bool also_over_items)\r\n{\r\n    if (!str_id)\r\n        str_id = \"window_context\";\r\n    ImGuiID id = GImGui->CurrentWindow->GetID(str_id);\r\n    if (IsMouseClicked(mouse_button))\r\n        if (IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))\r\n            if (also_over_items || !IsAnyItemHovered())\r\n                OpenPopupEx(id, true);\r\n    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);\r\n}\r\n\r\nbool ImGui::BeginPopupContextVoid(const char* str_id, int mouse_button)\r\n{\r\n    if (!str_id) \r\n        str_id = \"void_context\";\r\n    ImGuiID id = GImGui->CurrentWindow->GetID(str_id);\r\n    if (!IsAnyWindowHovered() && IsMouseClicked(mouse_button))\r\n        OpenPopupEx(id, true);\r\n    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);\r\n}\r\n\r\nstatic bool BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* parent_window = ImGui::GetCurrentWindow();\r\n    ImGuiWindowFlags flags = ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoResize|ImGuiWindowFlags_NoSavedSettings|ImGuiWindowFlags_ChildWindow;\r\n    flags |= (parent_window->Flags & ImGuiWindowFlags_NoMove);  // Inherit the NoMove flag\r\n\r\n    const ImVec2 content_avail = ImGui::GetContentRegionAvail();\r\n    ImVec2 size = ImFloor(size_arg);\r\n    const int auto_fit_axises = ((size.x == 0.0f) ? (1 << ImGuiAxis_X) : 0x00) | ((size.y == 0.0f) ? (1 << ImGuiAxis_Y) : 0x00);\r\n    if (size.x <= 0.0f)\r\n        size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too much issues)\r\n    if (size.y <= 0.0f)\r\n        size.y = ImMax(content_avail.y + size.y, 4.0f);\r\n\r\n    const float backup_border_size = g.Style.ChildBorderSize;\r\n    if (!border)\r\n        g.Style.ChildBorderSize = 0.0f;\r\n    flags |= extra_flags;\r\n\r\n    char title[256];\r\n    if (name)\r\n        ImFormatString(title, IM_ARRAYSIZE(title), \"%s/%s_%08X\", parent_window->Name, name, id);\r\n    else\r\n        ImFormatString(title, IM_ARRAYSIZE(title), \"%s/%08X\", parent_window->Name, id);\r\n\r\n    ImGui::SetNextWindowSize(size);\r\n    bool ret = ImGui::Begin(title, NULL, flags);\r\n    ImGuiWindow* child_window = ImGui::GetCurrentWindow();\r\n    child_window->AutoFitChildAxises = auto_fit_axises;\r\n    g.Style.ChildBorderSize = backup_border_size;\r\n\r\n    return ret;\r\n}\r\n\r\nbool ImGui::BeginChild(const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    return BeginChildEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);\r\n}\r\n\r\nbool ImGui::BeginChild(ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)\r\n{\r\n    return BeginChildEx(NULL, id, size_arg, border, extra_flags);\r\n}\r\n\r\nvoid ImGui::EndChild()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n\r\n    IM_ASSERT(window->Flags & ImGuiWindowFlags_ChildWindow);   // Mismatched BeginChild()/EndChild() callss\r\n    if (window->BeginCount > 1)\r\n    {\r\n        ImGui::End();\r\n    }\r\n    else\r\n    {\r\n        // When using auto-filling child window, we don't provide full width/height to ItemSize so that it doesn't feed back into automatic size-fitting.\r\n        ImVec2 sz = GetWindowSize();\r\n        if (window->AutoFitChildAxises & (1 << ImGuiAxis_X)) // Arbitrary minimum zero-ish child size of 4.0f causes less trouble than a 0.0f\r\n            sz.x = ImMax(4.0f, sz.x);\r\n        if (window->AutoFitChildAxises & (1 << ImGuiAxis_Y))\r\n            sz.y = ImMax(4.0f, sz.y);\r\n        ImGui::End();\r\n\r\n        ImGuiWindow* parent_window = GetCurrentWindow();\r\n        ImRect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + sz);\r\n        ItemSize(sz);\r\n        ItemAdd(bb, 0);\r\n    }\r\n}\r\n\r\n// Helper to create a child window / scrolling region that looks like a normal widget frame.\r\nbool ImGui::BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    PushStyleColor(ImGuiCol_ChildBg, style.Colors[ImGuiCol_FrameBg]);\r\n    PushStyleVar(ImGuiStyleVar_ChildRounding, style.FrameRounding);\r\n    PushStyleVar(ImGuiStyleVar_ChildBorderSize, style.FrameBorderSize);\r\n    PushStyleVar(ImGuiStyleVar_WindowPadding, style.FramePadding);\r\n    return BeginChild(id, size, true, ImGuiWindowFlags_NoMove | ImGuiWindowFlags_AlwaysUseWindowPadding | extra_flags);\r\n}\r\n\r\nvoid ImGui::EndChildFrame()\r\n{\r\n    EndChild();\r\n    PopStyleVar(3);\r\n    PopStyleColor();\r\n}\r\n\r\n// Save and compare stack sizes on Begin()/End() to detect usage errors\r\nstatic void CheckStacksSize(ImGuiWindow* window, bool write)\r\n{\r\n    // NOT checking: DC.ItemWidth, DC.AllowKeyboardFocus, DC.ButtonRepeat, DC.TextWrapPos (per window) to allow user to conveniently push once and not pop (they are cleared on Begin)\r\n    ImGuiContext& g = *GImGui;\r\n    int* p_backup = &window->DC.StackSizesBackup[0];\r\n    { int current = window->IDStack.Size;       if (write) *p_backup = current; else IM_ASSERT(*p_backup == current && \"PushID/PopID or TreeNode/TreePop Mismatch!\");   p_backup++; }    // Too few or too many PopID()/TreePop()\r\n    { int current = window->DC.GroupStack.Size; if (write) *p_backup = current; else IM_ASSERT(*p_backup == current && \"BeginGroup/EndGroup Mismatch!\");                p_backup++; }    // Too few or too many EndGroup()\r\n    { int current = g.CurrentPopupStack.Size;   if (write) *p_backup = current; else IM_ASSERT(*p_backup == current && \"BeginMenu/EndMenu or BeginPopup/EndPopup Mismatch\"); p_backup++;}// Too few or too many EndMenu()/EndPopup()\r\n    { int current = g.ColorModifiers.Size;      if (write) *p_backup = current; else IM_ASSERT(*p_backup == current && \"PushStyleColor/PopStyleColor Mismatch!\");       p_backup++; }    // Too few or too many PopStyleColor()\r\n    { int current = g.StyleModifiers.Size;      if (write) *p_backup = current; else IM_ASSERT(*p_backup == current && \"PushStyleVar/PopStyleVar Mismatch!\");           p_backup++; }    // Too few or too many PopStyleVar()\r\n    { int current = g.FontStack.Size;           if (write) *p_backup = current; else IM_ASSERT(*p_backup == current && \"PushFont/PopFont Mismatch!\");                   p_backup++; }    // Too few or too many PopFont()\r\n    IM_ASSERT(p_backup == window->DC.StackSizesBackup + IM_ARRAYSIZE(window->DC.StackSizesBackup));\r\n}\r\n\r\nenum ImGuiPopupPositionPolicy\r\n{\r\n    ImGuiPopupPositionPolicy_Default,\r\n    ImGuiPopupPositionPolicy_ComboBox\r\n};\r\n\r\nstatic ImVec2 FindBestWindowPosForPopup(const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy = ImGuiPopupPositionPolicy_Default)\r\n{\r\n    const ImGuiStyle& style = GImGui->Style;\r\n\r\n    // r_avoid = the rectangle to avoid (e.g. for tooltip it is a rectangle around the mouse cursor which we want to avoid. for popups it's a small point around the cursor.)\r\n    // r_outer = the visible area rectangle, minus safe area padding. If our popup size won't fit because of safe area padding we ignore it.\r\n    ImVec2 safe_padding = style.DisplaySafeAreaPadding;\r\n    ImRect r_outer(GetVisibleRect());\r\n    r_outer.Expand(ImVec2((size.x - r_outer.GetWidth() > safe_padding.x*2) ? -safe_padding.x : 0.0f, (size.y - r_outer.GetHeight() > safe_padding.y*2) ? -safe_padding.y : 0.0f));\r\n    ImVec2 base_pos_clamped = ImClamp(ref_pos, r_outer.Min, r_outer.Max - size);\r\n    //GImGui->OverlayDrawList.AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255,0,0,255));\r\n    //GImGui->OverlayDrawList.AddRect(r_outer.Min, r_outer.Max, IM_COL32(0,255,0,255));\r\n\r\n    // Combo Box policy (we want a connecting edge)\r\n    if (policy == ImGuiPopupPositionPolicy_ComboBox)\r\n    {\r\n        const ImGuiDir dir_prefered_order[ImGuiDir_Count_] = { ImGuiDir_Down, ImGuiDir_Right, ImGuiDir_Left, ImGuiDir_Up };\r\n        for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_Count_; n++)\r\n        {\r\n            const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];\r\n            if (n != -1 && dir == *last_dir) // Already tried this direction?\r\n                continue;\r\n            ImVec2 pos;\r\n            if (dir == ImGuiDir_Down)  pos = ImVec2(r_avoid.Min.x, r_avoid.Max.y);          // Below, Toward Right (default)\r\n            if (dir == ImGuiDir_Right) pos = ImVec2(r_avoid.Min.x, r_avoid.Min.y - size.y); // Above, Toward Right\r\n            if (dir == ImGuiDir_Left)  pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Max.y); // Below, Toward Left\r\n            if (dir == ImGuiDir_Up)    pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Min.y - size.y); // Above, Toward Left\r\n            if (!r_outer.Contains(ImRect(pos, pos + size)))\r\n                continue;\r\n            *last_dir = dir;\r\n            return pos;\r\n        }\r\n    }\r\n\r\n    // Default popup policy\r\n    const ImGuiDir dir_prefered_order[ImGuiDir_Count_] = { ImGuiDir_Right, ImGuiDir_Down, ImGuiDir_Up, ImGuiDir_Left };\r\n    for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_Count_; n++)\r\n    {\r\n        const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];\r\n        if (n != -1 && dir == *last_dir) // Already tried this direction?\r\n            continue;\r\n        float avail_w = (dir == ImGuiDir_Left ? r_avoid.Min.x : r_outer.Max.x) - (dir == ImGuiDir_Right ? r_avoid.Max.x : r_outer.Min.x);\r\n        float avail_h = (dir == ImGuiDir_Up ? r_avoid.Min.y : r_outer.Max.y) - (dir == ImGuiDir_Down ? r_avoid.Max.y : r_outer.Min.y);\r\n        if (avail_w < size.x || avail_h < size.y)\r\n            continue;\r\n        ImVec2 pos;\r\n        pos.x = (dir == ImGuiDir_Left) ? r_avoid.Min.x - size.x : (dir == ImGuiDir_Right) ? r_avoid.Max.x : base_pos_clamped.x;\r\n        pos.y = (dir == ImGuiDir_Up)   ? r_avoid.Min.y - size.y : (dir == ImGuiDir_Down)  ? r_avoid.Max.y : base_pos_clamped.y;\r\n        *last_dir = dir;\r\n        return pos;\r\n    }\r\n\r\n    // Fallback, try to keep within display\r\n    *last_dir = ImGuiDir_None;\r\n    ImVec2 pos = ref_pos;\r\n    pos.x = ImMax(ImMin(pos.x + size.x, r_outer.Max.x) - size.x, r_outer.Min.x);\r\n    pos.y = ImMax(ImMin(pos.y + size.y, r_outer.Max.y) - size.y, r_outer.Min.y);\r\n    return pos;\r\n}\r\n\r\nstatic void SetWindowConditionAllowFlags(ImGuiWindow* window, ImGuiCond flags, bool enabled)\r\n{\r\n    window->SetWindowPosAllowFlags       = enabled ? (window->SetWindowPosAllowFlags       | flags) : (window->SetWindowPosAllowFlags       & ~flags);\r\n    window->SetWindowSizeAllowFlags      = enabled ? (window->SetWindowSizeAllowFlags      | flags) : (window->SetWindowSizeAllowFlags      & ~flags);\r\n    window->SetWindowCollapsedAllowFlags = enabled ? (window->SetWindowCollapsedAllowFlags | flags) : (window->SetWindowCollapsedAllowFlags & ~flags);\r\n}\r\n\r\nImGuiWindow* ImGui::FindWindowByName(const char* name)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiID id = ImHash(name, 0);\r\n    return (ImGuiWindow*)g.WindowsById.GetVoidPtr(id);\r\n}\r\n\r\nstatic ImGuiWindow* CreateNewWindow(const char* name, ImVec2 size, ImGuiWindowFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    // Create window the first time\r\n    ImGuiWindow* window = IM_NEW(ImGuiWindow)(&g, name);\r\n    window->Flags = flags;\r\n    g.WindowsById.SetVoidPtr(window->ID, window);\r\n\r\n    // User can disable loading and saving of settings. Tooltip and child windows also don't store settings.\r\n    if (!(flags & ImGuiWindowFlags_NoSavedSettings))\r\n    {\r\n        // Retrieve settings from .ini file\r\n        // Use SetWindowPos() or SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.\r\n        window->PosFloat = ImVec2(60, 60);\r\n        window->Pos = ImVec2((float)(int)window->PosFloat.x, (float)(int)window->PosFloat.y);\r\n\r\n        if (ImGuiWindowSettings* settings = ImGui::FindWindowSettings(window->ID))\r\n        {\r\n            SetWindowConditionAllowFlags(window, ImGuiCond_FirstUseEver, false);\r\n            window->PosFloat = settings->Pos;\r\n            window->Pos = ImVec2((float)(int)window->PosFloat.x, (float)(int)window->PosFloat.y);\r\n            window->Collapsed = settings->Collapsed;\r\n            if (ImLengthSqr(settings->Size) > 0.00001f)\r\n                size = settings->Size;\r\n        }\r\n    }\r\n    window->Size = window->SizeFull = window->SizeFullAtLastBegin = size;\r\n\r\n    if ((flags & ImGuiWindowFlags_AlwaysAutoResize) != 0)\r\n    {\r\n        window->AutoFitFramesX = window->AutoFitFramesY = 2;\r\n        window->AutoFitOnlyGrows = false;\r\n    }\r\n    else\r\n    {\r\n        if (window->Size.x <= 0.0f)\r\n            window->AutoFitFramesX = 2;\r\n        if (window->Size.y <= 0.0f)\r\n            window->AutoFitFramesY = 2;\r\n        window->AutoFitOnlyGrows = (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);\r\n    }\r\n\r\n    if (flags & ImGuiWindowFlags_NoBringToFrontOnFocus)\r\n        g.Windows.insert(g.Windows.begin(), window); // Quite slow but rare and only once\r\n    else\r\n        g.Windows.push_back(window);\r\n    return window;\r\n}\r\n\r\nstatic ImVec2 CalcSizeAfterConstraint(ImGuiWindow* window, ImVec2 new_size)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.SetNextWindowSizeConstraint)\r\n    {\r\n        // Using -1,-1 on either X/Y axis to preserve the current size.\r\n        ImRect cr = g.SetNextWindowSizeConstraintRect;\r\n        new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;\r\n        new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;\r\n        if (g.SetNextWindowSizeConstraintCallback)\r\n        {\r\n            ImGuiSizeConstraintCallbackData data;\r\n            data.UserData = g.SetNextWindowSizeConstraintCallbackUserData;\r\n            data.Pos = window->Pos;\r\n            data.CurrentSize = window->SizeFull;\r\n            data.DesiredSize = new_size;\r\n            g.SetNextWindowSizeConstraintCallback(&data);\r\n            new_size = data.DesiredSize;\r\n        }\r\n    }\r\n\r\n    // Minimum size\r\n    if (!(window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_AlwaysAutoResize)))\r\n    {\r\n        new_size = ImMax(new_size, g.Style.WindowMinSize);\r\n        new_size.y = ImMax(new_size.y, window->TitleBarHeight() + window->MenuBarHeight() + ImMax(0.0f, g.Style.WindowRounding - 1.0f)); // Reduce artifacts with very small windows\r\n    }\r\n    return new_size;\r\n}\r\n\r\nstatic ImVec2 CalcSizeContents(ImGuiWindow* window)\r\n{\r\n    ImVec2 sz;\r\n    sz.x = (float)(int)((window->SizeContentsExplicit.x != 0.0f) ? window->SizeContentsExplicit.x : (window->DC.CursorMaxPos.x - window->Pos.x + window->Scroll.x));\r\n    sz.y = (float)(int)((window->SizeContentsExplicit.y != 0.0f) ? window->SizeContentsExplicit.y : (window->DC.CursorMaxPos.y - window->Pos.y + window->Scroll.y));\r\n    return sz + window->WindowPadding;\r\n}\r\n\r\nstatic ImVec2 CalcSizeAutoFit(ImGuiWindow* window, const ImVec2& size_contents)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiStyle& style = g.Style;\r\n    ImGuiWindowFlags flags = window->Flags;\r\n    ImVec2 size_auto_fit;\r\n    if ((flags & ImGuiWindowFlags_Tooltip) != 0)\r\n    {\r\n        // Tooltip always resize. We keep the spacing symmetric on both axises for aesthetic purpose.\r\n        size_auto_fit = size_contents;\r\n    }\r\n    else\r\n    {\r\n        // When the window cannot fit all contents (either because of constraints, either because screen is too small): we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than DisplaySize-WindowPadding.\r\n        size_auto_fit = ImClamp(size_contents, style.WindowMinSize, ImMax(style.WindowMinSize, g.IO.DisplaySize - g.Style.DisplaySafeAreaPadding));\r\n        ImVec2 size_auto_fit_after_constraint = CalcSizeAfterConstraint(window, size_auto_fit);\r\n        if (size_auto_fit_after_constraint.x < size_contents.x && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar))\r\n            size_auto_fit.y += style.ScrollbarSize;\r\n        if (size_auto_fit_after_constraint.y < size_contents.y && !(flags & ImGuiWindowFlags_NoScrollbar))\r\n            size_auto_fit.x += style.ScrollbarSize;\r\n    }\r\n    return size_auto_fit;\r\n}\r\n\r\nstatic float GetScrollMaxX(ImGuiWindow* window)\r\n{\r\n    return ImMax(0.0f, window->SizeContents.x - (window->SizeFull.x - window->ScrollbarSizes.x));\r\n}\r\n\r\nstatic float GetScrollMaxY(ImGuiWindow* window)\r\n{\r\n    return ImMax(0.0f, window->SizeContents.y - (window->SizeFull.y - window->ScrollbarSizes.y));\r\n}\r\n\r\nstatic ImVec2 CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window)\r\n{\r\n    ImVec2 scroll = window->Scroll;\r\n    float cr_x = window->ScrollTargetCenterRatio.x;\r\n    float cr_y = window->ScrollTargetCenterRatio.y;\r\n    if (window->ScrollTarget.x < FLT_MAX)\r\n        scroll.x = window->ScrollTarget.x - cr_x * (window->SizeFull.x - window->ScrollbarSizes.x);\r\n    if (window->ScrollTarget.y < FLT_MAX)\r\n        scroll.y = window->ScrollTarget.y - (1.0f - cr_y) * (window->TitleBarHeight() + window->MenuBarHeight()) - cr_y * (window->SizeFull.y - window->ScrollbarSizes.y);\r\n    scroll = ImMax(scroll, ImVec2(0.0f, 0.0f));\r\n    if (!window->Collapsed && !window->SkipItems)\r\n    {\r\n        scroll.x = ImMin(scroll.x, GetScrollMaxX(window));\r\n        scroll.y = ImMin(scroll.y, GetScrollMaxY(window));\r\n    }\r\n    return scroll;\r\n}\r\n\r\nstatic ImGuiCol GetWindowBgColorIdxFromFlags(ImGuiWindowFlags flags)\r\n{\r\n    if (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))\r\n        return ImGuiCol_PopupBg;\r\n    if (flags & ImGuiWindowFlags_ChildWindow)\r\n        return ImGuiCol_ChildBg;\r\n    return ImGuiCol_WindowBg;\r\n}\r\n\r\nstatic void CalcResizePosSizeFromAnyCorner(ImGuiWindow* window, const ImVec2& corner_target, const ImVec2& corner_norm, ImVec2* out_pos, ImVec2* out_size)\r\n{\r\n    ImVec2 pos_min = ImLerp(corner_target, window->Pos, corner_norm);                // Expected window upper-left\r\n    ImVec2 pos_max = ImLerp(window->Pos + window->Size, corner_target, corner_norm); // Expected window lower-right\r\n    ImVec2 size_expected = pos_max - pos_min;\r\n    ImVec2 size_constrained = CalcSizeAfterConstraint(window, size_expected);\r\n    *out_pos = pos_min;\r\n    if (corner_norm.x == 0.0f)\r\n        out_pos->x -= (size_constrained.x - size_expected.x);\r\n    if (corner_norm.y == 0.0f)\r\n        out_pos->y -= (size_constrained.y - size_expected.y);\r\n    *out_size = size_constrained;\r\n}\r\n\r\nstruct ImGuiResizeGripDef\r\n{\r\n    ImVec2           CornerPos;\r\n    ImVec2           InnerDir;\r\n    int              AngleMin12, AngleMax12;\r\n};\r\n\r\nconst ImGuiResizeGripDef resize_grip_def[4] =\r\n{\r\n    { ImVec2(1,1), ImVec2(-1,-1), 0, 3 }, // Lower right\r\n    { ImVec2(0,1), ImVec2(+1,-1), 3, 6 }, // Lower left\r\n    { ImVec2(0,0), ImVec2(+1,+1), 6, 9 }, // Upper left\r\n    { ImVec2(1,0), ImVec2(-1,+1), 9,12 }, // Upper right\r\n};\r\n\r\nstatic ImRect GetBorderRect(ImGuiWindow* window, int border_n, float perp_padding, float thickness)\r\n{\r\n    ImRect rect = window->Rect();\r\n    if (thickness == 0.0f) rect.Max -= ImVec2(1,1);\r\n    if (border_n == 0) return ImRect(rect.Min.x + perp_padding, rect.Min.y,                rect.Max.x - perp_padding, rect.Min.y + thickness);\r\n    if (border_n == 1) return ImRect(rect.Max.x - thickness,    rect.Min.y + perp_padding, rect.Max.x,                rect.Max.y - perp_padding);\r\n    if (border_n == 2) return ImRect(rect.Min.x + perp_padding, rect.Max.y - thickness,    rect.Max.x - perp_padding, rect.Max.y);\r\n    if (border_n == 3) return ImRect(rect.Min.x,                rect.Min.y + perp_padding, rect.Min.x + thickness,    rect.Max.y - perp_padding);\r\n    IM_ASSERT(0);\r\n    return ImRect();\r\n}\r\n\r\n// Push a new ImGui window to add widgets to.\r\n// - A default window called \"Debug\" is automatically stacked at the beginning of every frame so you can use widgets without explicitly calling a Begin/End pair.\r\n// - Begin/End can be called multiple times during the frame with the same window name to append content.\r\n// - The window name is used as a unique identifier to preserve window information across frames (and save rudimentary information to the .ini file).\r\n//   You can use the \"##\" or \"###\" markers to use the same label with different id, or same id with different label. See documentation at the top of this file.\r\n// - Return false when window is collapsed, so you can early out in your code. You always need to call ImGui::End() even if false is returned.\r\n// - Passing 'bool* p_open' displays a Close button on the upper-right corner of the window, the pointed value will be set to false when the button is pressed.\r\nbool ImGui::Begin(const char* name, bool* p_open, ImGuiWindowFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    IM_ASSERT(name != NULL);                        // Window name required\r\n    IM_ASSERT(g.Initialized);                       // Forgot to call ImGui::NewFrame()\r\n    IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet\r\n\r\n    if (flags & ImGuiWindowFlags_NoInputs)\r\n        flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;\r\n\r\n    // Find or create\r\n    ImGuiWindow* window = FindWindowByName(name);\r\n    if (!window)\r\n    {\r\n        ImVec2 size_on_first_use = (g.SetNextWindowSizeCond != 0) ? g.SetNextWindowSizeVal : ImVec2(0.0f, 0.0f); // Any condition flag will do since we are creating a new window here.\r\n        window = CreateNewWindow(name, size_on_first_use, flags);\r\n    }\r\n\r\n    const int current_frame = g.FrameCount;\r\n    const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);\r\n    if (first_begin_of_the_frame)\r\n        window->Flags = (ImGuiWindowFlags)flags;\r\n    else\r\n        flags = window->Flags;\r\n\r\n    // Update the Appearing flag\r\n    bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1);   // Not using !WasActive because the implicit \"Debug\" window would always toggle off->on\r\n    const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFrames == 1);\r\n    if (flags & ImGuiWindowFlags_Popup)\r\n    {\r\n        ImGuiPopupRef& popup_ref = g.OpenPopupStack[g.CurrentPopupStack.Size];\r\n        window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed\r\n        window_just_activated_by_user |= (window != popup_ref.Window);\r\n    }\r\n    window->Appearing = (window_just_activated_by_user || window_just_appearing_after_hidden_for_resize);\r\n    window->CloseButton = (p_open != NULL);\r\n    if (window->Appearing)\r\n        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);\r\n\r\n    // Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack\r\n    ImGuiWindow* parent_window_in_stack = g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back();\r\n    ImGuiWindow* parent_window = first_begin_of_the_frame ? ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;\r\n    IM_ASSERT(parent_window != NULL || !(flags & ImGuiWindowFlags_ChildWindow));\r\n\r\n    // Add to stack\r\n    g.CurrentWindowStack.push_back(window);\r\n    SetCurrentWindow(window);\r\n    CheckStacksSize(window, true);\r\n    if (flags & ImGuiWindowFlags_Popup)\r\n    {\r\n        ImGuiPopupRef& popup_ref = g.OpenPopupStack[g.CurrentPopupStack.Size];\r\n        popup_ref.Window = window;\r\n        g.CurrentPopupStack.push_back(popup_ref);\r\n        window->PopupId = popup_ref.PopupId;\r\n    }\r\n\r\n    // Process SetNextWindow***() calls\r\n    bool window_pos_set_by_api = false;\r\n    bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;\r\n    if (g.SetNextWindowPosCond)\r\n    {\r\n        window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.SetNextWindowPosCond) != 0;\r\n        if (window_pos_set_by_api && ImLengthSqr(g.SetNextWindowPosPivot) > 0.00001f)\r\n        {\r\n            // May be processed on the next frame if this is our first frame and we are measuring size\r\n            // FIXME: Look into removing the branch so everything can go through this same code path for consistency.\r\n            window->SetWindowPosVal = g.SetNextWindowPosVal;\r\n            window->SetWindowPosPivot = g.SetNextWindowPosPivot;\r\n            window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);\r\n        }\r\n        else\r\n        {\r\n            SetWindowPos(window, g.SetNextWindowPosVal, g.SetNextWindowPosCond);\r\n        }\r\n        g.SetNextWindowPosCond = 0;\r\n    }\r\n    if (g.SetNextWindowSizeCond)\r\n    {\r\n        window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.SetNextWindowSizeCond) != 0 && (g.SetNextWindowSizeVal.x > 0.0f);\r\n        window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.SetNextWindowSizeCond) != 0 && (g.SetNextWindowSizeVal.y > 0.0f);\r\n        SetWindowSize(window, g.SetNextWindowSizeVal, g.SetNextWindowSizeCond);\r\n        g.SetNextWindowSizeCond = 0;\r\n    }\r\n    if (g.SetNextWindowContentSizeCond)\r\n    {\r\n        // Adjust passed \"client size\" to become a \"window size\"\r\n        window->SizeContentsExplicit = g.SetNextWindowContentSizeVal;\r\n        window->SizeContentsExplicit.y += window->TitleBarHeight() + window->MenuBarHeight();\r\n        g.SetNextWindowContentSizeCond = 0;\r\n    }\r\n    else if (first_begin_of_the_frame)\r\n    {\r\n        window->SizeContentsExplicit = ImVec2(0.0f, 0.0f);\r\n    }\r\n    if (g.SetNextWindowCollapsedCond)\r\n    {\r\n        SetWindowCollapsed(window, g.SetNextWindowCollapsedVal, g.SetNextWindowCollapsedCond);\r\n        g.SetNextWindowCollapsedCond = 0;\r\n    }\r\n    if (g.SetNextWindowFocus)\r\n    {\r\n        SetWindowFocus();\r\n        g.SetNextWindowFocus = false;\r\n    }\r\n    if (window->Appearing)\r\n        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, false);\r\n\r\n    // When reusing window again multiple times a frame, just append content (don't need to setup again)\r\n    if (first_begin_of_the_frame)\r\n    {\r\n        // Initialize\r\n        window->ParentWindow = parent_window;\r\n        window->RootWindow = window->RootNonPopupWindow = window;\r\n        if (parent_window && (flags & ImGuiWindowFlags_ChildWindow))\r\n            window->RootWindow = parent_window->RootWindow;\r\n        if (parent_window && !(flags & ImGuiWindowFlags_Modal) && (flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)))\r\n            window->RootNonPopupWindow = parent_window->RootNonPopupWindow;\r\n        //window->RootNavWindow = window;\r\n        //while (window->RootNavWindow->Flags & ImGuiWindowFlags_NavFlattened)\r\n        //    window->RootNavWindow = window->RootNavWindow->ParentWindow;\r\n\r\n        window->Active = true;\r\n        window->BeginOrderWithinParent = 0;\r\n        window->BeginOrderWithinContext = g.WindowsActiveCount++;\r\n        window->BeginCount = 0;\r\n        window->ClipRect = ImVec4(-FLT_MAX,-FLT_MAX,+FLT_MAX,+FLT_MAX);\r\n        window->LastFrameActive = current_frame;\r\n        window->IDStack.resize(1);\r\n\r\n        // Setup draw list and outer clipping rectangle\r\n        window->DrawList->Clear();\r\n        window->DrawList->Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);\r\n        window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);\r\n        ImRect fullscreen_rect(GetVisibleRect());\r\n        if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup))\r\n            PushClipRect(parent_window->ClipRect.Min, parent_window->ClipRect.Max, true);\r\n        else\r\n            PushClipRect(fullscreen_rect.Min, fullscreen_rect.Max, true);\r\n\r\n        if (window_just_activated_by_user)\r\n        {\r\n            // Popup first latch mouse position, will position itself when it appears next frame\r\n            window->AutoPosLastDirection = ImGuiDir_None;\r\n            if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api)\r\n                window->PosFloat = g.IO.MousePos;\r\n        }\r\n\r\n        // Collapse window by double-clicking on title bar\r\n        // At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing\r\n        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !(flags & ImGuiWindowFlags_NoCollapse))\r\n        {\r\n            ImRect title_bar_rect = window->TitleBarRect();\r\n            if (g.HoveredWindow == window && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseDoubleClicked[0])\r\n            {\r\n                window->Collapsed = !window->Collapsed;\r\n                MarkIniSettingsDirty(window);\r\n                FocusWindow(window);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            window->Collapsed = false;\r\n        }\r\n\r\n        // SIZE\r\n\r\n        // Update contents size from last frame for auto-fitting (unless explicitly specified)\r\n        window->SizeContents = CalcSizeContents(window);\r\n\r\n        // Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)\r\n        if (window->HiddenFrames > 0)\r\n            window->HiddenFrames--;\r\n        if ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) != 0 && window_just_activated_by_user)\r\n        {\r\n            window->HiddenFrames = 1;\r\n            if (flags & ImGuiWindowFlags_AlwaysAutoResize)\r\n            {\r\n                if (!window_size_x_set_by_api)\r\n                    window->Size.x = window->SizeFull.x = 0.f;\r\n                if (!window_size_y_set_by_api)\r\n                    window->Size.y = window->SizeFull.y = 0.f;\r\n                window->SizeContents = ImVec2(0.f, 0.f);\r\n            }\r\n        }\r\n\r\n        // Lock window rounding, border size and rounding so that altering the border sizes for children doesn't have side-effects.\r\n        window->WindowRounding = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;\r\n        window->WindowBorderSize = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildBorderSize : ((flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;\r\n        window->WindowPadding = style.WindowPadding;\r\n        if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & (ImGuiWindowFlags_AlwaysUseWindowPadding | ImGuiWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)\r\n            window->WindowPadding = ImVec2(0.0f, (flags & ImGuiWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);\r\n        const float window_rounding = window->WindowRounding;\r\n        const float window_border_size = window->WindowBorderSize;\r\n\r\n        // Calculate auto-fit size, handle automatic resize\r\n        const ImVec2 size_auto_fit = CalcSizeAutoFit(window, window->SizeContents);\r\n        ImVec2 size_full_modified(FLT_MAX, FLT_MAX);\r\n        if (flags & ImGuiWindowFlags_AlwaysAutoResize && !window->Collapsed)\r\n        {\r\n            // Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.\r\n            if (!window_size_x_set_by_api)\r\n                window->SizeFull.x = size_full_modified.x = size_auto_fit.x;\r\n            if (!window_size_y_set_by_api)\r\n                window->SizeFull.y = size_full_modified.y = size_auto_fit.y;\r\n        }\r\n        else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)\r\n        {\r\n            // Auto-fit only grows during the first few frames\r\n            // We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.\r\n            if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)\r\n                window->SizeFull.x = size_full_modified.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;\r\n            if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)\r\n                window->SizeFull.y = size_full_modified.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;\r\n            if (!window->Collapsed)\r\n                MarkIniSettingsDirty(window);\r\n        }\r\n\r\n        // Apply minimum/maximum window size constraints and final size\r\n        window->SizeFull = CalcSizeAfterConstraint(window, window->SizeFull);\r\n        window->Size = window->Collapsed ? window->TitleBarRect().GetSize() : window->SizeFull;\r\n        if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup))\r\n        {\r\n            IM_ASSERT(window_size_x_set_by_api && window_size_y_set_by_api); // Submitted by BeginChild()\r\n            window->Size = window->SizeFull;\r\n        }\r\n\r\n        // SCROLLBAR STATUS\r\n\r\n        // Update scrollbar status (based on the Size that was effective during last frame or the auto-resized Size). \r\n        if (!window->Collapsed)\r\n        {\r\n            // When reading the current size we need to read it after size constraints have been applied\r\n            float size_x_for_scrollbars = size_full_modified.x != FLT_MAX ? window->SizeFull.x : window->SizeFullAtLastBegin.x;\r\n            float size_y_for_scrollbars = size_full_modified.y != FLT_MAX ? window->SizeFull.y : window->SizeFullAtLastBegin.y;\r\n            window->ScrollbarY = (flags & ImGuiWindowFlags_AlwaysVerticalScrollbar) || ((window->SizeContents.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar));\r\n            window->ScrollbarX = (flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar) || ((window->SizeContents.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f) - window->WindowPadding.x) && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar));\r\n            if (window->ScrollbarX && !window->ScrollbarY)\r\n                window->ScrollbarY = (window->SizeContents.y > size_y_for_scrollbars + style.ScrollbarSize) && !(flags & ImGuiWindowFlags_NoScrollbar);\r\n            window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);\r\n        }\r\n\r\n        // POSITION\r\n\r\n        // Position child window\r\n        if (flags & ImGuiWindowFlags_ChildWindow)\r\n        {\r\n            window->BeginOrderWithinParent = parent_window->DC.ChildWindows.Size;\r\n            parent_window->DC.ChildWindows.push_back(window);\r\n        }\r\n        if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_pos_set_by_api)\r\n            window->Pos = window->PosFloat = parent_window->DC.CursorPos;\r\n\r\n        const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFrames == 0);\r\n        if (window_pos_with_pivot)\r\n        {\r\n            // Position given a pivot (e.g. for centering)\r\n            SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, window->SetWindowPosVal - window->SizeFull * window->SetWindowPosPivot), 0);\r\n        }\r\n        else if (flags & ImGuiWindowFlags_ChildMenu)\r\n        {\r\n            // Child menus typically request _any_ position within the parent menu item, and then our FindBestPopupWindowPos() function will move the new menu outside the parent bounds.\r\n            // This is how we end up with child menus appearing (most-commonly) on the right of the parent menu.\r\n            IM_ASSERT(window_pos_set_by_api);\r\n            float horizontal_overlap = style.ItemSpacing.x; // We want some overlap to convey the relative depth of each popup (currently the amount of overlap it is hard-coded to style.ItemSpacing.x, may need to introduce another style value).\r\n            ImGuiWindow* parent_menu = parent_window_in_stack;\r\n            ImRect rect_to_avoid;\r\n            if (parent_menu->DC.MenuBarAppending)\r\n                rect_to_avoid = ImRect(-FLT_MAX, parent_menu->Pos.y + parent_menu->TitleBarHeight(), FLT_MAX, parent_menu->Pos.y + parent_menu->TitleBarHeight() + parent_menu->MenuBarHeight());\r\n            else\r\n                rect_to_avoid = ImRect(parent_menu->Pos.x + horizontal_overlap, -FLT_MAX, parent_menu->Pos.x + parent_menu->Size.x - horizontal_overlap - parent_menu->ScrollbarSizes.x, FLT_MAX);\r\n            window->PosFloat = FindBestWindowPosForPopup(window->PosFloat, window->Size, &window->AutoPosLastDirection, rect_to_avoid);\r\n        }\r\n        else if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)\r\n        {\r\n            ImRect rect_to_avoid(window->PosFloat.x - 1, window->PosFloat.y - 1, window->PosFloat.x + 1, window->PosFloat.y + 1);\r\n            window->PosFloat = FindBestWindowPosForPopup(window->PosFloat, window->Size, &window->AutoPosLastDirection, rect_to_avoid);\r\n        }\r\n\r\n        // Position tooltip (always follows mouse)\r\n        if ((flags & ImGuiWindowFlags_Tooltip) != 0 && !window_pos_set_by_api)\r\n        {\r\n            ImVec2 ref_pos = g.IO.MousePos;\r\n            ImRect rect_to_avoid(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 24, ref_pos.y + 24); // FIXME: Completely hard-coded. Store boxes in mouse cursor data? Scale? Center on cursor hit-point?\r\n            window->PosFloat = FindBestWindowPosForPopup(ref_pos, window->Size, &window->AutoPosLastDirection, rect_to_avoid);\r\n            if (window->AutoPosLastDirection == ImGuiDir_None)\r\n                window->PosFloat = ref_pos + ImVec2(2,2); // If there's not enough room, for tooltip we prefer avoiding the cursor at all cost even if it means that part of the tooltip won't be visible.\r\n        }\r\n\r\n        // Clamp position so it stays visible\r\n        if (!(flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Tooltip))\r\n        {\r\n            if (!window_pos_set_by_api && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && g.IO.DisplaySize.x > 0.0f && g.IO.DisplaySize.y > 0.0f) // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.\r\n            {\r\n                ImVec2 padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);\r\n                window->PosFloat = ImMax(window->PosFloat + window->Size, padding) - window->Size;\r\n                window->PosFloat = ImMin(window->PosFloat, g.IO.DisplaySize - padding);\r\n            }\r\n        }\r\n        window->Pos = ImVec2((float)(int)window->PosFloat.x, (float)(int)window->PosFloat.y);\r\n\r\n        // Default item width. Make it proportional to window size if window manually resizes\r\n        if (window->Size.x > 0.0f && !(flags & ImGuiWindowFlags_Tooltip) && !(flags & ImGuiWindowFlags_AlwaysAutoResize))\r\n            window->ItemWidthDefault = (float)(int)(window->Size.x * 0.65f);\r\n        else\r\n            window->ItemWidthDefault = (float)(int)(g.FontSize * 16.0f);\r\n\r\n        // Prepare for focus requests\r\n        window->FocusIdxAllRequestCurrent = (window->FocusIdxAllRequestNext == INT_MAX || window->FocusIdxAllCounter == -1) ? INT_MAX : (window->FocusIdxAllRequestNext + (window->FocusIdxAllCounter+1)) % (window->FocusIdxAllCounter+1);\r\n        window->FocusIdxTabRequestCurrent = (window->FocusIdxTabRequestNext == INT_MAX || window->FocusIdxTabCounter == -1) ? INT_MAX : (window->FocusIdxTabRequestNext + (window->FocusIdxTabCounter+1)) % (window->FocusIdxTabCounter+1);\r\n        window->FocusIdxAllCounter = window->FocusIdxTabCounter = -1;\r\n        window->FocusIdxAllRequestNext = window->FocusIdxTabRequestNext = INT_MAX;\r\n\r\n        // Apply scrolling\r\n        window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window);\r\n        window->ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);\r\n\r\n        // Apply focus, new windows appears in front\r\n        bool want_focus = false;\r\n        if (window_just_activated_by_user && !(flags & ImGuiWindowFlags_NoFocusOnAppearing))\r\n            if (!(flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Tooltip)) || (flags & ImGuiWindowFlags_Popup))\r\n                want_focus = true;\r\n\r\n        // Draw modal window background (darkens what is behind them)\r\n        if ((flags & ImGuiWindowFlags_Modal) != 0 && window == GetFrontMostModalRootWindow())\r\n            window->DrawList->AddRectFilled(fullscreen_rect.Min, fullscreen_rect.Max, GetColorU32(ImGuiCol_ModalWindowDarkening, g.ModalWindowDarkeningRatio));\r\n\r\n        // Draw window + handle manual resize\r\n        ImRect title_bar_rect = window->TitleBarRect();\r\n        if (window->Collapsed)\r\n        {\r\n            // Title bar only\r\n            float backup_border_size = style.FrameBorderSize;\r\n            g.Style.FrameBorderSize = window->WindowBorderSize;\r\n            RenderFrame(title_bar_rect.Min, title_bar_rect.Max, GetColorU32(ImGuiCol_TitleBgCollapsed), true, window_rounding);\r\n            g.Style.FrameBorderSize = backup_border_size;\r\n        }\r\n        else\r\n        {\r\n            // Handle resize for: Resize Grips, Borders, Gamepad\r\n            int border_held = -1;\r\n            ImU32 resize_grip_col[4] = { 0 };\r\n            const int resize_grip_count = (flags & ImGuiWindowFlags_ResizeFromAnySide) ? 2 : 1; // 4\r\n            const int resize_border_count = (flags & ImGuiWindowFlags_ResizeFromAnySide) ? 4 : 0;\r\n\r\n            const float grip_draw_size = (float)(int)ImMax(g.FontSize * 1.35f, window_rounding + 1.0f + g.FontSize * 0.2f);\r\n            const float grip_hover_size = (float)(int)(grip_draw_size * 0.75f);\r\n            if (!(flags & ImGuiWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && !(flags & ImGuiWindowFlags_NoResize))\r\n            {\r\n                ImVec2 pos_target(FLT_MAX, FLT_MAX);\r\n                ImVec2 size_target(FLT_MAX, FLT_MAX);\r\n\r\n                // Manual resize grips\r\n                PushID(\"#RESIZE\");\r\n                for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)\r\n                {\r\n                    const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];\r\n                    const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPos);\r\n\r\n                    // Using the FlattenChilds button flag we make the resize button accessible even if we are hovering over a child window\r\n                    ImRect resize_rect(corner, corner + grip.InnerDir * grip_hover_size);\r\n                    resize_rect.FixInverted();\r\n                    bool hovered, held;\r\n                    ButtonBehavior(resize_rect, window->GetID((void*)(intptr_t)resize_grip_n), &hovered, &held, ImGuiButtonFlags_FlattenChildren);\r\n                    if (hovered || held)\r\n                        g.MouseCursor = (resize_grip_n & 1) ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;\r\n\r\n                    if (g.HoveredWindow == window && held && g.IO.MouseDoubleClicked[0] && resize_grip_n == 0)\r\n                    {\r\n                        // Manual auto-fit when double-clicking\r\n                        size_target = CalcSizeAfterConstraint(window, size_auto_fit);\r\n                        ClearActiveID();\r\n                    }\r\n                    else if (held)\r\n                    {\r\n                        // Resize from any of the four corners\r\n                        // We don't use an incremental MouseDelta but rather compute an absolute target size based on mouse position\r\n                        ImVec2 corner_target = g.IO.MousePos - g.ActiveIdClickOffset + resize_rect.GetSize() * grip.CornerPos; // Corner of the window corresponding to our corner grip\r\n                        CalcResizePosSizeFromAnyCorner(window, corner_target, grip.CornerPos, &pos_target, &size_target);\r\n                    }\r\n                    if (resize_grip_n == 0 || held || hovered)\r\n                        resize_grip_col[resize_grip_n] = GetColorU32(held ? ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_ResizeGripHovered : ImGuiCol_ResizeGrip);\r\n                }\r\n                for (int border_n = 0; border_n < resize_border_count; border_n++)\r\n                {\r\n                    const float BORDER_SIZE = 5.0f;          // FIXME: Only works _inside_ window because of HoveredWindow check.\r\n                    const float BORDER_APPEAR_TIMER = 0.05f; // Reduce visual noise\r\n                    bool hovered, held;\r\n                    ImRect border_rect = GetBorderRect(window, border_n, grip_hover_size, BORDER_SIZE);\r\n                    ButtonBehavior(border_rect, window->GetID((void*)(intptr_t)(border_n+4)), &hovered, &held, ImGuiButtonFlags_FlattenChildren);\r\n                    if ((hovered && g.HoveredIdTimer > BORDER_APPEAR_TIMER) || held)\r\n                    {\r\n                        g.MouseCursor = (border_n & 1) ? ImGuiMouseCursor_ResizeEW : ImGuiMouseCursor_ResizeNS;\r\n                        if (held) border_held = border_n;\r\n                    }\r\n                    if (held)\r\n                    {\r\n                        ImVec2 border_target = window->Pos;\r\n                        ImVec2 border_posn;\r\n                        if (border_n == 0) { border_posn = ImVec2(0, 0); border_target.y = (g.IO.MousePos.y - g.ActiveIdClickOffset.y); }\r\n                        if (border_n == 1) { border_posn = ImVec2(1, 0); border_target.x = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + BORDER_SIZE); }\r\n                        if (border_n == 2) { border_posn = ImVec2(0, 1); border_target.y = (g.IO.MousePos.y - g.ActiveIdClickOffset.y + BORDER_SIZE); }\r\n                        if (border_n == 3) { border_posn = ImVec2(0, 0); border_target.x = (g.IO.MousePos.x - g.ActiveIdClickOffset.x); }\r\n                        CalcResizePosSizeFromAnyCorner(window, border_target, border_posn, &pos_target, &size_target);\r\n                    }\r\n                }\r\n                PopID();\r\n\r\n                // Apply back modified position/size to window\r\n                if (size_target.x != FLT_MAX)\r\n                {\r\n                    window->SizeFull = size_target;\r\n                    MarkIniSettingsDirty(window);\r\n                }\r\n                if (pos_target.x != FLT_MAX)\r\n                {\r\n                    window->Pos = window->PosFloat = ImVec2((float)(int)pos_target.x, (float)(int)pos_target.y);\r\n                    MarkIniSettingsDirty(window);\r\n                }\r\n\r\n                window->Size = window->SizeFull;\r\n                title_bar_rect = window->TitleBarRect();\r\n            }\r\n\r\n            // Window background, Default Alpha\r\n            ImU32 bg_col = GetColorU32(GetWindowBgColorIdxFromFlags(flags));\r\n            window->DrawList->AddRectFilled(window->Pos+ImVec2(0,window->TitleBarHeight()), window->Pos+window->Size, bg_col, window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Bot);\r\n\r\n            // Title bar\r\n            const bool window_is_focused = want_focus || (g.NavWindow && window->RootNonPopupWindow == g.NavWindow->RootNonPopupWindow);\r\n            if (!(flags & ImGuiWindowFlags_NoTitleBar))\r\n                window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, GetColorU32(window_is_focused ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg), window_rounding, ImDrawCornerFlags_Top);\r\n\r\n            // Menu bar\r\n            if (flags & ImGuiWindowFlags_MenuBar)\r\n            {\r\n                ImRect menu_bar_rect = window->MenuBarRect();\r\n                menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.\r\n                window->DrawList->AddRectFilled(menu_bar_rect.Min, menu_bar_rect.Max, GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawCornerFlags_Top);\r\n                if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)\r\n                    window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);\r\n            }\r\n\r\n            // Scrollbars\r\n            if (window->ScrollbarX)\r\n                Scrollbar(ImGuiLayoutType_Horizontal);\r\n            if (window->ScrollbarY)\r\n                Scrollbar(ImGuiLayoutType_Vertical);\r\n\r\n            // Render resize grips (after their input handling so we don't have a frame of latency)\r\n            if (!(flags & ImGuiWindowFlags_NoResize))\r\n            {\r\n                for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)\r\n                {\r\n                    const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];\r\n                    const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPos);\r\n                    window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(window_border_size, grip_draw_size) : ImVec2(grip_draw_size, window_border_size)));\r\n                    window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(grip_draw_size, window_border_size) : ImVec2(window_border_size, grip_draw_size)));\r\n                    window->DrawList->PathArcToFast(ImVec2(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);\r\n                    window->DrawList->PathFillConvex(resize_grip_col[resize_grip_n]);\r\n                }\r\n            }\r\n\r\n            // Borders\r\n            if (window_border_size > 0.0f)\r\n                window->DrawList->AddRect(window->Pos, window->Pos+window->Size, GetColorU32(ImGuiCol_Border), window_rounding, ImDrawCornerFlags_All, window_border_size);\r\n            if (border_held != -1)\r\n            {\r\n                ImRect border = GetBorderRect(window, border_held, grip_draw_size, 0.0f);\r\n                window->DrawList->AddLine(border.Min, border.Max, GetColorU32(ImGuiCol_SeparatorActive), ImMax(1.0f, window_border_size));\r\n            }\r\n            if (style.FrameBorderSize > 0 && !(flags & ImGuiWindowFlags_NoTitleBar))\r\n                window->DrawList->AddLine(title_bar_rect.GetBL() + ImVec2(style.WindowBorderSize, -1), title_bar_rect.GetBR() + ImVec2(-style.WindowBorderSize,-1), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);\r\n        }\r\n\r\n        // Store a backup of SizeFull which we will use next frame to decide if we need scrollbars. \r\n        window->SizeFullAtLastBegin = window->SizeFull;\r\n\r\n        // Update ContentsRegionMax. All the variable it depends on are set above in this function.\r\n        window->ContentsRegionRect.Min.x = -window->Scroll.x + window->WindowPadding.x;\r\n        window->ContentsRegionRect.Min.y = -window->Scroll.y + window->WindowPadding.y + window->TitleBarHeight() + window->MenuBarHeight();\r\n        window->ContentsRegionRect.Max.x = -window->Scroll.x - window->WindowPadding.x + (window->SizeContentsExplicit.x != 0.0f ? window->SizeContentsExplicit.x : (window->Size.x - window->ScrollbarSizes.x)); \r\n        window->ContentsRegionRect.Max.y = -window->Scroll.y - window->WindowPadding.y + (window->SizeContentsExplicit.y != 0.0f ? window->SizeContentsExplicit.y : (window->Size.y - window->ScrollbarSizes.y)); \r\n\r\n        // Setup drawing context\r\n        // (NB: That term \"drawing context / DC\" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)\r\n        window->DC.IndentX = 0.0f + window->WindowPadding.x - window->Scroll.x;\r\n        window->DC.GroupOffsetX = 0.0f;\r\n        window->DC.ColumnsOffsetX = 0.0f;\r\n        window->DC.CursorStartPos = window->Pos + ImVec2(window->DC.IndentX + window->DC.ColumnsOffsetX, window->TitleBarHeight() + window->MenuBarHeight() + window->WindowPadding.y - window->Scroll.y);\r\n        window->DC.CursorPos = window->DC.CursorStartPos;\r\n        window->DC.CursorPosPrevLine = window->DC.CursorPos;\r\n        window->DC.CursorMaxPos = window->DC.CursorStartPos;\r\n        window->DC.CurrentLineHeight = window->DC.PrevLineHeight = 0.0f;\r\n        window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;\r\n        window->DC.MenuBarAppending = false;\r\n        window->DC.MenuBarOffsetX = ImMax(window->WindowPadding.x, style.ItemSpacing.x);\r\n        window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f;\r\n        window->DC.ChildWindows.resize(0);\r\n        window->DC.LayoutType = ImGuiLayoutType_Vertical;\r\n        window->DC.ItemFlags = ImGuiItemFlags_Default_;\r\n        window->DC.ItemWidth = window->ItemWidthDefault;\r\n        window->DC.TextWrapPos = -1.0f; // disabled\r\n        window->DC.ItemFlagsStack.resize(0);\r\n        window->DC.ItemWidthStack.resize(0);\r\n        window->DC.TextWrapPosStack.resize(0);\r\n        window->DC.ColumnsSet = NULL;\r\n        window->DC.TreeDepth = 0;\r\n        window->DC.StateStorage = &window->StateStorage;\r\n        window->DC.GroupStack.resize(0);\r\n        window->MenuColumns.Update(3, style.ItemSpacing.x, window_just_activated_by_user);\r\n\r\n        if ((flags & ImGuiWindowFlags_ChildWindow) && (window->DC.ItemFlags != parent_window->DC.ItemFlags))\r\n        {\r\n            window->DC.ItemFlags = parent_window->DC.ItemFlags;\r\n            window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);\r\n        }\r\n\r\n        if (window->AutoFitFramesX > 0)\r\n            window->AutoFitFramesX--;\r\n        if (window->AutoFitFramesY > 0)\r\n            window->AutoFitFramesY--;\r\n\r\n        // Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)\r\n        if (want_focus)\r\n            FocusWindow(window);\r\n\r\n        // Title bar\r\n        if (!(flags & ImGuiWindowFlags_NoTitleBar))\r\n        {\r\n            // Collapse button\r\n            if (!(flags & ImGuiWindowFlags_NoCollapse))\r\n            {\r\n                RenderTriangle(window->Pos + style.FramePadding, window->Collapsed ? ImGuiDir_Right : ImGuiDir_Down, 1.0f);\r\n            }\r\n\r\n            // Close button\r\n            if (p_open != NULL)\r\n            {\r\n                const float PAD = 2.0f;\r\n                const float rad = (window->TitleBarHeight() - PAD*2.0f) * 0.5f;\r\n                if (CloseButton(window->GetID(\"#CLOSE\"), window->Rect().GetTR() + ImVec2(-PAD - rad, PAD + rad), rad))\r\n                    *p_open = false;\r\n            }\r\n\r\n            // Title text (FIXME: refactor text alignment facilities along with RenderText helpers)\r\n            const ImVec2 text_size = CalcTextSize(name, NULL, true);\r\n            ImVec2 text_min = window->Pos;\r\n            ImVec2 text_max = window->Pos + ImVec2(window->Size.x, style.FramePadding.y*2 + text_size.y);\r\n            ImRect clip_rect;\r\n            clip_rect.Max = ImVec2(window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x), text_max.y); // Match the size of CloseWindowButton()\r\n            float pad_left = (flags & ImGuiWindowFlags_NoCollapse) == 0 ? (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x) : style.FramePadding.x;\r\n            float pad_right = (p_open != NULL) ? (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x) : style.FramePadding.x;\r\n            if (style.WindowTitleAlign.x > 0.0f) pad_right = ImLerp(pad_right, pad_left, style.WindowTitleAlign.x);\r\n            text_min.x += pad_left;\r\n            text_max.x -= pad_right;\r\n            clip_rect.Min = ImVec2(text_min.x, window->Pos.y);\r\n            RenderTextClipped(text_min, text_max, name, NULL, &text_size, style.WindowTitleAlign, &clip_rect);\r\n        }\r\n\r\n        // Save clipped aabb so we can access it in constant-time in FindHoveredWindow()\r\n        window->WindowRectClipped = window->Rect();\r\n        window->WindowRectClipped.ClipWith(window->ClipRect);\r\n\r\n        // Pressing CTRL+C while holding on a window copy its content to the clipboard\r\n        // This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.\r\n        // Maybe we can support CTRL+C on every element?\r\n        /*\r\n        if (g.ActiveId == move_id)\r\n            if (g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_C))\r\n                ImGui::LogToClipboard();\r\n        */\r\n\r\n        // Inner rectangle\r\n        // We set this up after processing the resize grip so that our clip rectangle doesn't lag by a frame\r\n        // Note that if our window is collapsed we will end up with a null clipping rectangle which is the correct behavior.\r\n        window->InnerRect.Min.x = title_bar_rect.Min.x + window->WindowBorderSize;\r\n        window->InnerRect.Min.y = title_bar_rect.Max.y + window->MenuBarHeight() + (((flags & ImGuiWindowFlags_MenuBar) || !(flags & ImGuiWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);\r\n        window->InnerRect.Max.x = window->Pos.x + window->Size.x - window->ScrollbarSizes.x - window->WindowBorderSize;\r\n        window->InnerRect.Max.y = window->Pos.y + window->Size.y - window->ScrollbarSizes.y - window->WindowBorderSize;\r\n        //window->DrawList->AddRect(window->InnerRect.Min, window->InnerRect.Max, IM_COL32_WHITE);\r\n\r\n        // After Begin() we fill the last item / hovered data using the title bar data. Make that a standard behavior (to allow usage of context menus on title bar only, etc.).\r\n        window->DC.LastItemId = window->MoveId;\r\n        window->DC.LastItemRect = title_bar_rect;\r\n        window->DC.LastItemRectHoveredRect = IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false);\r\n    }\r\n\r\n    // Inner clipping rectangle\r\n    // Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.\r\n    const float border_size = window->WindowBorderSize;\r\n    ImRect clip_rect;\r\n    clip_rect.Min.x = ImFloor(0.5f + window->InnerRect.Min.x + ImMax(0.0f, ImFloor(window->WindowPadding.x*0.5f - border_size)));\r\n    clip_rect.Min.y = ImFloor(0.5f + window->InnerRect.Min.y);\r\n    clip_rect.Max.x = ImFloor(0.5f + window->InnerRect.Max.x - ImMax(0.0f, ImFloor(window->WindowPadding.x*0.5f - border_size)));\r\n    clip_rect.Max.y = ImFloor(0.5f + window->InnerRect.Max.y);\r\n    PushClipRect(clip_rect.Min, clip_rect.Max, true);\r\n\r\n    // Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default \"Debug\" window is unused)\r\n    if (first_begin_of_the_frame)\r\n        window->WriteAccessed = false;\r\n\r\n    window->BeginCount++;\r\n    g.SetNextWindowSizeConstraint = false;\r\n\r\n    // Child window can be out of sight and have \"negative\" clip windows.\r\n    // Mark them as collapsed so commands are skipped earlier (we can't manually collapse because they have no title bar).\r\n    if (flags & ImGuiWindowFlags_ChildWindow)\r\n    {\r\n        IM_ASSERT((flags & ImGuiWindowFlags_NoTitleBar) != 0);\r\n        window->Collapsed = parent_window && parent_window->Collapsed;\r\n\r\n        if (!(flags & ImGuiWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)\r\n            window->Collapsed |= (window->WindowRectClipped.Min.x >= window->WindowRectClipped.Max.x || window->WindowRectClipped.Min.y >= window->WindowRectClipped.Max.y);\r\n\r\n        // We also hide the window from rendering because we've already added its border to the command list.\r\n        // (we could perform the check earlier in the function but it is simpler at this point)\r\n        if (window->Collapsed)\r\n            window->Active = false;\r\n    }\r\n    if (style.Alpha <= 0.0f)\r\n        window->Active = false;\r\n\r\n    // Return false if we don't intend to display anything to allow user to perform an early out optimization\r\n    window->SkipItems = (window->Collapsed || !window->Active) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0;\r\n    return !window->SkipItems;\r\n}\r\n\r\n// Old Begin() API with 5 parameters, avoid calling this version directly! Use SetNextWindowSize()+Begin() instead.\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\nbool ImGui::Begin(const char* name, bool* p_open, const ImVec2& size_on_first_use, float bg_alpha_override, ImGuiWindowFlags flags)\r\n{\r\n    // Old API feature: we could pass the initial window size as a parameter, however this was very misleading because in most cases it would only affect the window when it didn't have storage in the .ini file.\r\n    if (size_on_first_use.x != 0.0f || size_on_first_use.y != 0.0f)\r\n        SetNextWindowSize(size_on_first_use, ImGuiCond_FirstUseEver);\r\n\r\n    // Old API feature: we could override the window background alpha with a parameter. This is actually tricky to reproduce manually because: \r\n    // (1) there are multiple variants of WindowBg (popup, tooltip, etc.) and (2) you can't call PushStyleColor before Begin and PopStyleColor just after Begin() because of how CheckStackSizes() behave.\r\n    // The user-side solution is to do backup = GetStyleColorVec4(ImGuiCol_xxxBG), PushStyleColor(ImGuiCol_xxxBg), Begin, PushStyleColor(ImGuiCol_xxxBg, backup), [...], PopStyleColor(), End(); PopStyleColor() - which is super awkward.\r\n    // The alpha override was rarely used but for now we'll leave the Begin() variant around for a bit. We may either lift the constraint on CheckStackSizes() either add a SetNextWindowBgAlpha() helper that does it magically.\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiCol bg_color_idx = GetWindowBgColorIdxFromFlags(flags);\r\n    const ImVec4 bg_color_backup = g.Style.Colors[bg_color_idx];\r\n    if (bg_alpha_override >= 0.0f)\r\n        g.Style.Colors[bg_color_idx].w = bg_alpha_override;\r\n\r\n    bool ret = Begin(name, p_open, flags);\r\n\r\n    if (bg_alpha_override >= 0.0f)\r\n        g.Style.Colors[bg_color_idx] = bg_color_backup;\r\n    return ret;\r\n}\r\n#endif // IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n\r\nvoid ImGui::End()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    if (window->DC.ColumnsSet != NULL)\r\n        EndColumns();\r\n    PopClipRect();   // inner window clip rectangle\r\n\r\n    // Stop logging\r\n    if (!(window->Flags & ImGuiWindowFlags_ChildWindow))    // FIXME: add more options for scope of logging\r\n        LogFinish();\r\n\r\n    // Pop\r\n    // NB: we don't clear 'window->RootWindow'. The pointer is allowed to live until the next call to Begin().\r\n    g.CurrentWindowStack.pop_back();\r\n    if (window->Flags & ImGuiWindowFlags_Popup)\r\n        g.CurrentPopupStack.pop_back();\r\n    CheckStacksSize(window, false);\r\n    SetCurrentWindow(g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back());\r\n}\r\n\r\n// Vertical scrollbar\r\n// The entire piece of code below is rather confusing because:\r\n// - We handle absolute seeking (when first clicking outside the grab) and relative manipulation (afterward or when clicking inside the grab)\r\n// - We store values as normalized ratio and in a form that allows the window content to change while we are holding on a scrollbar\r\n// - We handle both horizontal and vertical scrollbars, which makes the terminology not ideal.\r\nvoid ImGui::Scrollbar(ImGuiLayoutType direction)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    const bool horizontal = (direction == ImGuiLayoutType_Horizontal);\r\n    const ImGuiStyle& style = g.Style;\r\n    const ImGuiID id = window->GetID(horizontal ? \"#SCROLLX\" : \"#SCROLLY\");\r\n\r\n    // Render background\r\n    bool other_scrollbar = (horizontal ? window->ScrollbarY : window->ScrollbarX);\r\n    float other_scrollbar_size_w = other_scrollbar ? style.ScrollbarSize : 0.0f;\r\n    const ImRect window_rect = window->Rect();\r\n    const float border_size = window->WindowBorderSize;\r\n    ImRect bb = horizontal\r\n        ? ImRect(window->Pos.x + border_size, window_rect.Max.y - style.ScrollbarSize, window_rect.Max.x - other_scrollbar_size_w - border_size, window_rect.Max.y - border_size)\r\n        : ImRect(window_rect.Max.x - style.ScrollbarSize, window->Pos.y + border_size, window_rect.Max.x - border_size, window_rect.Max.y - other_scrollbar_size_w - border_size);\r\n    if (!horizontal)\r\n        bb.Min.y += window->TitleBarHeight() + ((window->Flags & ImGuiWindowFlags_MenuBar) ? window->MenuBarHeight() : 0.0f);\r\n    if (bb.GetWidth() <= 0.0f || bb.GetHeight() <= 0.0f)\r\n        return;\r\n\r\n    int window_rounding_corners;\r\n    if (horizontal)\r\n        window_rounding_corners = ImDrawCornerFlags_BotLeft | (other_scrollbar ? 0 : ImDrawCornerFlags_BotRight);\r\n    else\r\n        window_rounding_corners = (((window->Flags & ImGuiWindowFlags_NoTitleBar) && !(window->Flags & ImGuiWindowFlags_MenuBar)) ? ImDrawCornerFlags_TopRight : 0) | (other_scrollbar ? 0 : ImDrawCornerFlags_BotRight);\r\n    window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_ScrollbarBg), window->WindowRounding, window_rounding_corners);\r\n    bb.Expand(ImVec2(-ImClamp((float)(int)((bb.Max.x - bb.Min.x - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp((float)(int)((bb.Max.y - bb.Min.y - 2.0f) * 0.5f), 0.0f, 3.0f)));\r\n\r\n    // V denote the main, longer axis of the scrollbar (= height for a vertical scrollbar)\r\n    float scrollbar_size_v = horizontal ? bb.GetWidth() : bb.GetHeight();\r\n    float scroll_v = horizontal ? window->Scroll.x : window->Scroll.y;\r\n    float win_size_avail_v = (horizontal ? window->SizeFull.x : window->SizeFull.y) - other_scrollbar_size_w;\r\n    float win_size_contents_v = horizontal ? window->SizeContents.x : window->SizeContents.y;\r\n\r\n    // Calculate the height of our grabbable box. It generally represent the amount visible (vs the total scrollable amount)\r\n    // But we maintain a minimum size in pixel to allow for the user to still aim inside.\r\n    IM_ASSERT(ImMax(win_size_contents_v, win_size_avail_v) > 0.0f); // Adding this assert to check if the ImMax(XXX,1.0f) is still needed. PLEASE CONTACT ME if this triggers.\r\n    const float win_size_v = ImMax(ImMax(win_size_contents_v, win_size_avail_v), 1.0f);\r\n    const float grab_h_pixels = ImClamp(scrollbar_size_v * (win_size_avail_v / win_size_v), style.GrabMinSize, scrollbar_size_v);\r\n    const float grab_h_norm = grab_h_pixels / scrollbar_size_v;\r\n\r\n    // Handle input right away. None of the code of Begin() is relying on scrolling position before calling Scrollbar().\r\n    bool held = false;\r\n    bool hovered = false;\r\n    const bool previously_held = (g.ActiveId == id);\r\n    ButtonBehavior(bb, id, &hovered, &held);\r\n\r\n    float scroll_max = ImMax(1.0f, win_size_contents_v - win_size_avail_v);\r\n    float scroll_ratio = ImSaturate(scroll_v / scroll_max);\r\n    float grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;\r\n    if (held && grab_h_norm < 1.0f)\r\n    {\r\n        float scrollbar_pos_v = horizontal ? bb.Min.x : bb.Min.y;\r\n        float mouse_pos_v = horizontal ? g.IO.MousePos.x : g.IO.MousePos.y;\r\n        float* click_delta_to_grab_center_v = horizontal ? &g.ScrollbarClickDeltaToGrabCenter.x : &g.ScrollbarClickDeltaToGrabCenter.y;\r\n\r\n        // Click position in scrollbar normalized space (0.0f->1.0f)\r\n        const float clicked_v_norm = ImSaturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v);\r\n        SetHoveredID(id);\r\n\r\n        bool seek_absolute = false;\r\n        if (!previously_held)\r\n        {\r\n            // On initial click calculate the distance between mouse and the center of the grab\r\n            if (clicked_v_norm >= grab_v_norm && clicked_v_norm <= grab_v_norm + grab_h_norm)\r\n            {\r\n                *click_delta_to_grab_center_v = clicked_v_norm - grab_v_norm - grab_h_norm*0.5f;\r\n            }\r\n            else\r\n            {\r\n                seek_absolute = true;\r\n                *click_delta_to_grab_center_v = 0.0f;\r\n            }\r\n        }\r\n\r\n        // Apply scroll\r\n        // It is ok to modify Scroll here because we are being called in Begin() after the calculation of SizeContents and before setting up our starting position\r\n        const float scroll_v_norm = ImSaturate((clicked_v_norm - *click_delta_to_grab_center_v - grab_h_norm*0.5f) / (1.0f - grab_h_norm));\r\n        scroll_v = (float)(int)(0.5f + scroll_v_norm * scroll_max);//(win_size_contents_v - win_size_v));\r\n        if (horizontal)\r\n            window->Scroll.x = scroll_v;\r\n        else\r\n            window->Scroll.y = scroll_v;\r\n\r\n        // Update values for rendering\r\n        scroll_ratio = ImSaturate(scroll_v / scroll_max);\r\n        grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;\r\n\r\n        // Update distance to grab now that we have seeked and saturated\r\n        if (seek_absolute)\r\n            *click_delta_to_grab_center_v = clicked_v_norm - grab_v_norm - grab_h_norm*0.5f;\r\n    }\r\n\r\n    // Render\r\n    const ImU32 grab_col = GetColorU32(held ? ImGuiCol_ScrollbarGrabActive : hovered ? ImGuiCol_ScrollbarGrabHovered : ImGuiCol_ScrollbarGrab);\r\n    ImRect grab_rect;\r\n    if (horizontal)\r\n        grab_rect = ImRect(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y, ImMin(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, window_rect.Max.x), bb.Max.y);\r\n    else\r\n        grab_rect = ImRect(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm), bb.Max.x, ImMin(ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels, window_rect.Max.y));\r\n    window->DrawList->AddRectFilled(grab_rect.Min, grab_rect.Max, grab_col, style.ScrollbarRounding);\r\n}\r\n\r\nvoid ImGui::BringWindowToFront(ImGuiWindow* window)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.Windows.back() == window)\r\n        return;\r\n    for (int i = 0; i < g.Windows.Size; i++)\r\n        if (g.Windows[i] == window)\r\n        {\r\n            g.Windows.erase(g.Windows.begin() + i);\r\n            g.Windows.push_back(window);\r\n            break;\r\n        }\r\n}\r\n\r\nvoid ImGui::BringWindowToBack(ImGuiWindow* window)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.Windows[0] == window)\r\n        return;\r\n    for (int i = 0; i < g.Windows.Size; i++)\r\n        if (g.Windows[i] == window)\r\n        {\r\n            memmove(&g.Windows[1], &g.Windows[0], (size_t)i * sizeof(ImGuiWindow*));\r\n            g.Windows[0] = window;\r\n            break;\r\n        }\r\n}\r\n\r\n// Moving window to front of display and set focus (which happens to be back of our sorted list)\r\nvoid ImGui::FocusWindow(ImGuiWindow* window)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    // Always mark the window we passed as focused. This is used for keyboard interactions such as tabbing.\r\n    g.NavWindow = window;\r\n\r\n    // Passing NULL allow to disable keyboard focus\r\n    if (!window)\r\n        return;\r\n\r\n    // Move the root window to the top of the pile\r\n    if (window->RootWindow)\r\n        window = window->RootWindow;\r\n\r\n    // Steal focus on active widgets\r\n    if (window->Flags & ImGuiWindowFlags_Popup) // FIXME: This statement should be unnecessary. Need further testing before removing it..\r\n        if (g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow->RootWindow != window)\r\n            ClearActiveID();\r\n\r\n    // Bring to front\r\n    if (!(window->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus))\r\n        BringWindowToFront(window);\r\n}\r\n\r\nvoid ImGui::FocusPreviousWindow()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    for (int i = g.Windows.Size - 1; i >= 0; i--)\r\n        if (g.Windows[i]->WasActive && !(g.Windows[i]->Flags & ImGuiWindowFlags_ChildWindow))\r\n        {\r\n            FocusWindow(g.Windows[i]);\r\n            return;\r\n        }\r\n}\r\n\r\nvoid ImGui::PushItemWidth(float item_width)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.ItemWidth = (item_width == 0.0f ? window->ItemWidthDefault : item_width);\r\n    window->DC.ItemWidthStack.push_back(window->DC.ItemWidth);\r\n}\r\n\r\nvoid ImGui::PushMultiItemsWidths(int components, float w_full)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    const ImGuiStyle& style = GImGui->Style;\r\n    if (w_full <= 0.0f)\r\n        w_full = CalcItemWidth();\r\n    const float w_item_one  = ImMax(1.0f, (float)(int)((w_full - (style.ItemInnerSpacing.x) * (components-1)) / (float)components));\r\n    const float w_item_last = ImMax(1.0f, (float)(int)(w_full - (w_item_one + style.ItemInnerSpacing.x) * (components-1)));\r\n    window->DC.ItemWidthStack.push_back(w_item_last);\r\n    for (int i = 0; i < components-1; i++)\r\n        window->DC.ItemWidthStack.push_back(w_item_one);\r\n    window->DC.ItemWidth = window->DC.ItemWidthStack.back();\r\n}\r\n\r\nvoid ImGui::PopItemWidth()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.ItemWidthStack.pop_back();\r\n    window->DC.ItemWidth = window->DC.ItemWidthStack.empty() ? window->ItemWidthDefault : window->DC.ItemWidthStack.back();\r\n}\r\n\r\nfloat ImGui::CalcItemWidth()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    float w = window->DC.ItemWidth;\r\n    if (w < 0.0f)\r\n    {\r\n        // Align to a right-side limit. We include 1 frame padding in the calculation because this is how the width is always used (we add 2 frame padding to it), but we could move that responsibility to the widget as well.\r\n        float width_to_right_edge = GetContentRegionAvail().x;\r\n        w = ImMax(1.0f, width_to_right_edge + w);\r\n    }\r\n    w = (float)(int)w;\r\n    return w;\r\n}\r\n\r\nstatic ImFont* GetDefaultFont()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[0];\r\n}\r\n\r\nstatic void SetCurrentFont(ImFont* font)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(font && font->IsLoaded());    // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?\r\n    IM_ASSERT(font->Scale > 0.0f);\r\n    g.Font = font;\r\n    g.FontBaseSize = g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale;\r\n    g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;\r\n\r\n    ImFontAtlas* atlas = g.Font->ContainerAtlas;\r\n    g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;\r\n    g.DrawListSharedData.Font = g.Font;\r\n    g.DrawListSharedData.FontSize = g.FontSize;\r\n}\r\n\r\nvoid ImGui::PushFont(ImFont* font)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (!font)\r\n        font = GetDefaultFont();\r\n    SetCurrentFont(font);\r\n    g.FontStack.push_back(font);\r\n    g.CurrentWindow->DrawList->PushTextureID(font->ContainerAtlas->TexID);\r\n}\r\n\r\nvoid  ImGui::PopFont()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.CurrentWindow->DrawList->PopTextureID();\r\n    g.FontStack.pop_back();\r\n    SetCurrentFont(g.FontStack.empty() ? GetDefaultFont() : g.FontStack.back());\r\n}\r\n\r\nvoid ImGui::PushItemFlag(ImGuiItemFlags option, bool enabled)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (enabled)\r\n        window->DC.ItemFlags |= option;\r\n    else\r\n        window->DC.ItemFlags &= ~option;\r\n    window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);\r\n}\r\n\r\nvoid ImGui::PopItemFlag()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.ItemFlagsStack.pop_back();\r\n    window->DC.ItemFlags = window->DC.ItemFlagsStack.empty() ? ImGuiItemFlags_Default_ : window->DC.ItemFlagsStack.back();\r\n}\r\n\r\nvoid ImGui::PushAllowKeyboardFocus(bool allow_keyboard_focus)\r\n{\r\n    PushItemFlag(ImGuiItemFlags_AllowKeyboardFocus, allow_keyboard_focus);\r\n}\r\n\r\nvoid ImGui::PopAllowKeyboardFocus()\r\n{\r\n    PopItemFlag();\r\n}\r\n\r\nvoid ImGui::PushButtonRepeat(bool repeat)\r\n{\r\n    PushItemFlag(ImGuiItemFlags_ButtonRepeat, repeat);\r\n}\r\n\r\nvoid ImGui::PopButtonRepeat()\r\n{\r\n    PopItemFlag();\r\n}\r\n\r\nvoid ImGui::PushTextWrapPos(float wrap_pos_x)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.TextWrapPos = wrap_pos_x;\r\n    window->DC.TextWrapPosStack.push_back(wrap_pos_x);\r\n}\r\n\r\nvoid ImGui::PopTextWrapPos()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.TextWrapPosStack.pop_back();\r\n    window->DC.TextWrapPos = window->DC.TextWrapPosStack.empty() ? -1.0f : window->DC.TextWrapPosStack.back();\r\n}\r\n\r\n// FIXME: This may incur a round-trip (if the end user got their data from a float4) but eventually we aim to store the in-flight colors as ImU32\r\nvoid ImGui::PushStyleColor(ImGuiCol idx, ImU32 col)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiColMod backup;\r\n    backup.Col = idx;\r\n    backup.BackupValue = g.Style.Colors[idx];\r\n    g.ColorModifiers.push_back(backup);\r\n    g.Style.Colors[idx] = ColorConvertU32ToFloat4(col);\r\n}\r\n\r\nvoid ImGui::PushStyleColor(ImGuiCol idx, const ImVec4& col)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiColMod backup;\r\n    backup.Col = idx;\r\n    backup.BackupValue = g.Style.Colors[idx];\r\n    g.ColorModifiers.push_back(backup);\r\n    g.Style.Colors[idx] = col;\r\n}\r\n\r\nvoid ImGui::PopStyleColor(int count)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    while (count > 0)\r\n    {\r\n        ImGuiColMod& backup = g.ColorModifiers.back();\r\n        g.Style.Colors[backup.Col] = backup.BackupValue;\r\n        g.ColorModifiers.pop_back();\r\n        count--;\r\n    }\r\n}\r\n\r\nstruct ImGuiStyleVarInfo\r\n{\r\n    ImGuiDataType   Type;\r\n    ImU32           Offset;\r\n    void*           GetVarPtr(ImGuiStyle* style) const { return (void*)((unsigned char*)style + Offset); }\r\n};\r\n\r\nstatic const ImGuiStyleVarInfo GStyleVarInfo[ImGuiStyleVar_Count_] =\r\n{\r\n    { ImGuiDataType_Float,  (ImU32)IM_OFFSETOF(ImGuiStyle, Alpha) },                // ImGuiStyleVar_Alpha\r\n    { ImGuiDataType_Float2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowPadding) },        // ImGuiStyleVar_WindowPadding\r\n    { ImGuiDataType_Float,  (ImU32)IM_OFFSETOF(ImGuiStyle, WindowRounding) },       // ImGuiStyleVar_WindowRounding\r\n    { ImGuiDataType_Float,  (ImU32)IM_OFFSETOF(ImGuiStyle, WindowBorderSize) },     // ImGuiStyleVar_WindowBorderSize\r\n    { ImGuiDataType_Float2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowMinSize) },        // ImGuiStyleVar_WindowMinSize\r\n    { ImGuiDataType_Float,  (ImU32)IM_OFFSETOF(ImGuiStyle, ChildRounding) },        // ImGuiStyleVar_ChildRounding\r\n    { ImGuiDataType_Float,  (ImU32)IM_OFFSETOF(ImGuiStyle, ChildBorderSize) },      // ImGuiStyleVar_ChildBorderSize\r\n    { ImGuiDataType_Float,  (ImU32)IM_OFFSETOF(ImGuiStyle, PopupRounding) },        // ImGuiStyleVar_PopupRounding\r\n    { ImGuiDataType_Float,  (ImU32)IM_OFFSETOF(ImGuiStyle, PopupBorderSize) },      // ImGuiStyleVar_PopupBorderSize\r\n    { ImGuiDataType_Float2, (ImU32)IM_OFFSETOF(ImGuiStyle, FramePadding) },         // ImGuiStyleVar_FramePadding\r\n    { ImGuiDataType_Float,  (ImU32)IM_OFFSETOF(ImGuiStyle, FrameRounding) },        // ImGuiStyleVar_FrameRounding\r\n    { ImGuiDataType_Float,  (ImU32)IM_OFFSETOF(ImGuiStyle, FrameBorderSize) },      // ImGuiStyleVar_FrameBorderSize\r\n    { ImGuiDataType_Float2, (ImU32)IM_OFFSETOF(ImGuiStyle, ItemSpacing) },          // ImGuiStyleVar_ItemSpacing\r\n    { ImGuiDataType_Float2, (ImU32)IM_OFFSETOF(ImGuiStyle, ItemInnerSpacing) },     // ImGuiStyleVar_ItemInnerSpacing\r\n    { ImGuiDataType_Float,  (ImU32)IM_OFFSETOF(ImGuiStyle, IndentSpacing) },        // ImGuiStyleVar_IndentSpacing\r\n    { ImGuiDataType_Float,  (ImU32)IM_OFFSETOF(ImGuiStyle, GrabMinSize) },          // ImGuiStyleVar_GrabMinSize\r\n    { ImGuiDataType_Float2, (ImU32)IM_OFFSETOF(ImGuiStyle, ButtonTextAlign) },      // ImGuiStyleVar_ButtonTextAlign\r\n};\r\n\r\nstatic const ImGuiStyleVarInfo* GetStyleVarInfo(ImGuiStyleVar idx)\r\n{\r\n    IM_ASSERT(idx >= 0 && idx < ImGuiStyleVar_Count_);\r\n    return &GStyleVarInfo[idx];\r\n}\r\n\r\nvoid ImGui::PushStyleVar(ImGuiStyleVar idx, float val)\r\n{\r\n    const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);\r\n    if (var_info->Type == ImGuiDataType_Float)\r\n    {\r\n        ImGuiContext& g = *GImGui;\r\n        float* pvar = (float*)var_info->GetVarPtr(&g.Style);\r\n        g.StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));\r\n        *pvar = val;\r\n        return;\r\n    }\r\n    IM_ASSERT(0); // Called function with wrong-type? Variable is not a float.\r\n}\r\n\r\nvoid ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)\r\n{\r\n    const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);\r\n    if (var_info->Type == ImGuiDataType_Float2)\r\n    {\r\n        ImGuiContext& g = *GImGui;\r\n        ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);\r\n        g.StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));\r\n        *pvar = val;\r\n        return;\r\n    }\r\n    IM_ASSERT(0); // Called function with wrong-type? Variable is not a ImVec2.\r\n}\r\n\r\nvoid ImGui::PopStyleVar(int count)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    while (count > 0)\r\n    {\r\n        ImGuiStyleMod& backup = g.StyleModifiers.back();\r\n        const ImGuiStyleVarInfo* info = GetStyleVarInfo(backup.VarIdx);\r\n        if (info->Type == ImGuiDataType_Float)          (*(float*)info->GetVarPtr(&g.Style)) = backup.BackupFloat[0];\r\n        else if (info->Type == ImGuiDataType_Float2)    (*(ImVec2*)info->GetVarPtr(&g.Style)) = ImVec2(backup.BackupFloat[0], backup.BackupFloat[1]);\r\n        else if (info->Type == ImGuiDataType_Int)       (*(int*)info->GetVarPtr(&g.Style)) = backup.BackupInt[0];\r\n        g.StyleModifiers.pop_back();\r\n        count--;\r\n    }\r\n}\r\n\r\nconst char* ImGui::GetStyleColorName(ImGuiCol idx)\r\n{\r\n    // Create switch-case from enum with regexp: ImGuiCol_{.*}, --> case ImGuiCol_\\1: return \"\\1\";\r\n    switch (idx)\r\n    {\r\n    case ImGuiCol_Text: return \"Text\";\r\n    case ImGuiCol_TextDisabled: return \"TextDisabled\";\r\n    case ImGuiCol_WindowBg: return \"WindowBg\";\r\n    case ImGuiCol_ChildBg: return \"ChildBg\";\r\n    case ImGuiCol_PopupBg: return \"PopupBg\";\r\n    case ImGuiCol_Border: return \"Border\";\r\n    case ImGuiCol_BorderShadow: return \"BorderShadow\";\r\n    case ImGuiCol_FrameBg: return \"FrameBg\";\r\n    case ImGuiCol_FrameBgHovered: return \"FrameBgHovered\";\r\n    case ImGuiCol_FrameBgActive: return \"FrameBgActive\";\r\n    case ImGuiCol_TitleBg: return \"TitleBg\";\r\n    case ImGuiCol_TitleBgActive: return \"TitleBgActive\";\r\n    case ImGuiCol_TitleBgCollapsed: return \"TitleBgCollapsed\";\r\n    case ImGuiCol_MenuBarBg: return \"MenuBarBg\";\r\n    case ImGuiCol_ScrollbarBg: return \"ScrollbarBg\";\r\n    case ImGuiCol_ScrollbarGrab: return \"ScrollbarGrab\";\r\n    case ImGuiCol_ScrollbarGrabHovered: return \"ScrollbarGrabHovered\";\r\n    case ImGuiCol_ScrollbarGrabActive: return \"ScrollbarGrabActive\";\r\n    case ImGuiCol_CheckMark: return \"CheckMark\";\r\n    case ImGuiCol_SliderGrab: return \"SliderGrab\";\r\n    case ImGuiCol_SliderGrabActive: return \"SliderGrabActive\";\r\n    case ImGuiCol_Button: return \"Button\";\r\n    case ImGuiCol_ButtonHovered: return \"ButtonHovered\";\r\n    case ImGuiCol_ButtonActive: return \"ButtonActive\";\r\n    case ImGuiCol_Header: return \"Header\";\r\n    case ImGuiCol_HeaderHovered: return \"HeaderHovered\";\r\n    case ImGuiCol_HeaderActive: return \"HeaderActive\";\r\n    case ImGuiCol_Separator: return \"Separator\";\r\n    case ImGuiCol_SeparatorHovered: return \"SeparatorHovered\";\r\n    case ImGuiCol_SeparatorActive: return \"SeparatorActive\";\r\n    case ImGuiCol_ResizeGrip: return \"ResizeGrip\";\r\n    case ImGuiCol_ResizeGripHovered: return \"ResizeGripHovered\";\r\n    case ImGuiCol_ResizeGripActive: return \"ResizeGripActive\";\r\n    case ImGuiCol_CloseButton: return \"CloseButton\";\r\n    case ImGuiCol_CloseButtonHovered: return \"CloseButtonHovered\";\r\n    case ImGuiCol_CloseButtonActive: return \"CloseButtonActive\";\r\n    case ImGuiCol_PlotLines: return \"PlotLines\";\r\n    case ImGuiCol_PlotLinesHovered: return \"PlotLinesHovered\";\r\n    case ImGuiCol_PlotHistogram: return \"PlotHistogram\";\r\n    case ImGuiCol_PlotHistogramHovered: return \"PlotHistogramHovered\";\r\n    case ImGuiCol_TextSelectedBg: return \"TextSelectedBg\";\r\n    case ImGuiCol_ModalWindowDarkening: return \"ModalWindowDarkening\";\r\n    case ImGuiCol_DragDropTarget: return \"DragDropTarget\";\r\n    }\r\n    IM_ASSERT(0);\r\n    return \"Unknown\";\r\n}\r\n\r\nbool ImGui::IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent)\r\n{\r\n    if (window->RootWindow == potential_parent)\r\n        return true;\r\n    while (window != NULL)\r\n    {\r\n        if (window == potential_parent)\r\n            return true;\r\n        window = window->ParentWindow;\r\n    }\r\n    return false;\r\n}\r\n\r\nbool ImGui::IsWindowHovered(ImGuiHoveredFlags flags)\r\n{\r\n    IM_ASSERT((flags & ImGuiHoveredFlags_AllowWhenOverlapped) == 0);   // Flags not supported by this function\r\n    ImGuiContext& g = *GImGui;\r\n    switch (flags & (ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows))\r\n    {\r\n    case ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows:\r\n        if (g.HoveredRootWindow != g.CurrentWindow->RootWindow)\r\n            return false;\r\n        break;\r\n    case ImGuiHoveredFlags_RootWindow:\r\n        if (g.HoveredWindow != g.CurrentWindow->RootWindow)\r\n            return false;\r\n        break;\r\n    case ImGuiHoveredFlags_ChildWindows:\r\n        if (g.HoveredWindow == NULL || !IsWindowChildOf(g.HoveredWindow, g.CurrentWindow))\r\n            return false;\r\n        break;\r\n    default:\r\n        if (g.HoveredWindow != g.CurrentWindow)\r\n            return false;\r\n        break;\r\n    }\r\n\r\n    if (!IsWindowContentHoverable(g.HoveredRootWindow, flags))\r\n        return false;\r\n    if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))\r\n        if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != g.HoveredWindow->MoveId)\r\n            return false;\r\n    return true;\r\n}\r\n\r\nbool ImGui::IsWindowFocused(ImGuiFocusedFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(g.CurrentWindow);     // Not inside a Begin()/End()\r\n\r\n    switch (flags & (ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows))\r\n    {\r\n    case ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows:\r\n        return g.NavWindow && g.CurrentWindow->RootWindow == g.NavWindow->RootWindow;\r\n    case ImGuiFocusedFlags_RootWindow:\r\n        return g.CurrentWindow->RootWindow == g.NavWindow;\r\n    case ImGuiFocusedFlags_ChildWindows:\r\n        return g.NavWindow && IsWindowChildOf(g.NavWindow, g.CurrentWindow);\r\n    default:\r\n        return g.CurrentWindow == g.NavWindow;\r\n    }\r\n}\r\n\r\nfloat ImGui::GetWindowWidth()\r\n{\r\n    ImGuiWindow* window = GImGui->CurrentWindow;\r\n    return window->Size.x;\r\n}\r\n\r\nfloat ImGui::GetWindowHeight()\r\n{\r\n    ImGuiWindow* window = GImGui->CurrentWindow;\r\n    return window->Size.y;\r\n}\r\n\r\nImVec2 ImGui::GetWindowPos()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    return window->Pos;\r\n}\r\n\r\nstatic void SetWindowScrollY(ImGuiWindow* window, float new_scroll_y)\r\n{\r\n    window->DC.CursorMaxPos.y += window->Scroll.y; // SizeContents is generally computed based on CursorMaxPos which is affected by scroll position, so we need to apply our change to it.\r\n    window->Scroll.y = new_scroll_y;\r\n    window->DC.CursorMaxPos.y -= window->Scroll.y;\r\n}\r\n\r\nstatic void SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond)\r\n{\r\n    // Test condition (NB: bit 0 is always true) and clear flags for next time\r\n    if (cond && (window->SetWindowPosAllowFlags & cond) == 0)\r\n        return;\r\n    window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);\r\n    window->SetWindowPosVal = ImVec2(FLT_MAX, FLT_MAX);\r\n\r\n    // Set\r\n    const ImVec2 old_pos = window->Pos;\r\n    window->PosFloat = pos;\r\n    window->Pos = ImVec2((float)(int)window->PosFloat.x, (float)(int)window->PosFloat.y);\r\n    window->DC.CursorPos += (window->Pos - old_pos);    // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor\r\n    window->DC.CursorMaxPos += (window->Pos - old_pos); // And more importantly we need to adjust this so size calculation doesn't get affected.\r\n}\r\n\r\nvoid ImGui::SetWindowPos(const ImVec2& pos, ImGuiCond cond)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    SetWindowPos(window, pos, cond);\r\n}\r\n\r\nvoid ImGui::SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond)\r\n{\r\n    if (ImGuiWindow* window = FindWindowByName(name))\r\n        SetWindowPos(window, pos, cond);\r\n}\r\n\r\nImVec2 ImGui::GetWindowSize()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->Size;\r\n}\r\n\r\nstatic void SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond)\r\n{\r\n    // Test condition (NB: bit 0 is always true) and clear flags for next time\r\n    if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)\r\n        return;\r\n    window->SetWindowSizeAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);\r\n\r\n    // Set\r\n    if (size.x > 0.0f)\r\n    {\r\n        window->AutoFitFramesX = 0;\r\n        window->SizeFull.x = size.x;\r\n    }\r\n    else\r\n    {\r\n        window->AutoFitFramesX = 2;\r\n        window->AutoFitOnlyGrows = false;\r\n    }\r\n    if (size.y > 0.0f)\r\n    {\r\n        window->AutoFitFramesY = 0;\r\n        window->SizeFull.y = size.y;\r\n    }\r\n    else\r\n    {\r\n        window->AutoFitFramesY = 2;\r\n        window->AutoFitOnlyGrows = false;\r\n    }\r\n}\r\n\r\nvoid ImGui::SetWindowSize(const ImVec2& size, ImGuiCond cond)\r\n{\r\n    SetWindowSize(GImGui->CurrentWindow, size, cond);\r\n}\r\n\r\nvoid ImGui::SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond)\r\n{\r\n    if (ImGuiWindow* window = FindWindowByName(name))\r\n        SetWindowSize(window, size, cond);\r\n}\r\n\r\nstatic void SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond)\r\n{\r\n    // Test condition (NB: bit 0 is always true) and clear flags for next time\r\n    if (cond && (window->SetWindowCollapsedAllowFlags & cond) == 0)\r\n        return;\r\n    window->SetWindowCollapsedAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);\r\n\r\n    // Set\r\n    window->Collapsed = collapsed;\r\n}\r\n\r\nvoid ImGui::SetWindowCollapsed(bool collapsed, ImGuiCond cond)\r\n{\r\n    SetWindowCollapsed(GImGui->CurrentWindow, collapsed, cond);\r\n}\r\n\r\nbool ImGui::IsWindowCollapsed()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->Collapsed;\r\n}\r\n\r\nbool ImGui::IsWindowAppearing()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->Appearing;\r\n}\r\n\r\nvoid ImGui::SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond)\r\n{\r\n    if (ImGuiWindow* window = FindWindowByName(name))\r\n        SetWindowCollapsed(window, collapsed, cond);\r\n}\r\n\r\nvoid ImGui::SetWindowFocus()\r\n{\r\n    FocusWindow(GImGui->CurrentWindow);\r\n}\r\n\r\nvoid ImGui::SetWindowFocus(const char* name)\r\n{\r\n    if (name)\r\n    {\r\n        if (ImGuiWindow* window = FindWindowByName(name))\r\n            FocusWindow(window);\r\n    }\r\n    else\r\n    {\r\n        FocusWindow(NULL);\r\n    }\r\n}\r\n\r\nvoid ImGui::SetNextWindowPos(const ImVec2& pos, ImGuiCond cond, const ImVec2& pivot)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.SetNextWindowPosVal = pos;\r\n    g.SetNextWindowPosPivot = pivot;\r\n    g.SetNextWindowPosCond = cond ? cond : ImGuiCond_Always;\r\n}\r\n\r\nvoid ImGui::SetNextWindowSize(const ImVec2& size, ImGuiCond cond)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.SetNextWindowSizeVal = size;\r\n    g.SetNextWindowSizeCond = cond ? cond : ImGuiCond_Always;\r\n}\r\n\r\nvoid ImGui::SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeConstraintCallback custom_callback, void* custom_callback_user_data)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.SetNextWindowSizeConstraint = true;\r\n    g.SetNextWindowSizeConstraintRect = ImRect(size_min, size_max);\r\n    g.SetNextWindowSizeConstraintCallback = custom_callback;\r\n    g.SetNextWindowSizeConstraintCallbackUserData = custom_callback_user_data;\r\n}\r\n\r\nvoid ImGui::SetNextWindowContentSize(const ImVec2& size)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.SetNextWindowContentSizeVal = size;  // In Begin() we will add the size of window decorations (title bar, menu etc.) to that to form a SizeContents value.\r\n    g.SetNextWindowContentSizeCond = ImGuiCond_Always;\r\n}\r\n\r\nvoid ImGui::SetNextWindowCollapsed(bool collapsed, ImGuiCond cond)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.SetNextWindowCollapsedVal = collapsed;\r\n    g.SetNextWindowCollapsedCond = cond ? cond : ImGuiCond_Always;\r\n}\r\n\r\nvoid ImGui::SetNextWindowFocus()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.SetNextWindowFocus = true;\r\n}\r\n\r\n// In window space (not screen space!)\r\nImVec2 ImGui::GetContentRegionMax()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    ImVec2 mx = window->ContentsRegionRect.Max;\r\n    if (window->DC.ColumnsSet)\r\n        mx.x = GetColumnOffset(window->DC.ColumnsSet->Current + 1) - window->WindowPadding.x;\r\n    return mx;\r\n}\r\n\r\nImVec2 ImGui::GetContentRegionAvail()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return GetContentRegionMax() - (window->DC.CursorPos - window->Pos);\r\n}\r\n\r\nfloat ImGui::GetContentRegionAvailWidth()\r\n{\r\n    return GetContentRegionAvail().x;\r\n}\r\n\r\n// In window space (not screen space!)\r\nImVec2 ImGui::GetWindowContentRegionMin()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->ContentsRegionRect.Min;\r\n}\r\n\r\nImVec2 ImGui::GetWindowContentRegionMax()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->ContentsRegionRect.Max;\r\n}\r\n\r\nfloat ImGui::GetWindowContentRegionWidth()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->ContentsRegionRect.Max.x - window->ContentsRegionRect.Min.x;\r\n}\r\n\r\nfloat ImGui::GetTextLineHeight()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.FontSize;\r\n}\r\n\r\nfloat ImGui::GetTextLineHeightWithSpacing()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.FontSize + g.Style.ItemSpacing.y;\r\n}\r\n\r\nfloat ImGui::GetFrameHeight()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.FontSize + g.Style.FramePadding.y * 2.0f;\r\n}\r\n\r\nfloat ImGui::GetFrameHeightWithSpacing()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.FontSize + g.Style.FramePadding.y * 2.0f + g.Style.ItemSpacing.y;\r\n}\r\n\r\nImDrawList* ImGui::GetWindowDrawList()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    return window->DrawList;\r\n}\r\n\r\nImFont* ImGui::GetFont()\r\n{\r\n    return GImGui->Font;\r\n}\r\n\r\nfloat ImGui::GetFontSize()\r\n{\r\n    return GImGui->FontSize;\r\n}\r\n\r\nImVec2 ImGui::GetFontTexUvWhitePixel()\r\n{\r\n    return GImGui->DrawListSharedData.TexUvWhitePixel;\r\n}\r\n\r\nvoid ImGui::SetWindowFontScale(float scale)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->FontWindowScale = scale;\r\n    g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();\r\n}\r\n\r\n// User generally sees positions in window coordinates. Internally we store CursorPos in absolute screen coordinates because it is more convenient.\r\n// Conversion happens as we pass the value to user, but it makes our naming convention confusing because GetCursorPos() == (DC.CursorPos - window.Pos). May want to rename 'DC.CursorPos'.\r\nImVec2 ImGui::GetCursorPos()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->DC.CursorPos - window->Pos + window->Scroll;\r\n}\r\n\r\nfloat ImGui::GetCursorPosX()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;\r\n}\r\n\r\nfloat ImGui::GetCursorPosY()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->DC.CursorPos.y - window->Pos.y + window->Scroll.y;\r\n}\r\n\r\nvoid ImGui::SetCursorPos(const ImVec2& local_pos)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.CursorPos = window->Pos - window->Scroll + local_pos;\r\n    window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);\r\n}\r\n\r\nvoid ImGui::SetCursorPosX(float x)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;\r\n    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);\r\n}\r\n\r\nvoid ImGui::SetCursorPosY(float y)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.CursorPos.y = window->Pos.y - window->Scroll.y + y;\r\n    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y);\r\n}\r\n\r\nImVec2 ImGui::GetCursorStartPos()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->DC.CursorStartPos - window->Pos;\r\n}\r\n\r\nImVec2 ImGui::GetCursorScreenPos()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->DC.CursorPos;\r\n}\r\n\r\nvoid ImGui::SetCursorScreenPos(const ImVec2& screen_pos)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.CursorPos = screen_pos;\r\n    window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);\r\n}\r\n\r\nfloat ImGui::GetScrollX()\r\n{\r\n    return GImGui->CurrentWindow->Scroll.x;\r\n}\r\n\r\nfloat ImGui::GetScrollY()\r\n{\r\n    return GImGui->CurrentWindow->Scroll.y;\r\n}\r\n\r\nfloat ImGui::GetScrollMaxX()\r\n{\r\n    return GetScrollMaxX(GImGui->CurrentWindow);\r\n}\r\n\r\nfloat ImGui::GetScrollMaxY()\r\n{\r\n    return GetScrollMaxY(GImGui->CurrentWindow);\r\n}\r\n\r\nvoid ImGui::SetScrollX(float scroll_x)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->ScrollTarget.x = scroll_x;\r\n    window->ScrollTargetCenterRatio.x = 0.0f;\r\n}\r\n\r\nvoid ImGui::SetScrollY(float scroll_y)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->ScrollTarget.y = scroll_y + window->TitleBarHeight() + window->MenuBarHeight(); // title bar height canceled out when using ScrollTargetRelY\r\n    window->ScrollTargetCenterRatio.y = 0.0f;\r\n}\r\n\r\nvoid ImGui::SetScrollFromPosY(float pos_y, float center_y_ratio)\r\n{\r\n    // We store a target position so centering can occur on the next frame when we are guaranteed to have a known window size\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    IM_ASSERT(center_y_ratio >= 0.0f && center_y_ratio <= 1.0f);\r\n    window->ScrollTarget.y = (float)(int)(pos_y + window->Scroll.y);\r\n    window->ScrollTargetCenterRatio.y = center_y_ratio;\r\n\r\n    // Minor hack to to make scrolling to top/bottom of window take account of WindowPadding, it looks more right to the user this way\r\n    if (center_y_ratio <= 0.0f && window->ScrollTarget.y <= window->WindowPadding.y)\r\n        window->ScrollTarget.y = 0.0f;\r\n    else if (center_y_ratio >= 1.0f && window->ScrollTarget.y >= window->SizeContents.y - window->WindowPadding.y + GImGui->Style.ItemSpacing.y)\r\n        window->ScrollTarget.y = window->SizeContents.y;\r\n}\r\n\r\n// center_y_ratio: 0.0f top of last item, 0.5f vertical center of last item, 1.0f bottom of last item.\r\nvoid ImGui::SetScrollHere(float center_y_ratio)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    float target_y = window->DC.CursorPosPrevLine.y - window->Pos.y; // Top of last item, in window space\r\n    target_y += (window->DC.PrevLineHeight * center_y_ratio) + (GImGui->Style.ItemSpacing.y * (center_y_ratio - 0.5f) * 2.0f); // Precisely aim above, in the middle or below the last line.\r\n    SetScrollFromPosY(target_y, center_y_ratio);\r\n}\r\n\r\n// FIXME-NAV: This function is a placeholder for the upcoming Navigation branch + Focusing features.\r\n// In the current branch this function will only set the scrolling, in the navigation branch it will also set your navigation cursor.\r\n// Prefer using \"SetItemDefaultFocus()\" over \"if (IsWindowAppearing()) SetScrollHere()\" when applicable.\r\nvoid ImGui::SetItemDefaultFocus()\r\n{\r\n    if (IsWindowAppearing())\r\n        SetScrollHere();\r\n}\r\n\r\nvoid ImGui::SetKeyboardFocusHere(int offset)\r\n{\r\n    IM_ASSERT(offset >= -1);    // -1 is allowed but not below\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->FocusIdxAllRequestNext = window->FocusIdxAllCounter + 1 + offset;\r\n    window->FocusIdxTabRequestNext = INT_MAX;\r\n}\r\n\r\nvoid ImGui::SetStateStorage(ImGuiStorage* tree)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.StateStorage = tree ? tree : &window->StateStorage;\r\n}\r\n\r\nImGuiStorage* ImGui::GetStateStorage()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->DC.StateStorage;\r\n}\r\n\r\nvoid ImGui::TextV(const char* fmt, va_list args)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const char* text_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);\r\n    TextUnformatted(g.TempBuffer, text_end);\r\n}\r\n\r\nvoid ImGui::Text(const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    TextV(fmt, args);\r\n    va_end(args);\r\n}\r\n\r\nvoid ImGui::TextColoredV(const ImVec4& col, const char* fmt, va_list args)\r\n{\r\n    PushStyleColor(ImGuiCol_Text, col);\r\n    TextV(fmt, args);\r\n    PopStyleColor();\r\n}\r\n\r\nvoid ImGui::TextColored(const ImVec4& col, const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    TextColoredV(col, fmt, args);\r\n    va_end(args);\r\n}\r\n\r\nvoid ImGui::TextDisabledV(const char* fmt, va_list args)\r\n{\r\n    PushStyleColor(ImGuiCol_Text, GImGui->Style.Colors[ImGuiCol_TextDisabled]);\r\n    TextV(fmt, args);\r\n    PopStyleColor();\r\n}\r\n\r\nvoid ImGui::TextDisabled(const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    TextDisabledV(fmt, args);\r\n    va_end(args);\r\n}\r\n\r\nvoid ImGui::TextWrappedV(const char* fmt, va_list args)\r\n{\r\n    bool need_wrap = (GImGui->CurrentWindow->DC.TextWrapPos < 0.0f);    // Keep existing wrap position is one ia already set\r\n    if (need_wrap) PushTextWrapPos(0.0f);\r\n    TextV(fmt, args);\r\n    if (need_wrap) PopTextWrapPos();\r\n}\r\n\r\nvoid ImGui::TextWrapped(const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    TextWrappedV(fmt, args);\r\n    va_end(args);\r\n}\r\n\r\nvoid ImGui::TextUnformatted(const char* text, const char* text_end)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(text != NULL);\r\n    const char* text_begin = text;\r\n    if (text_end == NULL)\r\n        text_end = text + strlen(text); // FIXME-OPT\r\n\r\n    const ImVec2 text_pos(window->DC.CursorPos.x, window->DC.CursorPos.y + window->DC.CurrentLineTextBaseOffset);\r\n    const float wrap_pos_x = window->DC.TextWrapPos;\r\n    const bool wrap_enabled = wrap_pos_x >= 0.0f;\r\n    if (text_end - text > 2000 && !wrap_enabled)\r\n    {\r\n        // Long text!\r\n        // Perform manual coarse clipping to optimize for long multi-line text\r\n        // From this point we will only compute the width of lines that are visible. Optimization only available when word-wrapping is disabled.\r\n        // We also don't vertically center the text within the line full height, which is unlikely to matter because we are likely the biggest and only item on the line.\r\n        const char* line = text;\r\n        const float line_height = GetTextLineHeight();\r\n        const ImRect clip_rect = window->ClipRect;\r\n        ImVec2 text_size(0,0);\r\n\r\n        if (text_pos.y <= clip_rect.Max.y)\r\n        {\r\n            ImVec2 pos = text_pos;\r\n\r\n            // Lines to skip (can't skip when logging text)\r\n            if (!g.LogEnabled)\r\n            {\r\n                int lines_skippable = (int)((clip_rect.Min.y - text_pos.y) / line_height);\r\n                if (lines_skippable > 0)\r\n                {\r\n                    int lines_skipped = 0;\r\n                    while (line < text_end && lines_skipped < lines_skippable)\r\n                    {\r\n                        const char* line_end = strchr(line, '\\n');\r\n                        if (!line_end)\r\n                            line_end = text_end;\r\n                        line = line_end + 1;\r\n                        lines_skipped++;\r\n                    }\r\n                    pos.y += lines_skipped * line_height;\r\n                }\r\n            }\r\n\r\n            // Lines to render\r\n            if (line < text_end)\r\n            {\r\n                ImRect line_rect(pos, pos + ImVec2(FLT_MAX, line_height));\r\n                while (line < text_end)\r\n                {\r\n                    const char* line_end = strchr(line, '\\n');\r\n                    if (IsClippedEx(line_rect, 0, false))\r\n                        break;\r\n\r\n                    const ImVec2 line_size = CalcTextSize(line, line_end, false);\r\n                    text_size.x = ImMax(text_size.x, line_size.x);\r\n                    RenderText(pos, line, line_end, false);\r\n                    if (!line_end)\r\n                        line_end = text_end;\r\n                    line = line_end + 1;\r\n                    line_rect.Min.y += line_height;\r\n                    line_rect.Max.y += line_height;\r\n                    pos.y += line_height;\r\n                }\r\n\r\n                // Count remaining lines\r\n                int lines_skipped = 0;\r\n                while (line < text_end)\r\n                {\r\n                    const char* line_end = strchr(line, '\\n');\r\n                    if (!line_end)\r\n                        line_end = text_end;\r\n                    line = line_end + 1;\r\n                    lines_skipped++;\r\n                }\r\n                pos.y += lines_skipped * line_height;\r\n            }\r\n\r\n            text_size.y += (pos - text_pos).y;\r\n        }\r\n\r\n        ImRect bb(text_pos, text_pos + text_size);\r\n        ItemSize(bb);\r\n        ItemAdd(bb, 0);\r\n    }\r\n    else\r\n    {\r\n        const float wrap_width = wrap_enabled ? CalcWrapWidthForPos(window->DC.CursorPos, wrap_pos_x) : 0.0f;\r\n        const ImVec2 text_size = CalcTextSize(text_begin, text_end, false, wrap_width);\r\n\r\n        // Account of baseline offset\r\n        ImRect bb(text_pos, text_pos + text_size);\r\n        ItemSize(text_size);\r\n        if (!ItemAdd(bb, 0))\r\n            return;\r\n\r\n        // Render (we don't hide text after ## in this end-user function)\r\n        RenderTextWrapped(bb.Min, text_begin, text_end, wrap_width);\r\n    }\r\n}\r\n\r\nvoid ImGui::AlignTextToFramePadding()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    window->DC.CurrentLineHeight = ImMax(window->DC.CurrentLineHeight, g.FontSize + g.Style.FramePadding.y * 2);\r\n    window->DC.CurrentLineTextBaseOffset = ImMax(window->DC.CurrentLineTextBaseOffset, g.Style.FramePadding.y);\r\n}\r\n\r\n// Add a label+text combo aligned to other label+value widgets\r\nvoid ImGui::LabelTextV(const char* label, const char* fmt, va_list args)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const float w = CalcItemWidth();\r\n\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n    const ImRect value_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2));\r\n    const ImRect total_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w + (label_size.x > 0.0f ? style.ItemInnerSpacing.x : 0.0f), style.FramePadding.y*2) + label_size);\r\n    ItemSize(total_bb, style.FramePadding.y);\r\n    if (!ItemAdd(total_bb, 0))\r\n        return;\r\n\r\n    // Render\r\n    const char* value_text_begin = &g.TempBuffer[0];\r\n    const char* value_text_end = value_text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);\r\n    RenderTextClipped(value_bb.Min, value_bb.Max, value_text_begin, value_text_end, NULL, ImVec2(0.0f,0.5f));\r\n    if (label_size.x > 0.0f)\r\n        RenderText(ImVec2(value_bb.Max.x + style.ItemInnerSpacing.x, value_bb.Min.y + style.FramePadding.y), label);\r\n}\r\n\r\nvoid ImGui::LabelText(const char* label, const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    LabelTextV(label, fmt, args);\r\n    va_end(args);\r\n}\r\n\r\nbool ImGui::ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n\r\n    if (flags & ImGuiButtonFlags_Disabled)\r\n    {\r\n        if (out_hovered) *out_hovered = false;\r\n        if (out_held) *out_held = false;\r\n        if (g.ActiveId == id) ClearActiveID();\r\n        return false;\r\n    }\r\n\r\n    // Default behavior requires click+release on same spot\r\n    if ((flags & (ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnRelease | ImGuiButtonFlags_PressedOnDoubleClick)) == 0)\r\n        flags |= ImGuiButtonFlags_PressedOnClickRelease;\r\n\r\n    ImGuiWindow* backup_hovered_window = g.HoveredWindow;\r\n    if ((flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredRootWindow == window)\r\n        g.HoveredWindow = window;\r\n\r\n    bool pressed = false;\r\n    bool hovered = ItemHoverable(bb, id);\r\n\r\n    // Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers the button\r\n    if ((flags & ImGuiButtonFlags_PressedOnDragDropHold) && g.DragDropActive && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoHoldToOpenOthers))\r\n        if (IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))\r\n        {\r\n            hovered = true;\r\n            SetHoveredID(id);\r\n            if (CalcTypematicPressedRepeatAmount(g.HoveredIdTimer + 0.0001f, g.HoveredIdTimer + 0.0001f - g.IO.DeltaTime, 0.01f, 0.70f)) // FIXME: Our formula for CalcTypematicPressedRepeatAmount() is fishy\r\n            {\r\n                pressed = true;\r\n                FocusWindow(window);\r\n            }\r\n        }\r\n\r\n    if ((flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredRootWindow == window)\r\n        g.HoveredWindow = backup_hovered_window;\r\n\r\n    // AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match. This allows using patterns where a later submitted widget overlaps a previous one.\r\n    if (hovered && (flags & ImGuiButtonFlags_AllowItemOverlap) && (g.HoveredIdPreviousFrame != id && g.HoveredIdPreviousFrame != 0))\r\n        hovered = false;\r\n\r\n    if (hovered)\r\n    {\r\n        if (!(flags & ImGuiButtonFlags_NoKeyModifiers) || (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt))\r\n        {\r\n            //                        | CLICKING        | HOLDING with ImGuiButtonFlags_Repeat\r\n            // PressedOnClickRelease  |  <on release>*  |  <on repeat> <on repeat> .. (NOT on release)  <-- MOST COMMON! (*) only if both click/release were over bounds\r\n            // PressedOnClick         |  <on click>     |  <on click> <on repeat> <on repeat> ..\r\n            // PressedOnRelease       |  <on release>   |  <on repeat> <on repeat> .. (NOT on release)\r\n            // PressedOnDoubleClick   |  <on dclick>    |  <on dclick> <on repeat> <on repeat> ..\r\n            if ((flags & ImGuiButtonFlags_PressedOnClickRelease) && g.IO.MouseClicked[0])\r\n            {\r\n                SetActiveID(id, window); // Hold on ID\r\n                FocusWindow(window);\r\n                g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;\r\n            }\r\n            if (((flags & ImGuiButtonFlags_PressedOnClick) && g.IO.MouseClicked[0]) || ((flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseDoubleClicked[0]))\r\n            {\r\n                pressed = true;\r\n                if (flags & ImGuiButtonFlags_NoHoldingActiveID)\r\n                {\r\n                    ClearActiveID();\r\n                }\r\n                else\r\n                {\r\n                    SetActiveID(id, window); // Hold on ID\r\n                    g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;\r\n                }\r\n                FocusWindow(window);\r\n            }\r\n            if ((flags & ImGuiButtonFlags_PressedOnRelease) && g.IO.MouseReleased[0])\r\n            {\r\n                if (!((flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay))  // Repeat mode trumps <on release>\r\n                    pressed = true;\r\n                ClearActiveID();\r\n            }\r\n\r\n            // 'Repeat' mode acts when held regardless of _PressedOn flags (see table above). \r\n            // Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer RepeatDelay/RepeatRate settings.\r\n            if ((flags & ImGuiButtonFlags_Repeat) && g.ActiveId == id && g.IO.MouseDownDuration[0] > 0.0f && IsMouseClicked(0, true))\r\n                pressed = true;\r\n        }\r\n    }\r\n\r\n    bool held = false;\r\n    if (g.ActiveId == id)\r\n    {\r\n        if (g.IO.MouseDown[0])\r\n        {\r\n            held = true;\r\n        }\r\n        else\r\n        {\r\n            if (hovered && (flags & ImGuiButtonFlags_PressedOnClickRelease))\r\n                if (!((flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay))  // Repeat mode trumps <on release>\r\n                    if (!g.DragDropActive)\r\n                        pressed = true;\r\n            ClearActiveID();\r\n        }\r\n    }\r\n\r\n    if (out_hovered) *out_hovered = hovered;\r\n    if (out_held) *out_held = held;\r\n\r\n    return pressed;\r\n}\r\n\r\nbool ImGui::ButtonEx(const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const ImGuiID id = window->GetID(label);\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n\r\n    ImVec2 pos = window->DC.CursorPos;\r\n    if ((flags & ImGuiButtonFlags_AlignTextBaseLine) && style.FramePadding.y < window->DC.CurrentLineTextBaseOffset) // Try to vertically align buttons that are smaller/have no padding so that text baseline matches (bit hacky, since it shouldn't be a flag)\r\n        pos.y += window->DC.CurrentLineTextBaseOffset - style.FramePadding.y;\r\n    ImVec2 size = CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);\r\n\r\n    const ImRect bb(pos, pos + size);\r\n    ItemSize(bb, style.FramePadding.y);\r\n    if (!ItemAdd(bb, id))\r\n        return false;\r\n\r\n    if (window->DC.ItemFlags & ImGuiItemFlags_ButtonRepeat) flags |= ImGuiButtonFlags_Repeat;\r\n    bool hovered, held;\r\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);\r\n\r\n    // Render\r\n    const ImU32 col = GetColorU32((hovered && held) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);\r\n    RenderFrame(bb.Min, bb.Max, col, true, style.FrameRounding);\r\n    RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);\r\n\r\n    // Automatically close popups\r\n    //if (pressed && !(flags & ImGuiButtonFlags_DontClosePopups) && (window->Flags & ImGuiWindowFlags_Popup))\r\n    //    CloseCurrentPopup();\r\n\r\n    return pressed;\r\n}\r\n\r\nbool ImGui::Button(const char* label, const ImVec2& size_arg)\r\n{\r\n    return ButtonEx(label, size_arg, 0);\r\n}\r\n\r\n// Small buttons fits within text without additional vertical spacing.\r\nbool ImGui::SmallButton(const char* label)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    float backup_padding_y = g.Style.FramePadding.y;\r\n    g.Style.FramePadding.y = 0.0f;\r\n    bool pressed = ButtonEx(label, ImVec2(0,0), ImGuiButtonFlags_AlignTextBaseLine);\r\n    g.Style.FramePadding.y = backup_padding_y;\r\n    return pressed;\r\n}\r\n\r\n// Tip: use ImGui::PushID()/PopID() to push indices or pointers in the ID stack.\r\n// Then you can keep 'str_id' empty or the same for all your buttons (instead of creating a string based on a non-string id)\r\nbool ImGui::InvisibleButton(const char* str_id, const ImVec2& size_arg)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    const ImGuiID id = window->GetID(str_id);\r\n    ImVec2 size = CalcItemSize(size_arg, 0.0f, 0.0f);\r\n    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);\r\n    ItemSize(bb);\r\n    if (!ItemAdd(bb, id))\r\n        return false;\r\n\r\n    bool hovered, held;\r\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held);\r\n\r\n    return pressed;\r\n}\r\n\r\n// Upper-right button to close a window.\r\nbool ImGui::CloseButton(ImGuiID id, const ImVec2& pos, float radius)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n\r\n    const ImRect bb(pos - ImVec2(radius,radius), pos + ImVec2(radius,radius));\r\n\r\n    bool hovered, held;\r\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held);\r\n\r\n    // Render\r\n    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_CloseButtonActive : hovered ? ImGuiCol_CloseButtonHovered : ImGuiCol_CloseButton);\r\n    const ImVec2 center = bb.GetCenter();\r\n    window->DrawList->AddCircleFilled(center, ImMax(2.0f, radius), col, 12);\r\n\r\n    const float cross_extent = (radius * 0.7071f) - 1.0f;\r\n    if (hovered)\r\n    {\r\n        window->DrawList->AddLine(center + ImVec2(+cross_extent,+cross_extent), center + ImVec2(-cross_extent,-cross_extent), GetColorU32(ImGuiCol_Text));\r\n        window->DrawList->AddLine(center + ImVec2(+cross_extent,-cross_extent), center + ImVec2(-cross_extent,+cross_extent), GetColorU32(ImGuiCol_Text));\r\n    }\r\n\r\n    return pressed;\r\n}\r\n\r\n// [Internal]\r\nbool ImGui::ArrowButton(ImGuiID id, ImGuiDir dir, ImVec2 padding, ImGuiButtonFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    const ImGuiStyle& style = g.Style;\r\n\r\n    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize + padding.x * 2.0f, g.FontSize + padding.y * 2.0f));\r\n    ItemSize(bb, style.FramePadding.y);\r\n    if (!ItemAdd(bb, id))\r\n        return false;\r\n\r\n    bool hovered, held;\r\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);\r\n\r\n    const ImU32 col = GetColorU32((hovered && held) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);\r\n#ifdef IMGUI_HAS_NAV\r\n    RenderNavHighlight(bb, id);\r\n#endif\r\n    RenderFrame(bb.Min, bb.Max, col, true, style.FrameRounding);\r\n    RenderTriangle(bb.Min + padding, dir, 1.0f);\r\n\r\n    return pressed;\r\n}\r\n\r\nvoid ImGui::Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);\r\n    if (border_col.w > 0.0f)\r\n        bb.Max += ImVec2(2,2);\r\n    ItemSize(bb);\r\n    if (!ItemAdd(bb, 0))\r\n        return;\r\n\r\n    if (border_col.w > 0.0f)\r\n    {\r\n        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(border_col), 0.0f);\r\n        window->DrawList->AddImage(user_texture_id, bb.Min+ImVec2(1,1), bb.Max-ImVec2(1,1), uv0, uv1, GetColorU32(tint_col));\r\n    }\r\n    else\r\n    {\r\n        window->DrawList->AddImage(user_texture_id, bb.Min, bb.Max, uv0, uv1, GetColorU32(tint_col));\r\n    }\r\n}\r\n\r\n// frame_padding < 0: uses FramePadding from style (default)\r\n// frame_padding = 0: no framing\r\n// frame_padding > 0: set framing size\r\n// The color used are the button colors.\r\nbool ImGui::ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n\r\n    // Default to using texture ID as ID. User can still push string/integer prefixes.\r\n    // We could hash the size/uv to create a unique ID but that would prevent the user from animating UV.\r\n    PushID((void *)user_texture_id);\r\n    const ImGuiID id = window->GetID(\"#image\");\r\n    PopID();\r\n\r\n    const ImVec2 padding = (frame_padding >= 0) ? ImVec2((float)frame_padding, (float)frame_padding) : style.FramePadding;\r\n    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size + padding*2);\r\n    const ImRect image_bb(window->DC.CursorPos + padding, window->DC.CursorPos + padding + size);\r\n    ItemSize(bb);\r\n    if (!ItemAdd(bb, id))\r\n        return false;\r\n\r\n    bool hovered, held;\r\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held);\r\n\r\n    // Render\r\n    const ImU32 col = GetColorU32((hovered && held) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);\r\n    RenderFrame(bb.Min, bb.Max, col, true, ImClamp((float)ImMin(padding.x, padding.y), 0.0f, style.FrameRounding));\r\n    if (bg_col.w > 0.0f)\r\n        window->DrawList->AddRectFilled(image_bb.Min, image_bb.Max, GetColorU32(bg_col));\r\n    window->DrawList->AddImage(user_texture_id, image_bb.Min, image_bb.Max, uv0, uv1, GetColorU32(tint_col));\r\n\r\n    return pressed;\r\n}\r\n\r\n// Start logging ImGui output to TTY\r\nvoid ImGui::LogToTTY(int max_depth)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.LogEnabled)\r\n        return;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    g.LogEnabled = true;\r\n    g.LogFile = stdout;\r\n    g.LogStartDepth = window->DC.TreeDepth;\r\n    if (max_depth >= 0)\r\n        g.LogAutoExpandMaxDepth = max_depth;\r\n}\r\n\r\n// Start logging ImGui output to given file\r\nvoid ImGui::LogToFile(int max_depth, const char* filename)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.LogEnabled)\r\n        return;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    if (!filename)\r\n    {\r\n        filename = g.IO.LogFilename;\r\n        if (!filename)\r\n            return;\r\n    }\r\n\r\n    g.LogFile = ImFileOpen(filename, \"ab\");\r\n    if (!g.LogFile)\r\n    {\r\n        IM_ASSERT(g.LogFile != NULL); // Consider this an error\r\n        return;\r\n    }\r\n    g.LogEnabled = true;\r\n    g.LogStartDepth = window->DC.TreeDepth;\r\n    if (max_depth >= 0)\r\n        g.LogAutoExpandMaxDepth = max_depth;\r\n}\r\n\r\n// Start logging ImGui output to clipboard\r\nvoid ImGui::LogToClipboard(int max_depth)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.LogEnabled)\r\n        return;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    g.LogEnabled = true;\r\n    g.LogFile = NULL;\r\n    g.LogStartDepth = window->DC.TreeDepth;\r\n    if (max_depth >= 0)\r\n        g.LogAutoExpandMaxDepth = max_depth;\r\n}\r\n\r\nvoid ImGui::LogFinish()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (!g.LogEnabled)\r\n        return;\r\n\r\n    LogText(IM_NEWLINE);\r\n    g.LogEnabled = false;\r\n    if (g.LogFile != NULL)\r\n    {\r\n        if (g.LogFile == stdout)\r\n            fflush(g.LogFile);\r\n        else\r\n            fclose(g.LogFile);\r\n        g.LogFile = NULL;\r\n    }\r\n    if (g.LogClipboard->size() > 1)\r\n    {\r\n        SetClipboardText(g.LogClipboard->begin());\r\n        g.LogClipboard->clear();\r\n    }\r\n}\r\n\r\n// Helper to display logging buttons\r\nvoid ImGui::LogButtons()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    PushID(\"LogButtons\");\r\n    const bool log_to_tty = Button(\"Log To TTY\"); SameLine();\r\n    const bool log_to_file = Button(\"Log To File\"); SameLine();\r\n    const bool log_to_clipboard = Button(\"Log To Clipboard\"); SameLine();\r\n    PushItemWidth(80.0f);\r\n    PushAllowKeyboardFocus(false);\r\n    SliderInt(\"Depth\", &g.LogAutoExpandMaxDepth, 0, 9, NULL);\r\n    PopAllowKeyboardFocus();\r\n    PopItemWidth();\r\n    PopID();\r\n\r\n    // Start logging at the end of the function so that the buttons don't appear in the log\r\n    if (log_to_tty)\r\n        LogToTTY(g.LogAutoExpandMaxDepth);\r\n    if (log_to_file)\r\n        LogToFile(g.LogAutoExpandMaxDepth, g.IO.LogFilename);\r\n    if (log_to_clipboard)\r\n        LogToClipboard(g.LogAutoExpandMaxDepth);\r\n}\r\n\r\nbool ImGui::TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags)\r\n{\r\n    if (flags & ImGuiTreeNodeFlags_Leaf)\r\n        return true;\r\n\r\n    // We only write to the tree storage if the user clicks (or explicitely use SetNextTreeNode*** functions)\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    ImGuiStorage* storage = window->DC.StateStorage;\r\n\r\n    bool is_open;\r\n    if (g.SetNextTreeNodeOpenCond != 0)\r\n    {\r\n        if (g.SetNextTreeNodeOpenCond & ImGuiCond_Always)\r\n        {\r\n            is_open = g.SetNextTreeNodeOpenVal;\r\n            storage->SetInt(id, is_open);\r\n        }\r\n        else\r\n        {\r\n            // We treat ImGuiCond_Once and ImGuiCond_FirstUseEver the same because tree node state are not saved persistently.\r\n            const int stored_value = storage->GetInt(id, -1);\r\n            if (stored_value == -1)\r\n            {\r\n                is_open = g.SetNextTreeNodeOpenVal;\r\n                storage->SetInt(id, is_open);\r\n            }\r\n            else\r\n            {\r\n                is_open = stored_value != 0;\r\n            }\r\n        }\r\n        g.SetNextTreeNodeOpenCond = 0;\r\n    }\r\n    else\r\n    {\r\n        is_open = storage->GetInt(id, (flags & ImGuiTreeNodeFlags_DefaultOpen) ? 1 : 0) != 0;\r\n    }\r\n\r\n    // When logging is enabled, we automatically expand tree nodes (but *NOT* collapsing headers.. seems like sensible behavior).\r\n    // NB- If we are above max depth we still allow manually opened nodes to be logged.\r\n    if (g.LogEnabled && !(flags & ImGuiTreeNodeFlags_NoAutoOpenOnLog) && window->DC.TreeDepth < g.LogAutoExpandMaxDepth)\r\n        is_open = true;\r\n\r\n    return is_open;\r\n}\r\n\r\nbool ImGui::TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const bool display_frame = (flags & ImGuiTreeNodeFlags_Framed) != 0;\r\n    const ImVec2 padding = (display_frame || (flags & ImGuiTreeNodeFlags_FramePadding)) ? style.FramePadding : ImVec2(style.FramePadding.x, 0.0f);\r\n\r\n    if (!label_end)\r\n        label_end = FindRenderedTextEnd(label);\r\n    const ImVec2 label_size = CalcTextSize(label, label_end, false);\r\n\r\n    // We vertically grow up to current line height up the typical widget height.\r\n    const float text_base_offset_y = ImMax(padding.y, window->DC.CurrentLineTextBaseOffset); // Latch before ItemSize changes it\r\n    const float frame_height = ImMax(ImMin(window->DC.CurrentLineHeight, g.FontSize + style.FramePadding.y*2), label_size.y + padding.y*2);\r\n    ImRect bb = ImRect(window->DC.CursorPos, ImVec2(window->Pos.x + GetContentRegionMax().x, window->DC.CursorPos.y + frame_height));\r\n    if (display_frame)\r\n    {\r\n        // Framed header expand a little outside the default padding\r\n        bb.Min.x -= (float)(int)(window->WindowPadding.x*0.5f) - 1;\r\n        bb.Max.x += (float)(int)(window->WindowPadding.x*0.5f) - 1;\r\n    }\r\n\r\n    const float text_offset_x = (g.FontSize + (display_frame ? padding.x*3 : padding.x*2));   // Collapser arrow width + Spacing\r\n    const float text_width = g.FontSize + (label_size.x > 0.0f ? label_size.x + padding.x*2 : 0.0f);   // Include collapser\r\n    ItemSize(ImVec2(text_width, frame_height), text_base_offset_y);\r\n\r\n    // For regular tree nodes, we arbitrary allow to click past 2 worth of ItemSpacing\r\n    // (Ideally we'd want to add a flag for the user to specify if we want the hit test to be done up to the right side of the content or not)\r\n    const ImRect interact_bb = display_frame ? bb : ImRect(bb.Min.x, bb.Min.y, bb.Min.x + text_width + style.ItemSpacing.x*2, bb.Max.y);\r\n    bool is_open = TreeNodeBehaviorIsOpen(id, flags);\r\n    if (!ItemAdd(interact_bb, id))\r\n    {\r\n        if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))\r\n            TreePushRawID(id);\r\n        return is_open;\r\n    }\r\n\r\n    // Flags that affects opening behavior:\r\n    // - 0(default) ..................... single-click anywhere to open\r\n    // - OpenOnDoubleClick .............. double-click anywhere to open\r\n    // - OpenOnArrow .................... single-click on arrow to open\r\n    // - OpenOnDoubleClick|OpenOnArrow .. single-click on arrow or double-click anywhere to open\r\n    ImGuiButtonFlags button_flags = ImGuiButtonFlags_NoKeyModifiers | ((flags & ImGuiTreeNodeFlags_AllowItemOverlap) ? ImGuiButtonFlags_AllowItemOverlap : 0);\r\n    button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;\r\n    if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)\r\n        button_flags |= ImGuiButtonFlags_PressedOnDoubleClick | ((flags & ImGuiTreeNodeFlags_OpenOnArrow) ? ImGuiButtonFlags_PressedOnClickRelease : 0);\r\n\r\n    bool hovered, held, pressed = ButtonBehavior(interact_bb, id, &hovered, &held, button_flags);\r\n    if (pressed && !(flags & ImGuiTreeNodeFlags_Leaf))\r\n    {\r\n        bool toggled = !(flags & (ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick));\r\n        if (flags & ImGuiTreeNodeFlags_OpenOnArrow)\r\n            toggled |= IsMouseHoveringRect(interact_bb.Min, ImVec2(interact_bb.Min.x + text_offset_x, interact_bb.Max.y));\r\n        if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)\r\n            toggled |= g.IO.MouseDoubleClicked[0];\r\n        if (g.DragDropActive && is_open) // When using Drag and Drop \"hold to open\" we keep the node highlighted after opening, but never close it again.\r\n            toggled = false;\r\n        if (toggled)\r\n        {\r\n            is_open = !is_open;\r\n            window->DC.StateStorage->SetInt(id, is_open);\r\n        }\r\n    }\r\n    if (flags & ImGuiTreeNodeFlags_AllowItemOverlap)\r\n        SetItemAllowOverlap();\r\n\r\n    // Render\r\n    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);\r\n    const ImVec2 text_pos = bb.Min + ImVec2(text_offset_x, text_base_offset_y);\r\n    if (display_frame)\r\n    {\r\n        // Framed type\r\n        RenderFrame(bb.Min, bb.Max, col, true, style.FrameRounding);\r\n        RenderTriangle(bb.Min + ImVec2(padding.x, text_base_offset_y), is_open ? ImGuiDir_Down : ImGuiDir_Right, 1.0f);\r\n        if (g.LogEnabled)\r\n        {\r\n            // NB: '##' is normally used to hide text (as a library-wide feature), so we need to specify the text range to make sure the ## aren't stripped out here.\r\n            const char log_prefix[] = \"\\n##\";\r\n            const char log_suffix[] = \"##\";\r\n            LogRenderedText(&text_pos, log_prefix, log_prefix+3);\r\n            RenderTextClipped(text_pos, bb.Max, label, label_end, &label_size);\r\n            LogRenderedText(&text_pos, log_suffix+1, log_suffix+3);\r\n        }\r\n        else\r\n        {\r\n            RenderTextClipped(text_pos, bb.Max, label, label_end, &label_size);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        // Unframed typed for tree nodes\r\n        if (hovered || (flags & ImGuiTreeNodeFlags_Selected))\r\n            RenderFrame(bb.Min, bb.Max, col, false);\r\n\r\n        if (flags & ImGuiTreeNodeFlags_Bullet)\r\n            RenderBullet(bb.Min + ImVec2(text_offset_x * 0.5f, g.FontSize*0.50f + text_base_offset_y));\r\n        else if (!(flags & ImGuiTreeNodeFlags_Leaf))\r\n            RenderTriangle(bb.Min + ImVec2(padding.x, g.FontSize*0.15f + text_base_offset_y), is_open ? ImGuiDir_Down : ImGuiDir_Right, 0.70f);\r\n        if (g.LogEnabled)\r\n            LogRenderedText(&text_pos, \">\");\r\n        RenderText(text_pos, label, label_end, false);\r\n    }\r\n\r\n    if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))\r\n        TreePushRawID(id);\r\n    return is_open;\r\n}\r\n\r\n// CollapsingHeader returns true when opened but do not indent nor push into the ID stack (because of the ImGuiTreeNodeFlags_NoTreePushOnOpen flag).\r\n// This is basically the same as calling TreeNodeEx(label, ImGuiTreeNodeFlags_CollapsingHeader | ImGuiTreeNodeFlags_NoTreePushOnOpen). You can remove the _NoTreePushOnOpen flag if you want behavior closer to normal TreeNode().\r\nbool ImGui::CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    return TreeNodeBehavior(window->GetID(label), flags | ImGuiTreeNodeFlags_CollapsingHeader | ImGuiTreeNodeFlags_NoTreePushOnOpen, label);\r\n}\r\n\r\nbool ImGui::CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    if (p_open && !*p_open)\r\n        return false;\r\n\r\n    ImGuiID id = window->GetID(label);\r\n    bool is_open = TreeNodeBehavior(id, flags | ImGuiTreeNodeFlags_CollapsingHeader | ImGuiTreeNodeFlags_NoTreePushOnOpen | (p_open ? ImGuiTreeNodeFlags_AllowItemOverlap : 0), label);\r\n    if (p_open)\r\n    {\r\n        // Create a small overlapping close button // FIXME: We can evolve this into user accessible helpers to add extra buttons on title bars, headers, etc.\r\n        ImGuiContext& g = *GImGui;\r\n        float button_sz = g.FontSize * 0.5f;\r\n        ImGuiItemHoveredDataBackup last_item_backup;\r\n        if (CloseButton(window->GetID((void*)(intptr_t)(id+1)), ImVec2(ImMin(window->DC.LastItemRect.Max.x, window->ClipRect.Max.x) - g.Style.FramePadding.x - button_sz, window->DC.LastItemRect.Min.y + g.Style.FramePadding.y + button_sz), button_sz))\r\n            *p_open = false;\r\n        last_item_backup.Restore();\r\n    }\r\n\r\n    return is_open;\r\n}\r\n\r\nbool ImGui::TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    return TreeNodeBehavior(window->GetID(label), flags, label, NULL);\r\n}\r\n\r\nbool ImGui::TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);\r\n    return TreeNodeBehavior(window->GetID(str_id), flags, g.TempBuffer, label_end);\r\n}\r\n\r\nbool ImGui::TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);\r\n    return TreeNodeBehavior(window->GetID(ptr_id), flags, g.TempBuffer, label_end);\r\n}\r\n\r\nbool ImGui::TreeNodeV(const char* str_id, const char* fmt, va_list args)\r\n{\r\n    return TreeNodeExV(str_id, 0, fmt, args);\r\n}\r\n\r\nbool ImGui::TreeNodeV(const void* ptr_id, const char* fmt, va_list args)\r\n{\r\n    return TreeNodeExV(ptr_id, 0, fmt, args);\r\n}\r\n\r\nbool ImGui::TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    bool is_open = TreeNodeExV(str_id, flags, fmt, args);\r\n    va_end(args);\r\n    return is_open;\r\n}\r\n\r\nbool ImGui::TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    bool is_open = TreeNodeExV(ptr_id, flags, fmt, args);\r\n    va_end(args);\r\n    return is_open;\r\n}\r\n\r\nbool ImGui::TreeNode(const char* str_id, const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    bool is_open = TreeNodeExV(str_id, 0, fmt, args);\r\n    va_end(args);\r\n    return is_open;\r\n}\r\n\r\nbool ImGui::TreeNode(const void* ptr_id, const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    bool is_open = TreeNodeExV(ptr_id, 0, fmt, args);\r\n    va_end(args);\r\n    return is_open;\r\n}\r\n\r\nbool ImGui::TreeNode(const char* label)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n    return TreeNodeBehavior(window->GetID(label), 0, label, NULL);\r\n}\r\n\r\nvoid ImGui::TreeAdvanceToLabelPos()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.CurrentWindow->DC.CursorPos.x += GetTreeNodeToLabelSpacing();\r\n}\r\n\r\n// Horizontal distance preceding label when using TreeNode() or Bullet()\r\nfloat ImGui::GetTreeNodeToLabelSpacing()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.FontSize + (g.Style.FramePadding.x * 2.0f);\r\n}\r\n\r\nvoid ImGui::SetNextTreeNodeOpen(bool is_open, ImGuiCond cond)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.CurrentWindow->SkipItems)\r\n        return;\r\n    g.SetNextTreeNodeOpenVal = is_open;\r\n    g.SetNextTreeNodeOpenCond = cond ? cond : ImGuiCond_Always;\r\n}\r\n\r\nvoid ImGui::PushID(const char* str_id)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    window->IDStack.push_back(window->GetID(str_id));\r\n}\r\n\r\nvoid ImGui::PushID(const char* str_id_begin, const char* str_id_end)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    window->IDStack.push_back(window->GetID(str_id_begin, str_id_end));\r\n}\r\n\r\nvoid ImGui::PushID(const void* ptr_id)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    window->IDStack.push_back(window->GetID(ptr_id));\r\n}\r\n\r\nvoid ImGui::PushID(int int_id)\r\n{\r\n    const void* ptr_id = (void*)(intptr_t)int_id;\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    window->IDStack.push_back(window->GetID(ptr_id));\r\n}\r\n\r\nvoid ImGui::PopID()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    window->IDStack.pop_back();\r\n}\r\n\r\nImGuiID ImGui::GetID(const char* str_id)\r\n{\r\n    return GImGui->CurrentWindow->GetID(str_id);\r\n}\r\n\r\nImGuiID ImGui::GetID(const char* str_id_begin, const char* str_id_end)\r\n{\r\n    return GImGui->CurrentWindow->GetID(str_id_begin, str_id_end);\r\n}\r\n\r\nImGuiID ImGui::GetID(const void* ptr_id)\r\n{\r\n    return GImGui->CurrentWindow->GetID(ptr_id);\r\n}\r\n\r\nvoid ImGui::Bullet()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const float line_height = ImMax(ImMin(window->DC.CurrentLineHeight, g.FontSize + g.Style.FramePadding.y*2), g.FontSize);\r\n    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize, line_height));\r\n    ItemSize(bb);\r\n    if (!ItemAdd(bb, 0))\r\n    {\r\n        SameLine(0, style.FramePadding.x*2);\r\n        return;\r\n    }\r\n\r\n    // Render and stay on same line\r\n    RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize*0.5f, line_height*0.5f));\r\n    SameLine(0, style.FramePadding.x*2);\r\n}\r\n\r\n// Text with a little bullet aligned to the typical tree node.\r\nvoid ImGui::BulletTextV(const char* fmt, va_list args)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n\r\n    const char* text_begin = g.TempBuffer;\r\n    const char* text_end = text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);\r\n    const ImVec2 label_size = CalcTextSize(text_begin, text_end, false);\r\n    const float text_base_offset_y = ImMax(0.0f, window->DC.CurrentLineTextBaseOffset); // Latch before ItemSize changes it\r\n    const float line_height = ImMax(ImMin(window->DC.CurrentLineHeight, g.FontSize + g.Style.FramePadding.y*2), g.FontSize);\r\n    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize + (label_size.x > 0.0f ? (label_size.x + style.FramePadding.x*2) : 0.0f), ImMax(line_height, label_size.y)));  // Empty text doesn't add padding\r\n    ItemSize(bb);\r\n    if (!ItemAdd(bb, 0))\r\n        return;\r\n\r\n    // Render\r\n    RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize*0.5f, line_height*0.5f));\r\n    RenderText(bb.Min+ImVec2(g.FontSize + style.FramePadding.x*2, text_base_offset_y), text_begin, text_end, false);\r\n}\r\n\r\nvoid ImGui::BulletText(const char* fmt, ...)\r\n{\r\n    va_list args;\r\n    va_start(args, fmt);\r\n    BulletTextV(fmt, args);\r\n    va_end(args);\r\n}\r\n\r\nstatic inline void DataTypeFormatString(ImGuiDataType data_type, void* data_ptr, const char* display_format, char* buf, int buf_size)\r\n{\r\n    if (data_type == ImGuiDataType_Int)\r\n        ImFormatString(buf, buf_size, display_format, *(int*)data_ptr);\r\n    else if (data_type == ImGuiDataType_Float)\r\n        ImFormatString(buf, buf_size, display_format, *(float*)data_ptr);\r\n}\r\n\r\nstatic inline void DataTypeFormatString(ImGuiDataType data_type, void* data_ptr, int decimal_precision, char* buf, int buf_size)\r\n{\r\n    if (data_type == ImGuiDataType_Int)\r\n    {\r\n        if (decimal_precision < 0)\r\n            ImFormatString(buf, buf_size, \"%d\", *(int*)data_ptr);\r\n        else\r\n            ImFormatString(buf, buf_size, \"%.*d\", decimal_precision, *(int*)data_ptr);\r\n    }\r\n    else if (data_type == ImGuiDataType_Float)\r\n    {\r\n        if (decimal_precision < 0)\r\n            ImFormatString(buf, buf_size, \"%f\", *(float*)data_ptr);     // Ideally we'd have a minimum decimal precision of 1 to visually denote that it is a float, while hiding non-significant digits?\r\n        else\r\n            ImFormatString(buf, buf_size, \"%.*f\", decimal_precision, *(float*)data_ptr);\r\n    }\r\n}\r\n\r\nstatic void DataTypeApplyOp(ImGuiDataType data_type, int op, void* value1, const void* value2)// Store into value1\r\n{\r\n    if (data_type == ImGuiDataType_Int)\r\n    {\r\n        if (op == '+')\r\n            *(int*)value1 = *(int*)value1 + *(const int*)value2;\r\n        else if (op == '-')\r\n            *(int*)value1 = *(int*)value1 - *(const int*)value2;\r\n    }\r\n    else if (data_type == ImGuiDataType_Float)\r\n    {\r\n        if (op == '+')\r\n            *(float*)value1 = *(float*)value1 + *(const float*)value2;\r\n        else if (op == '-')\r\n            *(float*)value1 = *(float*)value1 - *(const float*)value2;\r\n    }\r\n}\r\n\r\n// User can input math operators (e.g. +100) to edit a numerical values.\r\nstatic bool DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* data_ptr, const char* scalar_format)\r\n{\r\n    while (ImCharIsSpace(*buf))\r\n        buf++;\r\n\r\n    // We don't support '-' op because it would conflict with inputing negative value.\r\n    // Instead you can use +-100 to subtract from an existing value\r\n    char op = buf[0];\r\n    if (op == '+' || op == '*' || op == '/')\r\n    {\r\n        buf++;\r\n        while (ImCharIsSpace(*buf))\r\n            buf++;\r\n    }\r\n    else\r\n    {\r\n        op = 0;\r\n    }\r\n    if (!buf[0])\r\n        return false;\r\n\r\n    if (data_type == ImGuiDataType_Int)\r\n    {\r\n        if (!scalar_format)\r\n            scalar_format = \"%d\";\r\n        int* v = (int*)data_ptr;\r\n        const int old_v = *v;\r\n        int arg0i = *v;\r\n        if (op && sscanf(initial_value_buf, scalar_format, &arg0i) < 1)\r\n            return false;\r\n\r\n        // Store operand in a float so we can use fractional value for multipliers (*1.1), but constant always parsed as integer so we can fit big integers (e.g. 2000000003) past float precision\r\n        float arg1f = 0.0f;\r\n        if (op == '+')      { if (sscanf(buf, \"%f\", &arg1f) == 1) *v = (int)(arg0i + arg1f); }                 // Add (use \"+-\" to subtract)\r\n        else if (op == '*') { if (sscanf(buf, \"%f\", &arg1f) == 1) *v = (int)(arg0i * arg1f); }                 // Multiply\r\n        else if (op == '/') { if (sscanf(buf, \"%f\", &arg1f) == 1 && arg1f != 0.0f) *v = (int)(arg0i / arg1f); }// Divide\r\n        else                { if (sscanf(buf, scalar_format, &arg0i) == 1) *v = arg0i; }                       // Assign constant (read as integer so big values are not lossy)\r\n        return (old_v != *v);\r\n    }\r\n    else if (data_type == ImGuiDataType_Float)\r\n    {\r\n        // For floats we have to ignore format with precision (e.g. \"%.2f\") because sscanf doesn't take them in\r\n        scalar_format = \"%f\";\r\n        float* v = (float*)data_ptr;\r\n        const float old_v = *v;\r\n        float arg0f = *v;\r\n        if (op && sscanf(initial_value_buf, scalar_format, &arg0f) < 1)\r\n            return false;\r\n\r\n        float arg1f = 0.0f;\r\n        if (sscanf(buf, scalar_format, &arg1f) < 1)\r\n            return false;\r\n        if (op == '+')      { *v = arg0f + arg1f; }                    // Add (use \"+-\" to subtract)\r\n        else if (op == '*') { *v = arg0f * arg1f; }                    // Multiply\r\n        else if (op == '/') { if (arg1f != 0.0f) *v = arg0f / arg1f; } // Divide\r\n        else                { *v = arg1f; }                            // Assign constant\r\n        return (old_v != *v);\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n// Create text input in place of a slider (when CTRL+Clicking on slider)\r\n// FIXME: Logic is messy and confusing.\r\nbool ImGui::InputScalarAsWidgetReplacement(const ImRect& aabb, const char* label, ImGuiDataType data_type, void* data_ptr, ImGuiID id, int decimal_precision)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n\r\n    // Our replacement widget will override the focus ID (registered previously to allow for a TAB focus to happen)\r\n    // On the first frame, g.ScalarAsInputTextId == 0, then on subsequent frames it becomes == id\r\n    SetActiveID(g.ScalarAsInputTextId, window);\r\n    SetHoveredID(0);\r\n    FocusableItemUnregister(window);\r\n\r\n    char buf[32];\r\n    DataTypeFormatString(data_type, data_ptr, decimal_precision, buf, IM_ARRAYSIZE(buf));\r\n    bool text_value_changed = InputTextEx(label, buf, IM_ARRAYSIZE(buf), aabb.GetSize(), ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_AutoSelectAll);\r\n    if (g.ScalarAsInputTextId == 0)     // First frame we started displaying the InputText widget\r\n    {\r\n        IM_ASSERT(g.ActiveId == id);    // InputText ID expected to match the Slider ID (else we'd need to store them both, which is also possible)\r\n        g.ScalarAsInputTextId = g.ActiveId;\r\n        SetHoveredID(id);\r\n    }\r\n    if (text_value_changed)\r\n        return DataTypeApplyOpFromText(buf, GImGui->InputTextState.InitialText.begin(), data_type, data_ptr, NULL);\r\n    return false;\r\n}\r\n\r\n// Parse display precision back from the display format string\r\nint ImGui::ParseFormatPrecision(const char* fmt, int default_precision)\r\n{\r\n    int precision = default_precision;\r\n    while ((fmt = strchr(fmt, '%')) != NULL)\r\n    {\r\n        fmt++;\r\n        if (fmt[0] == '%') { fmt++; continue; } // Ignore \"%%\"\r\n        while (*fmt >= '0' && *fmt <= '9')\r\n            fmt++;\r\n        if (*fmt == '.')\r\n        {\r\n            fmt = ImAtoi(fmt + 1, &precision);\r\n            if (precision < 0 || precision > 10)\r\n                precision = default_precision;\r\n        }\r\n        if (*fmt == 'e' || *fmt == 'E') // Maximum precision with scientific notation\r\n            precision = -1;\r\n        break;\r\n    }\r\n    return precision;\r\n}\r\n\r\nstatic float GetMinimumStepAtDecimalPrecision(int decimal_precision)\r\n{\r\n    static const float min_steps[10] = { 1.0f, 0.1f, 0.01f, 0.001f, 0.0001f, 0.00001f, 0.000001f, 0.0000001f, 0.00000001f, 0.000000001f };\r\n    return (decimal_precision >= 0 && decimal_precision < 10) ? min_steps[decimal_precision] : powf(10.0f, (float)-decimal_precision);\r\n}\r\n\r\nfloat ImGui::RoundScalar(float value, int decimal_precision)\r\n{\r\n    // Round past decimal precision\r\n    // So when our value is 1.99999 with a precision of 0.001 we'll end up rounding to 2.0\r\n    // FIXME: Investigate better rounding methods\r\n    if (decimal_precision < 0)\r\n        return value;\r\n    const float min_step = GetMinimumStepAtDecimalPrecision(decimal_precision);\r\n    bool negative = value < 0.0f;\r\n    value = fabsf(value);\r\n    float remainder = fmodf(value, min_step);\r\n    if (remainder <= min_step*0.5f)\r\n        value -= remainder;\r\n    else\r\n        value += (min_step - remainder);\r\n    return negative ? -value : value;\r\n}\r\n\r\nstatic inline float SliderBehaviorCalcRatioFromValue(float v, float v_min, float v_max, float power, float linear_zero_pos)\r\n{\r\n    if (v_min == v_max)\r\n        return 0.0f;\r\n\r\n    const bool is_non_linear = (power < 1.0f-0.00001f) || (power > 1.0f+0.00001f);\r\n    const float v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);\r\n    if (is_non_linear)\r\n    {\r\n        if (v_clamped < 0.0f)\r\n        {\r\n            const float f = 1.0f - (v_clamped - v_min) / (ImMin(0.0f,v_max) - v_min);\r\n            return (1.0f - powf(f, 1.0f/power)) * linear_zero_pos;\r\n        }\r\n        else\r\n        {\r\n            const float f = (v_clamped - ImMax(0.0f,v_min)) / (v_max - ImMax(0.0f,v_min));\r\n            return linear_zero_pos + powf(f, 1.0f/power) * (1.0f - linear_zero_pos);\r\n        }\r\n    }\r\n\r\n    // Linear slider\r\n    return (v_clamped - v_min) / (v_max - v_min);\r\n}\r\n\r\nbool ImGui::SliderBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v_min, float v_max, float power, int decimal_precision, ImGuiSliderFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    const ImGuiStyle& style = g.Style;\r\n\r\n    // Draw frame\r\n    RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);\r\n\r\n    const bool is_non_linear = (power < 1.0f-0.00001f) || (power > 1.0f+0.00001f);\r\n    const bool is_horizontal = (flags & ImGuiSliderFlags_Vertical) == 0;\r\n\r\n    const float grab_padding = 2.0f;\r\n    const float slider_sz = is_horizontal ? (frame_bb.GetWidth() - grab_padding * 2.0f) : (frame_bb.GetHeight() - grab_padding * 2.0f);\r\n    float grab_sz;\r\n    if (decimal_precision != 0)\r\n        grab_sz = ImMin(style.GrabMinSize, slider_sz);\r\n    else\r\n        grab_sz = ImMin(ImMax(1.0f * (slider_sz / ((v_min < v_max ? v_max - v_min : v_min - v_max) + 1.0f)), style.GrabMinSize), slider_sz);  // Integer sliders, if possible have the grab size represent 1 unit\r\n    const float slider_usable_sz = slider_sz - grab_sz;\r\n    const float slider_usable_pos_min = (is_horizontal ? frame_bb.Min.x : frame_bb.Min.y) + grab_padding + grab_sz*0.5f;\r\n    const float slider_usable_pos_max = (is_horizontal ? frame_bb.Max.x : frame_bb.Max.y) - grab_padding - grab_sz*0.5f;\r\n\r\n    // For logarithmic sliders that cross over sign boundary we want the exponential increase to be symmetric around 0.0f\r\n    float linear_zero_pos = 0.0f;   // 0.0->1.0f\r\n    if (v_min * v_max < 0.0f)\r\n    {\r\n        // Different sign\r\n        const float linear_dist_min_to_0 = powf(fabsf(0.0f - v_min), 1.0f/power);\r\n        const float linear_dist_max_to_0 = powf(fabsf(v_max - 0.0f), 1.0f/power);\r\n        linear_zero_pos = linear_dist_min_to_0 / (linear_dist_min_to_0+linear_dist_max_to_0);\r\n    }\r\n    else\r\n    {\r\n        // Same sign\r\n        linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;\r\n    }\r\n\r\n    // Process clicking on the slider\r\n    bool value_changed = false;\r\n    if (g.ActiveId == id)\r\n    {\r\n        bool set_new_value = false;\r\n        float clicked_t = 0.0f;\r\n        if (g.IO.MouseDown[0])\r\n        {\r\n            const float mouse_abs_pos = is_horizontal ? g.IO.MousePos.x : g.IO.MousePos.y;\r\n            clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;\r\n            if (!is_horizontal)\r\n                clicked_t = 1.0f - clicked_t;\r\n            set_new_value = true;\r\n        }\r\n        else\r\n        {\r\n            ClearActiveID();\r\n        }\r\n\r\n        if (set_new_value)\r\n        {\r\n            float new_value;\r\n            if (is_non_linear)\r\n            {\r\n                // Account for logarithmic scale on both sides of the zero\r\n                if (clicked_t < linear_zero_pos)\r\n                {\r\n                    // Negative: rescale to the negative range before powering\r\n                    float a = 1.0f - (clicked_t / linear_zero_pos);\r\n                    a = powf(a, power);\r\n                    new_value = ImLerp(ImMin(v_max,0.0f), v_min, a);\r\n                }\r\n                else\r\n                {\r\n                    // Positive: rescale to the positive range before powering\r\n                    float a;\r\n                    if (fabsf(linear_zero_pos - 1.0f) > 1.e-6f)\r\n                        a = (clicked_t - linear_zero_pos) / (1.0f - linear_zero_pos);\r\n                    else\r\n                        a = clicked_t;\r\n                    a = powf(a, power);\r\n                    new_value = ImLerp(ImMax(v_min,0.0f), v_max, a);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                // Linear slider\r\n                new_value = ImLerp(v_min, v_max, clicked_t);\r\n            }\r\n\r\n            // Round past decimal precision\r\n            new_value = RoundScalar(new_value, decimal_precision);\r\n            if (*v != new_value)\r\n            {\r\n                *v = new_value;\r\n                value_changed = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Draw\r\n    float grab_t = SliderBehaviorCalcRatioFromValue(*v, v_min, v_max, power, linear_zero_pos);\r\n    if (!is_horizontal)\r\n        grab_t = 1.0f - grab_t;\r\n    const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);\r\n    ImRect grab_bb;\r\n    if (is_horizontal)\r\n        grab_bb = ImRect(ImVec2(grab_pos - grab_sz*0.5f, frame_bb.Min.y + grab_padding), ImVec2(grab_pos + grab_sz*0.5f, frame_bb.Max.y - grab_padding));\r\n    else\r\n        grab_bb = ImRect(ImVec2(frame_bb.Min.x + grab_padding, grab_pos - grab_sz*0.5f), ImVec2(frame_bb.Max.x - grab_padding, grab_pos + grab_sz*0.5f));\r\n    window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);\r\n\r\n    return value_changed;\r\n}\r\n\r\n// Use power!=1.0 for logarithmic sliders.\r\n// Adjust display_format to decorate the value with a prefix or a suffix.\r\n//   \"%.3f\"         1.234\r\n//   \"%5.2f secs\"   01.23 secs\r\n//   \"Gold: %.0f\"   Gold: 1\r\nbool ImGui::SliderFloat(const char* label, float* v, float v_min, float v_max, const char* display_format, float power)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const ImGuiID id = window->GetID(label);\r\n    const float w = CalcItemWidth();\r\n\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));\r\n    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));\r\n\r\n    // NB- we don't call ItemSize() yet because we may turn into a text edit box below\r\n    if (!ItemAdd(total_bb, id))\r\n    {\r\n        ItemSize(total_bb, style.FramePadding.y);\r\n        return false;\r\n    }\r\n    const bool hovered = ItemHoverable(frame_bb, id);\r\n\r\n    if (!display_format)\r\n        display_format = \"%.3f\";\r\n    int decimal_precision = ParseFormatPrecision(display_format, 3);\r\n\r\n    // Tabbing or CTRL-clicking on Slider turns it into an input box\r\n    bool start_text_input = false;\r\n    const bool tab_focus_requested = FocusableItemRegister(window, id);\r\n    if (tab_focus_requested || (hovered && g.IO.MouseClicked[0]))\r\n    {\r\n        SetActiveID(id, window);\r\n        FocusWindow(window);\r\n        if (tab_focus_requested || g.IO.KeyCtrl)\r\n        {\r\n            start_text_input = true;\r\n            g.ScalarAsInputTextId = 0;\r\n        }\r\n    }\r\n    if (start_text_input || (g.ActiveId == id && g.ScalarAsInputTextId == id))\r\n        return InputScalarAsWidgetReplacement(frame_bb, label, ImGuiDataType_Float, v, id, decimal_precision);\r\n\r\n    // Actual slider behavior + render grab\r\n    ItemSize(total_bb, style.FramePadding.y);\r\n    const bool value_changed = SliderBehavior(frame_bb, id, v, v_min, v_max, power, decimal_precision);\r\n\r\n    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.\r\n    char value_buf[64];\r\n    const char* value_buf_end = value_buf + ImFormatString(value_buf, IM_ARRAYSIZE(value_buf), display_format, *v);\r\n    RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.5f));\r\n\r\n    if (label_size.x > 0.0f)\r\n        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);\r\n\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format, float power)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const ImGuiID id = window->GetID(label);\r\n\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);\r\n    const ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));\r\n\r\n    ItemSize(bb, style.FramePadding.y);\r\n    if (!ItemAdd(frame_bb, id))\r\n        return false;\r\n    const bool hovered = ItemHoverable(frame_bb, id);\r\n\r\n    if (!display_format)\r\n        display_format = \"%.3f\";\r\n    int decimal_precision = ParseFormatPrecision(display_format, 3);\r\n\r\n    if (hovered && g.IO.MouseClicked[0])\r\n    {\r\n        SetActiveID(id, window);\r\n        FocusWindow(window);\r\n    }\r\n\r\n    // Actual slider behavior + render grab\r\n    bool value_changed = SliderBehavior(frame_bb, id, v, v_min, v_max, power, decimal_precision, ImGuiSliderFlags_Vertical);\r\n\r\n    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.\r\n    // For the vertical slider we allow centered text to overlap the frame padding\r\n    char value_buf[64];\r\n    char* value_buf_end = value_buf + ImFormatString(value_buf, IM_ARRAYSIZE(value_buf), display_format, *v);\r\n    RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.0f));\r\n    if (label_size.x > 0.0f)\r\n        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);\r\n\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::SliderAngle(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max)\r\n{\r\n    float v_deg = (*v_rad) * 360.0f / (2*IM_PI);\r\n    bool value_changed = SliderFloat(label, &v_deg, v_degrees_min, v_degrees_max, \"%.0f deg\", 1.0f);\r\n    *v_rad = v_deg * (2*IM_PI) / 360.0f;\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::SliderInt(const char* label, int* v, int v_min, int v_max, const char* display_format)\r\n{\r\n    if (!display_format)\r\n        display_format = \"%.0f\";\r\n    float v_f = (float)*v;\r\n    bool value_changed = SliderFloat(label, &v_f, (float)v_min, (float)v_max, display_format, 1.0f);\r\n    *v = (int)v_f;\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format)\r\n{\r\n    if (!display_format)\r\n        display_format = \"%.0f\";\r\n    float v_f = (float)*v;\r\n    bool value_changed = VSliderFloat(label, size, &v_f, (float)v_min, (float)v_max, display_format, 1.0f);\r\n    *v = (int)v_f;\r\n    return value_changed;\r\n}\r\n\r\n// Add multiple sliders on 1 line for compact edition of multiple components\r\nbool ImGui::SliderFloatN(const char* label, float* v, int components, float v_min, float v_max, const char* display_format, float power)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    bool value_changed = false;\r\n    BeginGroup();\r\n    PushID(label);\r\n    PushMultiItemsWidths(components);\r\n    for (int i = 0; i < components; i++)\r\n    {\r\n        PushID(i);\r\n        value_changed |= SliderFloat(\"##v\", &v[i], v_min, v_max, display_format, power);\r\n        SameLine(0, g.Style.ItemInnerSpacing.x);\r\n        PopID();\r\n        PopItemWidth();\r\n    }\r\n    PopID();\r\n\r\n    TextUnformatted(label, FindRenderedTextEnd(label));\r\n    EndGroup();\r\n\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* display_format, float power)\r\n{\r\n    return SliderFloatN(label, v, 2, v_min, v_max, display_format, power);\r\n}\r\n\r\nbool ImGui::SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* display_format, float power)\r\n{\r\n    return SliderFloatN(label, v, 3, v_min, v_max, display_format, power);\r\n}\r\n\r\nbool ImGui::SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* display_format, float power)\r\n{\r\n    return SliderFloatN(label, v, 4, v_min, v_max, display_format, power);\r\n}\r\n\r\nbool ImGui::SliderIntN(const char* label, int* v, int components, int v_min, int v_max, const char* display_format)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    bool value_changed = false;\r\n    BeginGroup();\r\n    PushID(label);\r\n    PushMultiItemsWidths(components);\r\n    for (int i = 0; i < components; i++)\r\n    {\r\n        PushID(i);\r\n        value_changed |= SliderInt(\"##v\", &v[i], v_min, v_max, display_format);\r\n        SameLine(0, g.Style.ItemInnerSpacing.x);\r\n        PopID();\r\n        PopItemWidth();\r\n    }\r\n    PopID();\r\n\r\n    TextUnformatted(label, FindRenderedTextEnd(label));\r\n    EndGroup();\r\n\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* display_format)\r\n{\r\n    return SliderIntN(label, v, 2, v_min, v_max, display_format);\r\n}\r\n\r\nbool ImGui::SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* display_format)\r\n{\r\n    return SliderIntN(label, v, 3, v_min, v_max, display_format);\r\n}\r\n\r\nbool ImGui::SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* display_format)\r\n{\r\n    return SliderIntN(label, v, 4, v_min, v_max, display_format);\r\n}\r\n\r\nbool ImGui::DragBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v_speed, float v_min, float v_max, int decimal_precision, float power)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n\r\n    // Draw frame\r\n    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);\r\n    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding);\r\n\r\n    bool value_changed = false;\r\n\r\n    // Process clicking on the drag\r\n    if (g.ActiveId == id)\r\n    {\r\n        if (g.IO.MouseDown[0])\r\n        {\r\n            if (g.ActiveIdIsJustActivated)\r\n            {\r\n                // Lock current value on click\r\n                g.DragCurrentValue = *v;\r\n                g.DragLastMouseDelta = ImVec2(0.f, 0.f);\r\n            }\r\n\r\n            if (v_speed == 0.0f && (v_max - v_min) != 0.0f && (v_max - v_min) < FLT_MAX)\r\n                v_speed = (v_max - v_min) * g.DragSpeedDefaultRatio;\r\n\r\n            float v_cur = g.DragCurrentValue;\r\n            const ImVec2 mouse_drag_delta = GetMouseDragDelta(0, 1.0f);\r\n            float adjust_delta = 0.0f;\r\n            //if (g.ActiveIdSource == ImGuiInputSource_Mouse)\r\n            {\r\n                adjust_delta = mouse_drag_delta.x - g.DragLastMouseDelta.x;\r\n                if (g.IO.KeyShift && g.DragSpeedScaleFast >= 0.0f)\r\n                    adjust_delta *= g.DragSpeedScaleFast;\r\n                if (g.IO.KeyAlt && g.DragSpeedScaleSlow >= 0.0f)\r\n                    adjust_delta *= g.DragSpeedScaleSlow;\r\n            }\r\n            adjust_delta *= v_speed;\r\n            g.DragLastMouseDelta.x = mouse_drag_delta.x;\r\n\r\n            if (fabsf(adjust_delta) > 0.0f)\r\n            {\r\n                if (fabsf(power - 1.0f) > 0.001f)\r\n                {\r\n                    // Logarithmic curve on both side of 0.0\r\n                    float v0_abs = v_cur >= 0.0f ? v_cur : -v_cur;\r\n                    float v0_sign = v_cur >= 0.0f ? 1.0f : -1.0f;\r\n                    float v1 = powf(v0_abs, 1.0f / power) + (adjust_delta * v0_sign);\r\n                    float v1_abs = v1 >= 0.0f ? v1 : -v1;\r\n                    float v1_sign = v1 >= 0.0f ? 1.0f : -1.0f;          // Crossed sign line\r\n                    v_cur = powf(v1_abs, power) * v0_sign * v1_sign;    // Reapply sign\r\n                }\r\n                else\r\n                {\r\n                    v_cur += adjust_delta;\r\n                }\r\n\r\n                // Clamp\r\n                if (v_min < v_max)\r\n                    v_cur = ImClamp(v_cur, v_min, v_max);\r\n                g.DragCurrentValue = v_cur;\r\n            }\r\n\r\n            // Round to user desired precision, then apply\r\n            v_cur = RoundScalar(v_cur, decimal_precision);\r\n            if (*v != v_cur)\r\n            {\r\n                *v = v_cur;\r\n                value_changed = true;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            ClearActiveID();\r\n        }\r\n    }\r\n\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::DragFloat(const char* label, float* v, float v_speed, float v_min, float v_max, const char* display_format, float power)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const ImGuiID id = window->GetID(label);\r\n    const float w = CalcItemWidth();\r\n\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));\r\n    const ImRect inner_bb(frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding);\r\n    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));\r\n\r\n    // NB- we don't call ItemSize() yet because we may turn into a text edit box below\r\n    if (!ItemAdd(total_bb, id))\r\n    {\r\n        ItemSize(total_bb, style.FramePadding.y);\r\n        return false;\r\n    }\r\n    const bool hovered = ItemHoverable(frame_bb, id);\r\n\r\n    if (!display_format)\r\n        display_format = \"%.3f\";\r\n    int decimal_precision = ParseFormatPrecision(display_format, 3);\r\n\r\n    // Tabbing or CTRL-clicking on Drag turns it into an input box\r\n    bool start_text_input = false;\r\n    const bool tab_focus_requested = FocusableItemRegister(window, id);\r\n    if (tab_focus_requested || (hovered && (g.IO.MouseClicked[0] || g.IO.MouseDoubleClicked[0])))\r\n    {\r\n        SetActiveID(id, window);\r\n        FocusWindow(window);\r\n        if (tab_focus_requested || g.IO.KeyCtrl || g.IO.MouseDoubleClicked[0])\r\n        {\r\n            start_text_input = true;\r\n            g.ScalarAsInputTextId = 0;\r\n        }\r\n    }\r\n    if (start_text_input || (g.ActiveId == id && g.ScalarAsInputTextId == id))\r\n        return InputScalarAsWidgetReplacement(frame_bb, label, ImGuiDataType_Float, v, id, decimal_precision);\r\n\r\n    // Actual drag behavior\r\n    ItemSize(total_bb, style.FramePadding.y);\r\n    const bool value_changed = DragBehavior(frame_bb, id, v, v_speed, v_min, v_max, decimal_precision, power);\r\n\r\n    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.\r\n    char value_buf[64];\r\n    const char* value_buf_end = value_buf + ImFormatString(value_buf, IM_ARRAYSIZE(value_buf), display_format, *v);\r\n    RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.5f));\r\n\r\n    if (label_size.x > 0.0f)\r\n        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);\r\n\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::DragFloatN(const char* label, float* v, int components, float v_speed, float v_min, float v_max, const char* display_format, float power)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    bool value_changed = false;\r\n    BeginGroup();\r\n    PushID(label);\r\n    PushMultiItemsWidths(components);\r\n    for (int i = 0; i < components; i++)\r\n    {\r\n        PushID(i);\r\n        value_changed |= DragFloat(\"##v\", &v[i], v_speed, v_min, v_max, display_format, power);\r\n        SameLine(0, g.Style.ItemInnerSpacing.x);\r\n        PopID();\r\n        PopItemWidth();\r\n    }\r\n    PopID();\r\n\r\n    TextUnformatted(label, FindRenderedTextEnd(label));\r\n    EndGroup();\r\n\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* display_format, float power)\r\n{\r\n    return DragFloatN(label, v, 2, v_speed, v_min, v_max, display_format, power);\r\n}\r\n\r\nbool ImGui::DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* display_format, float power)\r\n{\r\n    return DragFloatN(label, v, 3, v_speed, v_min, v_max, display_format, power);\r\n}\r\n\r\nbool ImGui::DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* display_format, float power)\r\n{\r\n    return DragFloatN(label, v, 4, v_speed, v_min, v_max, display_format, power);\r\n}\r\n\r\nbool ImGui::DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* display_format, const char* display_format_max, float power)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    PushID(label);\r\n    BeginGroup();\r\n    PushMultiItemsWidths(2);\r\n\r\n    bool value_changed = DragFloat(\"##min\", v_current_min, v_speed, (v_min >= v_max) ? -FLT_MAX : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), display_format, power);\r\n    PopItemWidth();\r\n    SameLine(0, g.Style.ItemInnerSpacing.x);\r\n    value_changed |= DragFloat(\"##max\", v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? FLT_MAX : v_max, display_format_max ? display_format_max : display_format, power);\r\n    PopItemWidth();\r\n    SameLine(0, g.Style.ItemInnerSpacing.x);\r\n\r\n    TextUnformatted(label, FindRenderedTextEnd(label));\r\n    EndGroup();\r\n    PopID();\r\n\r\n    return value_changed;\r\n}\r\n\r\n// NB: v_speed is float to allow adjusting the drag speed with more precision\r\nbool ImGui::DragInt(const char* label, int* v, float v_speed, int v_min, int v_max, const char* display_format)\r\n{\r\n    if (!display_format)\r\n        display_format = \"%.0f\";\r\n    float v_f = (float)*v;\r\n    bool value_changed = DragFloat(label, &v_f, v_speed, (float)v_min, (float)v_max, display_format);\r\n    *v = (int)v_f;\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::DragIntN(const char* label, int* v, int components, float v_speed, int v_min, int v_max, const char* display_format)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    bool value_changed = false;\r\n    BeginGroup();\r\n    PushID(label);\r\n    PushMultiItemsWidths(components);\r\n    for (int i = 0; i < components; i++)\r\n    {\r\n        PushID(i);\r\n        value_changed |= DragInt(\"##v\", &v[i], v_speed, v_min, v_max, display_format);\r\n        SameLine(0, g.Style.ItemInnerSpacing.x);\r\n        PopID();\r\n        PopItemWidth();\r\n    }\r\n    PopID();\r\n\r\n    TextUnformatted(label, FindRenderedTextEnd(label));\r\n    EndGroup();\r\n\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::DragInt2(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* display_format)\r\n{\r\n    return DragIntN(label, v, 2, v_speed, v_min, v_max, display_format);\r\n}\r\n\r\nbool ImGui::DragInt3(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* display_format)\r\n{\r\n    return DragIntN(label, v, 3, v_speed, v_min, v_max, display_format);\r\n}\r\n\r\nbool ImGui::DragInt4(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* display_format)\r\n{\r\n    return DragIntN(label, v, 4, v_speed, v_min, v_max, display_format);\r\n}\r\n\r\nbool ImGui::DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* display_format, const char* display_format_max)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    PushID(label);\r\n    BeginGroup();\r\n    PushMultiItemsWidths(2);\r\n\r\n    bool value_changed = DragInt(\"##min\", v_current_min, v_speed, (v_min >= v_max) ? INT_MIN : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), display_format);\r\n    PopItemWidth();\r\n    SameLine(0, g.Style.ItemInnerSpacing.x);\r\n    value_changed |= DragInt(\"##max\", v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? INT_MAX : v_max, display_format_max ? display_format_max : display_format);\r\n    PopItemWidth();\r\n    SameLine(0, g.Style.ItemInnerSpacing.x);\r\n\r\n    TextUnformatted(label, FindRenderedTextEnd(label));\r\n    EndGroup();\r\n    PopID();\r\n\r\n    return value_changed;\r\n}\r\n\r\nvoid ImGui::PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n    if (graph_size.x == 0.0f)\r\n        graph_size.x = CalcItemWidth();\r\n    if (graph_size.y == 0.0f)\r\n        graph_size.y = label_size.y + (style.FramePadding.y * 2);\r\n\r\n    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(graph_size.x, graph_size.y));\r\n    const ImRect inner_bb(frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding);\r\n    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0));\r\n    ItemSize(total_bb, style.FramePadding.y);\r\n    if (!ItemAdd(total_bb, 0))\r\n        return;\r\n    const bool hovered = ItemHoverable(inner_bb, 0);\r\n\r\n    // Determine scale from values if not specified\r\n    if (scale_min == FLT_MAX || scale_max == FLT_MAX)\r\n    {\r\n        float v_min = FLT_MAX;\r\n        float v_max = -FLT_MAX;\r\n        for (int i = 0; i < values_count; i++)\r\n        {\r\n            const float v = values_getter(data, i);\r\n            v_min = ImMin(v_min, v);\r\n            v_max = ImMax(v_max, v);\r\n        }\r\n        if (scale_min == FLT_MAX)\r\n            scale_min = v_min;\r\n        if (scale_max == FLT_MAX)\r\n            scale_max = v_max;\r\n    }\r\n\r\n    RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);\r\n\r\n    if (values_count > 0)\r\n    {\r\n        int res_w = ImMin((int)graph_size.x, values_count) + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);\r\n        int item_count = values_count + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);\r\n\r\n        // Tooltip on hover\r\n        int v_hovered = -1;\r\n        if (hovered)\r\n        {\r\n            const float t = ImClamp((g.IO.MousePos.x - inner_bb.Min.x) / (inner_bb.Max.x - inner_bb.Min.x), 0.0f, 0.9999f);\r\n            const int v_idx = (int)(t * item_count);\r\n            IM_ASSERT(v_idx >= 0 && v_idx < values_count);\r\n\r\n            const float v0 = values_getter(data, (v_idx + values_offset) % values_count);\r\n            const float v1 = values_getter(data, (v_idx + 1 + values_offset) % values_count);\r\n            if (plot_type == ImGuiPlotType_Lines)\r\n                SetTooltip(\"%d: %8.4g\\n%d: %8.4g\", v_idx, v0, v_idx+1, v1);\r\n            else if (plot_type == ImGuiPlotType_Histogram)\r\n                SetTooltip(\"%d: %8.4g\", v_idx, v0);\r\n            v_hovered = v_idx;\r\n        }\r\n\r\n        const float t_step = 1.0f / (float)res_w;\r\n\r\n        float v0 = values_getter(data, (0 + values_offset) % values_count);\r\n        float t0 = 0.0f;\r\n        ImVec2 tp0 = ImVec2( t0, 1.0f - ImSaturate((v0 - scale_min) / (scale_max - scale_min)) );                       // Point in the normalized space of our target rectangle\r\n        float histogram_zero_line_t = (scale_min * scale_max < 0.0f) ? (-scale_min / (scale_max - scale_min)) : (scale_min < 0.0f ? 0.0f : 1.0f);   // Where does the zero line stands\r\n\r\n        const ImU32 col_base = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLines : ImGuiCol_PlotHistogram);\r\n        const ImU32 col_hovered = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLinesHovered : ImGuiCol_PlotHistogramHovered);\r\n\r\n        for (int n = 0; n < res_w; n++)\r\n        {\r\n            const float t1 = t0 + t_step;\r\n            const int v1_idx = (int)(t0 * item_count + 0.5f);\r\n            IM_ASSERT(v1_idx >= 0 && v1_idx < values_count);\r\n            const float v1 = values_getter(data, (v1_idx + values_offset + 1) % values_count);\r\n            const ImVec2 tp1 = ImVec2( t1, 1.0f - ImSaturate((v1 - scale_min) / (scale_max - scale_min)) );\r\n\r\n            // NB: Draw calls are merged together by the DrawList system. Still, we should render our batch are lower level to save a bit of CPU.\r\n            ImVec2 pos0 = ImLerp(inner_bb.Min, inner_bb.Max, tp0);\r\n            ImVec2 pos1 = ImLerp(inner_bb.Min, inner_bb.Max, (plot_type == ImGuiPlotType_Lines) ? tp1 : ImVec2(tp1.x, histogram_zero_line_t));\r\n            if (plot_type == ImGuiPlotType_Lines)\r\n            {\r\n                window->DrawList->AddLine(pos0, pos1, v_hovered == v1_idx ? col_hovered : col_base);\r\n            }\r\n            else if (plot_type == ImGuiPlotType_Histogram)\r\n            {\r\n                if (pos1.x >= pos0.x + 2.0f)\r\n                    pos1.x -= 1.0f;\r\n                window->DrawList->AddRectFilled(pos0, pos1, v_hovered == v1_idx ? col_hovered : col_base);\r\n            }\r\n\r\n            t0 = t1;\r\n            tp0 = tp1;\r\n        }\r\n    }\r\n\r\n    // Text overlay\r\n    if (overlay_text)\r\n        RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, overlay_text, NULL, NULL, ImVec2(0.5f,0.0f));\r\n\r\n    if (label_size.x > 0.0f)\r\n        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);\r\n}\r\n\r\nstruct ImGuiPlotArrayGetterData\r\n{\r\n    const float* Values;\r\n    int Stride;\r\n\r\n    ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }\r\n};\r\n\r\nstatic float Plot_ArrayGetter(void* data, int idx)\r\n{\r\n    ImGuiPlotArrayGetterData* plot_data = (ImGuiPlotArrayGetterData*)data;\r\n    const float v = *(float*)(void*)((unsigned char*)plot_data->Values + (size_t)idx * plot_data->Stride);\r\n    return v;\r\n}\r\n\r\nvoid ImGui::PlotLines(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)\r\n{\r\n    ImGuiPlotArrayGetterData data(values, stride);\r\n    PlotEx(ImGuiPlotType_Lines, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);\r\n}\r\n\r\nvoid ImGui::PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)\r\n{\r\n    PlotEx(ImGuiPlotType_Lines, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);\r\n}\r\n\r\nvoid ImGui::PlotHistogram(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)\r\n{\r\n    ImGuiPlotArrayGetterData data(values, stride);\r\n    PlotEx(ImGuiPlotType_Histogram, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);\r\n}\r\n\r\nvoid ImGui::PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)\r\n{\r\n    PlotEx(ImGuiPlotType_Histogram, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);\r\n}\r\n\r\n// size_arg (for each axis) < 0.0f: align to end, 0.0f: auto, > 0.0f: specified size\r\nvoid ImGui::ProgressBar(float fraction, const ImVec2& size_arg, const char* overlay)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n\r\n    ImVec2 pos = window->DC.CursorPos;\r\n    ImRect bb(pos, pos + CalcItemSize(size_arg, CalcItemWidth(), g.FontSize + style.FramePadding.y*2.0f));\r\n    ItemSize(bb, style.FramePadding.y);\r\n    if (!ItemAdd(bb, 0))\r\n        return;\r\n\r\n    // Render\r\n    fraction = ImSaturate(fraction);\r\n    RenderFrame(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);\r\n    bb.Expand(ImVec2(-style.FrameBorderSize, -style.FrameBorderSize));\r\n    const ImVec2 fill_br = ImVec2(ImLerp(bb.Min.x, bb.Max.x, fraction), bb.Max.y);\r\n    RenderRectFilledRangeH(window->DrawList, bb, GetColorU32(ImGuiCol_PlotHistogram), 0.0f, fraction, style.FrameRounding);\r\n\r\n    // Default displaying the fraction as percentage string, but user can override it\r\n    char overlay_buf[32];\r\n    if (!overlay)\r\n    {\r\n        ImFormatString(overlay_buf, IM_ARRAYSIZE(overlay_buf), \"%.0f%%\", fraction*100+0.01f);\r\n        overlay = overlay_buf;\r\n    }\r\n\r\n    ImVec2 overlay_size = CalcTextSize(overlay, NULL);\r\n    if (overlay_size.x > 0.0f)\r\n        RenderTextClipped(ImVec2(ImClamp(fill_br.x + style.ItemSpacing.x, bb.Min.x, bb.Max.x - overlay_size.x - style.ItemInnerSpacing.x), bb.Min.y), bb.Max, overlay, NULL, &overlay_size, ImVec2(0.0f,0.5f), &bb);\r\n}\r\n\r\nbool ImGui::Checkbox(const char* label, bool* v)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const ImGuiID id = window->GetID(label);\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n\r\n    const ImRect check_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(label_size.y + style.FramePadding.y*2, label_size.y + style.FramePadding.y*2)); // We want a square shape to we use Y twice\r\n    ItemSize(check_bb, style.FramePadding.y);\r\n\r\n    ImRect total_bb = check_bb;\r\n    if (label_size.x > 0)\r\n        SameLine(0, style.ItemInnerSpacing.x);\r\n    const ImRect text_bb(window->DC.CursorPos + ImVec2(0,style.FramePadding.y), window->DC.CursorPos + ImVec2(0,style.FramePadding.y) + label_size);\r\n    if (label_size.x > 0)\r\n    {\r\n        ItemSize(ImVec2(text_bb.GetWidth(), check_bb.GetHeight()), style.FramePadding.y);\r\n        total_bb = ImRect(ImMin(check_bb.Min, text_bb.Min), ImMax(check_bb.Max, text_bb.Max));\r\n    }\r\n\r\n    if (!ItemAdd(total_bb, id))\r\n        return false;\r\n\r\n    bool hovered, held;\r\n    bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);\r\n    if (pressed)\r\n        *v = !(*v);\r\n\r\n    RenderFrame(check_bb.Min, check_bb.Max, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), true, style.FrameRounding);\r\n    if (*v)\r\n    {\r\n        const float check_sz = ImMin(check_bb.GetWidth(), check_bb.GetHeight());\r\n        const float pad = ImMax(1.0f, (float)(int)(check_sz / 6.0f));\r\n        RenderCheckMark(check_bb.Min + ImVec2(pad,pad), GetColorU32(ImGuiCol_CheckMark), check_bb.GetWidth() - pad*2.0f);\r\n    }\r\n\r\n    if (g.LogEnabled)\r\n        LogRenderedText(&text_bb.Min, *v ? \"[x]\" : \"[ ]\");\r\n    if (label_size.x > 0.0f)\r\n        RenderText(text_bb.Min, label);\r\n\r\n    return pressed;\r\n}\r\n\r\nbool ImGui::CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value)\r\n{\r\n    bool v = ((*flags & flags_value) == flags_value);\r\n    bool pressed = Checkbox(label, &v);\r\n    if (pressed)\r\n    {\r\n        if (v)\r\n            *flags |= flags_value;\r\n        else\r\n            *flags &= ~flags_value;\r\n    }\r\n\r\n    return pressed;\r\n}\r\n\r\nbool ImGui::RadioButton(const char* label, bool active)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const ImGuiID id = window->GetID(label);\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n\r\n    const ImRect check_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(label_size.y + style.FramePadding.y*2-1, label_size.y + style.FramePadding.y*2-1));\r\n    ItemSize(check_bb, style.FramePadding.y);\r\n\r\n    ImRect total_bb = check_bb;\r\n    if (label_size.x > 0)\r\n        SameLine(0, style.ItemInnerSpacing.x);\r\n    const ImRect text_bb(window->DC.CursorPos + ImVec2(0, style.FramePadding.y), window->DC.CursorPos + ImVec2(0, style.FramePadding.y) + label_size);\r\n    if (label_size.x > 0)\r\n    {\r\n        ItemSize(ImVec2(text_bb.GetWidth(), check_bb.GetHeight()), style.FramePadding.y);\r\n        total_bb.Add(text_bb);\r\n    }\r\n\r\n    if (!ItemAdd(total_bb, id))\r\n        return false;\r\n\r\n    ImVec2 center = check_bb.GetCenter();\r\n    center.x = (float)(int)center.x + 0.5f;\r\n    center.y = (float)(int)center.y + 0.5f;\r\n    const float radius = check_bb.GetHeight() * 0.5f;\r\n\r\n    bool hovered, held;\r\n    bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);\r\n\r\n    window->DrawList->AddCircleFilled(center, radius, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), 16);\r\n    if (active)\r\n    {\r\n        const float check_sz = ImMin(check_bb.GetWidth(), check_bb.GetHeight());\r\n        const float pad = ImMax(1.0f, (float)(int)(check_sz / 6.0f));\r\n        window->DrawList->AddCircleFilled(center, radius-pad, GetColorU32(ImGuiCol_CheckMark), 16);\r\n    }\r\n\r\n    if (style.FrameBorderSize > 0.0f)\r\n    {\r\n        window->DrawList->AddCircle(center+ImVec2(1,1), radius, GetColorU32(ImGuiCol_BorderShadow), 16, style.FrameBorderSize);\r\n        window->DrawList->AddCircle(center, radius, GetColorU32(ImGuiCol_Border), 16, style.FrameBorderSize);\r\n    }\r\n\r\n    if (g.LogEnabled)\r\n        LogRenderedText(&text_bb.Min, active ? \"(x)\" : \"( )\");\r\n    if (label_size.x > 0.0f)\r\n        RenderText(text_bb.Min, label);\r\n\r\n    return pressed;\r\n}\r\n\r\nbool ImGui::RadioButton(const char* label, int* v, int v_button)\r\n{\r\n    const bool pressed = RadioButton(label, *v == v_button);\r\n    if (pressed)\r\n    {\r\n        *v = v_button;\r\n    }\r\n    return pressed;\r\n}\r\n\r\nstatic int InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end)\r\n{\r\n    int line_count = 0;\r\n    const char* s = text_begin;\r\n    while (char c = *s++) // We are only matching for \\n so we can ignore UTF-8 decoding\r\n        if (c == '\\n')\r\n            line_count++;\r\n    s--;\r\n    if (s[0] != '\\n' && s[0] != '\\r')\r\n        line_count++;\r\n    *out_text_end = s;\r\n    return line_count;\r\n}\r\n\r\nstatic ImVec2 InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining, ImVec2* out_offset, bool stop_on_new_line)\r\n{\r\n    ImFont* font = GImGui->Font;\r\n    const float line_height = GImGui->FontSize;\r\n    const float scale = line_height / font->FontSize;\r\n\r\n    ImVec2 text_size = ImVec2(0,0);\r\n    float line_width = 0.0f;\r\n\r\n    const ImWchar* s = text_begin;\r\n    while (s < text_end)\r\n    {\r\n        unsigned int c = (unsigned int)(*s++);\r\n        if (c == '\\n')\r\n        {\r\n            text_size.x = ImMax(text_size.x, line_width);\r\n            text_size.y += line_height;\r\n            line_width = 0.0f;\r\n            if (stop_on_new_line)\r\n                break;\r\n            continue;\r\n        }\r\n        if (c == '\\r')\r\n            continue;\r\n\r\n        const float char_width = font->GetCharAdvance((unsigned short)c) * scale;\r\n        line_width += char_width;\r\n    }\r\n\r\n    if (text_size.x < line_width)\r\n        text_size.x = line_width;\r\n\r\n    if (out_offset)\r\n        *out_offset = ImVec2(line_width, text_size.y + line_height);  // offset allow for the possibility of sitting after a trailing \\n\r\n\r\n    if (line_width > 0 || text_size.y == 0.0f)                        // whereas size.y will ignore the trailing \\n\r\n        text_size.y += line_height;\r\n\r\n    if (remaining)\r\n        *remaining = s;\r\n\r\n    return text_size;\r\n}\r\n\r\n// Wrapper for stb_textedit.h to edit text (our wrapper is for: statically sized buffer, single-line, wchar characters. InputText converts between UTF-8 and wchar)\r\nnamespace ImGuiStb\r\n{\r\n\r\nstatic int     STB_TEXTEDIT_STRINGLEN(const STB_TEXTEDIT_STRING* obj)                             { return obj->CurLenW; }\r\nstatic ImWchar STB_TEXTEDIT_GETCHAR(const STB_TEXTEDIT_STRING* obj, int idx)                      { return obj->Text[idx]; }\r\nstatic float   STB_TEXTEDIT_GETWIDTH(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->Text[line_start_idx+char_idx]; if (c == '\\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; return GImGui->Font->GetCharAdvance(c) * (GImGui->FontSize / GImGui->Font->FontSize); }\r\nstatic int     STB_TEXTEDIT_KEYTOTEXT(int key)                                                    { return key >= 0x10000 ? 0 : key; }\r\nstatic ImWchar STB_TEXTEDIT_NEWLINE = '\\n';\r\nstatic void    STB_TEXTEDIT_LAYOUTROW(StbTexteditRow* r, STB_TEXTEDIT_STRING* obj, int line_start_idx)\r\n{\r\n    const ImWchar* text = obj->Text.Data;\r\n    const ImWchar* text_remaining = NULL;\r\n    const ImVec2 size = InputTextCalcTextSizeW(text + line_start_idx, text + obj->CurLenW, &text_remaining, NULL, true);\r\n    r->x0 = 0.0f;\r\n    r->x1 = size.x;\r\n    r->baseline_y_delta = size.y;\r\n    r->ymin = 0.0f;\r\n    r->ymax = size.y;\r\n    r->num_chars = (int)(text_remaining - (text + line_start_idx));\r\n}\r\n\r\nstatic bool is_separator(unsigned int c)                                        { return ImCharIsSpace(c) || c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|'; }\r\nstatic int  is_word_boundary_from_right(STB_TEXTEDIT_STRING* obj, int idx)      { return idx > 0 ? (is_separator( obj->Text[idx-1] ) && !is_separator( obj->Text[idx] ) ) : 1; }\r\nstatic int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)   { idx--; while (idx >= 0 && !is_word_boundary_from_right(obj, idx)) idx--; return idx < 0 ? 0 : idx; }\r\n#ifdef __APPLE__    // FIXME: Move setting to IO structure\r\nstatic int  is_word_boundary_from_left(STB_TEXTEDIT_STRING* obj, int idx)       { return idx > 0 ? (!is_separator( obj->Text[idx-1] ) && is_separator( obj->Text[idx] ) ) : 1; }\r\nstatic int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_left(obj, idx)) idx++; return idx > len ? len : idx; }\r\n#else\r\nstatic int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_right(obj, idx)) idx++; return idx > len ? len : idx; }\r\n#endif\r\n#define STB_TEXTEDIT_MOVEWORDLEFT   STB_TEXTEDIT_MOVEWORDLEFT_IMPL    // They need to be #define for stb_textedit.h\r\n#define STB_TEXTEDIT_MOVEWORDRIGHT  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL\r\n\r\nstatic void STB_TEXTEDIT_DELETECHARS(STB_TEXTEDIT_STRING* obj, int pos, int n)\r\n{\r\n    ImWchar* dst = obj->Text.Data + pos;\r\n\r\n    // We maintain our buffer length in both UTF-8 and wchar formats\r\n    obj->CurLenA -= ImTextCountUtf8BytesFromStr(dst, dst + n);\r\n    obj->CurLenW -= n;\r\n\r\n    // Offset remaining text\r\n    const ImWchar* src = obj->Text.Data + pos + n;\r\n    while (ImWchar c = *src++)\r\n        *dst++ = c;\r\n    *dst = '\\0';\r\n}\r\n\r\nstatic bool STB_TEXTEDIT_INSERTCHARS(STB_TEXTEDIT_STRING* obj, int pos, const ImWchar* new_text, int new_text_len)\r\n{\r\n    const int text_len = obj->CurLenW;\r\n    IM_ASSERT(pos <= text_len);\r\n    if (new_text_len + text_len + 1 > obj->Text.Size)\r\n        return false;\r\n\r\n    const int new_text_len_utf8 = ImTextCountUtf8BytesFromStr(new_text, new_text + new_text_len);\r\n    if (new_text_len_utf8 + obj->CurLenA + 1 > obj->BufSizeA)\r\n        return false;\r\n\r\n    ImWchar* text = obj->Text.Data;\r\n    if (pos != text_len)\r\n        memmove(text + pos + new_text_len, text + pos, (size_t)(text_len - pos) * sizeof(ImWchar));\r\n    memcpy(text + pos, new_text, (size_t)new_text_len * sizeof(ImWchar));\r\n\r\n    obj->CurLenW += new_text_len;\r\n    obj->CurLenA += new_text_len_utf8;\r\n    obj->Text[obj->CurLenW] = '\\0';\r\n\r\n    return true;\r\n}\r\n\r\n// We don't use an enum so we can build even with conflicting symbols (if another user of stb_textedit.h leak their STB_TEXTEDIT_K_* symbols)\r\n#define STB_TEXTEDIT_K_LEFT         0x10000 // keyboard input to move cursor left\r\n#define STB_TEXTEDIT_K_RIGHT        0x10001 // keyboard input to move cursor right\r\n#define STB_TEXTEDIT_K_UP           0x10002 // keyboard input to move cursor up\r\n#define STB_TEXTEDIT_K_DOWN         0x10003 // keyboard input to move cursor down\r\n#define STB_TEXTEDIT_K_LINESTART    0x10004 // keyboard input to move cursor to start of line\r\n#define STB_TEXTEDIT_K_LINEEND      0x10005 // keyboard input to move cursor to end of line\r\n#define STB_TEXTEDIT_K_TEXTSTART    0x10006 // keyboard input to move cursor to start of text\r\n#define STB_TEXTEDIT_K_TEXTEND      0x10007 // keyboard input to move cursor to end of text\r\n#define STB_TEXTEDIT_K_DELETE       0x10008 // keyboard input to delete selection or character under cursor\r\n#define STB_TEXTEDIT_K_BACKSPACE    0x10009 // keyboard input to delete selection or character left of cursor\r\n#define STB_TEXTEDIT_K_UNDO         0x1000A // keyboard input to perform undo\r\n#define STB_TEXTEDIT_K_REDO         0x1000B // keyboard input to perform redo\r\n#define STB_TEXTEDIT_K_WORDLEFT     0x1000C // keyboard input to move cursor left one word\r\n#define STB_TEXTEDIT_K_WORDRIGHT    0x1000D // keyboard input to move cursor right one word\r\n#define STB_TEXTEDIT_K_SHIFT        0x20000\r\n\r\n#define STB_TEXTEDIT_IMPLEMENTATION\r\n#include \"stb_textedit.h\"\r\n\r\n}\r\n\r\nvoid ImGuiTextEditState::OnKeyPressed(int key)\r\n{\r\n    stb_textedit_key(this, &StbState, key);\r\n    CursorFollow = true;\r\n    CursorAnimReset();\r\n}\r\n\r\n// Public API to manipulate UTF-8 text\r\n// We expose UTF-8 to the user (unlike the STB_TEXTEDIT_* functions which are manipulating wchar)\r\n// FIXME: The existence of this rarely exercised code path is a bit of a nuisance.\r\nvoid ImGuiTextEditCallbackData::DeleteChars(int pos, int bytes_count)\r\n{\r\n    IM_ASSERT(pos + bytes_count <= BufTextLen);\r\n    char* dst = Buf + pos;\r\n    const char* src = Buf + pos + bytes_count;\r\n    while (char c = *src++)\r\n        *dst++ = c;\r\n    *dst = '\\0';\r\n\r\n    if (CursorPos + bytes_count >= pos)\r\n        CursorPos -= bytes_count;\r\n    else if (CursorPos >= pos)\r\n        CursorPos = pos;\r\n    SelectionStart = SelectionEnd = CursorPos;\r\n    BufDirty = true;\r\n    BufTextLen -= bytes_count;\r\n}\r\n\r\nvoid ImGuiTextEditCallbackData::InsertChars(int pos, const char* new_text, const char* new_text_end)\r\n{\r\n    const int new_text_len = new_text_end ? (int)(new_text_end - new_text) : (int)strlen(new_text);\r\n    if (new_text_len + BufTextLen + 1 >= BufSize)\r\n        return;\r\n\r\n    if (BufTextLen != pos)\r\n        memmove(Buf + pos + new_text_len, Buf + pos, (size_t)(BufTextLen - pos));\r\n    memcpy(Buf + pos, new_text, (size_t)new_text_len * sizeof(char));\r\n    Buf[BufTextLen + new_text_len] = '\\0';\r\n\r\n    if (CursorPos >= pos)\r\n        CursorPos += new_text_len;\r\n    SelectionStart = SelectionEnd = CursorPos;\r\n    BufDirty = true;\r\n    BufTextLen += new_text_len;\r\n}\r\n\r\n// Return false to discard a character.\r\nstatic bool InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)\r\n{\r\n    unsigned int c = *p_char;\r\n\r\n    if (c < 128 && c != ' ' && !isprint((int)(c & 0xFF)))\r\n    {\r\n        bool pass = false;\r\n        pass |= (c == '\\n' && (flags & ImGuiInputTextFlags_Multiline));\r\n        pass |= (c == '\\t' && (flags & ImGuiInputTextFlags_AllowTabInput));\r\n        if (!pass)\r\n            return false;\r\n    }\r\n\r\n    if (c >= 0xE000 && c <= 0xF8FF) // Filter private Unicode range. I don't imagine anybody would want to input them. GLFW on OSX seems to send private characters for special keys like arrow keys.\r\n        return false;\r\n\r\n    if (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase | ImGuiInputTextFlags_CharsNoBlank))\r\n    {\r\n        if (flags & ImGuiInputTextFlags_CharsDecimal)\r\n            if (!(c >= '0' && c <= '9') && (c != '.') && (c != '-') && (c != '+') && (c != '*') && (c != '/'))\r\n                return false;\r\n\r\n        if (flags & ImGuiInputTextFlags_CharsHexadecimal)\r\n            if (!(c >= '0' && c <= '9') && !(c >= 'a' && c <= 'f') && !(c >= 'A' && c <= 'F'))\r\n                return false;\r\n\r\n        if (flags & ImGuiInputTextFlags_CharsUppercase)\r\n            if (c >= 'a' && c <= 'z')\r\n                *p_char = (c += (unsigned int)('A'-'a'));\r\n\r\n        if (flags & ImGuiInputTextFlags_CharsNoBlank)\r\n            if (ImCharIsSpace(c))\r\n                return false;\r\n    }\r\n\r\n    if (flags & ImGuiInputTextFlags_CallbackCharFilter)\r\n    {\r\n        ImGuiTextEditCallbackData callback_data;\r\n        memset(&callback_data, 0, sizeof(ImGuiTextEditCallbackData));\r\n        callback_data.EventFlag = ImGuiInputTextFlags_CallbackCharFilter;\r\n        callback_data.EventChar = (ImWchar)c;\r\n        callback_data.Flags = flags;\r\n        callback_data.UserData = user_data;\r\n        if (callback(&callback_data) != 0)\r\n            return false;\r\n        *p_char = callback_data.EventChar;\r\n        if (!callback_data.EventChar)\r\n            return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n// Edit a string of text\r\n// NB: when active, hold on a privately held copy of the text (and apply back to 'buf'). So changing 'buf' while active has no effect.\r\n// FIXME: Rather messy function partly because we are doing UTF8 > u16 > UTF8 conversions on the go to more easily handle stb_textedit calls. Ideally we should stay in UTF-8 all the time. See https://github.com/nothings/stb/issues/188\r\nbool ImGui::InputTextEx(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackHistory) && (flags & ImGuiInputTextFlags_Multiline))); // Can't use both together (they both use up/down keys)\r\n    IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackCompletion) && (flags & ImGuiInputTextFlags_AllowTabInput))); // Can't use both together (they both use tab key)\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiIO& io = g.IO;\r\n    const ImGuiStyle& style = g.Style;\r\n\r\n    const bool is_multiline = (flags & ImGuiInputTextFlags_Multiline) != 0;\r\n    const bool is_editable = (flags & ImGuiInputTextFlags_ReadOnly) == 0;\r\n    const bool is_password = (flags & ImGuiInputTextFlags_Password) != 0;\r\n    const bool is_undoable = (flags & ImGuiInputTextFlags_NoUndoRedo) == 0;\r\n\r\n    if (is_multiline) // Open group before calling GetID() because groups tracks id created during their spawn\r\n        BeginGroup();\r\n    const ImGuiID id = window->GetID(label);\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n    ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), (is_multiline ? GetTextLineHeight() * 8.0f : label_size.y) + style.FramePadding.y*2.0f); // Arbitrary default of 8 lines high for multi-line\r\n    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);\r\n    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? (style.ItemInnerSpacing.x + label_size.x) : 0.0f, 0.0f));\r\n\r\n    ImGuiWindow* draw_window = window;\r\n    if (is_multiline)\r\n    {\r\n        if (!BeginChildFrame(id, frame_bb.GetSize()))\r\n        {\r\n            EndChildFrame();\r\n            EndGroup();\r\n            return false;\r\n        }\r\n        draw_window = GetCurrentWindow();\r\n        size.x -= draw_window->ScrollbarSizes.x;\r\n    }\r\n    else\r\n    {\r\n        ItemSize(total_bb, style.FramePadding.y);\r\n        if (!ItemAdd(total_bb, id))\r\n            return false;\r\n    }\r\n    const bool hovered = ItemHoverable(frame_bb, id);\r\n    if (hovered)\r\n        g.MouseCursor = ImGuiMouseCursor_TextInput;\r\n\r\n    // Password pushes a temporary font with only a fallback glyph\r\n    if (is_password)\r\n    {\r\n        const ImFontGlyph* glyph = g.Font->FindGlyph('*');\r\n        ImFont* password_font = &g.InputTextPasswordFont;\r\n        password_font->FontSize = g.Font->FontSize;\r\n        password_font->Scale = g.Font->Scale;\r\n        password_font->DisplayOffset = g.Font->DisplayOffset;\r\n        password_font->Ascent = g.Font->Ascent;\r\n        password_font->Descent = g.Font->Descent;\r\n        password_font->ContainerAtlas = g.Font->ContainerAtlas;\r\n        password_font->FallbackGlyph = glyph;\r\n        password_font->FallbackAdvanceX = glyph->AdvanceX;\r\n        IM_ASSERT(password_font->Glyphs.empty() && password_font->IndexAdvanceX.empty() && password_font->IndexLookup.empty());\r\n        PushFont(password_font);\r\n    }\r\n\r\n    // NB: we are only allowed to access 'edit_state' if we are the active widget.\r\n    ImGuiTextEditState& edit_state = g.InputTextState;\r\n\r\n    const bool focus_requested = FocusableItemRegister(window, id, (flags & (ImGuiInputTextFlags_CallbackCompletion|ImGuiInputTextFlags_AllowTabInput)) == 0);    // Using completion callback disable keyboard tabbing\r\n    const bool focus_requested_by_code = focus_requested && (window->FocusIdxAllCounter == window->FocusIdxAllRequestCurrent);\r\n    const bool focus_requested_by_tab = focus_requested && !focus_requested_by_code;\r\n\r\n    const bool user_clicked = hovered && io.MouseClicked[0];\r\n    const bool user_scrolled = is_multiline && g.ActiveId == 0 && edit_state.Id == id && g.ActiveIdPreviousFrame == draw_window->GetIDNoKeepAlive(\"#SCROLLY\");\r\n\r\n    bool clear_active_id = false;\r\n\r\n    bool select_all = (g.ActiveId != id) && (flags & ImGuiInputTextFlags_AutoSelectAll) != 0;\r\n    if (focus_requested || user_clicked || user_scrolled)\r\n    {\r\n        if (g.ActiveId != id)\r\n        {\r\n            // Start edition\r\n            // Take a copy of the initial buffer value (both in original UTF-8 format and converted to wchar)\r\n            // From the moment we focused we are ignoring the content of 'buf' (unless we are in read-only mode)\r\n            const int prev_len_w = edit_state.CurLenW;\r\n            edit_state.Text.resize(buf_size+1);        // wchar count <= UTF-8 count. we use +1 to make sure that .Data isn't NULL so it doesn't crash.\r\n            edit_state.InitialText.resize(buf_size+1); // UTF-8. we use +1 to make sure that .Data isn't NULL so it doesn't crash.\r\n            ImStrncpy(edit_state.InitialText.Data, buf, edit_state.InitialText.Size);\r\n            const char* buf_end = NULL;\r\n            edit_state.CurLenW = ImTextStrFromUtf8(edit_state.Text.Data, edit_state.Text.Size, buf, NULL, &buf_end);\r\n            edit_state.CurLenA = (int)(buf_end - buf); // We can't get the result from ImFormatString() above because it is not UTF-8 aware. Here we'll cut off malformed UTF-8.\r\n            edit_state.CursorAnimReset();\r\n\r\n            // Preserve cursor position and undo/redo stack if we come back to same widget\r\n            // FIXME: We should probably compare the whole buffer to be on the safety side. Comparing buf (utf8) and edit_state.Text (wchar).\r\n            const bool recycle_state = (edit_state.Id == id) && (prev_len_w == edit_state.CurLenW);\r\n            if (recycle_state)\r\n            {\r\n                // Recycle existing cursor/selection/undo stack but clamp position\r\n                // Note a single mouse click will override the cursor/position immediately by calling stb_textedit_click handler.\r\n                edit_state.CursorClamp();\r\n            }\r\n            else\r\n            {\r\n                edit_state.Id = id;\r\n                edit_state.ScrollX = 0.0f;\r\n                stb_textedit_initialize_state(&edit_state.StbState, !is_multiline);\r\n                if (!is_multiline && focus_requested_by_code)\r\n                    select_all = true;\r\n            }\r\n            if (flags & ImGuiInputTextFlags_AlwaysInsertMode)\r\n                edit_state.StbState.insert_mode = true;\r\n            if (!is_multiline && (focus_requested_by_tab || (user_clicked && io.KeyCtrl)))\r\n                select_all = true;\r\n        }\r\n        SetActiveID(id, window);\r\n        FocusWindow(window);\r\n    }\r\n    else if (io.MouseClicked[0])\r\n    {\r\n        // Release focus when we click outside\r\n        clear_active_id = true;\r\n    }\r\n\r\n    bool value_changed = false;\r\n    bool enter_pressed = false;\r\n\r\n    if (g.ActiveId == id)\r\n    {\r\n        if (!is_editable && !g.ActiveIdIsJustActivated)\r\n        {\r\n            // When read-only we always use the live data passed to the function\r\n            edit_state.Text.resize(buf_size+1);\r\n            const char* buf_end = NULL;\r\n            edit_state.CurLenW = ImTextStrFromUtf8(edit_state.Text.Data, edit_state.Text.Size, buf, NULL, &buf_end);\r\n            edit_state.CurLenA = (int)(buf_end - buf);\r\n            edit_state.CursorClamp();\r\n        }\r\n\r\n        edit_state.BufSizeA = buf_size;\r\n\r\n        // Although we are active we don't prevent mouse from hovering other elements unless we are interacting right now with the widget.\r\n        // Down the line we should have a cleaner library-wide concept of Selected vs Active.\r\n        g.ActiveIdAllowOverlap = !io.MouseDown[0];\r\n        g.WantTextInputNextFrame = 1;\r\n\r\n        // Edit in progress\r\n        const float mouse_x = (io.MousePos.x - frame_bb.Min.x - style.FramePadding.x) + edit_state.ScrollX;\r\n        const float mouse_y = (is_multiline ? (io.MousePos.y - draw_window->DC.CursorPos.y - style.FramePadding.y) : (g.FontSize*0.5f));\r\n\r\n        const bool osx_double_click_selects_words = io.OptMacOSXBehaviors;      // OS X style: Double click selects by word instead of selecting whole text\r\n        if (select_all || (hovered && !osx_double_click_selects_words && io.MouseDoubleClicked[0]))\r\n        {\r\n            edit_state.SelectAll();\r\n            edit_state.SelectedAllMouseLock = true;\r\n        }\r\n        else if (hovered && osx_double_click_selects_words && io.MouseDoubleClicked[0])\r\n        {\r\n            // Select a word only, OS X style (by simulating keystrokes)\r\n            edit_state.OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT);\r\n            edit_state.OnKeyPressed(STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT);\r\n        }\r\n        else if (io.MouseClicked[0] && !edit_state.SelectedAllMouseLock)\r\n        {\r\n            stb_textedit_click(&edit_state, &edit_state.StbState, mouse_x, mouse_y);\r\n            edit_state.CursorAnimReset();\r\n        }\r\n        else if (io.MouseDown[0] && !edit_state.SelectedAllMouseLock && (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f))\r\n        {\r\n            stb_textedit_drag(&edit_state, &edit_state.StbState, mouse_x, mouse_y);\r\n            edit_state.CursorAnimReset();\r\n            edit_state.CursorFollow = true;\r\n        }\r\n        if (edit_state.SelectedAllMouseLock && !io.MouseDown[0])\r\n            edit_state.SelectedAllMouseLock = false;\r\n\r\n        if (io.InputCharacters[0])\r\n        {\r\n            // Process text input (before we check for Return because using some IME will effectively send a Return?)\r\n            // We ignore CTRL inputs, but need to allow CTRL+ALT as some keyboards (e.g. German) use AltGR - which is Alt+Ctrl - to input certain characters.\r\n            if (!(io.KeyCtrl && !io.KeyAlt) && is_editable)\r\n            {\r\n                for (int n = 0; n < IM_ARRAYSIZE(io.InputCharacters) && io.InputCharacters[n]; n++)\r\n                    if (unsigned int c = (unsigned int)io.InputCharacters[n])\r\n                    {\r\n                        // Insert character if they pass filtering\r\n                        if (!InputTextFilterCharacter(&c, flags, callback, user_data))\r\n                            continue;\r\n                        edit_state.OnKeyPressed((int)c);\r\n                    }\r\n            }\r\n\r\n            // Consume characters\r\n            memset(g.IO.InputCharacters, 0, sizeof(g.IO.InputCharacters));\r\n        }\r\n    }\r\n\r\n    bool cancel_edit = false;\r\n    if (g.ActiveId == id && !g.ActiveIdIsJustActivated && !clear_active_id)\r\n    {\r\n        // Handle key-presses\r\n        const int k_mask = (io.KeyShift ? STB_TEXTEDIT_K_SHIFT : 0);\r\n        const bool is_shortcut_key_only = (io.OptMacOSXBehaviors ? (io.KeySuper && !io.KeyCtrl) : (io.KeyCtrl && !io.KeySuper)) && !io.KeyAlt && !io.KeyShift; // OS X style: Shortcuts using Cmd/Super instead of Ctrl\r\n        const bool is_wordmove_key_down = io.OptMacOSXBehaviors ? io.KeyAlt : io.KeyCtrl;                     // OS X style: Text editing cursor movement using Alt instead of Ctrl\r\n        const bool is_startend_key_down = io.OptMacOSXBehaviors && io.KeySuper && !io.KeyCtrl && !io.KeyAlt;  // OS X style: Line/Text Start and End using Cmd+Arrows instead of Home/End\r\n\r\n        if (IsKeyPressedMap(ImGuiKey_LeftArrow))                        { edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINESTART : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDLEFT : STB_TEXTEDIT_K_LEFT) | k_mask); }\r\n        else if (IsKeyPressedMap(ImGuiKey_RightArrow))                  { edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINEEND : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDRIGHT : STB_TEXTEDIT_K_RIGHT) | k_mask); }\r\n        else if (IsKeyPressedMap(ImGuiKey_UpArrow) && is_multiline)     { if (io.KeyCtrl) SetWindowScrollY(draw_window, ImMax(draw_window->Scroll.y - g.FontSize, 0.0f)); else edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTSTART : STB_TEXTEDIT_K_UP) | k_mask); }\r\n        else if (IsKeyPressedMap(ImGuiKey_DownArrow) && is_multiline)   { if (io.KeyCtrl) SetWindowScrollY(draw_window, ImMin(draw_window->Scroll.y + g.FontSize, GetScrollMaxY())); else edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTEND : STB_TEXTEDIT_K_DOWN) | k_mask); }\r\n        else if (IsKeyPressedMap(ImGuiKey_Home))                        { edit_state.OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTSTART | k_mask : STB_TEXTEDIT_K_LINESTART | k_mask); }\r\n        else if (IsKeyPressedMap(ImGuiKey_End))                         { edit_state.OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTEND | k_mask : STB_TEXTEDIT_K_LINEEND | k_mask); }\r\n        else if (IsKeyPressedMap(ImGuiKey_Delete) && is_editable)       { edit_state.OnKeyPressed(STB_TEXTEDIT_K_DELETE | k_mask); }\r\n        else if (IsKeyPressedMap(ImGuiKey_Backspace) && is_editable)\r\n        {\r\n            if (!edit_state.HasSelection())\r\n            {\r\n                if (is_wordmove_key_down) edit_state.OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT|STB_TEXTEDIT_K_SHIFT);\r\n                else if (io.OptMacOSXBehaviors && io.KeySuper && !io.KeyAlt && !io.KeyCtrl) edit_state.OnKeyPressed(STB_TEXTEDIT_K_LINESTART|STB_TEXTEDIT_K_SHIFT);\r\n            }\r\n            edit_state.OnKeyPressed(STB_TEXTEDIT_K_BACKSPACE | k_mask);\r\n        }\r\n        else if (IsKeyPressedMap(ImGuiKey_Enter))\r\n        {\r\n            bool ctrl_enter_for_new_line = (flags & ImGuiInputTextFlags_CtrlEnterForNewLine) != 0;\r\n            if (!is_multiline || (ctrl_enter_for_new_line && !io.KeyCtrl) || (!ctrl_enter_for_new_line && io.KeyCtrl))\r\n            {\r\n                enter_pressed = clear_active_id = true;\r\n            }\r\n            else if (is_editable)\r\n            {\r\n                unsigned int c = '\\n'; // Insert new line\r\n                if (InputTextFilterCharacter(&c, flags, callback, user_data))\r\n                    edit_state.OnKeyPressed((int)c);\r\n            }\r\n        }\r\n        else if ((flags & ImGuiInputTextFlags_AllowTabInput) && IsKeyPressedMap(ImGuiKey_Tab) && !io.KeyCtrl && !io.KeyShift && !io.KeyAlt && is_editable)\r\n        {\r\n            unsigned int c = '\\t'; // Insert TAB\r\n            if (InputTextFilterCharacter(&c, flags, callback, user_data))\r\n                edit_state.OnKeyPressed((int)c);\r\n        }\r\n        else if (IsKeyPressedMap(ImGuiKey_Escape))                                                       { clear_active_id = cancel_edit = true; }\r\n        else if (is_shortcut_key_only && IsKeyPressedMap(ImGuiKey_Z) && is_editable && is_undoable)      { edit_state.OnKeyPressed(STB_TEXTEDIT_K_UNDO); edit_state.ClearSelection(); }\r\n        else if (is_shortcut_key_only && IsKeyPressedMap(ImGuiKey_Y) && is_editable && is_undoable)      { edit_state.OnKeyPressed(STB_TEXTEDIT_K_REDO); edit_state.ClearSelection(); }\r\n        else if (is_shortcut_key_only && IsKeyPressedMap(ImGuiKey_A))                                    { edit_state.SelectAll(); edit_state.CursorFollow = true; }\r\n        else if (is_shortcut_key_only && !is_password && ((IsKeyPressedMap(ImGuiKey_X) && is_editable) || IsKeyPressedMap(ImGuiKey_C)) && (!is_multiline || edit_state.HasSelection()))\r\n        {\r\n            // Cut, Copy\r\n            const bool cut = IsKeyPressedMap(ImGuiKey_X);\r\n            if (cut && !edit_state.HasSelection())\r\n                edit_state.SelectAll();\r\n\r\n            if (io.SetClipboardTextFn)\r\n            {\r\n                const int ib = edit_state.HasSelection() ? ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end) : 0;\r\n                const int ie = edit_state.HasSelection() ? ImMax(edit_state.StbState.select_start, edit_state.StbState.select_end) : edit_state.CurLenW;\r\n                edit_state.TempTextBuffer.resize((ie-ib) * 4 + 1);\r\n                ImTextStrToUtf8(edit_state.TempTextBuffer.Data, edit_state.TempTextBuffer.Size, edit_state.Text.Data+ib, edit_state.Text.Data+ie);\r\n                SetClipboardText(edit_state.TempTextBuffer.Data);\r\n            }\r\n\r\n            if (cut)\r\n            {\r\n                edit_state.CursorFollow = true;\r\n                stb_textedit_cut(&edit_state, &edit_state.StbState);\r\n            }\r\n        }\r\n        else if (is_shortcut_key_only && IsKeyPressedMap(ImGuiKey_V) && is_editable)\r\n        {\r\n            // Paste\r\n            if (const char* clipboard = GetClipboardText())\r\n            {\r\n                // Filter pasted buffer\r\n                const int clipboard_len = (int)strlen(clipboard);\r\n                ImWchar* clipboard_filtered = (ImWchar*)ImGui::MemAlloc((clipboard_len+1) * sizeof(ImWchar));\r\n                int clipboard_filtered_len = 0;\r\n                for (const char* s = clipboard; *s; )\r\n                {\r\n                    unsigned int c;\r\n                    s += ImTextCharFromUtf8(&c, s, NULL);\r\n                    if (c == 0)\r\n                        break;\r\n                    if (c >= 0x10000 || !InputTextFilterCharacter(&c, flags, callback, user_data))\r\n                        continue;\r\n                    clipboard_filtered[clipboard_filtered_len++] = (ImWchar)c;\r\n                }\r\n                clipboard_filtered[clipboard_filtered_len] = 0;\r\n                if (clipboard_filtered_len > 0) // If everything was filtered, ignore the pasting operation\r\n                {\r\n                    stb_textedit_paste(&edit_state, &edit_state.StbState, clipboard_filtered, clipboard_filtered_len);\r\n                    edit_state.CursorFollow = true;\r\n                }\r\n                ImGui::MemFree(clipboard_filtered);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (g.ActiveId == id)\r\n    {\r\n        if (cancel_edit)\r\n        {\r\n            // Restore initial value\r\n            if (is_editable)\r\n            {\r\n                ImStrncpy(buf, edit_state.InitialText.Data, buf_size);\r\n                value_changed = true;\r\n            }\r\n        }\r\n\r\n        // When using 'ImGuiInputTextFlags_EnterReturnsTrue' as a special case we reapply the live buffer back to the input buffer before clearing ActiveId, even though strictly speaking it wasn't modified on this frame.\r\n        // If we didn't do that, code like InputInt() with ImGuiInputTextFlags_EnterReturnsTrue would fail. Also this allows the user to use InputText() with ImGuiInputTextFlags_EnterReturnsTrue without maintaining any user-side storage.\r\n        bool apply_edit_back_to_user_buffer = !cancel_edit || (enter_pressed && (flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0);\r\n        if (apply_edit_back_to_user_buffer)\r\n        {\r\n            // Apply new value immediately - copy modified buffer back\r\n            // Note that as soon as the input box is active, the in-widget value gets priority over any underlying modification of the input buffer\r\n            // FIXME: We actually always render 'buf' when calling DrawList->AddText, making the comment above incorrect.\r\n            // FIXME-OPT: CPU waste to do this every time the widget is active, should mark dirty state from the stb_textedit callbacks.\r\n            if (is_editable)\r\n            {\r\n                edit_state.TempTextBuffer.resize(edit_state.Text.Size * 4);\r\n                ImTextStrToUtf8(edit_state.TempTextBuffer.Data, edit_state.TempTextBuffer.Size, edit_state.Text.Data, NULL);\r\n            }\r\n\r\n            // User callback\r\n            if ((flags & (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_CallbackHistory | ImGuiInputTextFlags_CallbackAlways)) != 0)\r\n            {\r\n                IM_ASSERT(callback != NULL);\r\n\r\n                // The reason we specify the usage semantic (Completion/History) is that Completion needs to disable keyboard TABBING at the moment.\r\n                ImGuiInputTextFlags event_flag = 0;\r\n                ImGuiKey event_key = ImGuiKey_COUNT;\r\n                if ((flags & ImGuiInputTextFlags_CallbackCompletion) != 0 && IsKeyPressedMap(ImGuiKey_Tab))\r\n                {\r\n                    event_flag = ImGuiInputTextFlags_CallbackCompletion;\r\n                    event_key = ImGuiKey_Tab;\r\n                }\r\n                else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressedMap(ImGuiKey_UpArrow))\r\n                {\r\n                    event_flag = ImGuiInputTextFlags_CallbackHistory;\r\n                    event_key = ImGuiKey_UpArrow;\r\n                }\r\n                else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressedMap(ImGuiKey_DownArrow))\r\n                {\r\n                    event_flag = ImGuiInputTextFlags_CallbackHistory;\r\n                    event_key = ImGuiKey_DownArrow;\r\n                }\r\n                else if (flags & ImGuiInputTextFlags_CallbackAlways)\r\n                    event_flag = ImGuiInputTextFlags_CallbackAlways;\r\n\r\n                if (event_flag)\r\n                {\r\n                    ImGuiTextEditCallbackData callback_data;\r\n                    memset(&callback_data, 0, sizeof(ImGuiTextEditCallbackData));\r\n                    callback_data.EventFlag = event_flag;\r\n                    callback_data.Flags = flags;\r\n                    callback_data.UserData = user_data;\r\n                    callback_data.ReadOnly = !is_editable;\r\n\r\n                    callback_data.EventKey = event_key;\r\n                    callback_data.Buf = edit_state.TempTextBuffer.Data;\r\n                    callback_data.BufTextLen = edit_state.CurLenA;\r\n                    callback_data.BufSize = edit_state.BufSizeA;\r\n                    callback_data.BufDirty = false;\r\n\r\n                    // We have to convert from wchar-positions to UTF-8-positions, which can be pretty slow (an incentive to ditch the ImWchar buffer, see https://github.com/nothings/stb/issues/188)\r\n                    ImWchar* text = edit_state.Text.Data;\r\n                    const int utf8_cursor_pos = callback_data.CursorPos = ImTextCountUtf8BytesFromStr(text, text + edit_state.StbState.cursor);\r\n                    const int utf8_selection_start = callback_data.SelectionStart = ImTextCountUtf8BytesFromStr(text, text + edit_state.StbState.select_start);\r\n                    const int utf8_selection_end = callback_data.SelectionEnd = ImTextCountUtf8BytesFromStr(text, text + edit_state.StbState.select_end);\r\n\r\n                    // Call user code\r\n                    callback(&callback_data);\r\n\r\n                    // Read back what user may have modified\r\n                    IM_ASSERT(callback_data.Buf == edit_state.TempTextBuffer.Data);  // Invalid to modify those fields\r\n                    IM_ASSERT(callback_data.BufSize == edit_state.BufSizeA);\r\n                    IM_ASSERT(callback_data.Flags == flags);\r\n                    if (callback_data.CursorPos != utf8_cursor_pos)            edit_state.StbState.cursor = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.CursorPos);\r\n                    if (callback_data.SelectionStart != utf8_selection_start)  edit_state.StbState.select_start = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionStart);\r\n                    if (callback_data.SelectionEnd != utf8_selection_end)      edit_state.StbState.select_end = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionEnd);\r\n                    if (callback_data.BufDirty)\r\n                    {\r\n                        IM_ASSERT(callback_data.BufTextLen == (int)strlen(callback_data.Buf)); // You need to maintain BufTextLen if you change the text!\r\n                        edit_state.CurLenW = ImTextStrFromUtf8(edit_state.Text.Data, edit_state.Text.Size, callback_data.Buf, NULL);\r\n                        edit_state.CurLenA = callback_data.BufTextLen;  // Assume correct length and valid UTF-8 from user, saves us an extra strlen()\r\n                        edit_state.CursorAnimReset();\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Copy back to user buffer\r\n            if (is_editable && strcmp(edit_state.TempTextBuffer.Data, buf) != 0)\r\n            {\r\n                ImStrncpy(buf, edit_state.TempTextBuffer.Data, buf_size);\r\n                value_changed = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Release active ID at the end of the function (so e.g. pressing Return still does a final application of the value)\r\n    if (clear_active_id && g.ActiveId == id)\r\n        ClearActiveID();\r\n\r\n    // Render\r\n    // Select which buffer we are going to display. When ImGuiInputTextFlags_NoLiveEdit is set 'buf' might still be the old value. We set buf to NULL to prevent accidental usage from now on.\r\n    const char* buf_display = (g.ActiveId == id && is_editable) ? edit_state.TempTextBuffer.Data : buf; buf = NULL; \r\n\r\n    if (!is_multiline)\r\n        RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);\r\n\r\n    const ImVec4 clip_rect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + size.x, frame_bb.Min.y + size.y); // Not using frame_bb.Max because we have adjusted size\r\n    ImVec2 render_pos = is_multiline ? draw_window->DC.CursorPos : frame_bb.Min + style.FramePadding;\r\n    ImVec2 text_size(0.f, 0.f);\r\n    const bool is_currently_scrolling = (edit_state.Id == id && is_multiline && g.ActiveId == draw_window->GetIDNoKeepAlive(\"#SCROLLY\"));\r\n    if (g.ActiveId == id || is_currently_scrolling)\r\n    {\r\n        edit_state.CursorAnim += io.DeltaTime;\r\n\r\n        // This is going to be messy. We need to:\r\n        // - Display the text (this alone can be more easily clipped)\r\n        // - Handle scrolling, highlight selection, display cursor (those all requires some form of 1d->2d cursor position calculation)\r\n        // - Measure text height (for scrollbar)\r\n        // We are attempting to do most of that in **one main pass** to minimize the computation cost (non-negligible for large amount of text) + 2nd pass for selection rendering (we could merge them by an extra refactoring effort)\r\n        // FIXME: This should occur on buf_display but we'd need to maintain cursor/select_start/select_end for UTF-8.\r\n        const ImWchar* text_begin = edit_state.Text.Data;\r\n        ImVec2 cursor_offset, select_start_offset;\r\n\r\n        {\r\n            // Count lines + find lines numbers straddling 'cursor' and 'select_start' position.\r\n            const ImWchar* searches_input_ptr[2];\r\n            searches_input_ptr[0] = text_begin + edit_state.StbState.cursor;\r\n            searches_input_ptr[1] = NULL;\r\n            int searches_remaining = 1;\r\n            int searches_result_line_number[2] = { -1, -999 };\r\n            if (edit_state.StbState.select_start != edit_state.StbState.select_end)\r\n            {\r\n                searches_input_ptr[1] = text_begin + ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end);\r\n                searches_result_line_number[1] = -1;\r\n                searches_remaining++;\r\n            }\r\n\r\n            // Iterate all lines to find our line numbers\r\n            // In multi-line mode, we never exit the loop until all lines are counted, so add one extra to the searches_remaining counter.\r\n            searches_remaining += is_multiline ? 1 : 0;\r\n            int line_count = 0;\r\n            for (const ImWchar* s = text_begin; *s != 0; s++)\r\n                if (*s == '\\n')\r\n                {\r\n                    line_count++;\r\n                    if (searches_result_line_number[0] == -1 && s >= searches_input_ptr[0]) { searches_result_line_number[0] = line_count; if (--searches_remaining <= 0) break; }\r\n                    if (searches_result_line_number[1] == -1 && s >= searches_input_ptr[1]) { searches_result_line_number[1] = line_count; if (--searches_remaining <= 0) break; }\r\n                }\r\n            line_count++;\r\n            if (searches_result_line_number[0] == -1) searches_result_line_number[0] = line_count;\r\n            if (searches_result_line_number[1] == -1) searches_result_line_number[1] = line_count;\r\n\r\n            // Calculate 2d position by finding the beginning of the line and measuring distance\r\n            cursor_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[0], text_begin), searches_input_ptr[0]).x;\r\n            cursor_offset.y = searches_result_line_number[0] * g.FontSize;\r\n            if (searches_result_line_number[1] >= 0)\r\n            {\r\n                select_start_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[1], text_begin), searches_input_ptr[1]).x;\r\n                select_start_offset.y = searches_result_line_number[1] * g.FontSize;\r\n            }\r\n\r\n            // Store text height (note that we haven't calculated text width at all, see GitHub issues #383, #1224)\r\n            if (is_multiline)\r\n                text_size = ImVec2(size.x, line_count * g.FontSize);\r\n        }\r\n\r\n        // Scroll\r\n        if (edit_state.CursorFollow)\r\n        {\r\n            // Horizontal scroll in chunks of quarter width\r\n            if (!(flags & ImGuiInputTextFlags_NoHorizontalScroll))\r\n            {\r\n                const float scroll_increment_x = size.x * 0.25f;\r\n                if (cursor_offset.x < edit_state.ScrollX)\r\n                    edit_state.ScrollX = (float)(int)ImMax(0.0f, cursor_offset.x - scroll_increment_x);\r\n                else if (cursor_offset.x - size.x >= edit_state.ScrollX)\r\n                    edit_state.ScrollX = (float)(int)(cursor_offset.x - size.x + scroll_increment_x);\r\n            }\r\n            else\r\n            {\r\n                edit_state.ScrollX = 0.0f;\r\n            }\r\n\r\n            // Vertical scroll\r\n            if (is_multiline)\r\n            {\r\n                float scroll_y = draw_window->Scroll.y;\r\n                if (cursor_offset.y - g.FontSize < scroll_y)\r\n                    scroll_y = ImMax(0.0f, cursor_offset.y - g.FontSize);\r\n                else if (cursor_offset.y - size.y >= scroll_y)\r\n                    scroll_y = cursor_offset.y - size.y;\r\n                draw_window->DC.CursorPos.y += (draw_window->Scroll.y - scroll_y);   // To avoid a frame of lag\r\n                draw_window->Scroll.y = scroll_y;\r\n                render_pos.y = draw_window->DC.CursorPos.y;\r\n            }\r\n        }\r\n        edit_state.CursorFollow = false;\r\n        const ImVec2 render_scroll = ImVec2(edit_state.ScrollX, 0.0f);\r\n\r\n        // Draw selection\r\n        if (edit_state.StbState.select_start != edit_state.StbState.select_end)\r\n        {\r\n            const ImWchar* text_selected_begin = text_begin + ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end);\r\n            const ImWchar* text_selected_end = text_begin + ImMax(edit_state.StbState.select_start, edit_state.StbState.select_end);\r\n\r\n            float bg_offy_up = is_multiline ? 0.0f : -1.0f;    // FIXME: those offsets should be part of the style? they don't play so well with multi-line selection.\r\n            float bg_offy_dn = is_multiline ? 0.0f : 2.0f;\r\n            ImU32 bg_color = GetColorU32(ImGuiCol_TextSelectedBg);\r\n            ImVec2 rect_pos = render_pos + select_start_offset - render_scroll;\r\n            for (const ImWchar* p = text_selected_begin; p < text_selected_end; )\r\n            {\r\n                if (rect_pos.y > clip_rect.w + g.FontSize)\r\n                    break;\r\n                if (rect_pos.y < clip_rect.y)\r\n                {\r\n                    while (p < text_selected_end)\r\n                        if (*p++ == '\\n')\r\n                            break;\r\n                }\r\n                else\r\n                {\r\n                    ImVec2 rect_size = InputTextCalcTextSizeW(p, text_selected_end, &p, NULL, true);\r\n                    if (rect_size.x <= 0.0f) rect_size.x = (float)(int)(g.Font->GetCharAdvance((unsigned short)' ') * 0.50f); // So we can see selected empty lines\r\n                    ImRect rect(rect_pos + ImVec2(0.0f, bg_offy_up - g.FontSize), rect_pos +ImVec2(rect_size.x, bg_offy_dn));\r\n                    rect.ClipWith(clip_rect);\r\n                    if (rect.Overlaps(clip_rect))\r\n                        draw_window->DrawList->AddRectFilled(rect.Min, rect.Max, bg_color);\r\n                }\r\n                rect_pos.x = render_pos.x - render_scroll.x;\r\n                rect_pos.y += g.FontSize;\r\n            }\r\n        }\r\n\r\n        draw_window->DrawList->AddText(g.Font, g.FontSize, render_pos - render_scroll, GetColorU32(ImGuiCol_Text), buf_display, buf_display + edit_state.CurLenA, 0.0f, is_multiline ? NULL : &clip_rect);\r\n\r\n        // Draw blinking cursor\r\n        bool cursor_is_visible = (!g.IO.OptCursorBlink) || (g.InputTextState.CursorAnim <= 0.0f) || fmodf(g.InputTextState.CursorAnim, 1.20f) <= 0.80f;\r\n        ImVec2 cursor_screen_pos = render_pos + cursor_offset - render_scroll;\r\n        ImRect cursor_screen_rect(cursor_screen_pos.x, cursor_screen_pos.y-g.FontSize+0.5f, cursor_screen_pos.x+1.0f, cursor_screen_pos.y-1.5f);\r\n        if (cursor_is_visible && cursor_screen_rect.Overlaps(clip_rect))\r\n            draw_window->DrawList->AddLine(cursor_screen_rect.Min, cursor_screen_rect.GetBL(), GetColorU32(ImGuiCol_Text));\r\n\r\n        // Notify OS of text input position for advanced IME (-1 x offset so that Windows IME can cover our cursor. Bit of an extra nicety.)\r\n        if (is_editable)\r\n            g.OsImePosRequest = ImVec2(cursor_screen_pos.x - 1, cursor_screen_pos.y - g.FontSize);\r\n    }\r\n    else\r\n    {\r\n        // Render text only\r\n        const char* buf_end = NULL;\r\n        if (is_multiline)\r\n            text_size = ImVec2(size.x, InputTextCalcTextLenAndLineCount(buf_display, &buf_end) * g.FontSize); // We don't need width\r\n        draw_window->DrawList->AddText(g.Font, g.FontSize, render_pos, GetColorU32(ImGuiCol_Text), buf_display, buf_end, 0.0f, is_multiline ? NULL : &clip_rect);\r\n    }\r\n\r\n    if (is_multiline)\r\n    {\r\n        Dummy(text_size + ImVec2(0.0f, g.FontSize)); // Always add room to scroll an extra line\r\n        EndChildFrame();\r\n        EndGroup();\r\n    }\r\n\r\n    if (is_password)\r\n        PopFont();\r\n\r\n    // Log as text\r\n    if (g.LogEnabled && !is_password)\r\n        LogRenderedText(&render_pos, buf_display, NULL);\r\n\r\n    if (label_size.x > 0)\r\n        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);\r\n\r\n    if ((flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0)\r\n        return enter_pressed;\r\n    else\r\n        return value_changed;\r\n}\r\n\r\nbool ImGui::InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)\r\n{\r\n    IM_ASSERT(!(flags & ImGuiInputTextFlags_Multiline)); // call InputTextMultiline()\r\n    return InputTextEx(label, buf, (int)buf_size, ImVec2(0,0), flags, callback, user_data);\r\n}\r\n\r\nbool ImGui::InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)\r\n{\r\n    return InputTextEx(label, buf, (int)buf_size, size, flags | ImGuiInputTextFlags_Multiline, callback, user_data);\r\n}\r\n\r\n// NB: scalar_format here must be a simple \"%xx\" format string with no prefix/suffix (unlike the Drag/Slider functions \"display_format\" argument)\r\nbool ImGui::InputScalarEx(const char* label, ImGuiDataType data_type, void* data_ptr, void* step_ptr, void* step_fast_ptr, const char* scalar_format, ImGuiInputTextFlags extra_flags)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n\r\n    BeginGroup();\r\n    PushID(label);\r\n    const ImVec2 button_sz = ImVec2(GetFrameHeight(), GetFrameHeight());\r\n    if (step_ptr)\r\n        PushItemWidth(ImMax(1.0f, CalcItemWidth() - (button_sz.x + style.ItemInnerSpacing.x)*2));\r\n\r\n    char buf[64];\r\n    DataTypeFormatString(data_type, data_ptr, scalar_format, buf, IM_ARRAYSIZE(buf));\r\n\r\n    bool value_changed = false;\r\n    if (!(extra_flags & ImGuiInputTextFlags_CharsHexadecimal))\r\n        extra_flags |= ImGuiInputTextFlags_CharsDecimal;\r\n    extra_flags |= ImGuiInputTextFlags_AutoSelectAll;\r\n    if (InputText(\"\", buf, IM_ARRAYSIZE(buf), extra_flags)) // PushId(label) + \"\" gives us the expected ID from outside point of view\r\n        value_changed = DataTypeApplyOpFromText(buf, GImGui->InputTextState.InitialText.begin(), data_type, data_ptr, scalar_format);\r\n\r\n    // Step buttons\r\n    if (step_ptr)\r\n    {\r\n        PopItemWidth();\r\n        SameLine(0, style.ItemInnerSpacing.x);\r\n        if (ButtonEx(\"-\", button_sz, ImGuiButtonFlags_Repeat | ImGuiButtonFlags_DontClosePopups))\r\n        {\r\n            DataTypeApplyOp(data_type, '-', data_ptr, g.IO.KeyCtrl && step_fast_ptr ? step_fast_ptr : step_ptr);\r\n            value_changed = true;\r\n        }\r\n        SameLine(0, style.ItemInnerSpacing.x);\r\n        if (ButtonEx(\"+\", button_sz, ImGuiButtonFlags_Repeat | ImGuiButtonFlags_DontClosePopups))\r\n        {\r\n            DataTypeApplyOp(data_type, '+', data_ptr, g.IO.KeyCtrl && step_fast_ptr ? step_fast_ptr : step_ptr);\r\n            value_changed = true;\r\n        }\r\n    }\r\n    PopID();\r\n\r\n    if (label_size.x > 0)\r\n    {\r\n        SameLine(0, style.ItemInnerSpacing.x);\r\n        RenderText(ImVec2(window->DC.CursorPos.x, window->DC.CursorPos.y + style.FramePadding.y), label);\r\n        ItemSize(label_size, style.FramePadding.y);\r\n    }\r\n    EndGroup();\r\n\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags extra_flags)\r\n{\r\n    char display_format[16];\r\n    if (decimal_precision < 0)\r\n        strcpy(display_format, \"%f\");      // Ideally we'd have a minimum decimal precision of 1 to visually denote that this is a float, while hiding non-significant digits? %f doesn't have a minimum of 1\r\n    else\r\n        ImFormatString(display_format, IM_ARRAYSIZE(display_format), \"%%.%df\", decimal_precision);\r\n    return InputScalarEx(label, ImGuiDataType_Float, (void*)v, (void*)(step>0.0f ? &step : NULL), (void*)(step_fast>0.0f ? &step_fast : NULL), display_format, extra_flags);\r\n}\r\n\r\nbool ImGui::InputInt(const char* label, int* v, int step, int step_fast, ImGuiInputTextFlags extra_flags)\r\n{\r\n    // Hexadecimal input provided as a convenience but the flag name is awkward. Typically you'd use InputText() to parse your own data, if you want to handle prefixes.\r\n    const char* scalar_format = (extra_flags & ImGuiInputTextFlags_CharsHexadecimal) ? \"%08X\" : \"%d\";\r\n    return InputScalarEx(label, ImGuiDataType_Int, (void*)v, (void*)(step>0.0f ? &step : NULL), (void*)(step_fast>0.0f ? &step_fast : NULL), scalar_format, extra_flags);\r\n}\r\n\r\nbool ImGui::InputFloatN(const char* label, float* v, int components, int decimal_precision, ImGuiInputTextFlags extra_flags)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    bool value_changed = false;\r\n    BeginGroup();\r\n    PushID(label);\r\n    PushMultiItemsWidths(components);\r\n    for (int i = 0; i < components; i++)\r\n    {\r\n        PushID(i);\r\n        value_changed |= InputFloat(\"##v\", &v[i], 0, 0, decimal_precision, extra_flags);\r\n        SameLine(0, g.Style.ItemInnerSpacing.x);\r\n        PopID();\r\n        PopItemWidth();\r\n    }\r\n    PopID();\r\n\r\n    TextUnformatted(label, FindRenderedTextEnd(label));\r\n    EndGroup();\r\n\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::InputFloat2(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags extra_flags)\r\n{\r\n    return InputFloatN(label, v, 2, decimal_precision, extra_flags);\r\n}\r\n\r\nbool ImGui::InputFloat3(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags extra_flags)\r\n{\r\n    return InputFloatN(label, v, 3, decimal_precision, extra_flags);\r\n}\r\n\r\nbool ImGui::InputFloat4(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags extra_flags)\r\n{\r\n    return InputFloatN(label, v, 4, decimal_precision, extra_flags);\r\n}\r\n\r\nbool ImGui::InputIntN(const char* label, int* v, int components, ImGuiInputTextFlags extra_flags)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    bool value_changed = false;\r\n    BeginGroup();\r\n    PushID(label);\r\n    PushMultiItemsWidths(components);\r\n    for (int i = 0; i < components; i++)\r\n    {\r\n        PushID(i);\r\n        value_changed |= InputInt(\"##v\", &v[i], 0, 0, extra_flags);\r\n        SameLine(0, g.Style.ItemInnerSpacing.x);\r\n        PopID();\r\n        PopItemWidth();\r\n    }\r\n    PopID();\r\n\r\n    TextUnformatted(label, FindRenderedTextEnd(label));\r\n    EndGroup();\r\n\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags)\r\n{\r\n    return InputIntN(label, v, 2, extra_flags);\r\n}\r\n\r\nbool ImGui::InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags)\r\n{\r\n    return InputIntN(label, v, 3, extra_flags);\r\n}\r\n\r\nbool ImGui::InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags)\r\n{\r\n    return InputIntN(label, v, 4, extra_flags);\r\n}\r\n\r\nstatic float CalcMaxPopupHeightFromItemCount(int items_count)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (items_count <= 0)\r\n        return FLT_MAX;\r\n    return (g.FontSize + g.Style.ItemSpacing.y) * items_count - g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2);\r\n}\r\n\r\nbool ImGui::BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags)\r\n{\r\n    // Always consume the SetNextWindowSizeConstraint() call in our early return paths\r\n    ImGuiContext& g = *GImGui;\r\n    bool backup_has_next_window_size_constraint = g.SetNextWindowSizeConstraint;\r\n    g.SetNextWindowSizeConstraint = false;\r\n        \r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    const ImGuiStyle& style = g.Style;\r\n    const ImGuiID id = window->GetID(label);\r\n    const float w = CalcItemWidth();\r\n\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));\r\n    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));\r\n    ItemSize(total_bb, style.FramePadding.y);\r\n    if (!ItemAdd(total_bb, id))\r\n        return false;\r\n\r\n    bool hovered, held;\r\n    bool pressed = ButtonBehavior(frame_bb, id, &hovered, &held);\r\n    bool popup_open = IsPopupOpen(id);\r\n\r\n    const float arrow_size = GetFrameHeight();\r\n    const ImRect value_bb(frame_bb.Min, frame_bb.Max - ImVec2(arrow_size, 0.0f));\r\n    RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);\r\n    RenderFrame(ImVec2(frame_bb.Max.x-arrow_size, frame_bb.Min.y), frame_bb.Max, GetColorU32(popup_open || hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button), true, style.FrameRounding); // FIXME-ROUNDING\r\n    RenderTriangle(ImVec2(frame_bb.Max.x - arrow_size + style.FramePadding.y, frame_bb.Min.y + style.FramePadding.y), ImGuiDir_Down);\r\n    if (preview_value != NULL)\r\n        RenderTextClipped(frame_bb.Min + style.FramePadding, value_bb.Max, preview_value, NULL, NULL, ImVec2(0.0f,0.0f));\r\n    if (label_size.x > 0)\r\n        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);\r\n\r\n    if (pressed && !popup_open)\r\n    {\r\n        OpenPopupEx(id, false);\r\n        popup_open = true;\r\n    }\r\n\r\n    if (!popup_open)\r\n        return false;\r\n\r\n    if (backup_has_next_window_size_constraint)\r\n    {\r\n        g.SetNextWindowSizeConstraint = true;\r\n        g.SetNextWindowSizeConstraintRect.Min.x = ImMax(g.SetNextWindowSizeConstraintRect.Min.x, w);\r\n    }\r\n    else\r\n    {\r\n        if ((flags & ImGuiComboFlags_HeightMask_) == 0)\r\n            flags |= ImGuiComboFlags_HeightRegular;\r\n        IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiComboFlags_HeightMask_));    // Only one\r\n        int popup_max_height_in_items = -1;\r\n        if (flags & ImGuiComboFlags_HeightRegular)     popup_max_height_in_items = 8;\r\n        else if (flags & ImGuiComboFlags_HeightSmall)  popup_max_height_in_items = 4;\r\n        else if (flags & ImGuiComboFlags_HeightLarge)  popup_max_height_in_items = 20;\r\n        SetNextWindowSizeConstraints(ImVec2(w, 0.0f), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));\r\n    }\r\n\r\n    char name[16];\r\n    ImFormatString(name, IM_ARRAYSIZE(name), \"##Combo_%02d\", g.CurrentPopupStack.Size); // Recycle windows based on depth\r\n\r\n    // Peak into expected window size so we can position it\r\n    if (ImGuiWindow* popup_window = FindWindowByName(name))\r\n    {\r\n        ImVec2 size_contents = CalcSizeContents(popup_window);\r\n        ImVec2 size_expected = CalcSizeAfterConstraint(popup_window, CalcSizeAutoFit(popup_window, size_contents));\r\n        if (flags & ImGuiComboFlags_PopupAlignLeft)\r\n            popup_window->AutoPosLastDirection = ImGuiDir_Left;\r\n        ImVec2 pos = FindBestWindowPosForPopup(frame_bb.GetBL(), size_expected, &popup_window->AutoPosLastDirection, frame_bb, ImGuiPopupPositionPolicy_ComboBox);\r\n        SetNextWindowPos(pos);\r\n    }\r\n\r\n    ImGuiWindowFlags window_flags = ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_Popup | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings;\r\n    if (!Begin(name, NULL, window_flags))\r\n    {\r\n        EndPopup();\r\n        IM_ASSERT(0);   // This should never happen as we tested for IsPopupOpen() above\r\n        return false;\r\n    }\r\n\r\n    // Horizontally align ourselves with the framed text\r\n    if (style.FramePadding.x != style.WindowPadding.x)\r\n        Indent(style.FramePadding.x - style.WindowPadding.x);\r\n\r\n    return true;\r\n}\r\n\r\nvoid ImGui::EndCombo()\r\n{\r\n    const ImGuiStyle& style = GImGui->Style;\r\n    if (style.FramePadding.x != style.WindowPadding.x)\r\n        Unindent(style.FramePadding.x - style.WindowPadding.x);\r\n    EndPopup();\r\n}\r\n\r\n// Old API, prefer using BeginCombo() nowadays if you can.\r\nbool ImGui::Combo(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int popup_max_height_in_items)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    const char* preview_text = NULL;\r\n    if (*current_item >= 0 && *current_item < items_count)\r\n        items_getter(data, *current_item, &preview_text);\r\n\r\n    // The old Combo() API exposed \"popup_max_height_in_items\", however the new more general BeginCombo() API doesn't, so we emulate it here.\r\n    if (popup_max_height_in_items != -1 && !g.SetNextWindowSizeConstraint)\r\n    {\r\n        float popup_max_height = CalcMaxPopupHeightFromItemCount(popup_max_height_in_items);\r\n        SetNextWindowSizeConstraints(ImVec2(0,0), ImVec2(FLT_MAX, popup_max_height));\r\n    }\r\n\r\n    if (!BeginCombo(label, preview_text, 0))\r\n        return false;\r\n\r\n    // Display items\r\n    // FIXME-OPT: Use clipper (but we need to disable it on the appearing frame to make sure our call to SetItemDefaultFocus() is processed)\r\n    bool value_changed = false;\r\n    for (int i = 0; i < items_count; i++)\r\n    {\r\n        PushID((void*)(intptr_t)i);\r\n        const bool item_selected = (i == *current_item);\r\n        const char* item_text;\r\n        if (!items_getter(data, i, &item_text))\r\n            item_text = \"*Unknown item*\";\r\n        if (Selectable(item_text, item_selected))\r\n        {\r\n            value_changed = true;\r\n            *current_item = i;\r\n        }\r\n        if (item_selected)\r\n            SetItemDefaultFocus();\r\n        PopID();\r\n    }\r\n\r\n    EndCombo();\r\n    return value_changed;\r\n}\r\n\r\nstatic bool Items_ArrayGetter(void* data, int idx, const char** out_text)\r\n{\r\n    const char* const* items = (const char* const*)data;\r\n    if (out_text)\r\n        *out_text = items[idx];\r\n    return true;\r\n}\r\n\r\nstatic bool Items_SingleStringGetter(void* data, int idx, const char** out_text)\r\n{\r\n    // FIXME-OPT: we could pre-compute the indices to fasten this. But only 1 active combo means the waste is limited.\r\n    const char* items_separated_by_zeros = (const char*)data;\r\n    int items_count = 0;\r\n    const char* p = items_separated_by_zeros;\r\n    while (*p)\r\n    {\r\n        if (idx == items_count)\r\n            break;\r\n        p += strlen(p) + 1;\r\n        items_count++;\r\n    }\r\n    if (!*p)\r\n        return false;\r\n    if (out_text)\r\n        *out_text = p;\r\n    return true;\r\n}\r\n\r\n// Combo box helper allowing to pass an array of strings.\r\nbool ImGui::Combo(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items)\r\n{\r\n    const bool value_changed = Combo(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_in_items);\r\n    return value_changed;\r\n}\r\n\r\n// Combo box helper allowing to pass all items in a single string.\r\nbool ImGui::Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)\r\n{\r\n    int items_count = 0;\r\n    const char* p = items_separated_by_zeros;       // FIXME-OPT: Avoid computing this, or at least only when combo is open\r\n    while (*p)\r\n    {\r\n        p += strlen(p) + 1;\r\n        items_count++;\r\n    }\r\n    bool value_changed = Combo(label, current_item, Items_SingleStringGetter, (void*)items_separated_by_zeros, items_count, height_in_items);\r\n    return value_changed;\r\n}\r\n\r\n// Tip: pass an empty label (e.g. \"##dummy\") then you can use the space to draw other text or image.\r\n// But you need to make sure the ID is unique, e.g. enclose calls in PushID/PopID.\r\nbool ImGui::Selectable(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n\r\n    if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsSet) // FIXME-OPT: Avoid if vertically clipped.\r\n        PopClipRect();\r\n\r\n    ImGuiID id = window->GetID(label);\r\n    ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n    ImVec2 size(size_arg.x != 0.0f ? size_arg.x : label_size.x, size_arg.y != 0.0f ? size_arg.y : label_size.y);\r\n    ImVec2 pos = window->DC.CursorPos;\r\n    pos.y += window->DC.CurrentLineTextBaseOffset;\r\n    ImRect bb(pos, pos + size);\r\n    ItemSize(bb);\r\n\r\n    // Fill horizontal space.\r\n    ImVec2 window_padding = window->WindowPadding;\r\n    float max_x = (flags & ImGuiSelectableFlags_SpanAllColumns) ? GetWindowContentRegionMax().x : GetContentRegionMax().x;\r\n    float w_draw = ImMax(label_size.x, window->Pos.x + max_x - window_padding.x - window->DC.CursorPos.x);\r\n    ImVec2 size_draw((size_arg.x != 0 && !(flags & ImGuiSelectableFlags_DrawFillAvailWidth)) ? size_arg.x : w_draw, size_arg.y != 0.0f ? size_arg.y : size.y);\r\n    ImRect bb_with_spacing(pos, pos + size_draw);\r\n    if (size_arg.x == 0.0f || (flags & ImGuiSelectableFlags_DrawFillAvailWidth))\r\n        bb_with_spacing.Max.x += window_padding.x;\r\n\r\n    // Selectables are tightly packed together, we extend the box to cover spacing between selectable.\r\n    float spacing_L = (float)(int)(style.ItemSpacing.x * 0.5f);\r\n    float spacing_U = (float)(int)(style.ItemSpacing.y * 0.5f);\r\n    float spacing_R = style.ItemSpacing.x - spacing_L;\r\n    float spacing_D = style.ItemSpacing.y - spacing_U;\r\n    bb_with_spacing.Min.x -= spacing_L;\r\n    bb_with_spacing.Min.y -= spacing_U;\r\n    bb_with_spacing.Max.x += spacing_R;\r\n    bb_with_spacing.Max.y += spacing_D;\r\n    if (!ItemAdd(bb_with_spacing, id))\r\n    {\r\n        if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsSet)\r\n            PushColumnClipRect();\r\n        return false;\r\n    }\r\n\r\n    ImGuiButtonFlags button_flags = 0;\r\n    if (flags & ImGuiSelectableFlags_Menu) button_flags |= ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_NoHoldingActiveID;\r\n    if (flags & ImGuiSelectableFlags_MenuItem) button_flags |= ImGuiButtonFlags_PressedOnRelease;\r\n    if (flags & ImGuiSelectableFlags_Disabled) button_flags |= ImGuiButtonFlags_Disabled;\r\n    if (flags & ImGuiSelectableFlags_AllowDoubleClick) button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick;\r\n    bool hovered, held;\r\n    bool pressed = ButtonBehavior(bb_with_spacing, id, &hovered, &held, button_flags);\r\n    if (flags & ImGuiSelectableFlags_Disabled)\r\n        selected = false;\r\n\r\n    // Render\r\n    if (hovered || selected)\r\n    {\r\n        const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);\r\n        RenderFrame(bb_with_spacing.Min, bb_with_spacing.Max, col, false, 0.0f);\r\n    }\r\n\r\n    if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsSet)\r\n    {\r\n        PushColumnClipRect();\r\n        bb_with_spacing.Max.x -= (GetContentRegionMax().x - max_x);\r\n    }\r\n\r\n    if (flags & ImGuiSelectableFlags_Disabled) PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);\r\n    RenderTextClipped(bb.Min, bb_with_spacing.Max, label, NULL, &label_size, ImVec2(0.0f,0.0f));\r\n    if (flags & ImGuiSelectableFlags_Disabled) PopStyleColor();\r\n\r\n    // Automatically close popups\r\n    if (pressed && (window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiSelectableFlags_DontClosePopups) && !(window->DC.ItemFlags & ImGuiItemFlags_SelectableDontClosePopup))\r\n        CloseCurrentPopup();\r\n    return pressed;\r\n}\r\n\r\nbool ImGui::Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)\r\n{\r\n    if (Selectable(label, *p_selected, flags, size_arg))\r\n    {\r\n        *p_selected = !*p_selected;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n// Helper to calculate the size of a listbox and display a label on the right.\r\n// Tip: To have a list filling the entire window width, PushItemWidth(-1) and pass an empty label \"##empty\"\r\nbool ImGui::ListBoxHeader(const char* label, const ImVec2& size_arg)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    const ImGuiStyle& style = GetStyle();\r\n    const ImGuiID id = GetID(label);\r\n    const ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n\r\n    // Size default to hold ~7 items. Fractional number of items helps seeing that we can scroll down/up without looking at scrollbar.\r\n    ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), GetTextLineHeightWithSpacing() * 7.4f + style.ItemSpacing.y);\r\n    ImVec2 frame_size = ImVec2(size.x, ImMax(size.y, label_size.y));\r\n    ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);\r\n    ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));\r\n    window->DC.LastItemRect = bb;\r\n\r\n    BeginGroup();\r\n    if (label_size.x > 0)\r\n        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);\r\n\r\n    BeginChildFrame(id, frame_bb.GetSize());\r\n    return true;\r\n}\r\n\r\nbool ImGui::ListBoxHeader(const char* label, int items_count, int height_in_items)\r\n{\r\n    // Size default to hold ~7 items. Fractional number of items helps seeing that we can scroll down/up without looking at scrollbar.\r\n    // However we don't add +0.40f if items_count <= height_in_items. It is slightly dodgy, because it means a dynamic list of items will make the widget resize occasionally when it crosses that size.\r\n    // I am expecting that someone will come and complain about this behavior in a remote future, then we can advise on a better solution.\r\n    if (height_in_items < 0)\r\n        height_in_items = ImMin(items_count, 7);\r\n    float height_in_items_f = height_in_items < items_count ? (height_in_items + 0.40f) : (height_in_items + 0.00f);\r\n\r\n    // We include ItemSpacing.y so that a list sized for the exact number of items doesn't make a scrollbar appears. We could also enforce that by passing a flag to BeginChild().\r\n    ImVec2 size;\r\n    size.x = 0.0f;\r\n    size.y = GetTextLineHeightWithSpacing() * height_in_items_f + GetStyle().ItemSpacing.y;\r\n    return ListBoxHeader(label, size);\r\n}\r\n\r\nvoid ImGui::ListBoxFooter()\r\n{\r\n    ImGuiWindow* parent_window = GetCurrentWindow()->ParentWindow;\r\n    const ImRect bb = parent_window->DC.LastItemRect;\r\n    const ImGuiStyle& style = GetStyle();\r\n\r\n    EndChildFrame();\r\n\r\n    // Redeclare item size so that it includes the label (we have stored the full size in LastItemRect)\r\n    // We call SameLine() to restore DC.CurrentLine* data\r\n    SameLine();\r\n    parent_window->DC.CursorPos = bb.Min;\r\n    ItemSize(bb, style.FramePadding.y);\r\n    EndGroup();\r\n}\r\n\r\nbool ImGui::ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_items)\r\n{\r\n    const bool value_changed = ListBox(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_items);\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::ListBox(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)\r\n{\r\n    if (!ListBoxHeader(label, items_count, height_in_items))\r\n        return false;\r\n\r\n    // Assume all items have even height (= 1 line of text). If you need items of different or variable sizes you can create a custom version of ListBox() in your code without using the clipper.\r\n    bool value_changed = false;\r\n    ImGuiListClipper clipper(items_count, GetTextLineHeightWithSpacing()); // We know exactly our line height here so we pass it as a minor optimization, but generally you don't need to.\r\n    while (clipper.Step())\r\n        for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)\r\n        {\r\n            const bool item_selected = (i == *current_item);\r\n            const char* item_text;\r\n            if (!items_getter(data, i, &item_text))\r\n                item_text = \"*Unknown item*\";\r\n\r\n            PushID(i);\r\n            if (Selectable(item_text, item_selected))\r\n            {\r\n                *current_item = i;\r\n                value_changed = true;\r\n            }\r\n            PopID();\r\n        }\r\n    ListBoxFooter();\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::MenuItem(const char* label, const char* shortcut, bool selected, bool enabled)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiStyle& style = g.Style;\r\n    ImVec2 pos = window->DC.CursorPos;\r\n    ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n\r\n    ImGuiSelectableFlags flags = ImGuiSelectableFlags_MenuItem | (enabled ? 0 : ImGuiSelectableFlags_Disabled);\r\n    bool pressed;\r\n    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)\r\n    {\r\n        // Mimic the exact layout spacing of BeginMenu() to allow MenuItem() inside a menu bar, which is a little misleading but may be useful\r\n        // Note that in this situation we render neither the shortcut neither the selected tick mark\r\n        float w = label_size.x;\r\n        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * 0.5f);\r\n        PushStyleVar(ImGuiStyleVar_ItemSpacing, style.ItemSpacing * 2.0f);\r\n        pressed = Selectable(label, false, flags, ImVec2(w, 0.0f));\r\n        PopStyleVar();\r\n        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().\r\n    }\r\n    else\r\n    {\r\n        ImVec2 shortcut_size = shortcut ? CalcTextSize(shortcut, NULL) : ImVec2(0.0f, 0.0f);\r\n        float w = window->MenuColumns.DeclColumns(label_size.x, shortcut_size.x, (float)(int)(g.FontSize * 1.20f)); // Feedback for next frame\r\n        float extra_w = ImMax(0.0f, GetContentRegionAvail().x - w);\r\n        pressed = Selectable(label, false, flags | ImGuiSelectableFlags_DrawFillAvailWidth, ImVec2(w, 0.0f));\r\n        if (shortcut_size.x > 0.0f)\r\n        {\r\n            PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);\r\n            RenderText(pos + ImVec2(window->MenuColumns.Pos[1] + extra_w, 0.0f), shortcut, NULL, false);\r\n            PopStyleColor();\r\n        }\r\n        if (selected)\r\n            RenderCheckMark(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.40f, g.FontSize * 0.134f * 0.5f), GetColorU32(enabled ? ImGuiCol_Text : ImGuiCol_TextDisabled), g.FontSize  * 0.866f);\r\n    }\r\n    return pressed;\r\n}\r\n\r\nbool ImGui::MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled)\r\n{\r\n    if (MenuItem(label, shortcut, p_selected ? *p_selected : false, enabled))\r\n    {\r\n        if (p_selected)\r\n            *p_selected = !*p_selected;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nbool ImGui::BeginMainMenuBar()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    SetNextWindowPos(ImVec2(0.0f, 0.0f));\r\n    SetNextWindowSize(ImVec2(g.IO.DisplaySize.x, g.FontBaseSize + g.Style.FramePadding.y * 2.0f));\r\n    PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);\r\n    PushStyleVar(ImGuiStyleVar_WindowMinSize, ImVec2(0,0));\r\n    if (!Begin(\"##MainMenuBar\", NULL, ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoResize|ImGuiWindowFlags_NoMove|ImGuiWindowFlags_NoScrollbar|ImGuiWindowFlags_NoSavedSettings|ImGuiWindowFlags_MenuBar)\r\n        || !BeginMenuBar())\r\n    {\r\n        End();\r\n        PopStyleVar(2);\r\n        return false;\r\n    }\r\n    g.CurrentWindow->DC.MenuBarOffsetX += g.Style.DisplaySafeAreaPadding.x;\r\n    return true;\r\n}\r\n\r\nvoid ImGui::EndMainMenuBar()\r\n{\r\n    EndMenuBar();\r\n    End();\r\n    PopStyleVar(2);\r\n}\r\n\r\nbool ImGui::BeginMenuBar()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n    if (!(window->Flags & ImGuiWindowFlags_MenuBar))\r\n        return false;\r\n\r\n    IM_ASSERT(!window->DC.MenuBarAppending);\r\n    BeginGroup(); // Save position\r\n    PushID(\"##menubar\");\r\n    \r\n    // We don't clip with regular window clipping rectangle as it is already set to the area below. However we clip with window full rect.\r\n    // We remove 1 worth of rounding to Max.x to that text in long menus don't tend to display over the lower-right rounded area, which looks particularly glitchy.\r\n    ImRect bar_rect = window->MenuBarRect();\r\n    ImRect clip_rect(ImFloor(bar_rect.Min.x + 0.5f), ImFloor(bar_rect.Min.y + window->WindowBorderSize + 0.5f), ImFloor(ImMax(bar_rect.Min.x, bar_rect.Max.x - window->WindowRounding) + 0.5f), ImFloor(bar_rect.Max.y + 0.5f));\r\n    clip_rect.ClipWith(window->Rect());\r\n    PushClipRect(clip_rect.Min, clip_rect.Max, false);\r\n\r\n    window->DC.CursorPos = ImVec2(bar_rect.Min.x + window->DC.MenuBarOffsetX, bar_rect.Min.y);// + g.Style.FramePadding.y);\r\n    window->DC.LayoutType = ImGuiLayoutType_Horizontal;\r\n    window->DC.MenuBarAppending = true;\r\n    AlignTextToFramePadding();\r\n    return true;\r\n}\r\n\r\nvoid ImGui::EndMenuBar()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    IM_ASSERT(window->Flags & ImGuiWindowFlags_MenuBar);\r\n    IM_ASSERT(window->DC.MenuBarAppending);\r\n    PopClipRect();\r\n    PopID();\r\n    window->DC.MenuBarOffsetX = window->DC.CursorPos.x - window->MenuBarRect().Min.x;\r\n    window->DC.GroupStack.back().AdvanceCursor = false;\r\n    EndGroup();\r\n    window->DC.LayoutType = ImGuiLayoutType_Vertical;\r\n    window->DC.MenuBarAppending = false;\r\n}\r\n\r\nbool ImGui::BeginMenu(const char* label, bool enabled)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const ImGuiID id = window->GetID(label);\r\n\r\n    ImVec2 label_size = CalcTextSize(label, NULL, true);\r\n\r\n    bool pressed;\r\n    bool menu_is_open = IsPopupOpen(id);\r\n    bool menuset_is_open = !(window->Flags & ImGuiWindowFlags_Popup) && (g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].ParentMenuSet == window->GetID(\"##Menus\"));\r\n    ImGuiWindow* backed_nav_window = g.NavWindow;\r\n    if (menuset_is_open)\r\n        g.NavWindow = window;  // Odd hack to allow hovering across menus of a same menu-set (otherwise we wouldn't be able to hover parent)\r\n\r\n    // The reference position stored in popup_pos will be used by Begin() to find a suitable position for the child menu (using FindBestPopupWindowPos).\r\n    ImVec2 popup_pos, pos = window->DC.CursorPos;\r\n    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)\r\n    {\r\n        // Menu inside an horizontal menu bar\r\n        // Selectable extend their highlight by half ItemSpacing in each direction.\r\n        // For ChildMenu, the popup position will be overwritten by the call to FindBestPopupWindowPos() in Begin()\r\n        popup_pos = ImVec2(pos.x - window->WindowPadding.x, pos.y - style.FramePadding.y + window->MenuBarHeight());\r\n        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * 0.5f);\r\n        PushStyleVar(ImGuiStyleVar_ItemSpacing, style.ItemSpacing * 2.0f);\r\n        float w = label_size.x;\r\n        pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_Menu | ImGuiSelectableFlags_DontClosePopups | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));\r\n        PopStyleVar();\r\n        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().\r\n    }\r\n    else\r\n    {\r\n        // Menu inside a menu\r\n        popup_pos = ImVec2(pos.x, pos.y - style.WindowPadding.y);\r\n        float w = window->MenuColumns.DeclColumns(label_size.x, 0.0f, (float)(int)(g.FontSize * 1.20f)); // Feedback to next frame\r\n        float extra_w = ImMax(0.0f, GetContentRegionAvail().x - w);\r\n        pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_Menu | ImGuiSelectableFlags_DontClosePopups | ImGuiSelectableFlags_DrawFillAvailWidth | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));\r\n        if (!enabled) PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);\r\n        RenderTriangle(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.30f, 0.0f), ImGuiDir_Right);\r\n        if (!enabled) PopStyleColor();\r\n    }\r\n\r\n    const bool hovered = enabled && ItemHoverable(window->DC.LastItemRect, id);\r\n    if (menuset_is_open)\r\n        g.NavWindow = backed_nav_window;\r\n\r\n    bool want_open = false, want_close = false;\r\n    if (window->DC.LayoutType != ImGuiLayoutType_Horizontal) // (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))\r\n    {\r\n        // Implement http://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown to avoid using timers, so menus feels more reactive.\r\n        bool moving_within_opened_triangle = false;\r\n        if (g.HoveredWindow == window && g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].ParentWindow == window)\r\n        {\r\n            if (ImGuiWindow* next_window = g.OpenPopupStack[g.CurrentPopupStack.Size].Window)\r\n            {\r\n                ImRect next_window_rect = next_window->Rect();\r\n                ImVec2 ta = g.IO.MousePos - g.IO.MouseDelta;\r\n                ImVec2 tb = (window->Pos.x < next_window->Pos.x) ? next_window_rect.GetTL() : next_window_rect.GetTR();\r\n                ImVec2 tc = (window->Pos.x < next_window->Pos.x) ? next_window_rect.GetBL() : next_window_rect.GetBR();\r\n                float extra = ImClamp(fabsf(ta.x - tb.x) * 0.30f, 5.0f, 30.0f); // add a bit of extra slack.\r\n                ta.x += (window->Pos.x < next_window->Pos.x) ? -0.5f : +0.5f;   // to avoid numerical issues\r\n                tb.y = ta.y + ImMax((tb.y - extra) - ta.y, -100.0f);            // triangle is maximum 200 high to limit the slope and the bias toward large sub-menus // FIXME: Multiply by fb_scale?\r\n                tc.y = ta.y + ImMin((tc.y + extra) - ta.y, +100.0f);\r\n                moving_within_opened_triangle = ImTriangleContainsPoint(ta, tb, tc, g.IO.MousePos);\r\n                //window->DrawList->PushClipRectFullScreen(); window->DrawList->AddTriangleFilled(ta, tb, tc, moving_within_opened_triangle ? IM_COL32(0,128,0,128) : IM_COL32(128,0,0,128)); window->DrawList->PopClipRect(); // Debug\r\n            }\r\n        }\r\n\r\n        want_close = (menu_is_open && !hovered && g.HoveredWindow == window && g.HoveredIdPreviousFrame != 0 && g.HoveredIdPreviousFrame != id && !moving_within_opened_triangle);\r\n        want_open = (!menu_is_open && hovered && !moving_within_opened_triangle) || (!menu_is_open && hovered && pressed);\r\n    }\r\n    else\r\n    {\r\n        // Menu bar\r\n        if (menu_is_open && pressed && menuset_is_open) // Click an open menu again to close it\r\n        {\r\n            want_close = true;\r\n            want_open = menu_is_open = false;\r\n        }\r\n        else if (pressed || (hovered && menuset_is_open && !menu_is_open)) // First click to open, then hover to open others\r\n        {\r\n            want_open = true;\r\n        }\r\n    }\r\n\r\n    if (!enabled) // explicitly close if an open menu becomes disabled, facilitate users code a lot in pattern such as 'if (BeginMenu(\"options\", has_object)) { ..use object.. }'\r\n        want_close = true;\r\n    if (want_close && IsPopupOpen(id))\r\n        ClosePopupToLevel(GImGui->CurrentPopupStack.Size);\r\n\r\n    if (!menu_is_open && want_open && g.OpenPopupStack.Size > g.CurrentPopupStack.Size)\r\n    {\r\n        // Don't recycle same menu level in the same frame, first close the other menu and yield for a frame.\r\n        OpenPopup(label);\r\n        return false;\r\n    }\r\n\r\n    menu_is_open |= want_open;\r\n    if (want_open)\r\n        OpenPopup(label);\r\n\r\n    if (menu_is_open)\r\n    {\r\n        SetNextWindowPos(popup_pos, ImGuiCond_Always);\r\n        ImGuiWindowFlags flags = ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings | ((window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu)) ? ImGuiWindowFlags_ChildMenu|ImGuiWindowFlags_ChildWindow : ImGuiWindowFlags_ChildMenu);\r\n        menu_is_open = BeginPopupEx(id, flags); // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)\r\n    }\r\n\r\n    return menu_is_open;\r\n}\r\n\r\nvoid ImGui::EndMenu()\r\n{\r\n    EndPopup();\r\n}\r\n\r\n// Note: only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.\r\nvoid ImGui::ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);\r\n    BeginTooltipEx(0, true);\r\n    \r\n    const char* text_end = text ? FindRenderedTextEnd(text, NULL) : text;\r\n    if (text_end > text)\r\n    {\r\n        TextUnformatted(text, text_end);\r\n        Separator();\r\n    }\r\n\r\n    ImVec2 sz(g.FontSize * 3 + g.Style.FramePadding.y * 2, g.FontSize * 3 + g.Style.FramePadding.y * 2);\r\n    ColorButton(\"##preview\", ImVec4(col[0], col[1], col[2], col[3]), (flags & (ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf)) | ImGuiColorEditFlags_NoTooltip, sz);\r\n    SameLine();\r\n    if (flags & ImGuiColorEditFlags_NoAlpha)\r\n        Text(\"#%02X%02X%02X\\nR: %d, G: %d, B: %d\\n(%.3f, %.3f, %.3f)\", cr, cg, cb, cr, cg, cb, col[0], col[1], col[2]);\r\n    else\r\n        Text(\"#%02X%02X%02X%02X\\nR:%d, G:%d, B:%d, A:%d\\n(%.3f, %.3f, %.3f, %.3f)\", cr, cg, cb, ca, cr, cg, cb, ca, col[0], col[1], col[2], col[3]);\r\n    EndTooltip();\r\n}\r\n\r\nstatic inline ImU32 ImAlphaBlendColor(ImU32 col_a, ImU32 col_b)\r\n{\r\n    float t = ((col_b >> IM_COL32_A_SHIFT) & 0xFF) / 255.f;\r\n    int r = ImLerp((int)(col_a >> IM_COL32_R_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_R_SHIFT) & 0xFF, t);\r\n    int g = ImLerp((int)(col_a >> IM_COL32_G_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_G_SHIFT) & 0xFF, t);\r\n    int b = ImLerp((int)(col_a >> IM_COL32_B_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_B_SHIFT) & 0xFF, t);\r\n    return IM_COL32(r, g, b, 0xFF);\r\n}\r\n\r\n// NB: This is rather brittle and will show artifact when rounding this enabled if rounded corners overlap multiple cells. Caller currently responsible for avoiding that.\r\n// I spent a non reasonable amount of time trying to getting this right for ColorButton with rounding+anti-aliasing+ImGuiColorEditFlags_HalfAlphaPreview flag + various grid sizes and offsets, and eventually gave up... probably more reasonable to disable rounding alltogether.\r\nvoid ImGui::RenderColorRectWithAlphaCheckerboard(ImVec2 p_min, ImVec2 p_max, ImU32 col, float grid_step, ImVec2 grid_off, float rounding, int rounding_corners_flags)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (((col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT) < 0xFF)\r\n    {\r\n        ImU32 col_bg1 = GetColorU32(ImAlphaBlendColor(IM_COL32(204,204,204,255), col));\r\n        ImU32 col_bg2 = GetColorU32(ImAlphaBlendColor(IM_COL32(128,128,128,255), col));\r\n        window->DrawList->AddRectFilled(p_min, p_max, col_bg1, rounding, rounding_corners_flags);\r\n\r\n        int yi = 0;\r\n        for (float y = p_min.y + grid_off.y; y < p_max.y; y += grid_step, yi++)\r\n        {\r\n            float y1 = ImClamp(y, p_min.y, p_max.y), y2 = ImMin(y + grid_step, p_max.y);\r\n            if (y2 <= y1)\r\n                continue;\r\n            for (float x = p_min.x + grid_off.x + (yi & 1) * grid_step; x < p_max.x; x += grid_step * 2.0f)\r\n            {\r\n                float x1 = ImClamp(x, p_min.x, p_max.x), x2 = ImMin(x + grid_step, p_max.x);\r\n                if (x2 <= x1)\r\n                    continue;\r\n                int rounding_corners_flags_cell = 0;\r\n                if (y1 <= p_min.y) { if (x1 <= p_min.x) rounding_corners_flags_cell |= ImDrawCornerFlags_TopLeft; if (x2 >= p_max.x) rounding_corners_flags_cell |= ImDrawCornerFlags_TopRight; }\r\n                if (y2 >= p_max.y) { if (x1 <= p_min.x) rounding_corners_flags_cell |= ImDrawCornerFlags_BotLeft; if (x2 >= p_max.x) rounding_corners_flags_cell |= ImDrawCornerFlags_BotRight; }\r\n                rounding_corners_flags_cell &= rounding_corners_flags;\r\n                window->DrawList->AddRectFilled(ImVec2(x1,y1), ImVec2(x2,y2), col_bg2, rounding_corners_flags_cell ? rounding : 0.0f, rounding_corners_flags_cell);\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        window->DrawList->AddRectFilled(p_min, p_max, col, rounding, rounding_corners_flags);\r\n    }\r\n}\r\n\r\nvoid ImGui::SetColorEditOptions(ImGuiColorEditFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if ((flags & ImGuiColorEditFlags__InputsMask) == 0)\r\n        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__InputsMask;\r\n    if ((flags & ImGuiColorEditFlags__DataTypeMask) == 0)\r\n        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__DataTypeMask;\r\n    if ((flags & ImGuiColorEditFlags__PickerMask) == 0)\r\n        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__PickerMask;\r\n    IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__InputsMask)));   // Check only 1 option is selected\r\n    IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__DataTypeMask))); // Check only 1 option is selected\r\n    IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__PickerMask)));   // Check only 1 option is selected\r\n    g.ColorEditOptions = flags;\r\n}\r\n\r\n// A little colored square. Return true when clicked.\r\n// FIXME: May want to display/ignore the alpha component in the color display? Yet show it in the tooltip.\r\n// 'desc_id' is not called 'label' because we don't display it next to the button, but only in the tooltip.\r\nbool ImGui::ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags, ImVec2 size)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiID id = window->GetID(desc_id);\r\n    float default_size = GetFrameHeight();\r\n    if (size.x == 0.0f)\r\n        size.x = default_size;\r\n    if (size.y == 0.0f)\r\n        size.y = default_size;\r\n    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);\r\n    ItemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);\r\n    if (!ItemAdd(bb, id))\r\n        return false;\r\n\r\n    bool hovered, held;\r\n    bool pressed = ButtonBehavior(bb, id, &hovered, &held);\r\n\r\n    if (flags & ImGuiColorEditFlags_NoAlpha)\r\n        flags &= ~(ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf);\r\n    \r\n    ImVec4 col_without_alpha(col.x, col.y, col.z, 1.0f);\r\n    float grid_step = ImMin(size.x, size.y) / 2.99f;\r\n    float rounding = ImMin(g.Style.FrameRounding, grid_step * 0.5f);\r\n    ImRect bb_inner = bb;\r\n    float off = -0.75f; // The border (using Col_FrameBg) tends to look off when color is near-opaque and rounding is enabled. This offset seemed like a good middle ground to reduce those artifacts.\r\n    bb_inner.Expand(off);\r\n    if ((flags & ImGuiColorEditFlags_AlphaPreviewHalf) && col.w < 1.0f)\r\n    {\r\n        float mid_x = (float)(int)((bb_inner.Min.x + bb_inner.Max.x) * 0.5f + 0.5f);\r\n        RenderColorRectWithAlphaCheckerboard(ImVec2(bb_inner.Min.x + grid_step, bb_inner.Min.y), bb_inner.Max, GetColorU32(col), grid_step, ImVec2(-grid_step + off, off), rounding, ImDrawCornerFlags_TopRight| ImDrawCornerFlags_BotRight);\r\n        window->DrawList->AddRectFilled(bb_inner.Min, ImVec2(mid_x, bb_inner.Max.y), GetColorU32(col_without_alpha), rounding, ImDrawCornerFlags_TopLeft|ImDrawCornerFlags_BotLeft);\r\n    }\r\n    else\r\n    {\r\n        // Because GetColorU32() multiplies by the global style Alpha and we don't want to display a checkerboard if the source code had no alpha\r\n        ImVec4 col_source = (flags & ImGuiColorEditFlags_AlphaPreview) ? col : col_without_alpha;\r\n        if (col_source.w < 1.0f)\r\n            RenderColorRectWithAlphaCheckerboard(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), grid_step, ImVec2(off, off), rounding);\r\n        else\r\n            window->DrawList->AddRectFilled(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), rounding, ImDrawCornerFlags_All);\r\n    }\r\n    if (g.Style.FrameBorderSize > 0.0f)\r\n        RenderFrameBorder(bb.Min, bb.Max, rounding);\r\n    else\r\n        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), rounding); // Color button are often in need of some sort of border\r\n\r\n    // Drag and Drop Source\r\n    if (g.ActiveId == id && BeginDragDropSource()) // NB: The ActiveId test is merely an optional micro-optimization\r\n    {\r\n        if (flags & ImGuiColorEditFlags_NoAlpha)\r\n            SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F, &col, sizeof(float) * 3, ImGuiCond_Once);\r\n        else\r\n            SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F, &col, sizeof(float) * 4, ImGuiCond_Once);\r\n        ColorButton(desc_id, col, flags);\r\n        SameLine();\r\n        TextUnformatted(\"Color\");\r\n        EndDragDropSource();\r\n        hovered = false;\r\n    }\r\n\r\n    // Tooltip\r\n    if (!(flags & ImGuiColorEditFlags_NoTooltip) && hovered)\r\n        ColorTooltip(desc_id, &col.x, flags & (ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf));\r\n\r\n    return pressed;\r\n}\r\n\r\nbool ImGui::ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags)\r\n{\r\n    return ColorEdit4(label, col, flags | ImGuiColorEditFlags_NoAlpha);\r\n}\r\n\r\nvoid ImGui::ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags)\r\n{\r\n    bool allow_opt_inputs = !(flags & ImGuiColorEditFlags__InputsMask);\r\n    bool allow_opt_datatype = !(flags & ImGuiColorEditFlags__DataTypeMask);\r\n    if ((!allow_opt_inputs && !allow_opt_datatype) || !BeginPopup(\"context\"))\r\n        return;\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiColorEditFlags opts = g.ColorEditOptions;\r\n    if (allow_opt_inputs)\r\n    {\r\n        if (RadioButton(\"RGB\", (opts & ImGuiColorEditFlags_RGB) ? 1 : 0)) opts = (opts & ~ImGuiColorEditFlags__InputsMask) | ImGuiColorEditFlags_RGB;\r\n        if (RadioButton(\"HSV\", (opts & ImGuiColorEditFlags_HSV) ? 1 : 0)) opts = (opts & ~ImGuiColorEditFlags__InputsMask) | ImGuiColorEditFlags_HSV;\r\n        if (RadioButton(\"HEX\", (opts & ImGuiColorEditFlags_HEX) ? 1 : 0)) opts = (opts & ~ImGuiColorEditFlags__InputsMask) | ImGuiColorEditFlags_HEX;\r\n    }\r\n    if (allow_opt_datatype)\r\n    {\r\n        if (allow_opt_inputs) Separator();\r\n        if (RadioButton(\"0..255\",     (opts & ImGuiColorEditFlags_Uint8) ? 1 : 0)) opts = (opts & ~ImGuiColorEditFlags__DataTypeMask) | ImGuiColorEditFlags_Uint8;\r\n        if (RadioButton(\"0.00..1.00\", (opts & ImGuiColorEditFlags_Float) ? 1 : 0)) opts = (opts & ~ImGuiColorEditFlags__DataTypeMask) | ImGuiColorEditFlags_Float;\r\n    }\r\n\r\n    if (allow_opt_inputs || allow_opt_datatype)\r\n        Separator();\r\n    if (Button(\"Copy as..\", ImVec2(-1,0)))\r\n        OpenPopup(\"Copy\");\r\n    if (BeginPopup(\"Copy\"))\r\n    {\r\n        int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);\r\n        char buf[64];\r\n        ImFormatString(buf, IM_ARRAYSIZE(buf), \"(%.3ff, %.3ff, %.3ff, %.3ff)\", col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);\r\n        if (Selectable(buf))\r\n            SetClipboardText(buf);\r\n        ImFormatString(buf, IM_ARRAYSIZE(buf), \"(%d,%d,%d,%d)\", cr, cg, cb, ca);\r\n        if (Selectable(buf))\r\n            SetClipboardText(buf);\r\n        if (flags & ImGuiColorEditFlags_NoAlpha)\r\n            ImFormatString(buf, IM_ARRAYSIZE(buf), \"0x%02X%02X%02X\", cr, cg, cb);\r\n        else\r\n            ImFormatString(buf, IM_ARRAYSIZE(buf), \"0x%02X%02X%02X%02X\", cr, cg, cb, ca);\r\n        if (Selectable(buf))\r\n            SetClipboardText(buf);\r\n        EndPopup();\r\n    }\r\n\r\n    g.ColorEditOptions = opts;\r\n    EndPopup();\r\n}\r\n\r\nstatic void ColorPickerOptionsPopup(ImGuiColorEditFlags flags, const float* ref_col)\r\n{\r\n    bool allow_opt_picker = !(flags & ImGuiColorEditFlags__PickerMask);\r\n    bool allow_opt_alpha_bar = !(flags & ImGuiColorEditFlags_NoAlpha) && !(flags & ImGuiColorEditFlags_AlphaBar);\r\n    if ((!allow_opt_picker && !allow_opt_alpha_bar) || !ImGui::BeginPopup(\"context\"))\r\n        return;\r\n    ImGuiContext& g = *GImGui;\r\n    if (allow_opt_picker)\r\n    {\r\n        ImVec2 picker_size(g.FontSize * 8, ImMax(g.FontSize * 8 - (ImGui::GetFrameHeight() + g.Style.ItemInnerSpacing.x), 1.0f)); // FIXME: Picker size copied from main picker function\r\n        ImGui::PushItemWidth(picker_size.x);\r\n        for (int picker_type = 0; picker_type < 2; picker_type++)\r\n        {\r\n            // Draw small/thumbnail version of each picker type (over an invisible button for selection)\r\n            if (picker_type > 0) ImGui::Separator();\r\n            ImGui::PushID(picker_type);\r\n            ImGuiColorEditFlags picker_flags = ImGuiColorEditFlags_NoInputs|ImGuiColorEditFlags_NoOptions|ImGuiColorEditFlags_NoLabel|ImGuiColorEditFlags_NoSidePreview|(flags & ImGuiColorEditFlags_NoAlpha);\r\n            if (picker_type == 0) picker_flags |= ImGuiColorEditFlags_PickerHueBar;\r\n            if (picker_type == 1) picker_flags |= ImGuiColorEditFlags_PickerHueWheel;\r\n            ImVec2 backup_pos = ImGui::GetCursorScreenPos();\r\n            if (ImGui::Selectable(\"##selectable\", false, 0, picker_size)) // By default, Selectable() is closing popup\r\n                g.ColorEditOptions = (g.ColorEditOptions & ~ImGuiColorEditFlags__PickerMask) | (picker_flags & ImGuiColorEditFlags__PickerMask);\r\n            ImGui::SetCursorScreenPos(backup_pos);\r\n            ImVec4 dummy_ref_col;\r\n            memcpy(&dummy_ref_col.x, ref_col, sizeof(float) * (picker_flags & ImGuiColorEditFlags_NoAlpha ? 3 : 4));\r\n            ImGui::ColorPicker4(\"##dummypicker\", &dummy_ref_col.x, picker_flags);\r\n            ImGui::PopID();\r\n        }\r\n        ImGui::PopItemWidth();\r\n    }\r\n    if (allow_opt_alpha_bar)\r\n    {\r\n        if (allow_opt_picker) ImGui::Separator();\r\n        ImGui::CheckboxFlags(\"Alpha Bar\", (unsigned int*)&g.ColorEditOptions, ImGuiColorEditFlags_AlphaBar);\r\n    }\r\n    ImGui::EndPopup();\r\n}\r\n\r\n// Edit colors components (each component in 0.0f..1.0f range). \r\n// See enum ImGuiColorEditFlags_ for available options. e.g. Only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.\r\n// With typical options: Left-click on colored square to open color picker. Right-click to open option menu. CTRL-Click over input fields to edit them and TAB to go to next item.\r\nbool ImGui::ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return false;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiStyle& style = g.Style;\r\n    const float square_sz = GetFrameHeight();\r\n    const float w_extra = (flags & ImGuiColorEditFlags_NoSmallPreview) ? 0.0f : (square_sz + style.ItemInnerSpacing.x);\r\n    const float w_items_all = CalcItemWidth() - w_extra;\r\n    const char* label_display_end = FindRenderedTextEnd(label);\r\n\r\n    const bool alpha = (flags & ImGuiColorEditFlags_NoAlpha) == 0;\r\n    const bool hdr = (flags & ImGuiColorEditFlags_HDR) != 0;\r\n    const int components = alpha ? 4 : 3;\r\n    const ImGuiColorEditFlags flags_untouched = flags;\r\n\r\n    BeginGroup();\r\n    PushID(label);\r\n\r\n    // If we're not showing any slider there's no point in doing any HSV conversions\r\n    if (flags & ImGuiColorEditFlags_NoInputs)\r\n        flags = (flags & (~ImGuiColorEditFlags__InputsMask)) | ImGuiColorEditFlags_RGB | ImGuiColorEditFlags_NoOptions;\r\n\r\n    // Context menu: display and modify options (before defaults are applied)\r\n    if (!(flags & ImGuiColorEditFlags_NoOptions))\r\n        ColorEditOptionsPopup(col, flags);\r\n \r\n    // Read stored options\r\n    if (!(flags & ImGuiColorEditFlags__InputsMask))\r\n        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__InputsMask);\r\n    if (!(flags & ImGuiColorEditFlags__DataTypeMask))\r\n        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__DataTypeMask);\r\n    if (!(flags & ImGuiColorEditFlags__PickerMask))\r\n        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__PickerMask);\r\n    flags |= (g.ColorEditOptions & ~(ImGuiColorEditFlags__InputsMask | ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__PickerMask));\r\n\r\n    // Convert to the formats we need\r\n    float f[4] = { col[0], col[1], col[2], alpha ? col[3] : 1.0f };\r\n    if (flags & ImGuiColorEditFlags_HSV)\r\n        ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);\r\n    int i[4] = { IM_F32_TO_INT8_UNBOUND(f[0]), IM_F32_TO_INT8_UNBOUND(f[1]), IM_F32_TO_INT8_UNBOUND(f[2]), IM_F32_TO_INT8_UNBOUND(f[3]) };\r\n\r\n    bool value_changed = false;\r\n    bool value_changed_as_float = false;\r\n\r\n    if ((flags & (ImGuiColorEditFlags_RGB | ImGuiColorEditFlags_HSV)) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)\r\n    {\r\n        // RGB/HSV 0..255 Sliders\r\n        const float w_item_one  = ImMax(1.0f, (float)(int)((w_items_all - (style.ItemInnerSpacing.x) * (components-1)) / (float)components));\r\n        const float w_item_last = ImMax(1.0f, (float)(int)(w_items_all - (w_item_one + style.ItemInnerSpacing.x) * (components-1)));\r\n\r\n        const bool hide_prefix = (w_item_one <= CalcTextSize((flags & ImGuiColorEditFlags_Float) ? \"M:0.000\" : \"M:000\").x);\r\n        const char* ids[4] = { \"##X\", \"##Y\", \"##Z\", \"##W\" };\r\n        const char* fmt_table_int[3][4] =\r\n        {\r\n            {   \"%3.0f\",   \"%3.0f\",   \"%3.0f\",   \"%3.0f\" }, // Short display\r\n            { \"R:%3.0f\", \"G:%3.0f\", \"B:%3.0f\", \"A:%3.0f\" }, // Long display for RGBA\r\n            { \"H:%3.0f\", \"S:%3.0f\", \"V:%3.0f\", \"A:%3.0f\" }  // Long display for HSVA\r\n        };\r\n        const char* fmt_table_float[3][4] =\r\n        {\r\n            {   \"%0.3f\",   \"%0.3f\",   \"%0.3f\",   \"%0.3f\" }, // Short display\r\n            { \"R:%0.3f\", \"G:%0.3f\", \"B:%0.3f\", \"A:%0.3f\" }, // Long display for RGBA\r\n            { \"H:%0.3f\", \"S:%0.3f\", \"V:%0.3f\", \"A:%0.3f\" }  // Long display for HSVA\r\n        };\r\n        const int fmt_idx = hide_prefix ? 0 : (flags & ImGuiColorEditFlags_HSV) ? 2 : 1;\r\n\r\n        PushItemWidth(w_item_one);\r\n        for (int n = 0; n < components; n++)\r\n        {\r\n            if (n > 0)\r\n                SameLine(0, style.ItemInnerSpacing.x);\r\n            if (n + 1 == components)\r\n                PushItemWidth(w_item_last);\r\n            if (flags & ImGuiColorEditFlags_Float)\r\n                value_changed = value_changed_as_float = value_changed | DragFloat(ids[n], &f[n], 1.0f/255.0f, 0.0f, hdr ? 0.0f : 1.0f, fmt_table_float[fmt_idx][n]);\r\n            else\r\n                value_changed |= DragInt(ids[n], &i[n], 1.0f, 0, hdr ? 0 : 255, fmt_table_int[fmt_idx][n]);\r\n            if (!(flags & ImGuiColorEditFlags_NoOptions))\r\n                OpenPopupOnItemClick(\"context\");\r\n        }\r\n        PopItemWidth();\r\n        PopItemWidth();\r\n    }\r\n    else if ((flags & ImGuiColorEditFlags_HEX) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)\r\n    {\r\n        // RGB Hexadecimal Input\r\n        char buf[64];\r\n        if (alpha)\r\n            ImFormatString(buf, IM_ARRAYSIZE(buf), \"#%02X%02X%02X%02X\", ImClamp(i[0],0,255), ImClamp(i[1],0,255), ImClamp(i[2],0,255), ImClamp(i[3],0,255));\r\n        else\r\n            ImFormatString(buf, IM_ARRAYSIZE(buf), \"#%02X%02X%02X\", ImClamp(i[0],0,255), ImClamp(i[1],0,255), ImClamp(i[2],0,255));\r\n        PushItemWidth(w_items_all);\r\n        if (InputText(\"##Text\", buf, IM_ARRAYSIZE(buf), ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase))\r\n        {\r\n            value_changed = true;\r\n            char* p = buf;\r\n            while (*p == '#' || ImCharIsSpace(*p))\r\n                p++;\r\n            i[0] = i[1] = i[2] = i[3] = 0;\r\n            if (alpha)\r\n                sscanf(p, \"%02X%02X%02X%02X\", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2], (unsigned int*)&i[3]); // Treat at unsigned (%X is unsigned)\r\n            else\r\n                sscanf(p, \"%02X%02X%02X\", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2]);\r\n        }\r\n        if (!(flags & ImGuiColorEditFlags_NoOptions))\r\n            OpenPopupOnItemClick(\"context\");\r\n        PopItemWidth();\r\n    }\r\n\r\n    ImGuiWindow* picker_active_window = NULL;\r\n    if (!(flags & ImGuiColorEditFlags_NoSmallPreview))\r\n    {\r\n        if (!(flags & ImGuiColorEditFlags_NoInputs))\r\n            SameLine(0, style.ItemInnerSpacing.x);\r\n\r\n        const ImVec4 col_v4(col[0], col[1], col[2], alpha ? col[3] : 1.0f);\r\n        if (ColorButton(\"##ColorButton\", col_v4, flags))\r\n        {\r\n            if (!(flags & ImGuiColorEditFlags_NoPicker))\r\n            {\r\n                // Store current color and open a picker\r\n                g.ColorPickerRef = col_v4;\r\n                OpenPopup(\"picker\");\r\n                SetNextWindowPos(window->DC.LastItemRect.GetBL() + ImVec2(-1,style.ItemSpacing.y));\r\n            }\r\n        }\r\n        if (!(flags & ImGuiColorEditFlags_NoOptions))\r\n            OpenPopupOnItemClick(\"context\");\r\n        \r\n        if (BeginPopup(\"picker\"))\r\n        {\r\n            picker_active_window = g.CurrentWindow;\r\n            if (label != label_display_end)\r\n            {\r\n                TextUnformatted(label, label_display_end);\r\n                Separator();\r\n            }\r\n            ImGuiColorEditFlags picker_flags_to_forward = ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__PickerMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaBar;\r\n            ImGuiColorEditFlags picker_flags = (flags_untouched & picker_flags_to_forward) | ImGuiColorEditFlags__InputsMask | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_AlphaPreviewHalf;\r\n            PushItemWidth(square_sz * 12.0f); // Use 256 + bar sizes?\r\n            value_changed |= ColorPicker4(\"##picker\", col, picker_flags, &g.ColorPickerRef.x);\r\n            PopItemWidth();\r\n            EndPopup();\r\n        }\r\n    }\r\n\r\n    if (label != label_display_end && !(flags & ImGuiColorEditFlags_NoLabel))\r\n    {\r\n        SameLine(0, style.ItemInnerSpacing.x);\r\n        TextUnformatted(label, label_display_end);\r\n    }\r\n\r\n    // Convert back\r\n    if (picker_active_window == NULL)\r\n    {\r\n        if (!value_changed_as_float) \r\n            for (int n = 0; n < 4; n++)\r\n                f[n] = i[n] / 255.0f;\r\n        if (flags & ImGuiColorEditFlags_HSV)\r\n            ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);\r\n        if (value_changed)\r\n        {\r\n            col[0] = f[0];\r\n            col[1] = f[1];\r\n            col[2] = f[2];\r\n            if (alpha)\r\n                col[3] = f[3];\r\n        }\r\n    }\r\n\r\n    PopID();\r\n    EndGroup();\r\n\r\n    // Drag and Drop Target\r\n    if (window->DC.LastItemRectHoveredRect && BeginDragDropTarget()) // NB: The LastItemRectHoveredRect test is merely an optional micro-optimization\r\n    {\r\n        if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F))\r\n        {\r\n            memcpy((float*)col, payload->Data, sizeof(float) * 3);\r\n            value_changed = true;\r\n        }\r\n        if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F))\r\n        {\r\n            memcpy((float*)col, payload->Data, sizeof(float) * components);\r\n            value_changed = true;\r\n        }\r\n        EndDragDropTarget();\r\n    }\r\n\r\n    // When picker is being actively used, use its active id so IsItemActive() will function on ColorEdit4().\r\n    if (picker_active_window && g.ActiveId != 0 && g.ActiveIdWindow == picker_active_window)\r\n        window->DC.LastItemId = g.ActiveId;\r\n\r\n    return value_changed;\r\n}\r\n\r\nbool ImGui::ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags)\r\n{\r\n    float col4[4] = { col[0], col[1], col[2], 1.0f };\r\n    if (!ColorPicker4(label, col4, flags | ImGuiColorEditFlags_NoAlpha))\r\n        return false;\r\n    col[0] = col4[0]; col[1] = col4[1]; col[2] = col4[2];\r\n    return true;\r\n}\r\n\r\n// 'pos' is position of the arrow tip. half_sz.x is length from base to tip. half_sz.y is length on each side.\r\nstatic void RenderArrow(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col)\r\n{\r\n    switch (direction)\r\n    {\r\n    case ImGuiDir_Left:  draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), pos, col); return;\r\n    case ImGuiDir_Right: draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), pos, col); return;\r\n    case ImGuiDir_Up:    draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), pos, col); return;\r\n    case ImGuiDir_Down:  draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), pos, col); return;\r\n    case ImGuiDir_None: case ImGuiDir_Count_: break; // Fix warnings\r\n    }\r\n}\r\n\r\nstatic void RenderArrowsForVerticalBar(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, float bar_w)\r\n{\r\n    RenderArrow(draw_list, ImVec2(pos.x + half_sz.x + 1,         pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Right, IM_COL32_BLACK);\r\n    RenderArrow(draw_list, ImVec2(pos.x + half_sz.x,             pos.y), half_sz,                              ImGuiDir_Right, IM_COL32_WHITE);\r\n    RenderArrow(draw_list, ImVec2(pos.x + bar_w - half_sz.x - 1, pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Left,  IM_COL32_BLACK);\r\n    RenderArrow(draw_list, ImVec2(pos.x + bar_w - half_sz.x,     pos.y), half_sz,                              ImGuiDir_Left,  IM_COL32_WHITE);\r\n}\r\n\r\n// ColorPicker\r\n// Note: only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.\r\n// FIXME: we adjust the big color square height based on item width, which may cause a flickering feedback loop (if automatic height makes a vertical scrollbar appears, affecting automatic width..) \r\nbool ImGui::ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags, const float* ref_col)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    ImDrawList* draw_list = window->DrawList;\r\n\r\n    ImGuiStyle& style = g.Style;\r\n    ImGuiIO& io = g.IO;\r\n\r\n    PushID(label);\r\n    BeginGroup();\r\n\r\n    if (!(flags & ImGuiColorEditFlags_NoSidePreview))\r\n        flags |= ImGuiColorEditFlags_NoSmallPreview;\r\n\r\n    // Context menu: display and store options.\r\n    if (!(flags & ImGuiColorEditFlags_NoOptions))\r\n        ColorPickerOptionsPopup(flags, col);\r\n\r\n    // Read stored options\r\n    if (!(flags & ImGuiColorEditFlags__PickerMask))\r\n        flags |= ((g.ColorEditOptions & ImGuiColorEditFlags__PickerMask) ? g.ColorEditOptions : ImGuiColorEditFlags__OptionsDefault) & ImGuiColorEditFlags__PickerMask; \r\n    IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__PickerMask))); // Check that only 1 is selected\r\n    if (!(flags & ImGuiColorEditFlags_NoOptions))\r\n        flags |= (g.ColorEditOptions & ImGuiColorEditFlags_AlphaBar);\r\n\r\n    // Setup\r\n    int components = (flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4;\r\n    bool alpha_bar = (flags & ImGuiColorEditFlags_AlphaBar) && !(flags & ImGuiColorEditFlags_NoAlpha);\r\n    ImVec2 picker_pos = window->DC.CursorPos;\r\n    float square_sz = GetFrameHeight();\r\n    float bars_width = square_sz; // Arbitrary smallish width of Hue/Alpha picking bars\r\n    float sv_picker_size = ImMax(bars_width * 1, CalcItemWidth() - (alpha_bar ? 2 : 1) * (bars_width + style.ItemInnerSpacing.x)); // Saturation/Value picking box\r\n    float bar0_pos_x = picker_pos.x + sv_picker_size + style.ItemInnerSpacing.x;\r\n    float bar1_pos_x = bar0_pos_x + bars_width + style.ItemInnerSpacing.x;\r\n    float bars_triangles_half_sz = (float)(int)(bars_width * 0.20f);\r\n\r\n    float backup_initial_col[4];\r\n    memcpy(backup_initial_col, col, components * sizeof(float));\r\n\r\n    float wheel_thickness = sv_picker_size * 0.08f;\r\n    float wheel_r_outer = sv_picker_size * 0.50f;\r\n    float wheel_r_inner = wheel_r_outer - wheel_thickness;\r\n    ImVec2 wheel_center(picker_pos.x + (sv_picker_size + bars_width)*0.5f, picker_pos.y + sv_picker_size*0.5f);\r\n    \r\n    // Note: the triangle is displayed rotated with triangle_pa pointing to Hue, but most coordinates stays unrotated for logic.\r\n    float triangle_r = wheel_r_inner - (int)(sv_picker_size * 0.027f);\r\n    ImVec2 triangle_pa = ImVec2(triangle_r, 0.0f); // Hue point.\r\n    ImVec2 triangle_pb = ImVec2(triangle_r * -0.5f, triangle_r * -0.866025f); // Black point.\r\n    ImVec2 triangle_pc = ImVec2(triangle_r * -0.5f, triangle_r * +0.866025f); // White point.\r\n\r\n    float H,S,V;\r\n    ColorConvertRGBtoHSV(col[0], col[1], col[2], H, S, V);\r\n\r\n    bool value_changed = false, value_changed_h = false, value_changed_sv = false;\r\n\r\n    if (flags & ImGuiColorEditFlags_PickerHueWheel)\r\n    {\r\n        // Hue wheel + SV triangle logic\r\n        InvisibleButton(\"hsv\", ImVec2(sv_picker_size + style.ItemInnerSpacing.x + bars_width, sv_picker_size));\r\n        if (IsItemActive())\r\n        {\r\n            ImVec2 initial_off = g.IO.MouseClickedPos[0] - wheel_center;\r\n            ImVec2 current_off = g.IO.MousePos - wheel_center;\r\n            float initial_dist2 = ImLengthSqr(initial_off);\r\n            if (initial_dist2 >= (wheel_r_inner-1)*(wheel_r_inner-1) && initial_dist2 <= (wheel_r_outer+1)*(wheel_r_outer+1))\r\n            {\r\n                // Interactive with Hue wheel\r\n                H = atan2f(current_off.y, current_off.x) / IM_PI*0.5f;\r\n                if (H < 0.0f)\r\n                    H += 1.0f;\r\n                value_changed = value_changed_h = true;\r\n            }\r\n            float cos_hue_angle = cosf(-H * 2.0f * IM_PI);\r\n            float sin_hue_angle = sinf(-H * 2.0f * IM_PI);\r\n            if (ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, ImRotate(initial_off, cos_hue_angle, sin_hue_angle)))\r\n            {\r\n                // Interacting with SV triangle\r\n                ImVec2 current_off_unrotated = ImRotate(current_off, cos_hue_angle, sin_hue_angle);\r\n                if (!ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated))\r\n                    current_off_unrotated = ImTriangleClosestPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated);\r\n                float uu, vv, ww;\r\n                ImTriangleBarycentricCoords(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated, uu, vv, ww);\r\n                V = ImClamp(1.0f - vv, 0.0001f, 1.0f);\r\n                S = ImClamp(uu / V, 0.0001f, 1.0f);\r\n                value_changed = value_changed_sv = true;\r\n            }\r\n        }\r\n        if (!(flags & ImGuiColorEditFlags_NoOptions))\r\n            OpenPopupOnItemClick(\"context\");\r\n    }\r\n    else if (flags & ImGuiColorEditFlags_PickerHueBar)\r\n    {\r\n        // SV rectangle logic\r\n        InvisibleButton(\"sv\", ImVec2(sv_picker_size, sv_picker_size));\r\n        if (IsItemActive())\r\n        {\r\n            S = ImSaturate((io.MousePos.x - picker_pos.x) / (sv_picker_size-1));\r\n            V = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));\r\n            value_changed = value_changed_sv = true;\r\n        }\r\n        if (!(flags & ImGuiColorEditFlags_NoOptions))\r\n            OpenPopupOnItemClick(\"context\");\r\n\r\n        // Hue bar logic\r\n        SetCursorScreenPos(ImVec2(bar0_pos_x, picker_pos.y));\r\n        InvisibleButton(\"hue\", ImVec2(bars_width, sv_picker_size));\r\n        if (IsItemActive())\r\n        {\r\n            H = ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));\r\n            value_changed = value_changed_h = true;\r\n        }\r\n    }\r\n\r\n    // Alpha bar logic\r\n    if (alpha_bar)\r\n    {\r\n        SetCursorScreenPos(ImVec2(bar1_pos_x, picker_pos.y));\r\n        InvisibleButton(\"alpha\", ImVec2(bars_width, sv_picker_size));\r\n        if (IsItemActive())\r\n        {\r\n            col[3] = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));\r\n            value_changed = true;\r\n        }\r\n    }\r\n\r\n    if (!(flags & ImGuiColorEditFlags_NoSidePreview))\r\n    {\r\n        SameLine(0, style.ItemInnerSpacing.x);\r\n        BeginGroup();\r\n    }\r\n\r\n    if (!(flags & ImGuiColorEditFlags_NoLabel))\r\n    {\r\n        const char* label_display_end = FindRenderedTextEnd(label);\r\n        if (label != label_display_end)\r\n        {\r\n            if ((flags & ImGuiColorEditFlags_NoSidePreview))\r\n                SameLine(0, style.ItemInnerSpacing.x);\r\n            TextUnformatted(label, label_display_end);\r\n        }\r\n    }\r\n\r\n    if (!(flags & ImGuiColorEditFlags_NoSidePreview))\r\n    {\r\n        ImVec4 col_v4(col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);\r\n        if ((flags & ImGuiColorEditFlags_NoLabel))\r\n            Text(\"Current\");\r\n        ColorButton(\"##current\", col_v4, (flags & (ImGuiColorEditFlags_HDR|ImGuiColorEditFlags_AlphaPreview|ImGuiColorEditFlags_AlphaPreviewHalf|ImGuiColorEditFlags_NoTooltip)), ImVec2(square_sz * 3, square_sz * 2));\r\n        if (ref_col != NULL)\r\n        {\r\n            Text(\"Original\");\r\n            ImVec4 ref_col_v4(ref_col[0], ref_col[1], ref_col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : ref_col[3]);\r\n            if (ColorButton(\"##original\", ref_col_v4, (flags & (ImGuiColorEditFlags_HDR|ImGuiColorEditFlags_AlphaPreview|ImGuiColorEditFlags_AlphaPreviewHalf|ImGuiColorEditFlags_NoTooltip)), ImVec2(square_sz * 3, square_sz * 2)))\r\n            {\r\n                memcpy(col, ref_col, components * sizeof(float));\r\n                value_changed = true;\r\n            }\r\n        }\r\n        EndGroup();\r\n    }\r\n\r\n    // Convert back color to RGB\r\n    if (value_changed_h || value_changed_sv)\r\n        ColorConvertHSVtoRGB(H >= 1.0f ? H - 10 * 1e-6f : H, S > 0.0f ? S : 10*1e-6f, V > 0.0f ? V : 1e-6f, col[0], col[1], col[2]);\r\n\r\n    // R,G,B and H,S,V slider color editor\r\n    if ((flags & ImGuiColorEditFlags_NoInputs) == 0)\r\n    {\r\n        PushItemWidth((alpha_bar ? bar1_pos_x : bar0_pos_x) + bars_width - picker_pos.x);\r\n        ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoSmallPreview | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf;\r\n        ImGuiColorEditFlags sub_flags = (flags & sub_flags_to_forward) | ImGuiColorEditFlags_NoPicker;\r\n        if (flags & ImGuiColorEditFlags_RGB || (flags & ImGuiColorEditFlags__InputsMask) == 0)\r\n            value_changed |= ColorEdit4(\"##rgb\", col, sub_flags | ImGuiColorEditFlags_RGB);\r\n        if (flags & ImGuiColorEditFlags_HSV || (flags & ImGuiColorEditFlags__InputsMask) == 0)\r\n            value_changed |= ColorEdit4(\"##hsv\", col, sub_flags | ImGuiColorEditFlags_HSV);\r\n        if (flags & ImGuiColorEditFlags_HEX || (flags & ImGuiColorEditFlags__InputsMask) == 0)\r\n            value_changed |= ColorEdit4(\"##hex\", col, sub_flags | ImGuiColorEditFlags_HEX);\r\n        PopItemWidth();\r\n    }\r\n\r\n    // Try to cancel hue wrap (after ColorEdit), if any\r\n    if (value_changed)\r\n    {\r\n        float new_H, new_S, new_V;\r\n        ColorConvertRGBtoHSV(col[0], col[1], col[2], new_H, new_S, new_V);\r\n        if (new_H <= 0 && H > 0) \r\n        {\r\n            if (new_V <= 0 && V != new_V)\r\n                ColorConvertHSVtoRGB(H, S, new_V <= 0 ? V * 0.5f : new_V, col[0], col[1], col[2]);\r\n            else if (new_S <= 0)\r\n                ColorConvertHSVtoRGB(H, new_S <= 0 ? S * 0.5f : new_S, new_V, col[0], col[1], col[2]);\r\n        }\r\n    }\r\n\r\n    ImVec4 hue_color_f(1, 1, 1, 1); ColorConvertHSVtoRGB(H, 1, 1, hue_color_f.x, hue_color_f.y, hue_color_f.z);\r\n    ImU32 hue_color32 = ColorConvertFloat4ToU32(hue_color_f);\r\n    ImU32 col32_no_alpha = ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 1.0f));\r\n\r\n    const ImU32 hue_colors[6+1] = { IM_COL32(255,0,0,255), IM_COL32(255,255,0,255), IM_COL32(0,255,0,255), IM_COL32(0,255,255,255), IM_COL32(0,0,255,255), IM_COL32(255,0,255,255), IM_COL32(255,0,0,255) };\r\n    ImVec2 sv_cursor_pos;\r\n    \r\n    if (flags & ImGuiColorEditFlags_PickerHueWheel)\r\n    {\r\n        // Render Hue Wheel\r\n        const float aeps = 1.5f / wheel_r_outer; // Half a pixel arc length in radians (2pi cancels out).\r\n        const int segment_per_arc = ImMax(4, (int)wheel_r_outer / 12);\r\n        for (int n = 0; n < 6; n++)\r\n        {\r\n            const float a0 = (n)     /6.0f * 2.0f * IM_PI - aeps;\r\n            const float a1 = (n+1.0f)/6.0f * 2.0f * IM_PI + aeps;\r\n            const int vert_start_idx = draw_list->VtxBuffer.Size;\r\n            draw_list->PathArcTo(wheel_center, (wheel_r_inner + wheel_r_outer)*0.5f, a0, a1, segment_per_arc);\r\n            draw_list->PathStroke(IM_COL32_WHITE, false, wheel_thickness);\r\n            const int vert_end_idx = draw_list->VtxBuffer.Size;\r\n\r\n            // Paint colors over existing vertices\r\n            ImVec2 gradient_p0(wheel_center.x + cosf(a0) * wheel_r_inner, wheel_center.y + sinf(a0) * wheel_r_inner);\r\n            ImVec2 gradient_p1(wheel_center.x + cosf(a1) * wheel_r_inner, wheel_center.y + sinf(a1) * wheel_r_inner);\r\n            ShadeVertsLinearColorGradientKeepAlpha(draw_list->VtxBuffer.Data + vert_start_idx, draw_list->VtxBuffer.Data + vert_end_idx, gradient_p0, gradient_p1, hue_colors[n], hue_colors[n+1]);\r\n        }\r\n\r\n        // Render Cursor + preview on Hue Wheel\r\n        float cos_hue_angle = cosf(H * 2.0f * IM_PI);\r\n        float sin_hue_angle = sinf(H * 2.0f * IM_PI);\r\n        ImVec2 hue_cursor_pos(wheel_center.x + cos_hue_angle * (wheel_r_inner+wheel_r_outer)*0.5f, wheel_center.y + sin_hue_angle * (wheel_r_inner+wheel_r_outer)*0.5f);\r\n        float hue_cursor_rad = value_changed_h ? wheel_thickness * 0.65f : wheel_thickness * 0.55f;\r\n        int hue_cursor_segments = ImClamp((int)(hue_cursor_rad / 1.4f), 9, 32);\r\n        draw_list->AddCircleFilled(hue_cursor_pos, hue_cursor_rad, hue_color32, hue_cursor_segments);\r\n        draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad+1, IM_COL32(128,128,128,255), hue_cursor_segments);\r\n        draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad, IM_COL32_WHITE, hue_cursor_segments);\r\n\r\n        // Render SV triangle (rotated according to hue)\r\n        ImVec2 tra = wheel_center + ImRotate(triangle_pa, cos_hue_angle, sin_hue_angle);\r\n        ImVec2 trb = wheel_center + ImRotate(triangle_pb, cos_hue_angle, sin_hue_angle);\r\n        ImVec2 trc = wheel_center + ImRotate(triangle_pc, cos_hue_angle, sin_hue_angle);\r\n        ImVec2 uv_white = GetFontTexUvWhitePixel();\r\n        draw_list->PrimReserve(6, 6);\r\n        draw_list->PrimVtx(tra, uv_white, hue_color32);\r\n        draw_list->PrimVtx(trb, uv_white, hue_color32);\r\n        draw_list->PrimVtx(trc, uv_white, IM_COL32_WHITE);\r\n        draw_list->PrimVtx(tra, uv_white, IM_COL32_BLACK_TRANS);\r\n        draw_list->PrimVtx(trb, uv_white, IM_COL32_BLACK);\r\n        draw_list->PrimVtx(trc, uv_white, IM_COL32_BLACK_TRANS);\r\n        draw_list->AddTriangle(tra, trb, trc, IM_COL32(128,128,128,255), 1.5f);\r\n        sv_cursor_pos = ImLerp(ImLerp(trc, tra, ImSaturate(S)), trb, ImSaturate(1 - V));\r\n    }\r\n    else if (flags & ImGuiColorEditFlags_PickerHueBar)\r\n    {\r\n        // Render SV Square\r\n        draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size,sv_picker_size), IM_COL32_WHITE, hue_color32, hue_color32, IM_COL32_WHITE);\r\n        draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size,sv_picker_size), IM_COL32_BLACK_TRANS, IM_COL32_BLACK_TRANS, IM_COL32_BLACK, IM_COL32_BLACK);\r\n        RenderFrameBorder(picker_pos, picker_pos + ImVec2(sv_picker_size,sv_picker_size), 0.0f);\r\n        sv_cursor_pos.x = ImClamp((float)(int)(picker_pos.x + ImSaturate(S)     * sv_picker_size + 0.5f), picker_pos.x + 2, picker_pos.x + sv_picker_size - 2); // Sneakily prevent the circle to stick out too much\r\n        sv_cursor_pos.y = ImClamp((float)(int)(picker_pos.y + ImSaturate(1 - V) * sv_picker_size + 0.5f), picker_pos.y + 2, picker_pos.y + sv_picker_size - 2);\r\n\r\n        // Render Hue Bar\r\n        for (int i = 0; i < 6; ++i)\r\n            draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), hue_colors[i], hue_colors[i], hue_colors[i + 1], hue_colors[i + 1]);\r\n        float bar0_line_y = (float)(int)(picker_pos.y + H * sv_picker_size + 0.5f);\r\n        RenderFrameBorder(ImVec2(bar0_pos_x, picker_pos.y), ImVec2(bar0_pos_x + bars_width, picker_pos.y + sv_picker_size), 0.0f);\r\n        RenderArrowsForVerticalBar(draw_list, ImVec2(bar0_pos_x - 1, bar0_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f);\r\n    }\r\n\r\n    // Render cursor/preview circle (clamp S/V within 0..1 range because floating points colors may lead HSV values to be out of range)\r\n    float sv_cursor_rad = value_changed_sv ? 10.0f : 6.0f;\r\n    draw_list->AddCircleFilled(sv_cursor_pos, sv_cursor_rad, col32_no_alpha, 12);\r\n    draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad+1, IM_COL32(128,128,128,255), 12);\r\n    draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad, IM_COL32_WHITE, 12);\r\n\r\n    // Render alpha bar\r\n    if (alpha_bar)\r\n    {\r\n        float alpha = ImSaturate(col[3]);\r\n        ImRect bar1_bb(bar1_pos_x, picker_pos.y, bar1_pos_x + bars_width, picker_pos.y + sv_picker_size);\r\n        RenderColorRectWithAlphaCheckerboard(bar1_bb.Min, bar1_bb.Max, IM_COL32(0,0,0,0), bar1_bb.GetWidth() / 2.0f, ImVec2(0.0f, 0.0f));\r\n        draw_list->AddRectFilledMultiColor(bar1_bb.Min, bar1_bb.Max, col32_no_alpha, col32_no_alpha, col32_no_alpha & ~IM_COL32_A_MASK, col32_no_alpha & ~IM_COL32_A_MASK);\r\n        float bar1_line_y = (float)(int)(picker_pos.y + (1.0f - alpha) * sv_picker_size + 0.5f);\r\n        RenderFrameBorder(bar1_bb.Min, bar1_bb.Max, 0.0f);\r\n        RenderArrowsForVerticalBar(draw_list, ImVec2(bar1_pos_x - 1, bar1_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f);\r\n    }\r\n\r\n    EndGroup();\r\n    PopID();\r\n\r\n    return value_changed && memcmp(backup_initial_col, col, components * sizeof(float));\r\n}\r\n\r\n// Horizontal separating line.\r\nvoid ImGui::Separator()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    ImGuiWindowFlags flags = 0;\r\n    if ((flags & (ImGuiSeparatorFlags_Horizontal | ImGuiSeparatorFlags_Vertical)) == 0)\r\n        flags |= (window->DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;\r\n    IM_ASSERT(ImIsPowerOfTwo((int)(flags & (ImGuiSeparatorFlags_Horizontal | ImGuiSeparatorFlags_Vertical))));   // Check that only 1 option is selected\r\n    if (flags & ImGuiSeparatorFlags_Vertical)\r\n    {\r\n        VerticalSeparator();\r\n        return;\r\n    }\r\n\r\n    // Horizontal Separator\r\n    if (window->DC.ColumnsSet)\r\n        PopClipRect();\r\n\r\n    float x1 = window->Pos.x;\r\n    float x2 = window->Pos.x + window->Size.x;\r\n    if (!window->DC.GroupStack.empty())\r\n        x1 += window->DC.IndentX;\r\n\r\n    const ImRect bb(ImVec2(x1, window->DC.CursorPos.y), ImVec2(x2, window->DC.CursorPos.y+1.0f));\r\n    ItemSize(ImVec2(0.0f, 0.0f)); // NB: we don't provide our width so that it doesn't get feed back into AutoFit, we don't provide height to not alter layout.\r\n    if (!ItemAdd(bb, 0))\r\n    {\r\n        if (window->DC.ColumnsSet)\r\n            PushColumnClipRect();\r\n        return;\r\n    }\r\n\r\n    window->DrawList->AddLine(bb.Min, ImVec2(bb.Max.x,bb.Min.y), GetColorU32(ImGuiCol_Separator));\r\n\r\n    if (g.LogEnabled)\r\n            LogRenderedText(NULL, IM_NEWLINE \"--------------------------------\");\r\n\r\n    if (window->DC.ColumnsSet)\r\n    {\r\n        PushColumnClipRect();\r\n        window->DC.ColumnsSet->CellMinY = window->DC.CursorPos.y;\r\n    }\r\n}\r\n\r\nvoid ImGui::VerticalSeparator()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n    ImGuiContext& g = *GImGui;\r\n\r\n    float y1 = window->DC.CursorPos.y;\r\n    float y2 = window->DC.CursorPos.y + window->DC.CurrentLineHeight; \r\n    const ImRect bb(ImVec2(window->DC.CursorPos.x, y1), ImVec2(window->DC.CursorPos.x + 1.0f, y2));\r\n    ItemSize(ImVec2(bb.GetWidth(), 0.0f));\r\n    if (!ItemAdd(bb, 0))\r\n        return;\r\n\r\n    window->DrawList->AddLine(ImVec2(bb.Min.x, bb.Min.y), ImVec2(bb.Min.x, bb.Max.y), GetColorU32(ImGuiCol_Separator));\r\n    if (g.LogEnabled)\r\n        LogText(\" |\");\r\n}\r\n\r\nbool ImGui::SplitterBehavior(ImGuiID id, const ImRect& bb, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    const ImGuiItemFlags item_flags_backup = window->DC.ItemFlags;\r\n#ifdef IMGUI_HAS_NAV\r\n    window->DC.ItemFlags |= ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus;\r\n#endif\r\n    bool add = ItemAdd(bb, id);\r\n    window->DC.ItemFlags = item_flags_backup;\r\n    if (!add)\r\n        return false;\r\n\r\n    bool hovered, held;\r\n    ImRect bb_interact = bb;\r\n    bb_interact.Expand(axis == ImGuiAxis_Y ? ImVec2(0.0f, hover_extend) : ImVec2(hover_extend, 0.0f));\r\n    ButtonBehavior(bb_interact, id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_AllowItemOverlap);\r\n    if (g.ActiveId != id)\r\n        SetItemAllowOverlap();\r\n\r\n    if (held || (g.HoveredId == id && g.HoveredIdPreviousFrame == id))\r\n        SetMouseCursor(axis == ImGuiAxis_Y ? ImGuiMouseCursor_ResizeNS : ImGuiMouseCursor_ResizeEW);\r\n\r\n    ImRect bb_render = bb;\r\n    if (held)\r\n    {\r\n        ImVec2 mouse_delta_2d = g.IO.MousePos - g.ActiveIdClickOffset - bb_interact.Min;\r\n        float mouse_delta = (axis == ImGuiAxis_Y) ? mouse_delta_2d.y : mouse_delta_2d.x;\r\n\r\n        // Minimum pane size\r\n        if (mouse_delta < min_size1 - *size1)\r\n            mouse_delta = min_size1 - *size1;\r\n        if (mouse_delta > *size2 - min_size2)\r\n            mouse_delta = *size2 - min_size2;\r\n\r\n        // Apply resize\r\n        *size1 += mouse_delta;\r\n        *size2 -= mouse_delta;\r\n        bb_render.Translate((axis == ImGuiAxis_X) ? ImVec2(mouse_delta, 0.0f) : ImVec2(0.0f, mouse_delta));\r\n    }\r\n\r\n    // Render\r\n    const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : hovered ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);\r\n    window->DrawList->AddRectFilled(bb_render.Min, bb_render.Max, col, g.Style.FrameRounding);\r\n\r\n    return held;\r\n}\r\n\r\nvoid ImGui::Spacing()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n    ItemSize(ImVec2(0,0));\r\n}\r\n\r\nvoid ImGui::Dummy(const ImVec2& size)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);\r\n    ItemSize(bb);\r\n    ItemAdd(bb, 0);\r\n}\r\n\r\nbool ImGui::IsRectVisible(const ImVec2& size)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->ClipRect.Overlaps(ImRect(window->DC.CursorPos, window->DC.CursorPos + size));\r\n}\r\n\r\nbool ImGui::IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->ClipRect.Overlaps(ImRect(rect_min, rect_max));\r\n}\r\n\r\n// Lock horizontal starting position + capture group bounding box into one \"item\" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)\r\nvoid ImGui::BeginGroup()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n\r\n    window->DC.GroupStack.resize(window->DC.GroupStack.Size + 1);\r\n    ImGuiGroupData& group_data = window->DC.GroupStack.back();\r\n    group_data.BackupCursorPos = window->DC.CursorPos;\r\n    group_data.BackupCursorMaxPos = window->DC.CursorMaxPos;\r\n    group_data.BackupIndentX = window->DC.IndentX;\r\n    group_data.BackupGroupOffsetX = window->DC.GroupOffsetX;\r\n    group_data.BackupCurrentLineHeight = window->DC.CurrentLineHeight;\r\n    group_data.BackupCurrentLineTextBaseOffset = window->DC.CurrentLineTextBaseOffset;\r\n    group_data.BackupLogLinePosY = window->DC.LogLinePosY;\r\n    group_data.BackupActiveIdIsAlive = GImGui->ActiveIdIsAlive;\r\n    group_data.AdvanceCursor = true;\r\n\r\n    window->DC.GroupOffsetX = window->DC.CursorPos.x - window->Pos.x - window->DC.ColumnsOffsetX;\r\n    window->DC.IndentX = window->DC.GroupOffsetX;\r\n    window->DC.CursorMaxPos = window->DC.CursorPos;\r\n    window->DC.CurrentLineHeight = 0.0f;\r\n    window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f;\r\n}\r\n\r\nvoid ImGui::EndGroup()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n\r\n    IM_ASSERT(!window->DC.GroupStack.empty());    // Mismatched BeginGroup()/EndGroup() calls\r\n\r\n    ImGuiGroupData& group_data = window->DC.GroupStack.back();\r\n\r\n    ImRect group_bb(group_data.BackupCursorPos, window->DC.CursorMaxPos);\r\n    group_bb.Max = ImMax(group_bb.Min, group_bb.Max);\r\n\r\n    window->DC.CursorPos = group_data.BackupCursorPos;\r\n    window->DC.CursorMaxPos = ImMax(group_data.BackupCursorMaxPos, window->DC.CursorMaxPos);\r\n    window->DC.CurrentLineHeight = group_data.BackupCurrentLineHeight;\r\n    window->DC.CurrentLineTextBaseOffset = group_data.BackupCurrentLineTextBaseOffset;\r\n    window->DC.IndentX = group_data.BackupIndentX;\r\n    window->DC.GroupOffsetX = group_data.BackupGroupOffsetX;\r\n    window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f;\r\n\r\n    if (group_data.AdvanceCursor)\r\n    {\r\n        window->DC.CurrentLineTextBaseOffset = ImMax(window->DC.PrevLineTextBaseOffset, group_data.BackupCurrentLineTextBaseOffset);      // FIXME: Incorrect, we should grab the base offset from the *first line* of the group but it is hard to obtain now.\r\n        ItemSize(group_bb.GetSize(), group_data.BackupCurrentLineTextBaseOffset);\r\n        ItemAdd(group_bb, 0);\r\n    }\r\n\r\n    // If the current ActiveId was declared within the boundary of our group, we copy it to LastItemId so IsItemActive() will be functional on the entire group.\r\n    // It would be be neater if we replaced window.DC.LastItemId by e.g. 'bool LastItemIsActive', but if you search for LastItemId you'll notice it is only used in that context.\r\n    const bool active_id_within_group = (!group_data.BackupActiveIdIsAlive && g.ActiveIdIsAlive && g.ActiveId && g.ActiveIdWindow->RootWindow == window->RootWindow);\r\n    if (active_id_within_group)\r\n        window->DC.LastItemId = g.ActiveId;\r\n    window->DC.LastItemRect = group_bb;\r\n\r\n    window->DC.GroupStack.pop_back();\r\n\r\n    //window->DrawList->AddRect(group_bb.Min, group_bb.Max, IM_COL32(255,0,255,255));   // [Debug]\r\n}\r\n\r\n// Gets back to previous line and continue with horizontal layout\r\n//      pos_x == 0      : follow right after previous item\r\n//      pos_x != 0      : align to specified x position (relative to window/group left)\r\n//      spacing_w < 0   : use default spacing if pos_x == 0, no spacing if pos_x != 0\r\n//      spacing_w >= 0  : enforce spacing amount\r\nvoid ImGui::SameLine(float pos_x, float spacing_w)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    if (pos_x != 0.0f)\r\n    {\r\n        if (spacing_w < 0.0f) spacing_w = 0.0f;\r\n        window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + pos_x + spacing_w + window->DC.GroupOffsetX + window->DC.ColumnsOffsetX;\r\n        window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;\r\n    }\r\n    else\r\n    {\r\n        if (spacing_w < 0.0f) spacing_w = g.Style.ItemSpacing.x;\r\n        window->DC.CursorPos.x = window->DC.CursorPosPrevLine.x + spacing_w;\r\n        window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;\r\n    }\r\n    window->DC.CurrentLineHeight = window->DC.PrevLineHeight;\r\n    window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset;\r\n}\r\n\r\nvoid ImGui::NewLine()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    const ImGuiLayoutType backup_layout_type = window->DC.LayoutType;\r\n    window->DC.LayoutType = ImGuiLayoutType_Vertical;\r\n    if (window->DC.CurrentLineHeight > 0.0f)     // In the event that we are on a line with items that is smaller that FontSize high, we will preserve its height.\r\n        ItemSize(ImVec2(0,0));\r\n    else\r\n        ItemSize(ImVec2(0.0f, g.FontSize));\r\n    window->DC.LayoutType = backup_layout_type;\r\n}\r\n\r\nvoid ImGui::NextColumn()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    if (window->SkipItems || window->DC.ColumnsSet == NULL)\r\n        return;\r\n\r\n    ImGuiContext& g = *GImGui;\r\n    PopItemWidth();\r\n    PopClipRect();\r\n\r\n    ImGuiColumnsSet* columns = window->DC.ColumnsSet;\r\n    columns->CellMaxY = ImMax(columns->CellMaxY, window->DC.CursorPos.y);\r\n    if (++columns->Current < columns->Count)\r\n    {\r\n        // Columns 1+ cancel out IndentX\r\n        window->DC.ColumnsOffsetX = GetColumnOffset(columns->Current) - window->DC.IndentX + g.Style.ItemSpacing.x;\r\n        window->DrawList->ChannelsSetCurrent(columns->Current);\r\n    }\r\n    else\r\n    {\r\n        window->DC.ColumnsOffsetX = 0.0f;\r\n        window->DrawList->ChannelsSetCurrent(0);\r\n        columns->Current = 0;\r\n        columns->CellMinY = columns->CellMaxY;\r\n    }\r\n    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.IndentX + window->DC.ColumnsOffsetX);\r\n    window->DC.CursorPos.y = columns->CellMinY;\r\n    window->DC.CurrentLineHeight = 0.0f;\r\n    window->DC.CurrentLineTextBaseOffset = 0.0f;\r\n\r\n    PushColumnClipRect();\r\n    PushItemWidth(GetColumnWidth() * 0.65f);  // FIXME: Move on columns setup\r\n}\r\n\r\nint ImGui::GetColumnIndex()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->DC.ColumnsSet ? window->DC.ColumnsSet->Current : 0;\r\n}\r\n\r\nint ImGui::GetColumnsCount()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    return window->DC.ColumnsSet ? window->DC.ColumnsSet->Count : 1;\r\n}\r\n\r\nstatic float OffsetNormToPixels(const ImGuiColumnsSet* columns, float offset_norm)\r\n{\r\n    return offset_norm * (columns->MaxX - columns->MinX);\r\n}\r\n\r\nstatic float PixelsToOffsetNorm(const ImGuiColumnsSet* columns, float offset)\r\n{\r\n    return offset / (columns->MaxX - columns->MinX);\r\n}\r\n\r\nstatic inline float GetColumnsRectHalfWidth() { return 4.0f; }\r\n\r\nstatic float GetDraggedColumnOffset(ImGuiColumnsSet* columns, int column_index)\r\n{\r\n    // Active (dragged) column always follow mouse. The reason we need this is that dragging a column to the right edge of an auto-resizing\r\n    // window creates a feedback loop because we store normalized positions. So while dragging we enforce absolute positioning.\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    IM_ASSERT(column_index > 0); // We cannot drag column 0. If you get this assert you may have a conflict between the ID of your columns and another widgets.\r\n    IM_ASSERT(g.ActiveId == columns->ID + ImGuiID(column_index));\r\n\r\n    float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x + GetColumnsRectHalfWidth() - window->Pos.x;\r\n    x = ImMax(x, ImGui::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);\r\n    if ((columns->Flags & ImGuiColumnsFlags_NoPreserveWidths))\r\n        x = ImMin(x, ImGui::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);\r\n\r\n    return x;\r\n}\r\n\r\nfloat ImGui::GetColumnOffset(int column_index)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    ImGuiColumnsSet* columns = window->DC.ColumnsSet;\r\n    IM_ASSERT(columns != NULL);\r\n\r\n    if (column_index < 0)\r\n        column_index = columns->Current;\r\n    IM_ASSERT(column_index < columns->Columns.Size);\r\n\r\n    /*\r\n    if (g.ActiveId)\r\n    {\r\n        ImGuiContext& g = *GImGui;\r\n        const ImGuiID column_id = columns->ColumnsSetId + ImGuiID(column_index);\r\n        if (g.ActiveId == column_id)\r\n            return GetDraggedColumnOffset(columns, column_index);\r\n    }\r\n    */\r\n\r\n    const float t = columns->Columns[column_index].OffsetNorm;\r\n    const float x_offset = ImLerp(columns->MinX, columns->MaxX, t);\r\n    return x_offset;\r\n}\r\n\r\nstatic float GetColumnWidthEx(ImGuiColumnsSet* columns, int column_index, bool before_resize = false)\r\n{\r\n    if (column_index < 0)\r\n        column_index = columns->Current;\r\n\r\n    float offset_norm;\r\n    if (before_resize)\r\n        offset_norm = columns->Columns[column_index + 1].OffsetNormBeforeResize - columns->Columns[column_index].OffsetNormBeforeResize;\r\n    else\r\n        offset_norm = columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm;\r\n    return OffsetNormToPixels(columns, offset_norm);\r\n}\r\n\r\nfloat ImGui::GetColumnWidth(int column_index)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    ImGuiColumnsSet* columns = window->DC.ColumnsSet;\r\n    IM_ASSERT(columns != NULL);\r\n\r\n    if (column_index < 0)\r\n        column_index = columns->Current;\r\n    return OffsetNormToPixels(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);\r\n}\r\n\r\nvoid ImGui::SetColumnOffset(int column_index, float offset)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    ImGuiColumnsSet* columns = window->DC.ColumnsSet;\r\n    IM_ASSERT(columns != NULL);\r\n\r\n    if (column_index < 0)\r\n        column_index = columns->Current;\r\n    IM_ASSERT(column_index < columns->Columns.Size);\r\n\r\n    const bool preserve_width = !(columns->Flags & ImGuiColumnsFlags_NoPreserveWidths) && (column_index < columns->Count-1);\r\n    const float width = preserve_width ? GetColumnWidthEx(columns, column_index, columns->IsBeingResized) : 0.0f;\r\n\r\n    if (!(columns->Flags & ImGuiColumnsFlags_NoForceWithinWindow))\r\n        offset = ImMin(offset, columns->MaxX - g.Style.ColumnsMinSpacing * (columns->Count - column_index));\r\n    columns->Columns[column_index].OffsetNorm = PixelsToOffsetNorm(columns, offset - columns->MinX);\r\n\r\n    if (preserve_width)\r\n        SetColumnOffset(column_index + 1, offset + ImMax(g.Style.ColumnsMinSpacing, width));\r\n}\r\n\r\nvoid ImGui::SetColumnWidth(int column_index, float width)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    ImGuiColumnsSet* columns = window->DC.ColumnsSet;\r\n    IM_ASSERT(columns != NULL);\r\n\r\n    if (column_index < 0)\r\n        column_index = columns->Current;\r\n    SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width);\r\n}\r\n\r\nvoid ImGui::PushColumnClipRect(int column_index)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindowRead();\r\n    ImGuiColumnsSet* columns = window->DC.ColumnsSet;\r\n    if (column_index < 0)\r\n        column_index = columns->Current;\r\n\r\n    PushClipRect(columns->Columns[column_index].ClipRect.Min, columns->Columns[column_index].ClipRect.Max, false);\r\n}\r\n\r\nstatic ImGuiColumnsSet* FindOrAddColumnsSet(ImGuiWindow* window, ImGuiID id)\r\n{\r\n    for (int n = 0; n < window->ColumnsStorage.Size; n++)\r\n        if (window->ColumnsStorage[n].ID == id)\r\n            return &window->ColumnsStorage[n];\r\n\r\n    window->ColumnsStorage.push_back(ImGuiColumnsSet());\r\n    ImGuiColumnsSet* columns = &window->ColumnsStorage.back();\r\n    columns->ID = id;\r\n    return columns;\r\n}\r\n\r\nvoid ImGui::BeginColumns(const char* str_id, int columns_count, ImGuiColumnsFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n\r\n    IM_ASSERT(columns_count > 1);\r\n    IM_ASSERT(window->DC.ColumnsSet == NULL); // Nested columns are currently not supported\r\n\r\n    // Differentiate column ID with an arbitrary prefix for cases where users name their columns set the same as another widget.\r\n    // In addition, when an identifier isn't explicitly provided we include the number of columns in the hash to make it uniquer.\r\n    PushID(0x11223347 + (str_id ? 0 : columns_count));\r\n    ImGuiID id = window->GetID(str_id ? str_id : \"columns\");\r\n    PopID();\r\n\r\n    // Acquire storage for the columns set\r\n    ImGuiColumnsSet* columns = FindOrAddColumnsSet(window, id);\r\n    IM_ASSERT(columns->ID == id);\r\n    columns->Current = 0;\r\n    columns->Count = columns_count;\r\n    columns->Flags = flags;\r\n    window->DC.ColumnsSet = columns;\r\n\r\n    // Set state for first column\r\n    const float content_region_width = (window->SizeContentsExplicit.x != 0.0f) ? (window->SizeContentsExplicit.x) : (window->Size.x -window->ScrollbarSizes.x);\r\n    columns->MinX = window->DC.IndentX - g.Style.ItemSpacing.x; // Lock our horizontal range\r\n    //column->MaxX = content_region_width - window->Scroll.x - ((window->Flags & ImGuiWindowFlags_NoScrollbar) ? 0 : g.Style.ScrollbarSize);// - window->WindowPadding().x;\r\n    columns->MaxX = content_region_width - window->Scroll.x;\r\n    columns->StartPosY = window->DC.CursorPos.y;\r\n    columns->StartMaxPosX = window->DC.CursorMaxPos.x;\r\n    columns->CellMinY = columns->CellMaxY = window->DC.CursorPos.y;\r\n    window->DC.ColumnsOffsetX = 0.0f;\r\n    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.IndentX + window->DC.ColumnsOffsetX);\r\n\r\n    // Initialize defaults\r\n    columns->IsFirstFrame = (columns->Columns.Size == 0);\r\n    if (columns->Columns.Size == 0)\r\n    {\r\n        columns->Columns.reserve(columns_count + 1);\r\n        for (int n = 0; n < columns_count + 1; n++)\r\n        {\r\n            ImGuiColumnData column;\r\n            column.OffsetNorm = n / (float)columns_count;\r\n            columns->Columns.push_back(column);\r\n        }\r\n    }\r\n    IM_ASSERT(columns->Columns.Size == columns_count + 1);\r\n\r\n    for (int n = 0; n < columns_count + 1; n++)\r\n    {\r\n        // Clamp position\r\n        ImGuiColumnData* column = &columns->Columns[n];\r\n        float t = column->OffsetNorm;\r\n        if (!(columns->Flags & ImGuiColumnsFlags_NoForceWithinWindow))\r\n            t = ImMin(t, PixelsToOffsetNorm(columns, (columns->MaxX - columns->MinX) - g.Style.ColumnsMinSpacing * (columns->Count - n)));\r\n        column->OffsetNorm = t;\r\n\r\n        if (n == columns_count)\r\n            continue;\r\n\r\n        // Compute clipping rectangle\r\n        float clip_x1 = ImFloor(0.5f + window->Pos.x + GetColumnOffset(n) - 1.0f);\r\n        float clip_x2 = ImFloor(0.5f + window->Pos.x + GetColumnOffset(n + 1) - 1.0f);\r\n        column->ClipRect = ImRect(clip_x1, -FLT_MAX, clip_x2, +FLT_MAX);\r\n        column->ClipRect.ClipWith(window->ClipRect);\r\n    }\r\n\r\n    window->DrawList->ChannelsSplit(columns->Count);\r\n    PushColumnClipRect();\r\n    PushItemWidth(GetColumnWidth() * 0.65f);\r\n}\r\n\r\nvoid ImGui::EndColumns()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    ImGuiColumnsSet* columns = window->DC.ColumnsSet;\r\n    IM_ASSERT(columns != NULL);\r\n\r\n    PopItemWidth();\r\n    PopClipRect();\r\n    window->DrawList->ChannelsMerge();\r\n\r\n    columns->CellMaxY = ImMax(columns->CellMaxY, window->DC.CursorPos.y);\r\n    window->DC.CursorPos.y = columns->CellMaxY;\r\n    if (!(columns->Flags & ImGuiColumnsFlags_GrowParentContentsSize))\r\n        window->DC.CursorMaxPos.x = ImMax(columns->StartMaxPosX, columns->MaxX);  // Restore cursor max pos, as columns don't grow parent\r\n\r\n    // Draw columns borders and handle resize\r\n    bool is_being_resized = false;\r\n    if (!(columns->Flags & ImGuiColumnsFlags_NoBorder) && !window->SkipItems)\r\n    {\r\n        const float y1 = columns->StartPosY;\r\n        const float y2 = window->DC.CursorPos.y;\r\n        int dragging_column = -1;\r\n        for (int n = 1; n < columns->Count; n++)\r\n        {\r\n            float x = window->Pos.x + GetColumnOffset(n);\r\n            const ImGuiID column_id = columns->ID + ImGuiID(n);\r\n            const float column_hw = GetColumnsRectHalfWidth(); // Half-width for interaction\r\n            const ImRect column_rect(ImVec2(x - column_hw, y1), ImVec2(x + column_hw, y2));\r\n            KeepAliveID(column_id);\r\n            if (IsClippedEx(column_rect, column_id, false))\r\n                continue;\r\n            \r\n            bool hovered = false, held = false;\r\n            if (!(columns->Flags & ImGuiColumnsFlags_NoResize))\r\n            {\r\n                ButtonBehavior(column_rect, column_id, &hovered, &held);\r\n                if (hovered || held)\r\n                    g.MouseCursor = ImGuiMouseCursor_ResizeEW;\r\n                if (held && !(columns->Columns[n].Flags & ImGuiColumnsFlags_NoResize))\r\n                    dragging_column = n;\r\n            }\r\n\r\n            // Draw column (we clip the Y boundaries CPU side because very long triangles are mishandled by some GPU drivers.)\r\n            const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : hovered ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);\r\n            const float xi = (float)(int)x;\r\n            window->DrawList->AddLine(ImVec2(xi, ImMax(y1 + 1.0f, window->ClipRect.Min.y)), ImVec2(xi, ImMin(y2, window->ClipRect.Max.y)), col);\r\n        }\r\n\r\n        // Apply dragging after drawing the column lines, so our rendered lines are in sync with how items were displayed during the frame.\r\n        if (dragging_column != -1)\r\n        {\r\n            if (!columns->IsBeingResized)\r\n                for (int n = 0; n < columns->Count + 1; n++)\r\n                    columns->Columns[n].OffsetNormBeforeResize = columns->Columns[n].OffsetNorm;\r\n            columns->IsBeingResized = is_being_resized = true;\r\n            float x = GetDraggedColumnOffset(columns, dragging_column);\r\n            SetColumnOffset(dragging_column, x);\r\n        }\r\n    }\r\n    columns->IsBeingResized = is_being_resized;\r\n\r\n    window->DC.ColumnsSet = NULL;\r\n    window->DC.ColumnsOffsetX = 0.0f;\r\n    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.IndentX + window->DC.ColumnsOffsetX);\r\n}\r\n\r\n// [2017/12: This is currently the only public API, while we are working on making BeginColumns/EndColumns user-facing]\r\nvoid ImGui::Columns(int columns_count, const char* id, bool border)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    IM_ASSERT(columns_count >= 1);\r\n    if (window->DC.ColumnsSet != NULL && window->DC.ColumnsSet->Count != columns_count)\r\n        EndColumns();\r\n    \r\n    ImGuiColumnsFlags flags = (border ? 0 : ImGuiColumnsFlags_NoBorder);\r\n    //flags |= ImGuiColumnsFlags_NoPreserveWidths; // NB: Legacy behavior\r\n    if (columns_count != 1)\r\n        BeginColumns(id, columns_count, flags);\r\n}\r\n\r\nvoid ImGui::Indent(float indent_w)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.IndentX += (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;\r\n    window->DC.CursorPos.x = window->Pos.x + window->DC.IndentX + window->DC.ColumnsOffsetX;\r\n}\r\n\r\nvoid ImGui::Unindent(float indent_w)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    window->DC.IndentX -= (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;\r\n    window->DC.CursorPos.x = window->Pos.x + window->DC.IndentX + window->DC.ColumnsOffsetX;\r\n}\r\n\r\nvoid ImGui::TreePush(const char* str_id)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    Indent();\r\n    window->DC.TreeDepth++;\r\n    PushID(str_id ? str_id : \"#TreePush\");\r\n}\r\n\r\nvoid ImGui::TreePush(const void* ptr_id)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    Indent();\r\n    window->DC.TreeDepth++;\r\n    PushID(ptr_id ? ptr_id : (const void*)\"#TreePush\");\r\n}\r\n\r\nvoid ImGui::TreePushRawID(ImGuiID id)\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    Indent();\r\n    window->DC.TreeDepth++;\r\n    window->IDStack.push_back(id);\r\n}\r\n\r\nvoid ImGui::TreePop()\r\n{\r\n    ImGuiWindow* window = GetCurrentWindow();\r\n    Unindent();\r\n    window->DC.TreeDepth--;\r\n    PopID();\r\n}\r\n\r\nvoid ImGui::Value(const char* prefix, bool b)\r\n{\r\n    Text(\"%s: %s\", prefix, (b ? \"true\" : \"false\"));\r\n}\r\n\r\nvoid ImGui::Value(const char* prefix, int v)\r\n{\r\n    Text(\"%s: %d\", prefix, v);\r\n}\r\n\r\nvoid ImGui::Value(const char* prefix, unsigned int v)\r\n{\r\n    Text(\"%s: %d\", prefix, v);\r\n}\r\n\r\nvoid ImGui::Value(const char* prefix, float v, const char* float_format)\r\n{\r\n    if (float_format)\r\n    {\r\n        char fmt[64];\r\n        ImFormatString(fmt, IM_ARRAYSIZE(fmt), \"%%s: %s\", float_format);\r\n        Text(fmt, prefix, v);\r\n    }\r\n    else\r\n    {\r\n        Text(\"%s: %.3f\", prefix, v);\r\n    }\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// DRAG AND DROP\r\n//-----------------------------------------------------------------------------\r\n\r\nvoid ImGui::ClearDragDrop()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.DragDropActive = false;\r\n    g.DragDropPayload.Clear();\r\n    g.DragDropAcceptIdCurr = g.DragDropAcceptIdPrev = 0;\r\n    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;\r\n    g.DragDropAcceptFrameCount = -1;\r\n}\r\n\r\n// Call when current ID is active. \r\n// When this returns true you need to: a) call SetDragDropPayload() exactly once, b) you may render the payload visual/description, c) call EndDragDropSource()\r\nbool ImGui::BeginDragDropSource(ImGuiDragDropFlags flags, int mouse_button)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n\r\n    bool source_drag_active = false;\r\n    ImGuiID source_id = 0;\r\n    ImGuiID source_parent_id = 0;\r\n    if (!(flags & ImGuiDragDropFlags_SourceExtern))\r\n    {\r\n        source_id = window->DC.LastItemId;\r\n        if (source_id != 0 && g.ActiveId != source_id) // Early out for most common case\r\n            return false;\r\n        if (g.IO.MouseDown[mouse_button] == false)\r\n            return false;\r\n\r\n        if (source_id == 0)\r\n        {\r\n            // If you want to use BeginDragDropSource() on an item with no unique identifier for interaction, such as Text() or Image(), you need to:\r\n            // A) Read the explanation below, B) Use the ImGuiDragDropFlags_SourceAllowNullID flag, C) Swallow your programmer pride.\r\n            if (!(flags & ImGuiDragDropFlags_SourceAllowNullID))\r\n            {\r\n                IM_ASSERT(0);\r\n                return false;\r\n            }\r\n\r\n            // Magic fallback (=somehow reprehensible) to handle items with no assigned ID, e.g. Text(), Image()\r\n            // We build a throwaway ID based on current ID stack + relative AABB of items in window. \r\n            // THE IDENTIFIER WON'T SURVIVE ANY REPOSITIONING OF THE WIDGET, so if your widget moves your dragging operation will be canceled. \r\n            // We don't need to maintain/call ClearActiveID() as releasing the button will early out this function and trigger !ActiveIdIsAlive.\r\n            bool is_hovered = window->DC.LastItemRectHoveredRect;\r\n            if (!is_hovered && (g.ActiveId == 0 || g.ActiveIdWindow != window))\r\n                return false;\r\n            source_id = window->DC.LastItemId = window->GetIDFromRectangle(window->DC.LastItemRect);\r\n            if (is_hovered)\r\n                SetHoveredID(source_id);\r\n            if (is_hovered && g.IO.MouseClicked[mouse_button])\r\n            {\r\n                SetActiveID(source_id, window);\r\n                FocusWindow(window);\r\n            }\r\n            if (g.ActiveId == source_id) // Allow the underlying widget to display/return hovered during the mouse release frame, else we would get a flicker.\r\n                g.ActiveIdAllowOverlap = is_hovered;\r\n        }\r\n        if (g.ActiveId != source_id)\r\n            return false;\r\n        source_parent_id = window->IDStack.back();\r\n        source_drag_active = IsMouseDragging(mouse_button);\r\n    }\r\n    else\r\n    {\r\n        window = NULL;\r\n        source_id = ImHash(\"#SourceExtern\", 0);\r\n        source_drag_active = true;\r\n    }\r\n\r\n    if (source_drag_active)\r\n    {\r\n        if (!g.DragDropActive)\r\n        {\r\n            IM_ASSERT(source_id != 0);\r\n            ClearDragDrop();\r\n            ImGuiPayload& payload = g.DragDropPayload;\r\n            payload.SourceId = source_id;\r\n            payload.SourceParentId = source_parent_id;\r\n            g.DragDropActive = true;\r\n            g.DragDropSourceFlags = flags;\r\n            g.DragDropMouseButton = mouse_button;\r\n        }\r\n\r\n        if (!(flags & ImGuiDragDropFlags_SourceNoPreviewTooltip))\r\n        {\r\n            // FIXME-DRAG\r\n            //SetNextWindowPos(g.IO.MousePos - g.ActiveIdClickOffset - g.Style.WindowPadding);\r\n            //PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * 0.60f); // This is better but e.g ColorButton with checkboard has issue with transparent colors :(\r\n            SetNextWindowPos(g.IO.MousePos);\r\n            PushStyleColor(ImGuiCol_PopupBg, GetStyleColorVec4(ImGuiCol_PopupBg) * ImVec4(1.0f, 1.0f, 1.0f, 0.6f));\r\n            BeginTooltipEx(ImGuiWindowFlags_NoInputs);\r\n        }\r\n\r\n        if (!(flags & ImGuiDragDropFlags_SourceNoDisableHover) && !(flags & ImGuiDragDropFlags_SourceExtern))\r\n            window->DC.LastItemRectHoveredRect = false;\r\n\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nvoid ImGui::EndDragDropSource()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    IM_ASSERT(g.DragDropActive);\r\n\r\n    if (!(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))\r\n    {\r\n        EndTooltip();\r\n        PopStyleColor();\r\n        //PopStyleVar();\r\n    }\r\n\r\n    // Discard the drag if have not called SetDragDropPayload()\r\n    if (g.DragDropPayload.DataFrameCount == -1)\r\n        ClearDragDrop();\r\n}\r\n\r\n// Use 'cond' to choose to submit payload on drag start or every frame\r\nbool ImGui::SetDragDropPayload(const char* type, const void* data, size_t data_size, ImGuiCond cond)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiPayload& payload = g.DragDropPayload;\r\n    if (cond == 0)\r\n        cond = ImGuiCond_Always;\r\n\r\n    IM_ASSERT(type != NULL);\r\n    IM_ASSERT(strlen(type) < IM_ARRAYSIZE(payload.DataType));       // Payload type can be at most 8 characters longs\r\n    IM_ASSERT((data != NULL && data_size > 0) || (data == NULL && data_size == 0));\r\n    IM_ASSERT(cond == ImGuiCond_Always || cond == ImGuiCond_Once);\r\n    IM_ASSERT(payload.SourceId != 0);                               // Not called between BeginDragDropSource() and EndDragDropSource()\r\n\r\n    if (cond == ImGuiCond_Always || payload.DataFrameCount == -1)\r\n    {\r\n        // Copy payload\r\n        ImStrncpy(payload.DataType, type, IM_ARRAYSIZE(payload.DataType));\r\n        g.DragDropPayloadBufHeap.resize(0);\r\n        if (data_size > sizeof(g.DragDropPayloadBufLocal))\r\n        {\r\n            // Store in heap\r\n            g.DragDropPayloadBufHeap.resize((int)data_size);\r\n            payload.Data = g.DragDropPayloadBufHeap.Data;\r\n            memcpy((void*)payload.Data, data, data_size);\r\n        }\r\n        else if (data_size > 0)\r\n        {\r\n            // Store locally\r\n            memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));\r\n            payload.Data = g.DragDropPayloadBufLocal;\r\n            memcpy((void*)payload.Data, data, data_size);\r\n        }\r\n        else\r\n        {\r\n            payload.Data = NULL;\r\n        }\r\n        payload.DataSize = (int)data_size;\r\n    }\r\n    payload.DataFrameCount = g.FrameCount;\r\n\r\n    return (g.DragDropAcceptFrameCount == g.FrameCount) || (g.DragDropAcceptFrameCount == g.FrameCount - 1);\r\n}\r\n\r\nbool ImGui::BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (!g.DragDropActive)\r\n        return false;\r\n\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    if (g.HoveredWindow == NULL || window->RootWindow != g.HoveredWindow->RootWindow)\r\n        return false;\r\n    IM_ASSERT(id != 0);\r\n    if (!IsMouseHoveringRect(bb.Min, bb.Max) || (id == g.DragDropPayload.SourceId))\r\n        return false;\r\n\r\n    g.DragDropTargetRect = bb;\r\n    g.DragDropTargetId = id;\r\n    return true;\r\n}\r\n\r\n// We don't use BeginDragDropTargetCustom() and duplicate its code because:\r\n// 1) we use LastItemRectHoveredRect which handles items that pushes a temporarily clip rectangle in their code. Calling BeginDragDropTargetCustom(LastItemRect) would not handle them.\r\n// 2) and it's faster. as this code may be very frequently called, we want to early out as fast as we can.\r\n// Also note how the HoveredWindow test is positioned differently in both functions (in both functions we optimize for the cheapest early out case)\r\nbool ImGui::BeginDragDropTarget()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    if (!g.DragDropActive)\r\n        return false;\r\n\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    if (!window->DC.LastItemRectHoveredRect)\r\n        return false;\r\n    if (g.HoveredWindow == NULL || window->RootWindow != g.HoveredWindow->RootWindow)\r\n        return false;\r\n\r\n    ImGuiID id = window->DC.LastItemId;\r\n    if (id == 0)\r\n        id = window->GetIDFromRectangle(window->DC.LastItemRect);\r\n    if (g.DragDropPayload.SourceId == id)\r\n        return false;\r\n\r\n    g.DragDropTargetRect = window->DC.LastItemRect;\r\n    g.DragDropTargetId = id;\r\n    return true;\r\n}\r\n\r\nbool ImGui::IsDragDropPayloadBeingAccepted()\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.DragDropActive && g.DragDropAcceptIdPrev != 0;\r\n}\r\n\r\nconst ImGuiPayload* ImGui::AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    ImGuiWindow* window = g.CurrentWindow;\r\n    ImGuiPayload& payload = g.DragDropPayload;\r\n    IM_ASSERT(g.DragDropActive);                        // Not called between BeginDragDropTarget() and EndDragDropTarget() ?\r\n    IM_ASSERT(payload.DataFrameCount != -1);            // Forgot to call EndDragDropTarget() ? \r\n    if (type != NULL && !payload.IsDataType(type))\r\n        return NULL;\r\n\r\n    // Accept smallest drag target bounding box, this allows us to nest drag targets conveniently without ordering constraints.\r\n    // NB: We currently accept NULL id as target. However, overlapping targets requires a unique ID to function!\r\n    const bool was_accepted_previously = (g.DragDropAcceptIdPrev == g.DragDropTargetId);\r\n    ImRect r = g.DragDropTargetRect;\r\n    float r_surface = r.GetWidth() * r.GetHeight();\r\n    if (r_surface < g.DragDropAcceptIdCurrRectSurface)\r\n    {\r\n        g.DragDropAcceptIdCurr = g.DragDropTargetId;\r\n        g.DragDropAcceptIdCurrRectSurface = r_surface;\r\n    }\r\n\r\n    // Render default drop visuals\r\n    payload.Preview = was_accepted_previously;\r\n    flags |= (g.DragDropSourceFlags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect); // Source can also inhibit the preview (useful for external sources that lives for 1 frame)\r\n    if (!(flags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect) && payload.Preview)\r\n    {\r\n        // FIXME-DRAG: Settle on a proper default visuals for drop target.\r\n        r.Expand(3.5f);\r\n        bool push_clip_rect = !window->ClipRect.Contains(r);\r\n        if (push_clip_rect) window->DrawList->PushClipRectFullScreen();\r\n        window->DrawList->AddRect(r.Min, r.Max, GetColorU32(ImGuiCol_DragDropTarget), 0.0f, ~0, 2.0f);\r\n        if (push_clip_rect) window->DrawList->PopClipRect();\r\n    }\r\n\r\n    g.DragDropAcceptFrameCount = g.FrameCount;\r\n    payload.Delivery = was_accepted_previously && !IsMouseDown(g.DragDropMouseButton); // For extern drag sources affecting os window focus, it's easier to just test !IsMouseDown() instead of IsMouseReleased()\r\n    if (!payload.Delivery && !(flags & ImGuiDragDropFlags_AcceptBeforeDelivery))\r\n        return NULL;\r\n\r\n    return &payload;\r\n}\r\n\r\n// We don't really use/need this now, but added it for the sake of consistency and because we might need it later.\r\nvoid ImGui::EndDragDropTarget()\r\n{\r\n    ImGuiContext& g = *GImGui; (void)g;\r\n    IM_ASSERT(g.DragDropActive);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// PLATFORM DEPENDENT HELPERS\r\n//-----------------------------------------------------------------------------\r\n\r\n#if defined(_WIN32) && !defined(_WINDOWS_) && (!defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS) || !defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS))\r\n#undef WIN32_LEAN_AND_MEAN\r\n#define WIN32_LEAN_AND_MEAN\r\n#include <Windows.h>\r\n#endif\r\n\r\n// Win32 API clipboard implementation\r\n#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS)\r\n\r\n#ifdef _MSC_VER\r\n#pragma comment(lib, \"user32\")\r\n#endif\r\n\r\nstatic const char* GetClipboardTextFn_DefaultImpl(void*)\r\n{\r\n    static ImVector<char> buf_local;\r\n    buf_local.clear();\r\n    if (!OpenClipboard(NULL))\r\n        return NULL;\r\n    HANDLE wbuf_handle = GetClipboardData(CF_UNICODETEXT);\r\n    if (wbuf_handle == NULL)\r\n    {\r\n        CloseClipboard();\r\n        return NULL;\r\n    }\r\n    if (ImWchar* wbuf_global = (ImWchar*)GlobalLock(wbuf_handle))\r\n    {\r\n        int buf_len = ImTextCountUtf8BytesFromStr(wbuf_global, NULL) + 1;\r\n        buf_local.resize(buf_len);\r\n        ImTextStrToUtf8(buf_local.Data, buf_len, wbuf_global, NULL);\r\n    }\r\n    GlobalUnlock(wbuf_handle);\r\n    CloseClipboard();\r\n    return buf_local.Data;\r\n}\r\n\r\nstatic void SetClipboardTextFn_DefaultImpl(void*, const char* text)\r\n{\r\n    if (!OpenClipboard(NULL))\r\n        return;\r\n    const int wbuf_length = ImTextCountCharsFromUtf8(text, NULL) + 1;\r\n    HGLOBAL wbuf_handle = GlobalAlloc(GMEM_MOVEABLE, (SIZE_T)wbuf_length * sizeof(ImWchar));\r\n    if (wbuf_handle == NULL)\r\n    {\r\n        CloseClipboard();\r\n        return;\r\n    }\r\n    ImWchar* wbuf_global = (ImWchar*)GlobalLock(wbuf_handle);\r\n    ImTextStrFromUtf8(wbuf_global, wbuf_length, text, NULL);\r\n    GlobalUnlock(wbuf_handle);\r\n    EmptyClipboard();\r\n    SetClipboardData(CF_UNICODETEXT, wbuf_handle);\r\n    CloseClipboard();\r\n}\r\n\r\n#else\r\n\r\n// Local ImGui-only clipboard implementation, if user hasn't defined better clipboard handlers\r\nstatic const char* GetClipboardTextFn_DefaultImpl(void*)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    return g.PrivateClipboard.empty() ? NULL : g.PrivateClipboard.begin();\r\n}\r\n\r\n// Local ImGui-only clipboard implementation, if user hasn't defined better clipboard handlers\r\nstatic void SetClipboardTextFn_DefaultImpl(void*, const char* text)\r\n{\r\n    ImGuiContext& g = *GImGui;\r\n    g.PrivateClipboard.clear();\r\n    const char* text_end = text + strlen(text);\r\n    g.PrivateClipboard.resize((int)(text_end - text) + 1);\r\n    memcpy(&g.PrivateClipboard[0], text, (size_t)(text_end - text));\r\n    g.PrivateClipboard[(int)(text_end - text)] = 0;\r\n}\r\n\r\n#endif\r\n\r\n// Win32 API IME support (for Asian languages, etc.)\r\n#if defined(_WIN32) && !defined(__GNUC__) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS)\r\n\r\n#include <imm.h>\r\n#ifdef _MSC_VER\r\n#pragma comment(lib, \"imm32\")\r\n#endif\r\n\r\nstatic void ImeSetInputScreenPosFn_DefaultImpl(int x, int y)\r\n{\r\n    // Notify OS Input Method Editor of text input position\r\n    if (HWND hwnd = (HWND)GImGui->IO.ImeWindowHandle)\r\n        if (HIMC himc = ImmGetContext(hwnd))\r\n        {\r\n            COMPOSITIONFORM cf;\r\n            cf.ptCurrentPos.x = x;\r\n            cf.ptCurrentPos.y = y;\r\n            cf.dwStyle = CFS_FORCE_POSITION;\r\n            ImmSetCompositionWindow(himc, &cf);\r\n        }\r\n}\r\n\r\n#else\r\n\r\nstatic void ImeSetInputScreenPosFn_DefaultImpl(int, int) {}\r\n\r\n#endif\r\n\r\n//-----------------------------------------------------------------------------\r\n// HELP\r\n//-----------------------------------------------------------------------------\r\n\r\nvoid ImGui::ShowMetricsWindow(bool* p_open)\r\n{\r\n    if (ImGui::Begin(\"ImGui Metrics\", p_open))\r\n    {\r\n        ImGui::Text(\"ImGui %s\", ImGui::GetVersion());\r\n        ImGui::Text(\"Application average %.3f ms/frame (%.1f FPS)\", 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);\r\n        ImGui::Text(\"%d vertices, %d indices (%d triangles)\", ImGui::GetIO().MetricsRenderVertices, ImGui::GetIO().MetricsRenderIndices, ImGui::GetIO().MetricsRenderIndices / 3);\r\n        ImGui::Text(\"%d allocations\", ImGui::GetIO().MetricsAllocs);\r\n        static bool show_clip_rects = true;\r\n        ImGui::Checkbox(\"Show clipping rectangles when hovering an ImDrawCmd\", &show_clip_rects);\r\n        ImGui::Separator();\r\n\r\n        struct Funcs\r\n        {\r\n            static void NodeDrawList(ImDrawList* draw_list, const char* label)\r\n            {\r\n                bool node_open = ImGui::TreeNode(draw_list, \"%s: '%s' %d vtx, %d indices, %d cmds\", label, draw_list->_OwnerName ? draw_list->_OwnerName : \"\", draw_list->VtxBuffer.Size, draw_list->IdxBuffer.Size, draw_list->CmdBuffer.Size);\r\n                if (draw_list == ImGui::GetWindowDrawList())\r\n                {\r\n                    ImGui::SameLine();\r\n                    ImGui::TextColored(ImColor(255,100,100), \"CURRENTLY APPENDING\"); // Can't display stats for active draw list! (we don't have the data double-buffered)\r\n                    if (node_open) ImGui::TreePop();\r\n                    return;\r\n                }\r\n                if (!node_open)\r\n                    return;\r\n\r\n                ImDrawList* overlay_draw_list = &GImGui->OverlayDrawList;   // Render additional visuals into the top-most draw list\r\n                int elem_offset = 0;\r\n                for (const ImDrawCmd* pcmd = draw_list->CmdBuffer.begin(); pcmd < draw_list->CmdBuffer.end(); elem_offset += pcmd->ElemCount, pcmd++)\r\n                {\r\n                    if (pcmd->UserCallback == NULL && pcmd->ElemCount == 0)\r\n                        continue;\r\n                    if (pcmd->UserCallback)\r\n                    {\r\n                        ImGui::BulletText(\"Callback %p, user_data %p\", pcmd->UserCallback, pcmd->UserCallbackData);\r\n                        continue;\r\n                    }\r\n                    ImDrawIdx* idx_buffer = (draw_list->IdxBuffer.Size > 0) ? draw_list->IdxBuffer.Data : NULL;\r\n                    bool pcmd_node_open = ImGui::TreeNode((void*)(pcmd - draw_list->CmdBuffer.begin()), \"Draw %-4d %s vtx, tex = %p, clip_rect = (%.0f,%.0f)..(%.0f,%.0f)\", pcmd->ElemCount, draw_list->IdxBuffer.Size > 0 ? \"indexed\" : \"non-indexed\", pcmd->TextureId, pcmd->ClipRect.x, pcmd->ClipRect.y, pcmd->ClipRect.z, pcmd->ClipRect.w);\r\n                    if (show_clip_rects && ImGui::IsItemHovered())\r\n                    {\r\n                        ImRect clip_rect = pcmd->ClipRect;\r\n                        ImRect vtxs_rect;\r\n                        for (int i = elem_offset; i < elem_offset + (int)pcmd->ElemCount; i++)\r\n                            vtxs_rect.Add(draw_list->VtxBuffer[idx_buffer ? idx_buffer[i] : i].pos);\r\n                        clip_rect.Floor(); overlay_draw_list->AddRect(clip_rect.Min, clip_rect.Max, IM_COL32(255,255,0,255));\r\n                        vtxs_rect.Floor(); overlay_draw_list->AddRect(vtxs_rect.Min, vtxs_rect.Max, IM_COL32(255,0,255,255));\r\n                    }\r\n                    if (!pcmd_node_open)\r\n                        continue;\r\n\r\n                    // Display individual triangles/vertices. Hover on to get the corresponding triangle highlighted.\r\n                    ImGuiListClipper clipper(pcmd->ElemCount/3); // Manually coarse clip our print out of individual vertices to save CPU, only items that may be visible.\r\n                    while (clipper.Step())\r\n                        for (int prim = clipper.DisplayStart, vtx_i = elem_offset + clipper.DisplayStart*3; prim < clipper.DisplayEnd; prim++)\r\n                        {\r\n                            char buf[300];\r\n                            char *buf_p = buf, *buf_end = buf + IM_ARRAYSIZE(buf);\r\n                            ImVec2 triangles_pos[3];\r\n                            for (int n = 0; n < 3; n++, vtx_i++)\r\n                            {\r\n                                ImDrawVert& v = draw_list->VtxBuffer[idx_buffer ? idx_buffer[vtx_i] : vtx_i];\r\n                                triangles_pos[n] = v.pos;\r\n                                buf_p += ImFormatString(buf_p, (int)(buf_end - buf_p), \"%s %04d { pos = (%8.2f,%8.2f), uv = (%.6f,%.6f), col = %08X }\\n\", (n == 0) ? \"vtx\" : \"   \", vtx_i, v.pos.x, v.pos.y, v.uv.x, v.uv.y, v.col);\r\n                            }\r\n                            ImGui::Selectable(buf, false);\r\n                            if (ImGui::IsItemHovered())\r\n                            {\r\n                                ImDrawListFlags backup_flags = overlay_draw_list->Flags;\r\n                                overlay_draw_list->Flags &= ~ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines at is more readable for very large and thin triangles.\r\n                                overlay_draw_list->AddPolyline(triangles_pos, 3, IM_COL32(255,255,0,255), true, 1.0f);\r\n                                overlay_draw_list->Flags = backup_flags;\r\n                            }\r\n                        }\r\n                    ImGui::TreePop();\r\n                }\r\n                ImGui::TreePop();\r\n            }\r\n\r\n            static void NodeWindows(ImVector<ImGuiWindow*>& windows, const char* label)\r\n            {\r\n                if (!ImGui::TreeNode(label, \"%s (%d)\", label, windows.Size))\r\n                    return;\r\n                for (int i = 0; i < windows.Size; i++)\r\n                    Funcs::NodeWindow(windows[i], \"Window\");\r\n                ImGui::TreePop();\r\n            }\r\n\r\n            static void NodeWindow(ImGuiWindow* window, const char* label)\r\n            {\r\n                if (!ImGui::TreeNode(window, \"%s '%s', %d @ 0x%p\", label, window->Name, window->Active || window->WasActive, window))\r\n                    return;\r\n                NodeDrawList(window->DrawList, \"DrawList\");\r\n                ImGui::BulletText(\"Pos: (%.1f,%.1f), Size: (%.1f,%.1f), SizeContents (%.1f,%.1f)\", window->Pos.x, window->Pos.y, window->Size.x, window->Size.y, window->SizeContents.x, window->SizeContents.y);\r\n                if (ImGui::IsItemHovered())\r\n                    GImGui->OverlayDrawList.AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255,255,0,255));\r\n                ImGui::BulletText(\"Scroll: (%.2f/%.2f,%.2f/%.2f)\", window->Scroll.x, GetScrollMaxX(window), window->Scroll.y, GetScrollMaxY(window));\r\n                ImGui::BulletText(\"Active: %d, WriteAccessed: %d\", window->Active, window->WriteAccessed);\r\n                if (window->RootWindow != window) NodeWindow(window->RootWindow, \"RootWindow\");\r\n                if (window->DC.ChildWindows.Size > 0) NodeWindows(window->DC.ChildWindows, \"ChildWindows\");\r\n                ImGui::BulletText(\"Storage: %d bytes\", window->StateStorage.Data.Size * (int)sizeof(ImGuiStorage::Pair));\r\n                ImGui::TreePop();\r\n            }\r\n        };\r\n\r\n        ImGuiContext& g = *GImGui;                // Access private state\r\n        Funcs::NodeWindows(g.Windows, \"Windows\");\r\n        if (ImGui::TreeNode(\"DrawList\", \"Active DrawLists (%d)\", g.RenderDrawLists[0].Size))\r\n        {\r\n            for (int layer = 0; layer < IM_ARRAYSIZE(g.RenderDrawLists); layer++)\r\n                for (int i = 0; i < g.RenderDrawLists[layer].Size; i++)\r\n                    Funcs::NodeDrawList(g.RenderDrawLists[0][i], \"DrawList\");\r\n            ImGui::TreePop();\r\n        }\r\n        if (ImGui::TreeNode(\"Popups\", \"Open Popups Stack (%d)\", g.OpenPopupStack.Size))\r\n        {\r\n            for (int i = 0; i < g.OpenPopupStack.Size; i++)\r\n            {\r\n                ImGuiWindow* window = g.OpenPopupStack[i].Window;\r\n                ImGui::BulletText(\"PopupID: %08x, Window: '%s'%s%s\", g.OpenPopupStack[i].PopupId, window ? window->Name : \"NULL\", window && (window->Flags & ImGuiWindowFlags_ChildWindow) ? \" ChildWindow\" : \"\", window && (window->Flags & ImGuiWindowFlags_ChildMenu) ? \" ChildMenu\" : \"\");\r\n            }\r\n            ImGui::TreePop();\r\n        }\r\n        if (ImGui::TreeNode(\"Basic state\"))\r\n        {\r\n            ImGui::Text(\"HoveredWindow: '%s'\", g.HoveredWindow ? g.HoveredWindow->Name : \"NULL\");\r\n            ImGui::Text(\"HoveredRootWindow: '%s'\", g.HoveredRootWindow ? g.HoveredRootWindow->Name : \"NULL\");\r\n            ImGui::Text(\"HoveredId: 0x%08X/0x%08X (%.2f sec)\", g.HoveredId, g.HoveredIdPreviousFrame, g.HoveredIdTimer); // Data is \"in-flight\" so depending on when the Metrics window is called we may see current frame information or not\r\n            ImGui::Text(\"ActiveId: 0x%08X/0x%08X (%.2f sec)\", g.ActiveId, g.ActiveIdPreviousFrame, g.ActiveIdTimer);\r\n            ImGui::Text(\"ActiveIdWindow: '%s'\", g.ActiveIdWindow ? g.ActiveIdWindow->Name : \"NULL\");\r\n            ImGui::Text(\"NavWindow: '%s'\", g.NavWindow ? g.NavWindow->Name : \"NULL\");\r\n            ImGui::TreePop();\r\n        }\r\n    }\r\n    ImGui::End();\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n\r\n// Include imgui_user.inl at the end of imgui.cpp to access private data/functions that aren't exposed.\r\n// Prefer just including imgui_internal.h from your code rather than using this define. If a declaration is missing from imgui_internal.h add it or request it on the github.\r\n#ifdef IMGUI_INCLUDE_IMGUI_USER_INL\r\n#include \"imgui_user.inl\"\r\n#endif\r\n\r\n//-----------------------------------------------------------------------------\r\n","// dear imgui, v1.53\r\n// (internals)\r\n\r\n// You may use this file to debug, understand or extend ImGui features but we don't provide any guarantee of forward compatibility!\r\n// Set:\r\n//   #define IMGUI_DEFINE_MATH_OPERATORS\r\n// To implement maths operators for ImVec2 (disabled by default to not collide with using IM_VEC2_CLASS_EXTRA along with your own math types+operators)\r\n\r\n#pragma once\r\n\r\n#ifndef IMGUI_VERSION\r\n#error Must include imgui.h before imgui_internal.h\r\n#endif\r\n\r\n#include <stdio.h>      // FILE*\r\n#include <math.h>       // sqrtf, fabsf, fmodf, powf, floorf, ceilf, cosf, sinf\r\n\r\n#ifdef _MSC_VER\r\n#pragma warning (push)\r\n#pragma warning (disable: 4251) // class 'xxx' needs to have dll-interface to be used by clients of struct 'xxx' // when IMGUI_API is set to__declspec(dllexport)\r\n#endif\r\n\r\n#ifdef __clang__\r\n#pragma clang diagnostic push\r\n#pragma clang diagnostic ignored \"-Wunused-function\"        // for stb_textedit.h\r\n#pragma clang diagnostic ignored \"-Wmissing-prototypes\"     // for stb_textedit.h\r\n#pragma clang diagnostic ignored \"-Wold-style-cast\"\r\n#endif\r\n\r\n//-----------------------------------------------------------------------------\r\n// Forward Declarations\r\n//-----------------------------------------------------------------------------\r\n\r\nstruct ImRect;\r\nstruct ImGuiColMod;\r\nstruct ImGuiStyleMod;\r\nstruct ImGuiGroupData;\r\nstruct ImGuiSimpleColumns;\r\nstruct ImGuiDrawContext;\r\nstruct ImGuiTextEditState;\r\nstruct ImGuiMouseCursorData;\r\nstruct ImGuiPopupRef;\r\nstruct ImGuiWindow;\r\nstruct ImGuiWindowSettings;\r\n\r\ntypedef int ImGuiLayoutType;        // enum: horizontal or vertical             // enum ImGuiLayoutType_\r\ntypedef int ImGuiButtonFlags;       // flags: for ButtonEx(), ButtonBehavior()  // enum ImGuiButtonFlags_\r\ntypedef int ImGuiItemFlags;         // flags: for PushItemFlag()                // enum ImGuiItemFlags_\r\ntypedef int ImGuiSeparatorFlags;    // flags: for Separator() - internal        // enum ImGuiSeparatorFlags_\r\ntypedef int ImGuiSliderFlags;       // flags: for SliderBehavior()              // enum ImGuiSliderFlags_\r\n\r\n//-------------------------------------------------------------------------\r\n// STB libraries\r\n//-------------------------------------------------------------------------\r\n\r\nnamespace ImGuiStb\r\n{\r\n\r\n#undef STB_TEXTEDIT_STRING\r\n#undef STB_TEXTEDIT_CHARTYPE\r\n#define STB_TEXTEDIT_STRING             ImGuiTextEditState\r\n#define STB_TEXTEDIT_CHARTYPE           ImWchar\r\n#define STB_TEXTEDIT_GETWIDTH_NEWLINE   -1.0f\r\n#include \"stb_textedit.h\"\r\n\r\n} // namespace ImGuiStb\r\n\r\n//-----------------------------------------------------------------------------\r\n// Context\r\n//-----------------------------------------------------------------------------\r\n\r\n#ifndef GImGui\r\nextern IMGUI_API ImGuiContext* GImGui;  // Current implicit ImGui context pointer\r\n#endif\r\n\r\n//-----------------------------------------------------------------------------\r\n// Helpers\r\n//-----------------------------------------------------------------------------\r\n\r\n#define IM_PI                       3.14159265358979323846f\r\n#define IM_OFFSETOF(_TYPE,_ELM)     ((size_t)&(((_TYPE*)0)->_ELM))\r\n\r\n// Helpers: UTF-8 <> wchar\r\nIMGUI_API int           ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end);      // return output UTF-8 bytes count\r\nIMGUI_API int           ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end);          // return input UTF-8 bytes count\r\nIMGUI_API int           ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_remaining = NULL);   // return input UTF-8 bytes count\r\nIMGUI_API int           ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end);                            // return number of UTF-8 code-points (NOT bytes count)\r\nIMGUI_API int           ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end);                   // return number of bytes to express string as UTF-8 code-points\r\n\r\n// Helpers: Misc\r\nIMGUI_API ImU32         ImHash(const void* data, int data_size, ImU32 seed = 0);    // Pass data_size==0 for zero-terminated strings\r\nIMGUI_API void*         ImFileLoadToMemory(const char* filename, const char* file_open_mode, int* out_file_size = NULL, int padding_bytes = 0);\r\nIMGUI_API FILE*         ImFileOpen(const char* filename, const char* file_open_mode);\r\nstatic inline bool      ImCharIsSpace(int c)            { return c == ' ' || c == '\\t' || c == 0x3000; }\r\nstatic inline bool      ImIsPowerOfTwo(int v)           { return v != 0 && (v & (v - 1)) == 0; }\r\nstatic inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }\r\n\r\n// Helpers: Geometry\r\nIMGUI_API ImVec2        ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p);\r\nIMGUI_API bool          ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p);\r\nIMGUI_API ImVec2        ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p);\r\nIMGUI_API void          ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w);\r\n\r\n// Helpers: String\r\nIMGUI_API int           ImStricmp(const char* str1, const char* str2);\r\nIMGUI_API int           ImStrnicmp(const char* str1, const char* str2, size_t count);\r\nIMGUI_API void          ImStrncpy(char* dst, const char* src, size_t count);\r\nIMGUI_API char*         ImStrdup(const char* str);\r\nIMGUI_API char*         ImStrchrRange(const char* str_begin, const char* str_end, char c);\r\nIMGUI_API int           ImStrlenW(const ImWchar* str);\r\nIMGUI_API const ImWchar*ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin); // Find beginning-of-line\r\nIMGUI_API const char*   ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end);\r\nIMGUI_API int           ImFormatString(char* buf, size_t buf_size, const char* fmt, ...) IM_FMTARGS(3);\r\nIMGUI_API int           ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args) IM_FMTLIST(3);\r\n\r\n// Helpers: Math\r\n// We are keeping those not leaking to the user by default, in the case the user has implicit cast operators between ImVec2 and its own types (when IM_VEC2_CLASS_EXTRA is defined)\r\n#ifdef IMGUI_DEFINE_MATH_OPERATORS\r\nstatic inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }\r\nstatic inline ImVec2 operator/(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x/rhs, lhs.y/rhs); }\r\nstatic inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }\r\nstatic inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }\r\nstatic inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }\r\nstatic inline ImVec2 operator/(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x/rhs.x, lhs.y/rhs.y); }\r\nstatic inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }\r\nstatic inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }\r\nstatic inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }\r\nstatic inline ImVec2& operator/=(ImVec2& lhs, const float rhs)                  { lhs.x /= rhs; lhs.y /= rhs; return lhs; }\r\nstatic inline ImVec4 operator+(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x+rhs.x, lhs.y+rhs.y, lhs.z+rhs.z, lhs.w+rhs.w); }\r\nstatic inline ImVec4 operator-(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x-rhs.x, lhs.y-rhs.y, lhs.z-rhs.z, lhs.w-rhs.w); }\r\nstatic inline ImVec4 operator*(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x*rhs.x, lhs.y*rhs.y, lhs.z*rhs.z, lhs.w*rhs.w); }\r\n#endif\r\n\r\nstatic inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }\r\nstatic inline int    ImMax(int lhs, int rhs)                                    { return lhs >= rhs ? lhs : rhs; }\r\nstatic inline float  ImMin(float lhs, float rhs)                                { return lhs < rhs ? lhs : rhs; }\r\nstatic inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }\r\nstatic inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(ImMin(lhs.x,rhs.x), ImMin(lhs.y,rhs.y)); }\r\nstatic inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(ImMax(lhs.x,rhs.x), ImMax(lhs.y,rhs.y)); }\r\nstatic inline int    ImClamp(int v, int mn, int mx)                             { return (v < mn) ? mn : (v > mx) ? mx : v; }\r\nstatic inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }\r\nstatic inline ImVec2 ImClamp(const ImVec2& f, const ImVec2& mn, ImVec2 mx)      { return ImVec2(ImClamp(f.x,mn.x,mx.x), ImClamp(f.y,mn.y,mx.y)); }\r\nstatic inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }\r\nstatic inline void   ImSwap(int& a, int& b)                                     { int tmp = a; a = b; b = tmp; }\r\nstatic inline void   ImSwap(float& a, float& b)                                 { float tmp = a; a = b; b = tmp; }\r\nstatic inline int    ImLerp(int a, int b, float t)                              { return (int)(a + (b - a) * t); }\r\nstatic inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }\r\nstatic inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, float t)          { return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t); }\r\nstatic inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }\r\nstatic inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }\r\nstatic inline float  ImLengthSqr(const ImVec2& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y; }\r\nstatic inline float  ImLengthSqr(const ImVec4& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y + lhs.z*lhs.z + lhs.w*lhs.w; }\r\nstatic inline float  ImInvLength(const ImVec2& lhs, float fail_value)           { float d = lhs.x*lhs.x + lhs.y*lhs.y; if (d > 0.0f) return 1.0f / sqrtf(d); return fail_value; }\r\nstatic inline float  ImFloor(float f)                                           { return (float)(int)f; }\r\nstatic inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2((float)(int)v.x, (float)(int)v.y); }\r\nstatic inline float  ImDot(const ImVec2& a, const ImVec2& b)                    { return a.x * b.x + a.y * b.y; }\r\nstatic inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }\r\nstatic inline float  ImLinearSweep(float current, float target, float speed)    { if (current < target) return ImMin(current + speed, target); if (current > target) return ImMax(current - speed, target); return current; }\r\nstatic inline ImVec2 ImMul(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }\r\n\r\n// We call C++ constructor on own allocated memory via the placement \"new(ptr) Type()\" syntax.\r\n// Defining a custom placement new() with a dummy parameter allows us to bypass including <new> which on some platforms complains when user has disabled exceptions.\r\nstruct ImNewPlacementDummy {};\r\ninline void* operator   new(size_t, ImNewPlacementDummy, void* ptr) { return ptr; }\r\ninline void  operator   delete(void*, ImNewPlacementDummy, void*)   {} // This is only required so we can use the symetrical new()\r\n#define IM_PLACEMENT_NEW(_PTR)              new(ImNewPlacementDummy(), _PTR)\r\n#define IM_NEW(_TYPE)                       new(ImNewPlacementDummy(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE\r\ntemplate <typename T> void IM_DELETE(T*& p) { if (p) { p->~T(); ImGui::MemFree(p); p = NULL; } }\r\n\r\n//-----------------------------------------------------------------------------\r\n// Types\r\n//-----------------------------------------------------------------------------\r\n\r\n// Internal Drag and Drop payload types. String starting with '_' are reserved for Dear ImGui.\r\n#define IMGUI_PAYLOAD_TYPE_DOCKABLE         \"_IMDOCK\"   // ImGuiWindow* // [Internal] Docking/tabs\r\n\r\nenum ImGuiButtonFlags_\r\n{\r\n    ImGuiButtonFlags_Repeat                 = 1 << 0,   // hold to repeat\r\n    ImGuiButtonFlags_PressedOnClickRelease  = 1 << 1,   // return true on click + release on same item [DEFAULT if no PressedOn* flag is set]\r\n    ImGuiButtonFlags_PressedOnClick         = 1 << 2,   // return true on click (default requires click+release)\r\n    ImGuiButtonFlags_PressedOnRelease       = 1 << 3,   // return true on release (default requires click+release)\r\n    ImGuiButtonFlags_PressedOnDoubleClick   = 1 << 4,   // return true on double-click (default requires click+release)\r\n    ImGuiButtonFlags_FlattenChildren        = 1 << 5,   // allow interactions even if a child window is overlapping\r\n    ImGuiButtonFlags_AllowItemOverlap       = 1 << 6,   // require previous frame HoveredId to either match id or be null before being usable, use along with SetItemAllowOverlap()\r\n    ImGuiButtonFlags_DontClosePopups        = 1 << 7,   // disable automatically closing parent popup on press // [UNUSED]\r\n    ImGuiButtonFlags_Disabled               = 1 << 8,   // disable interactions\r\n    ImGuiButtonFlags_AlignTextBaseLine      = 1 << 9,   // vertically align button to match text baseline - ButtonEx() only // FIXME: Should be removed and handled by SmallButton(), not possible currently because of DC.CursorPosPrevLine\r\n    ImGuiButtonFlags_NoKeyModifiers         = 1 << 10,  // disable interaction if a key modifier is held\r\n    ImGuiButtonFlags_NoHoldingActiveID      = 1 << 11,  // don't set ActiveId while holding the mouse (ImGuiButtonFlags_PressedOnClick only)\r\n    ImGuiButtonFlags_PressedOnDragDropHold  = 1 << 12   // press when held into while we are drag and dropping another item (used by e.g. tree nodes, collapsing headers)\r\n};\r\n\r\nenum ImGuiSliderFlags_\r\n{\r\n    ImGuiSliderFlags_Vertical               = 1 << 0\r\n};\r\n\r\nenum ImGuiColumnsFlags_\r\n{\r\n    // Default: 0\r\n    ImGuiColumnsFlags_NoBorder              = 1 << 0,   // Disable column dividers\r\n    ImGuiColumnsFlags_NoResize              = 1 << 1,   // Disable resizing columns when clicking on the dividers\r\n    ImGuiColumnsFlags_NoPreserveWidths      = 1 << 2,   // Disable column width preservation when adjusting columns\r\n    ImGuiColumnsFlags_NoForceWithinWindow   = 1 << 3,   // Disable forcing columns to fit within window\r\n    ImGuiColumnsFlags_GrowParentContentsSize= 1 << 4    // (WIP) Restore pre-1.51 behavior of extending the parent window contents size but _without affecting the columns width at all_. Will eventually remove.\r\n};\r\n\r\nenum ImGuiSelectableFlagsPrivate_\r\n{\r\n    // NB: need to be in sync with last value of ImGuiSelectableFlags_\r\n    ImGuiSelectableFlags_Menu               = 1 << 3,   // -> PressedOnClick\r\n    ImGuiSelectableFlags_MenuItem           = 1 << 4,   // -> PressedOnRelease\r\n    ImGuiSelectableFlags_Disabled           = 1 << 5,\r\n    ImGuiSelectableFlags_DrawFillAvailWidth = 1 << 6\r\n};\r\n\r\nenum ImGuiSeparatorFlags_\r\n{\r\n    ImGuiSeparatorFlags_Horizontal          = 1 << 0,   // Axis default to current layout type, so generally Horizontal unless e.g. in a menu bar\r\n    ImGuiSeparatorFlags_Vertical            = 1 << 1\r\n};\r\n\r\n// FIXME: this is in development, not exposed/functional as a generic feature yet.\r\nenum ImGuiLayoutType_\r\n{\r\n    ImGuiLayoutType_Vertical,\r\n    ImGuiLayoutType_Horizontal\r\n};\r\n\r\nenum ImGuiAxis\r\n{\r\n    ImGuiAxis_None = -1,\r\n    ImGuiAxis_X = 0,\r\n    ImGuiAxis_Y = 1\r\n};\r\n\r\nenum ImGuiPlotType\r\n{\r\n    ImGuiPlotType_Lines,\r\n    ImGuiPlotType_Histogram\r\n};\r\n\r\nenum ImGuiDataType\r\n{\r\n    ImGuiDataType_Int,\r\n    ImGuiDataType_Float,\r\n    ImGuiDataType_Float2\r\n};\r\n\r\nenum ImGuiDir\r\n{\r\n    ImGuiDir_None    = -1,\r\n    ImGuiDir_Left    = 0,\r\n    ImGuiDir_Right   = 1,\r\n    ImGuiDir_Up      = 2,\r\n    ImGuiDir_Down    = 3,\r\n    ImGuiDir_Count_\r\n};\r\n\r\n// 2D axis aligned bounding-box\r\n// NB: we can't rely on ImVec2 math operators being available here\r\nstruct IMGUI_API ImRect\r\n{\r\n    ImVec2      Min;    // Upper-left\r\n    ImVec2      Max;    // Lower-right\r\n\r\n    ImRect()                                        : Min(FLT_MAX,FLT_MAX), Max(-FLT_MAX,-FLT_MAX)  {}\r\n    ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}\r\n    ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)                  {}\r\n    ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)                      {}\r\n\r\n    ImVec2      GetCenter() const               { return ImVec2((Min.x+Max.x)*0.5f, (Min.y+Max.y)*0.5f); }\r\n    ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }\r\n    float       GetWidth() const                { return Max.x-Min.x; }\r\n    float       GetHeight() const               { return Max.y-Min.y; }\r\n    ImVec2      GetTL() const                   { return Min; }                   // Top-left\r\n    ImVec2      GetTR() const                   { return ImVec2(Max.x, Min.y); }  // Top-right\r\n    ImVec2      GetBL() const                   { return ImVec2(Min.x, Max.y); }  // Bottom-left\r\n    ImVec2      GetBR() const                   { return Max; }                   // Bottom-right\r\n    bool        Contains(const ImVec2& p) const { return p.x >= Min.x     && p.y >= Min.y     && p.x < Max.x     && p.y < Max.y; }\r\n    bool        Contains(const ImRect& r) const { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x < Max.x && r.Max.y < Max.y; }\r\n    bool        Overlaps(const ImRect& r) const { return r.Min.y < Max.y  && r.Max.y > Min.y  && r.Min.x < Max.x && r.Max.x > Min.x; }\r\n    void        Add(const ImVec2& rhs)          { if (Min.x > rhs.x)     Min.x = rhs.x;     if (Min.y > rhs.y) Min.y = rhs.y;         if (Max.x < rhs.x) Max.x = rhs.x;         if (Max.y < rhs.y) Max.y = rhs.y; }\r\n    void        Add(const ImRect& rhs)          { if (Min.x > rhs.Min.x) Min.x = rhs.Min.x; if (Min.y > rhs.Min.y) Min.y = rhs.Min.y; if (Max.x < rhs.Max.x) Max.x = rhs.Max.x; if (Max.y < rhs.Max.y) Max.y = rhs.Max.y; }\r\n    void        Expand(const float amount)      { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }\r\n    void        Expand(const ImVec2& amount)    { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }\r\n    void        Translate(const ImVec2& v)      { Min.x += v.x; Min.y += v.y; Max.x += v.x; Max.y += v.y; }\r\n    void        ClipWith(const ImRect& clip)    { if (Min.x < clip.Min.x) Min.x = clip.Min.x; if (Min.y < clip.Min.y) Min.y = clip.Min.y; if (Max.x > clip.Max.x) Max.x = clip.Max.x; if (Max.y > clip.Max.y) Max.y = clip.Max.y; }\r\n    void        Floor()                         { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; }\r\n    void        FixInverted()                   { if (Min.x > Max.x) ImSwap(Min.x, Max.x); if (Min.y > Max.y) ImSwap(Min.y, Max.y); }\r\n    bool        IsFinite() const                { return Min.x != FLT_MAX; }\r\n    ImVec2      GetClosestPoint(ImVec2 p, bool on_edge) const\r\n    {\r\n        if (!on_edge && Contains(p))\r\n            return p;\r\n        if (p.x > Max.x) p.x = Max.x;\r\n        else if (p.x < Min.x) p.x = Min.x;\r\n        if (p.y > Max.y) p.y = Max.y;\r\n        else if (p.y < Min.y) p.y = Min.y;\r\n        return p;\r\n    }\r\n};\r\n\r\n// Stacked color modifier, backup of modified data so we can restore it\r\nstruct ImGuiColMod\r\n{\r\n    ImGuiCol    Col;\r\n    ImVec4      BackupValue;\r\n};\r\n\r\n// Stacked style modifier, backup of modified data so we can restore it. Data type inferred from the variable.\r\nstruct ImGuiStyleMod\r\n{\r\n    ImGuiStyleVar   VarIdx;\r\n    union           { int BackupInt[2]; float BackupFloat[2]; };\r\n    ImGuiStyleMod(ImGuiStyleVar idx, int v)     { VarIdx = idx; BackupInt[0] = v; }\r\n    ImGuiStyleMod(ImGuiStyleVar idx, float v)   { VarIdx = idx; BackupFloat[0] = v; }\r\n    ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }\r\n};\r\n\r\n// Stacked data for BeginGroup()/EndGroup()\r\nstruct ImGuiGroupData\r\n{\r\n    ImVec2      BackupCursorPos;\r\n    ImVec2      BackupCursorMaxPos;\r\n    float       BackupIndentX;\r\n    float       BackupGroupOffsetX;\r\n    float       BackupCurrentLineHeight;\r\n    float       BackupCurrentLineTextBaseOffset;\r\n    float       BackupLogLinePosY;\r\n    bool        BackupActiveIdIsAlive;\r\n    bool        AdvanceCursor;\r\n};\r\n\r\n// Simple column measurement currently used for MenuItem() only. This is very short-sighted/throw-away code and NOT a generic helper.\r\nstruct IMGUI_API ImGuiSimpleColumns\r\n{\r\n    int         Count;\r\n    float       Spacing;\r\n    float       Width, NextWidth;\r\n    float       Pos[8], NextWidths[8];\r\n\r\n    ImGuiSimpleColumns();\r\n    void        Update(int count, float spacing, bool clear);\r\n    float       DeclColumns(float w0, float w1, float w2);\r\n    float       CalcExtraSpace(float avail_w);\r\n};\r\n\r\n// Internal state of the currently focused/edited text input box\r\nstruct IMGUI_API ImGuiTextEditState\r\n{\r\n    ImGuiID             Id;                         // widget id owning the text state\r\n    ImVector<ImWchar>   Text;                       // edit buffer, we need to persist but can't guarantee the persistence of the user-provided buffer. so we copy into own buffer.\r\n    ImVector<char>      InitialText;                // backup of end-user buffer at the time of focus (in UTF-8, unaltered)\r\n    ImVector<char>      TempTextBuffer;\r\n    int                 CurLenA, CurLenW;           // we need to maintain our buffer length in both UTF-8 and wchar format.\r\n    int                 BufSizeA;                   // end-user buffer size\r\n    float               ScrollX;\r\n    ImGuiStb::STB_TexteditState   StbState;\r\n    float               CursorAnim;\r\n    bool                CursorFollow;\r\n    bool                SelectedAllMouseLock;\r\n\r\n    ImGuiTextEditState()                            { memset(this, 0, sizeof(*this)); }\r\n    void                CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking\r\n    void                CursorClamp()               { StbState.cursor = ImMin(StbState.cursor, CurLenW); StbState.select_start = ImMin(StbState.select_start, CurLenW); StbState.select_end = ImMin(StbState.select_end, CurLenW); }\r\n    bool                HasSelection() const        { return StbState.select_start != StbState.select_end; }\r\n    void                ClearSelection()            { StbState.select_start = StbState.select_end = StbState.cursor; }\r\n    void                SelectAll()                 { StbState.select_start = 0; StbState.select_end = CurLenW; StbState.cursor = StbState.select_end; StbState.has_preferred_x = false; }\r\n    void                OnKeyPressed(int key);\r\n};\r\n\r\n// Data saved in imgui.ini file\r\nstruct ImGuiWindowSettings\r\n{\r\n    char*       Name;\r\n    ImGuiID     Id;\r\n    ImVec2      Pos;\r\n    ImVec2      Size;\r\n    bool        Collapsed;\r\n\r\n    ImGuiWindowSettings() { Name = NULL; Id = 0; Pos = Size = ImVec2(0,0); Collapsed = false; }\r\n};\r\n\r\nstruct ImGuiSettingsHandler\r\n{\r\n    const char* TypeName;   // Short description stored in .ini file. Disallowed characters: '[' ']'  \r\n    ImGuiID     TypeHash;   // == ImHash(TypeName, 0, 0)\r\n    void*       (*ReadOpenFn)(ImGuiContext& ctx, const char* name);\r\n    void        (*ReadLineFn)(ImGuiContext& ctx, void* entry, const char* line);\r\n    void        (*WriteAllFn)(ImGuiContext& ctx, ImGuiTextBuffer* out_buf);\r\n};\r\n\r\n// Mouse cursor data (used when io.MouseDrawCursor is set)\r\nstruct ImGuiMouseCursorData\r\n{\r\n    ImGuiMouseCursor    Type;\r\n    ImVec2              HotOffset;\r\n    ImVec2              Size;\r\n    ImVec2              TexUvMin[2];\r\n    ImVec2              TexUvMax[2];\r\n};\r\n\r\n// Storage for current popup stack\r\nstruct ImGuiPopupRef\r\n{\r\n    ImGuiID             PopupId;        // Set on OpenPopup()\r\n    ImGuiWindow*        Window;         // Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()\r\n    ImGuiWindow*        ParentWindow;   // Set on OpenPopup()\r\n    ImGuiID             ParentMenuSet;  // Set on OpenPopup()\r\n    ImVec2              MousePosOnOpen; // Copy of mouse position at the time of opening popup\r\n\r\n    ImGuiPopupRef(ImGuiID id, ImGuiWindow* parent_window, ImGuiID parent_menu_set, const ImVec2& mouse_pos) { PopupId = id; Window = NULL; ParentWindow = parent_window; ParentMenuSet = parent_menu_set; MousePosOnOpen = mouse_pos; }\r\n};\r\n\r\nstruct ImGuiColumnData\r\n{\r\n    float               OffsetNorm;         // Column start offset, normalized 0.0 (far left) -> 1.0 (far right)\r\n    float               OffsetNormBeforeResize;\r\n    ImGuiColumnsFlags   Flags;              // Not exposed\r\n    ImRect              ClipRect;\r\n\r\n    ImGuiColumnData()   { OffsetNorm = OffsetNormBeforeResize = 0.0f; Flags = 0; }\r\n};\r\n\r\nstruct ImGuiColumnsSet\r\n{\r\n    ImGuiID             ID;\r\n    ImGuiColumnsFlags   Flags;\r\n    bool                IsFirstFrame;\r\n    bool                IsBeingResized;\r\n    int                 Current;\r\n    int                 Count;\r\n    float               MinX, MaxX;\r\n    float               StartPosY;\r\n    float               StartMaxPosX;       // Backup of CursorMaxPos\r\n    float               CellMinY, CellMaxY;\r\n    ImVector<ImGuiColumnData> Columns;\r\n\r\n    ImGuiColumnsSet()   { Clear(); }\r\n    void Clear()\r\n    {\r\n        ID = 0;\r\n        Flags = 0;\r\n        IsFirstFrame = false;\r\n        IsBeingResized = false;\r\n        Current = 0;\r\n        Count = 1;\r\n        MinX = MaxX = 0.0f;\r\n        StartPosY = 0.0f;\r\n        StartMaxPosX = 0.0f;\r\n        CellMinY = CellMaxY = 0.0f;\r\n        Columns.clear();\r\n    }\r\n};\r\n\r\nstruct ImDrawListSharedData\r\n{\r\n    ImVec2          TexUvWhitePixel;            // UV of white pixel in the atlas\r\n    ImFont*         Font;                       // Current/default font (optional, for simplified AddText overload)\r\n    float           FontSize;                   // Current/default font size (optional, for simplified AddText overload)\r\n    float           CurveTessellationTol;\r\n    ImVec4          ClipRectFullscreen;         // Value for PushClipRectFullscreen()\r\n\r\n    // Const data\r\n    // FIXME: Bake rounded corners fill/borders in atlas\r\n    ImVec2          CircleVtx12[12];\r\n\r\n    ImDrawListSharedData();\r\n};\r\n\r\n// Main state for ImGui\r\nstruct ImGuiContext\r\n{\r\n    bool                    Initialized;\r\n    ImGuiIO                 IO;\r\n    ImGuiStyle              Style;\r\n    ImFont*                 Font;                               // (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()\r\n    float                   FontSize;                           // (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize(). Text height for current window.\r\n    float                   FontBaseSize;                       // (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Base text height.\r\n    ImDrawListSharedData    DrawListSharedData;\r\n\r\n    float                   Time;\r\n    int                     FrameCount;\r\n    int                     FrameCountEnded;\r\n    int                     FrameCountRendered;\r\n    ImVector<ImGuiWindow*>  Windows;\r\n    ImVector<ImGuiWindow*>  WindowsSortBuffer;\r\n    ImVector<ImGuiWindow*>  CurrentWindowStack;\r\n    ImGuiStorage            WindowsById;\r\n    int                     WindowsActiveCount;\r\n    ImGuiWindow*            CurrentWindow;                      // Being drawn into\r\n    ImGuiWindow*            NavWindow;                          // Nav/focused window for navigation\r\n    ImGuiWindow*            HoveredWindow;                      // Will catch mouse inputs\r\n    ImGuiWindow*            HoveredRootWindow;                  // Will catch mouse inputs (for focus/move only)\r\n    ImGuiID                 HoveredId;                          // Hovered widget\r\n    bool                    HoveredIdAllowOverlap;\r\n    ImGuiID                 HoveredIdPreviousFrame;\r\n    float                   HoveredIdTimer;\r\n    ImGuiID                 ActiveId;                           // Active widget\r\n    ImGuiID                 ActiveIdPreviousFrame;\r\n    float                   ActiveIdTimer;\r\n    bool                    ActiveIdIsAlive;                    // Active widget has been seen this frame\r\n    bool                    ActiveIdIsJustActivated;            // Set at the time of activation for one frame\r\n    bool                    ActiveIdAllowOverlap;               // Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)\r\n    ImVec2                  ActiveIdClickOffset;                // Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)\r\n    ImGuiWindow*            ActiveIdWindow;\r\n    ImGuiWindow*            MovingWindow;                       // Track the child window we clicked on to move a window.\r\n    ImGuiID                 MovingWindowMoveId;                 // == MovingWindow->MoveId\r\n    ImVector<ImGuiColMod>   ColorModifiers;                     // Stack for PushStyleColor()/PopStyleColor()\r\n    ImVector<ImGuiStyleMod> StyleModifiers;                     // Stack for PushStyleVar()/PopStyleVar()\r\n    ImVector<ImFont*>       FontStack;                          // Stack for PushFont()/PopFont()\r\n    ImVector<ImGuiPopupRef> OpenPopupStack;                     // Which popups are open (persistent)\r\n    ImVector<ImGuiPopupRef> CurrentPopupStack;                  // Which level of BeginPopup() we are in (reset every frame)\r\n\r\n    // Storage for SetNexWindow** and SetNextTreeNode*** functions\r\n    ImVec2                  SetNextWindowPosVal;\r\n    ImVec2                  SetNextWindowPosPivot;\r\n    ImVec2                  SetNextWindowSizeVal;\r\n    ImVec2                  SetNextWindowContentSizeVal;\r\n    bool                    SetNextWindowCollapsedVal;\r\n    ImGuiCond               SetNextWindowPosCond;\r\n    ImGuiCond               SetNextWindowSizeCond;\r\n    ImGuiCond               SetNextWindowContentSizeCond;\r\n    ImGuiCond               SetNextWindowCollapsedCond;\r\n    ImRect                  SetNextWindowSizeConstraintRect;           // Valid if 'SetNextWindowSizeConstraint' is true\r\n    ImGuiSizeConstraintCallback SetNextWindowSizeConstraintCallback;\r\n    void*                   SetNextWindowSizeConstraintCallbackUserData;\r\n    bool                    SetNextWindowSizeConstraint;\r\n    bool                    SetNextWindowFocus;\r\n    bool                    SetNextTreeNodeOpenVal;\r\n    ImGuiCond               SetNextTreeNodeOpenCond;\r\n\r\n    // Render\r\n    ImDrawData              RenderDrawData;                     // Main ImDrawData instance to pass render information to the user\r\n    ImVector<ImDrawList*>   RenderDrawLists[3];\r\n    float                   ModalWindowDarkeningRatio;\r\n    ImDrawList              OverlayDrawList;                    // Optional software render of mouse cursors, if io.MouseDrawCursor is set + a few debug overlays\r\n    ImGuiMouseCursor        MouseCursor;\r\n    ImGuiMouseCursorData    MouseCursorData[ImGuiMouseCursor_Count_];\r\n\r\n    // Drag and Drop\r\n    bool                    DragDropActive;\r\n    ImGuiDragDropFlags      DragDropSourceFlags;\r\n    int                     DragDropMouseButton;\r\n    ImGuiPayload            DragDropPayload;\r\n    ImRect                  DragDropTargetRect;\r\n    ImGuiID                 DragDropTargetId;\r\n    float                   DragDropAcceptIdCurrRectSurface;\r\n    ImGuiID                 DragDropAcceptIdCurr;               // Target item id (set at the time of accepting the payload)\r\n    ImGuiID                 DragDropAcceptIdPrev;               // Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)\r\n    int                     DragDropAcceptFrameCount;           // Last time a target expressed a desire to accept the source\r\n    ImVector<unsigned char> DragDropPayloadBufHeap;             // We don't expose the ImVector<> directly\r\n    unsigned char           DragDropPayloadBufLocal[8];\r\n\r\n    // Widget state\r\n    ImGuiTextEditState      InputTextState;\r\n    ImFont                  InputTextPasswordFont;\r\n    ImGuiID                 ScalarAsInputTextId;                // Temporary text input when CTRL+clicking on a slider, etc.\r\n    ImGuiColorEditFlags     ColorEditOptions;                   // Store user options for color edit widgets\r\n    ImVec4                  ColorPickerRef;\r\n    float                   DragCurrentValue;                   // Currently dragged value, always float, not rounded by end-user precision settings\r\n    ImVec2                  DragLastMouseDelta;\r\n    float                   DragSpeedDefaultRatio;              // If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio\r\n    float                   DragSpeedScaleSlow;\r\n    float                   DragSpeedScaleFast;\r\n    ImVec2                  ScrollbarClickDeltaToGrabCenter;    // Distance between mouse and center of grab box, normalized in parent space. Use storage?\r\n    int                     TooltipOverrideCount;\r\n    ImVector<char>          PrivateClipboard;                   // If no custom clipboard handler is defined\r\n    ImVec2                  OsImePosRequest, OsImePosSet;       // Cursor position request & last passed to the OS Input Method Editor\r\n\r\n    // Settings\r\n    float                          SettingsDirtyTimer;          // Save .ini Settings on disk when time reaches zero\r\n    ImVector<ImGuiWindowSettings>  SettingsWindows;             // .ini settings for ImGuiWindow\r\n    ImVector<ImGuiSettingsHandler> SettingsHandlers;            // List of .ini settings handlers\r\n\r\n    // Logging\r\n    bool                    LogEnabled;\r\n    FILE*                   LogFile;                            // If != NULL log to stdout/ file\r\n    ImGuiTextBuffer*        LogClipboard;                       // Else log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.\r\n    int                     LogStartDepth;\r\n    int                     LogAutoExpandMaxDepth;\r\n\r\n    // Misc\r\n    float                   FramerateSecPerFrame[120];          // calculate estimate of framerate for user\r\n    int                     FramerateSecPerFrameIdx;\r\n    float                   FramerateSecPerFrameAccum;\r\n    int                     WantCaptureMouseNextFrame;          // explicit capture via CaptureInputs() sets those flags\r\n    int                     WantCaptureKeyboardNextFrame;\r\n    int                     WantTextInputNextFrame;\r\n    char                    TempBuffer[1024*3+1];               // temporary text buffer\r\n\r\n    ImGuiContext() : OverlayDrawList(NULL)\r\n    {\r\n        Initialized = false;\r\n        Font = NULL;\r\n        FontSize = FontBaseSize = 0.0f;\r\n\r\n        Time = 0.0f;\r\n        FrameCount = 0;\r\n        FrameCountEnded = FrameCountRendered = -1;\r\n        WindowsActiveCount = 0;\r\n        CurrentWindow = NULL;\r\n        NavWindow = NULL;\r\n        HoveredWindow = NULL;\r\n        HoveredRootWindow = NULL;\r\n        HoveredId = 0;\r\n        HoveredIdAllowOverlap = false;\r\n        HoveredIdPreviousFrame = 0;\r\n        HoveredIdTimer = 0.0f;\r\n        ActiveId = 0;\r\n        ActiveIdPreviousFrame = 0;\r\n        ActiveIdTimer = 0.0f;\r\n        ActiveIdIsAlive = false;\r\n        ActiveIdIsJustActivated = false;\r\n        ActiveIdAllowOverlap = false;\r\n        ActiveIdClickOffset = ImVec2(-1,-1);\r\n        ActiveIdWindow = NULL;\r\n        MovingWindow = NULL;\r\n        MovingWindowMoveId = 0;\r\n\r\n        SetNextWindowPosVal = ImVec2(0.0f, 0.0f);\r\n        SetNextWindowSizeVal = ImVec2(0.0f, 0.0f);\r\n        SetNextWindowCollapsedVal = false;\r\n        SetNextWindowPosCond = 0;\r\n        SetNextWindowSizeCond = 0;\r\n        SetNextWindowContentSizeCond = 0;\r\n        SetNextWindowCollapsedCond = 0;\r\n        SetNextWindowSizeConstraintRect = ImRect();\r\n        SetNextWindowSizeConstraintCallback = NULL;\r\n        SetNextWindowSizeConstraintCallbackUserData = NULL;\r\n        SetNextWindowSizeConstraint = false;\r\n        SetNextWindowFocus = false;\r\n        SetNextTreeNodeOpenVal = false;\r\n        SetNextTreeNodeOpenCond = 0;\r\n\r\n        DragDropActive = false;\r\n        DragDropSourceFlags = 0;\r\n        DragDropMouseButton = -1;\r\n        DragDropTargetId = 0;\r\n        DragDropAcceptIdPrev = DragDropAcceptIdCurr = 0;\r\n        DragDropAcceptFrameCount = -1;\r\n        memset(DragDropPayloadBufLocal, 0, sizeof(DragDropPayloadBufLocal));\r\n\r\n        ScalarAsInputTextId = 0;\r\n        ColorEditOptions = ImGuiColorEditFlags__OptionsDefault;\r\n        DragCurrentValue = 0.0f;\r\n        DragLastMouseDelta = ImVec2(0.0f, 0.0f);\r\n        DragSpeedDefaultRatio = 1.0f / 100.0f;\r\n        DragSpeedScaleSlow = 1.0f / 100.0f;\r\n        DragSpeedScaleFast = 10.0f;\r\n        ScrollbarClickDeltaToGrabCenter = ImVec2(0.0f, 0.0f);\r\n        TooltipOverrideCount = 0;\r\n        OsImePosRequest = OsImePosSet = ImVec2(-1.0f, -1.0f);\r\n\r\n        ModalWindowDarkeningRatio = 0.0f;\r\n        OverlayDrawList._Data = &DrawListSharedData;\r\n        OverlayDrawList._OwnerName = \"##Overlay\"; // Give it a name for debugging\r\n        MouseCursor = ImGuiMouseCursor_Arrow;\r\n        memset(MouseCursorData, 0, sizeof(MouseCursorData));\r\n\r\n        SettingsDirtyTimer = 0.0f;\r\n\r\n        LogEnabled = false;\r\n        LogFile = NULL;\r\n        LogClipboard = NULL;\r\n        LogStartDepth = 0;\r\n        LogAutoExpandMaxDepth = 2;\r\n\r\n        memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));\r\n        FramerateSecPerFrameIdx = 0;\r\n        FramerateSecPerFrameAccum = 0.0f;\r\n        WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame = WantTextInputNextFrame = -1;\r\n        memset(TempBuffer, 0, sizeof(TempBuffer));\r\n    }\r\n};\r\n\r\n// Transient per-window flags, reset at the beginning of the frame. For child window, inherited from parent on first Begin().\r\nenum ImGuiItemFlags_\r\n{\r\n    ImGuiItemFlags_AllowKeyboardFocus           = 1 << 0,  // true\r\n    ImGuiItemFlags_ButtonRepeat                 = 1 << 1,  // false    // Button() will return true multiple times based on io.KeyRepeatDelay and io.KeyRepeatRate settings.\r\n    ImGuiItemFlags_Disabled                     = 1 << 2,  // false    // FIXME-WIP: Disable interactions but doesn't affect visuals. Should be: grey out and disable interactions with widgets that affect data + view widgets (WIP) \r\n    //ImGuiItemFlags_NoNav                      = 1 << 3,  // false\r\n    //ImGuiItemFlags_NoNavDefaultFocus          = 1 << 4,  // false\r\n    ImGuiItemFlags_SelectableDontClosePopup     = 1 << 5,  // false    // MenuItem/Selectable() automatically closes current Popup window\r\n    ImGuiItemFlags_Default_                     = ImGuiItemFlags_AllowKeyboardFocus\r\n};\r\n\r\n// Transient per-window data, reset at the beginning of the frame\r\n// FIXME: That's theory, in practice the delimitation between ImGuiWindow and ImGuiDrawContext is quite tenuous and could be reconsidered.\r\nstruct IMGUI_API ImGuiDrawContext\r\n{\r\n    ImVec2                  CursorPos;\r\n    ImVec2                  CursorPosPrevLine;\r\n    ImVec2                  CursorStartPos;\r\n    ImVec2                  CursorMaxPos;           // Used to implicitly calculate the size of our contents, always growing during the frame. Turned into window->SizeContents at the beginning of next frame\r\n    float                   CurrentLineHeight;\r\n    float                   CurrentLineTextBaseOffset;\r\n    float                   PrevLineHeight;\r\n    float                   PrevLineTextBaseOffset;\r\n    float                   LogLinePosY;\r\n    int                     TreeDepth;\r\n    ImGuiID                 LastItemId;\r\n    ImRect                  LastItemRect;\r\n    bool                    LastItemRectHoveredRect;\r\n    bool                    MenuBarAppending;\r\n    float                   MenuBarOffsetX;\r\n    ImVector<ImGuiWindow*>  ChildWindows;\r\n    ImGuiStorage*           StateStorage;\r\n    ImGuiLayoutType         LayoutType;\r\n\r\n    // We store the current settings outside of the vectors to increase memory locality (reduce cache misses). The vectors are rarely modified. Also it allows us to not heap allocate for short-lived windows which are not using those settings.\r\n    ImGuiItemFlags          ItemFlags;              // == ItemFlagsStack.back() [empty == ImGuiItemFlags_Default]\r\n    float                   ItemWidth;              // == ItemWidthStack.back(). 0.0: default, >0.0: width in pixels, <0.0: align xx pixels to the right of window\r\n    float                   TextWrapPos;            // == TextWrapPosStack.back() [empty == -1.0f]\r\n    ImVector<ImGuiItemFlags>ItemFlagsStack;\r\n    ImVector<float>         ItemWidthStack;\r\n    ImVector<float>         TextWrapPosStack;\r\n    ImVector<ImGuiGroupData>GroupStack;\r\n    int                     StackSizesBackup[6];    // Store size of various stacks for asserting\r\n\r\n    float                   IndentX;                // Indentation / start position from left of window (increased by TreePush/TreePop, etc.)\r\n    float                   GroupOffsetX;\r\n    float                   ColumnsOffsetX;         // Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.\r\n    ImGuiColumnsSet*        ColumnsSet;             // Current columns set\r\n\r\n    ImGuiDrawContext()\r\n    {\r\n        CursorPos = CursorPosPrevLine = CursorStartPos = CursorMaxPos = ImVec2(0.0f, 0.0f);\r\n        CurrentLineHeight = PrevLineHeight = 0.0f;\r\n        CurrentLineTextBaseOffset = PrevLineTextBaseOffset = 0.0f;\r\n        LogLinePosY = -1.0f;\r\n        TreeDepth = 0;\r\n        LastItemId = 0;\r\n        LastItemRect = ImRect();\r\n        LastItemRectHoveredRect = false;\r\n        MenuBarAppending = false;\r\n        MenuBarOffsetX = 0.0f;\r\n        StateStorage = NULL;\r\n        LayoutType = ImGuiLayoutType_Vertical;\r\n        ItemWidth = 0.0f;\r\n        ItemFlags = ImGuiItemFlags_Default_;\r\n        TextWrapPos = -1.0f;\r\n        memset(StackSizesBackup, 0, sizeof(StackSizesBackup));\r\n\r\n        IndentX = 0.0f;\r\n        GroupOffsetX = 0.0f;\r\n        ColumnsOffsetX = 0.0f;\r\n        ColumnsSet = NULL;\r\n    }\r\n};\r\n\r\n// Windows data\r\nstruct IMGUI_API ImGuiWindow\r\n{\r\n    char*                   Name;\r\n    ImGuiID                 ID;                                 // == ImHash(Name)\r\n    ImGuiWindowFlags        Flags;                              // See enum ImGuiWindowFlags_\r\n    ImVec2                  PosFloat;\r\n    ImVec2                  Pos;                                // Position rounded-up to nearest pixel\r\n    ImVec2                  Size;                               // Current size (==SizeFull or collapsed title bar size)\r\n    ImVec2                  SizeFull;                           // Size when non collapsed\r\n    ImVec2                  SizeFullAtLastBegin;                // Copy of SizeFull at the end of Begin. This is the reference value we'll use on the next frame to decide if we need scrollbars.\r\n    ImVec2                  SizeContents;                       // Size of contents (== extents reach of the drawing cursor) from previous frame. Include decoration, window title, border, menu, etc.\r\n    ImVec2                  SizeContentsExplicit;               // Size of contents explicitly set by the user via SetNextWindowContentSize()\r\n    ImRect                  ContentsRegionRect;                 // Maximum visible content position in window coordinates. ~~ (SizeContentsExplicit ? SizeContentsExplicit : Size - ScrollbarSizes) - CursorStartPos, per axis\r\n    ImVec2                  WindowPadding;                      // Window padding at the time of begin.\r\n    float                   WindowRounding;                     // Window rounding at the time of begin.\r\n    float                   WindowBorderSize;                   // Window border size at the time of begin.\r\n    ImGuiID                 MoveId;                             // == window->GetID(\"#MOVE\")\r\n    ImVec2                  Scroll;\r\n    ImVec2                  ScrollTarget;                       // target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)\r\n    ImVec2                  ScrollTargetCenterRatio;            // 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered\r\n    bool                    ScrollbarX, ScrollbarY;\r\n    ImVec2                  ScrollbarSizes;\r\n    bool                    Active;                             // Set to true on Begin()\r\n    bool                    WasActive;\r\n    bool                    WriteAccessed;                      // Set to true when any widget access the current window\r\n    bool                    Collapsed;                          // Set when collapsing window to become only title-bar\r\n    bool                    SkipItems;                          // Set when items can safely be all clipped (e.g. window not visible or collapsed)\r\n    bool                    Appearing;                          // Set during the frame where the window is appearing (or re-appearing)\r\n    bool                    CloseButton;                        // Set when the window has a close button (p_open != NULL)\r\n    int                     BeginOrderWithinParent;             // Order within immediate parent window, if we are a child window. Otherwise 0.\r\n    int                     BeginOrderWithinContext;            // Order within entire imgui context. This is mostly used for debugging submission order related issues.\r\n    int                     BeginCount;                         // Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin/End pairs)\r\n    ImGuiID                 PopupId;                            // ID in the popup stack when this window is used as a popup/menu (because we use generic Name/ID for recycling)\r\n    int                     AutoFitFramesX, AutoFitFramesY;\r\n    bool                    AutoFitOnlyGrows;\r\n    int                     AutoFitChildAxises;\r\n    ImGuiDir                AutoPosLastDirection;\r\n    int                     HiddenFrames;\r\n    ImGuiCond               SetWindowPosAllowFlags;             // store condition flags for next SetWindowPos() call.\r\n    ImGuiCond               SetWindowSizeAllowFlags;            // store condition flags for next SetWindowSize() call.\r\n    ImGuiCond               SetWindowCollapsedAllowFlags;       // store condition flags for next SetWindowCollapsed() call.\r\n    ImVec2                  SetWindowPosVal;                    // store window position when using a non-zero Pivot (position set needs to be processed when we know the window size)\r\n    ImVec2                  SetWindowPosPivot;                  // store window pivot for positioning. ImVec2(0,0) when positioning from top-left corner; ImVec2(0.5f,0.5f) for centering; ImVec2(1,1) for bottom right.\r\n\r\n    ImGuiDrawContext        DC;                                 // Temporary per-window data, reset at the beginning of the frame\r\n    ImVector<ImGuiID>       IDStack;                            // ID stack. ID are hashes seeded with the value at the top of the stack\r\n    ImRect                  ClipRect;                           // = DrawList->clip_rect_stack.back(). Scissoring / clipping rectangle. x1, y1, x2, y2.\r\n    ImRect                  WindowRectClipped;                  // = WindowRect just after setup in Begin(). == window->Rect() for root window.\r\n    ImRect                  InnerRect;\r\n    int                     LastFrameActive;\r\n    float                   ItemWidthDefault;\r\n    ImGuiSimpleColumns      MenuColumns;                        // Simplified columns storage for menu items\r\n    ImGuiStorage            StateStorage;\r\n    ImVector<ImGuiColumnsSet> ColumnsStorage;\r\n    float                   FontWindowScale;                    // Scale multiplier per-window\r\n    ImDrawList*             DrawList;\r\n    ImGuiWindow*            ParentWindow;                       // If we are a child _or_ popup window, this is pointing to our parent. Otherwise NULL.\r\n    ImGuiWindow*            RootWindow;                         // Generally point to ourself. If we are a child window, this is pointing to the first non-child parent window.\r\n    ImGuiWindow*            RootNonPopupWindow;                 // Generally point to ourself. Used to display TitleBgActive color and for selecting which window to use for NavWindowing\r\n\r\n    // Navigation / Focus\r\n    int                     FocusIdxAllCounter;                 // Start at -1 and increase as assigned via FocusItemRegister()\r\n    int                     FocusIdxTabCounter;                 // (same, but only count widgets which you can Tab through)\r\n    int                     FocusIdxAllRequestCurrent;          // Item being requested for focus\r\n    int                     FocusIdxTabRequestCurrent;          // Tab-able item being requested for focus\r\n    int                     FocusIdxAllRequestNext;             // Item being requested for focus, for next update (relies on layout to be stable between the frame pressing TAB and the next frame)\r\n    int                     FocusIdxTabRequestNext;             // \"\r\n\r\npublic:\r\n    ImGuiWindow(ImGuiContext* context, const char* name);\r\n    ~ImGuiWindow();\r\n\r\n    ImGuiID     GetID(const char* str, const char* str_end = NULL);\r\n    ImGuiID     GetID(const void* ptr);\r\n    ImGuiID     GetIDNoKeepAlive(const char* str, const char* str_end = NULL);\r\n    ImGuiID     GetIDFromRectangle(const ImRect& r_abs);\r\n\r\n    // We don't use g.FontSize because the window may be != g.CurrentWidow.\r\n    ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }\r\n    float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }\r\n    float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }\r\n    ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }\r\n    float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }\r\n    ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }\r\n};\r\n\r\n// Backup and restore just enough data to be able to use IsItemHovered() on item A after another B in the same window has overwritten the data.  \r\nstruct ImGuiItemHoveredDataBackup\r\n{\r\n    ImGuiID     LastItemId;\r\n    ImRect      LastItemRect;\r\n    bool        LastItemRectHoveredRect;\r\n\r\n    ImGuiItemHoveredDataBackup() { Backup(); }\r\n    void Backup()        { ImGuiWindow* window = GImGui->CurrentWindow; LastItemId = window->DC.LastItemId; LastItemRect = window->DC.LastItemRect; LastItemRectHoveredRect = window->DC.LastItemRectHoveredRect; }\r\n    void Restore() const { ImGuiWindow* window = GImGui->CurrentWindow; window->DC.LastItemId = LastItemId; window->DC.LastItemRect = LastItemRect; window->DC.LastItemRectHoveredRect = LastItemRectHoveredRect; }\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// Internal API\r\n// No guarantee of forward compatibility here.\r\n//-----------------------------------------------------------------------------\r\n\r\nnamespace ImGui\r\n{\r\n    // We should always have a CurrentWindow in the stack (there is an implicit \"Debug\" window)\r\n    // If this ever crash because g.CurrentWindow is NULL it means that either\r\n    // - ImGui::NewFrame() has never been called, which is illegal.\r\n    // - You are calling ImGui functions after ImGui::Render() and before the next ImGui::NewFrame(), which is also illegal.\r\n    inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }\r\n    inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }\r\n    IMGUI_API ImGuiWindow*  FindWindowByName(const char* name);\r\n    IMGUI_API void          FocusWindow(ImGuiWindow* window);\r\n    IMGUI_API void          BringWindowToFront(ImGuiWindow* window);\r\n    IMGUI_API void          BringWindowToBack(ImGuiWindow* window);\r\n    IMGUI_API bool          IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent);\r\n\r\n    IMGUI_API void          Initialize();\r\n\r\n    IMGUI_API void                  MarkIniSettingsDirty();\r\n    IMGUI_API ImGuiSettingsHandler* FindSettingsHandler(ImGuiID type_id);\r\n    IMGUI_API ImGuiWindowSettings*  FindWindowSettings(ImGuiID id);\r\n\r\n    IMGUI_API void          SetActiveID(ImGuiID id, ImGuiWindow* window);\r\n    IMGUI_API void          ClearActiveID();\r\n    IMGUI_API void          SetHoveredID(ImGuiID id);\r\n    IMGUI_API void          KeepAliveID(ImGuiID id);\r\n\r\n    IMGUI_API void          ItemSize(const ImVec2& size, float text_offset_y = 0.0f);\r\n    IMGUI_API void          ItemSize(const ImRect& bb, float text_offset_y = 0.0f);\r\n    IMGUI_API bool          ItemAdd(const ImRect& bb, ImGuiID id);\r\n    IMGUI_API bool          ItemHoverable(const ImRect& bb, ImGuiID id);\r\n    IMGUI_API bool          IsClippedEx(const ImRect& bb, ImGuiID id, bool clip_even_when_logged);\r\n    IMGUI_API bool          FocusableItemRegister(ImGuiWindow* window, ImGuiID id, bool tab_stop = true);      // Return true if focus is requested\r\n    IMGUI_API void          FocusableItemUnregister(ImGuiWindow* window);\r\n    IMGUI_API ImVec2        CalcItemSize(ImVec2 size, float default_x, float default_y);\r\n    IMGUI_API float         CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x);\r\n    IMGUI_API void          PushMultiItemsWidths(int components, float width_full = 0.0f);\r\n    IMGUI_API void          PushItemFlag(ImGuiItemFlags option, bool enabled);\r\n    IMGUI_API void          PopItemFlag();\r\n\r\n    IMGUI_API void          OpenPopupEx(ImGuiID id, bool reopen_existing);\r\n    IMGUI_API void          ClosePopup(ImGuiID id);\r\n    IMGUI_API bool          IsPopupOpen(ImGuiID id);\r\n    IMGUI_API bool          BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_flags);\r\n    IMGUI_API void          BeginTooltipEx(ImGuiWindowFlags extra_flags, bool override_previous_tooltip = true);\r\n\r\n    IMGUI_API int           CalcTypematicPressedRepeatAmount(float t, float t_prev, float repeat_delay, float repeat_rate);\r\n\r\n    IMGUI_API void          Scrollbar(ImGuiLayoutType direction);\r\n    IMGUI_API void          VerticalSeparator();        // Vertical separator, for menu bars (use current line height). not exposed because it is misleading what it doesn't have an effect on regular layout.\r\n    IMGUI_API bool          SplitterBehavior(ImGuiID id, const ImRect& bb, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend = 0.0f);\r\n\r\n    IMGUI_API bool          BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id);\r\n    IMGUI_API void          ClearDragDrop();\r\n    IMGUI_API bool          IsDragDropPayloadBeingAccepted();\r\n\r\n    // FIXME-WIP: New Columns API\r\n    IMGUI_API void          BeginColumns(const char* str_id, int count, ImGuiColumnsFlags flags = 0); // setup number of columns. use an identifier to distinguish multiple column sets. close with EndColumns().\r\n    IMGUI_API void          EndColumns();                                                             // close columns\r\n    IMGUI_API void          PushColumnClipRect(int column_index = -1);\r\n\r\n    // NB: All position are in absolute pixels coordinates (never using window coordinates internally)\r\n    // AVOID USING OUTSIDE OF IMGUI.CPP! NOT FOR PUBLIC CONSUMPTION. THOSE FUNCTIONS ARE A MESS. THEIR SIGNATURE AND BEHAVIOR WILL CHANGE, THEY NEED TO BE REFACTORED INTO SOMETHING DECENT.\r\n    IMGUI_API void          RenderText(ImVec2 pos, const char* text, const char* text_end = NULL, bool hide_text_after_hash = true);\r\n    IMGUI_API void          RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width);\r\n    IMGUI_API void          RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0,0), const ImRect* clip_rect = NULL);\r\n    IMGUI_API void          RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border = true, float rounding = 0.0f);\r\n    IMGUI_API void          RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding = 0.0f);\r\n    IMGUI_API void          RenderColorRectWithAlphaCheckerboard(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, float grid_step, ImVec2 grid_off, float rounding = 0.0f, int rounding_corners_flags = ~0);\r\n    IMGUI_API void          RenderTriangle(ImVec2 pos, ImGuiDir dir, float scale = 1.0f);\r\n    IMGUI_API void          RenderBullet(ImVec2 pos);\r\n    IMGUI_API void          RenderCheckMark(ImVec2 pos, ImU32 col, float sz);\r\n    IMGUI_API void          RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding);\r\n    IMGUI_API const char*   FindRenderedTextEnd(const char* text, const char* text_end = NULL); // Find the optional ## from which we stop displaying text.\r\n\r\n    IMGUI_API bool          ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags = 0);\r\n    IMGUI_API bool          ButtonEx(const char* label, const ImVec2& size_arg = ImVec2(0,0), ImGuiButtonFlags flags = 0);\r\n    IMGUI_API bool          CloseButton(ImGuiID id, const ImVec2& pos, float radius);\r\n    IMGUI_API bool          ArrowButton(ImGuiID id, ImGuiDir dir, ImVec2 padding, ImGuiButtonFlags flags = 0);\r\n\r\n    IMGUI_API bool          SliderBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v_min, float v_max, float power, int decimal_precision, ImGuiSliderFlags flags = 0);\r\n    IMGUI_API bool          SliderFloatN(const char* label, float* v, int components, float v_min, float v_max, const char* display_format, float power);\r\n    IMGUI_API bool          SliderIntN(const char* label, int* v, int components, int v_min, int v_max, const char* display_format);\r\n\r\n    IMGUI_API bool          DragBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v_speed, float v_min, float v_max, int decimal_precision, float power);\r\n    IMGUI_API bool          DragFloatN(const char* label, float* v, int components, float v_speed, float v_min, float v_max, const char* display_format, float power);\r\n    IMGUI_API bool          DragIntN(const char* label, int* v, int components, float v_speed, int v_min, int v_max, const char* display_format);\r\n\r\n    IMGUI_API bool          InputTextEx(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback = NULL, void* user_data = NULL);\r\n    IMGUI_API bool          InputFloatN(const char* label, float* v, int components, int decimal_precision, ImGuiInputTextFlags extra_flags);\r\n    IMGUI_API bool          InputIntN(const char* label, int* v, int components, ImGuiInputTextFlags extra_flags);\r\n    IMGUI_API bool          InputScalarEx(const char* label, ImGuiDataType data_type, void* data_ptr, void* step_ptr, void* step_fast_ptr, const char* scalar_format, ImGuiInputTextFlags extra_flags);\r\n    IMGUI_API bool          InputScalarAsWidgetReplacement(const ImRect& aabb, const char* label, ImGuiDataType data_type, void* data_ptr, ImGuiID id, int decimal_precision);\r\n\r\n    IMGUI_API void          ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags);\r\n    IMGUI_API void          ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags);\r\n\r\n    IMGUI_API bool          TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end = NULL);\r\n    IMGUI_API bool          TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags = 0);                     // Consume previous SetNextTreeNodeOpened() data, if any. May return true when logging\r\n    IMGUI_API void          TreePushRawID(ImGuiID id);\r\n\r\n    IMGUI_API void          PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size);\r\n\r\n    IMGUI_API int           ParseFormatPrecision(const char* fmt, int default_value);\r\n    IMGUI_API float         RoundScalar(float value, int decimal_precision);\r\n\r\n    // Shade functions\r\n    IMGUI_API void          ShadeVertsLinearColorGradientKeepAlpha(ImDrawVert* vert_start, ImDrawVert* vert_end, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1);\r\n    IMGUI_API void          ShadeVertsLinearAlphaGradientForLeftToRightText(ImDrawVert* vert_start, ImDrawVert* vert_end, float gradient_p0_x, float gradient_p1_x);\r\n    IMGUI_API void          ShadeVertsLinearUV(ImDrawVert* vert_start, ImDrawVert* vert_end, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp);\r\n\r\n} // namespace ImGui\r\n\r\n// ImFontAtlas internals\r\nIMGUI_API bool              ImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas);\r\nIMGUI_API void              ImFontAtlasBuildRegisterDefaultCustomRects(ImFontAtlas* atlas);\r\nIMGUI_API void              ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent); \r\nIMGUI_API void              ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* spc);\r\nIMGUI_API void              ImFontAtlasBuildFinish(ImFontAtlas* atlas);\r\nIMGUI_API void              ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_multiply_factor);\r\nIMGUI_API void              ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride);\r\n\r\n#ifdef __clang__\r\n#pragma clang diagnostic pop\r\n#endif\r\n\r\n#ifdef _MSC_VER\r\n#pragma warning (pop)\r\n#endif\r\n","// dear imgui, v1.53\r\n// (headers)\r\n\r\n// See imgui.cpp file for documentation.\r\n// Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code.\r\n// Read 'Programmer guide' in imgui.cpp for notes on how to setup ImGui in your codebase.\r\n// Get latest version at https://github.com/ocornut/imgui\r\n\r\n#pragma once\r\n\r\n#if !defined(IMGUI_DISABLE_INCLUDE_IMCONFIG_H) || defined(IMGUI_INCLUDE_IMCONFIG_H)\r\n#include \"imconfig.h\"       // User-editable configuration file\r\n#endif\r\n#include <float.h>          // FLT_MAX\r\n#include <stdarg.h>         // va_list\r\n#include <stddef.h>         // ptrdiff_t, NULL\r\n#include <string.h>         // memset, memmove, memcpy, strlen, strchr, strcpy, strcmp\r\n\r\n#define IMGUI_VERSION       \"1.53\"\r\n\r\n// Define attributes of all API symbols declarations, e.g. for DLL under Windows.\r\n#ifndef IMGUI_API\r\n#define IMGUI_API\r\n#endif\r\n\r\n// Define assertion handler.\r\n#ifndef IM_ASSERT\r\n#include <assert.h>\r\n#define IM_ASSERT(_EXPR)    assert(_EXPR)\r\n#endif\r\n\r\n// Helpers\r\n// Some compilers support applying printf-style warnings to user functions.\r\n#if defined(__clang__) || defined(__GNUC__)\r\n#define IM_FMTARGS(FMT)             __attribute__((format(printf, FMT, FMT+1)))\r\n#define IM_FMTLIST(FMT)             __attribute__((format(printf, FMT, 0)))\r\n#else\r\n#define IM_FMTARGS(FMT)\r\n#define IM_FMTLIST(FMT)\r\n#endif\r\n#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR)/sizeof(*_ARR)))\r\n\r\n#if defined(__clang__)\r\n#pragma clang diagnostic push\r\n#pragma clang diagnostic ignored \"-Wold-style-cast\"\r\n#endif\r\n\r\n// Forward declarations\r\nstruct ImDrawChannel;               // Temporary storage for outputting drawing commands out of order, used by ImDrawList::ChannelsSplit()\r\nstruct ImDrawCmd;                   // A single draw command within a parent ImDrawList (generally maps to 1 GPU draw call)\r\nstruct ImDrawData;                  // All draw command lists required to render the frame\r\nstruct ImDrawList;                  // A single draw command list (generally one per window)\r\nstruct ImDrawListSharedData;        // Data shared among multiple draw lists (typically owned by parent ImGui context, but you may create one yourself)\r\nstruct ImDrawVert;                  // A single vertex (20 bytes by default, override layout with IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT)\r\nstruct ImFont;                      // Runtime data for a single font within a parent ImFontAtlas\r\nstruct ImFontAtlas;                 // Runtime data for multiple fonts, bake multiple fonts into a single texture, TTF/OTF font loader\r\nstruct ImFontConfig;                // Configuration data when adding a font or merging fonts\r\nstruct ImColor;                     // Helper functions to create a color that can be converted to either u32 or float4\r\nstruct ImGuiIO;                     // Main configuration and I/O between your application and ImGui\r\nstruct ImGuiOnceUponAFrame;         // Simple helper for running a block of code not more than once a frame, used by IMGUI_ONCE_UPON_A_FRAME macro\r\nstruct ImGuiStorage;                // Simple custom key value storage\r\nstruct ImGuiStyle;                  // Runtime data for styling/colors\r\nstruct ImGuiTextFilter;             // Parse and apply text filters. In format \"aaaaa[,bbbb][,ccccc]\"\r\nstruct ImGuiTextBuffer;             // Text buffer for logging/accumulating text\r\nstruct ImGuiTextEditCallbackData;   // Shared state of ImGui::InputText() when using custom ImGuiTextEditCallback (rare/advanced use)\r\nstruct ImGuiSizeConstraintCallbackData;// Structure used to constraint window size in custom ways when using custom ImGuiSizeConstraintCallback (rare/advanced use)\r\nstruct ImGuiListClipper;            // Helper to manually clip large list of items\r\nstruct ImGuiPayload;                // User data payload for drag and drop operations\r\nstruct ImGuiContext;                // ImGui context (opaque)\r\n\r\n// Typedefs and Enumerations (declared as int for compatibility and to not pollute the top of this file)\r\ntypedef unsigned int ImU32;         // 32-bit unsigned integer (typically used to store packed colors)\r\ntypedef unsigned int ImGuiID;       // unique ID used by widgets (typically hashed from a stack of string)\r\ntypedef unsigned short ImWchar;     // character for keyboard input/display\r\ntypedef void* ImTextureID;          // user data to identify a texture (this is whatever to you want it to be! read the FAQ about ImTextureID in imgui.cpp)\r\ntypedef int ImGuiCol;               // enum: a color identifier for styling     // enum ImGuiCol_\r\ntypedef int ImGuiCond;              // enum: a condition for Set*()             // enum ImGuiCond_\r\ntypedef int ImGuiKey;               // enum: a key identifier (ImGui-side enum) // enum ImGuiKey_\r\ntypedef int ImGuiMouseCursor;       // enum: a mouse cursor identifier          // enum ImGuiMouseCursor_\r\ntypedef int ImGuiStyleVar;          // enum: a variable identifier for styling  // enum ImGuiStyleVar_\r\ntypedef int ImDrawCornerFlags;      // flags: for ImDrawList::AddRect*() etc.   // enum ImDrawCornerFlags_\r\ntypedef int ImDrawListFlags;        // flags: for ImDrawList                    // enum ImDrawListFlags_\r\ntypedef int ImGuiColorEditFlags;    // flags: for ColorEdit*(), ColorPicker*()  // enum ImGuiColorEditFlags_\r\ntypedef int ImGuiColumnsFlags;      // flags: for *Columns*()                   // enum ImGuiColumnsFlags_\r\ntypedef int ImGuiDragDropFlags;     // flags: for *DragDrop*()                  // enum ImGuiDragDropFlags_\r\ntypedef int ImGuiComboFlags;        // flags: for BeginCombo()                  // enum ImGuiComboFlags_\r\ntypedef int ImGuiFocusedFlags;      // flags: for IsWindowFocused()             // enum ImGuiFocusedFlags_\r\ntypedef int ImGuiHoveredFlags;      // flags: for IsItemHovered() etc.          // enum ImGuiHoveredFlags_\r\ntypedef int ImGuiInputTextFlags;    // flags: for InputText*()                  // enum ImGuiInputTextFlags_\r\ntypedef int ImGuiSelectableFlags;   // flags: for Selectable()                  // enum ImGuiSelectableFlags_\r\ntypedef int ImGuiTreeNodeFlags;     // flags: for TreeNode*(),CollapsingHeader()// enum ImGuiTreeNodeFlags_\r\ntypedef int ImGuiWindowFlags;       // flags: for Begin*()                      // enum ImGuiWindowFlags_\r\ntypedef int (*ImGuiTextEditCallback)(ImGuiTextEditCallbackData *data);\r\ntypedef void (*ImGuiSizeConstraintCallback)(ImGuiSizeConstraintCallbackData* data);\r\n#if defined(_MSC_VER) && !defined(__clang__)\r\ntypedef unsigned __int64 ImU64;     // 64-bit unsigned integer\r\n#else\r\ntypedef unsigned long long ImU64;   // 64-bit unsigned integer\r\n#endif \r\n\r\n// Others helpers at bottom of the file:\r\n// class ImVector<>                 // Lightweight std::vector like class.\r\n// IMGUI_ONCE_UPON_A_FRAME          // Execute a block of code once per frame only (convenient for creating UI within deep-nested code that runs multiple times)\r\n\r\nstruct ImVec2\r\n{\r\n    float x, y;\r\n    ImVec2() { x = y = 0.0f; }\r\n    ImVec2(float _x, float _y) { x = _x; y = _y; }\r\n#ifdef IM_VEC2_CLASS_EXTRA          // Define constructor and implicit cast operators in imconfig.h to convert back<>forth from your math types and ImVec2.\r\n    IM_VEC2_CLASS_EXTRA\r\n#endif\r\n};\r\n\r\nstruct ImVec4\r\n{\r\n    float x, y, z, w;\r\n    ImVec4() { x = y = z = w = 0.0f; }\r\n    ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }\r\n#ifdef IM_VEC4_CLASS_EXTRA          // Define constructor and implicit cast operators in imconfig.h to convert back<>forth from your math types and ImVec4.\r\n    IM_VEC4_CLASS_EXTRA\r\n#endif\r\n};\r\n\r\n// ImGui end-user API\r\n// In a namespace so that user can add extra functions in a separate file (e.g. Value() helpers for your vector or common types)\r\nnamespace ImGui\r\n{\r\n    // Main\r\n    IMGUI_API ImGuiIO&      GetIO();\r\n    IMGUI_API ImGuiStyle&   GetStyle();\r\n    IMGUI_API ImDrawData*   GetDrawData();                              // same value as passed to your io.RenderDrawListsFn() function. valid after Render() and until the next call to NewFrame()\r\n    IMGUI_API void          NewFrame();                                 // start a new ImGui frame, you can submit any command from this point until Render()/EndFrame().\r\n    IMGUI_API void          Render();                                   // ends the ImGui frame, finalize the draw data, then call your io.RenderDrawListsFn() function if set.\r\n    IMGUI_API void          EndFrame();                                 // ends the ImGui frame. automatically called by Render(), so most likely don't need to ever call that yourself directly. If you don't need to render you may call EndFrame() but you'll have wasted CPU already. If you don't need to render, better to not create any imgui windows instead!\r\n    IMGUI_API void          Shutdown();\r\n\r\n    // Demo, Debug, Informations\r\n    IMGUI_API void          ShowDemoWindow(bool* p_open = NULL);        // create demo/test window (previously called ShowTestWindow). demonstrate most ImGui features. call this to learn about the library! try to make it always available in your application!\r\n    IMGUI_API void          ShowMetricsWindow(bool* p_open = NULL);     // create metrics window. display ImGui internals: draw commands (with individual draw calls and vertices), window list, basic internal state, etc.\r\n    IMGUI_API void          ShowStyleEditor(ImGuiStyle* ref = NULL);    // add style editor block (not a window). you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style)\r\n    IMGUI_API bool          ShowStyleSelector(const char* label);\r\n    IMGUI_API void          ShowFontSelector(const char* label);\r\n    IMGUI_API void          ShowUserGuide();                            // add basic help/info block (not a window): how to manipulate ImGui as a end-user (mouse/keyboard controls).\r\n\r\n    // Window\r\n    IMGUI_API bool          Begin(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);                                                   // push window to the stack and start appending to it. see .cpp for details. return false when window is collapsed, so you can early out in your code. 'bool* p_open' creates a widget on the upper-right to close the window (which sets your bool to false).\r\n    IMGUI_API void          End();                                                                                                                      // finish appending to current window, pop it off the window stack.\r\n    IMGUI_API bool          BeginChild(const char* str_id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0);    // begin a scrolling region. size==0.0f: use remaining window size, size<0.0f: use remaining window size minus abs(size). size>0.0f: fixed size. each axis can use a different mode, e.g. ImVec2(0,400).\r\n    IMGUI_API bool          BeginChild(ImGuiID id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0);            // \"\r\n    IMGUI_API void          EndChild();\r\n    IMGUI_API ImVec2        GetContentRegionMax();                                              // current content boundaries (typically window boundaries including scrolling, or current column boundaries), in windows coordinates\r\n    IMGUI_API ImVec2        GetContentRegionAvail();                                            // == GetContentRegionMax() - GetCursorPos()\r\n    IMGUI_API float         GetContentRegionAvailWidth();                                       //\r\n    IMGUI_API ImVec2        GetWindowContentRegionMin();                                        // content boundaries min (roughly (0,0)-Scroll), in window coordinates\r\n    IMGUI_API ImVec2        GetWindowContentRegionMax();                                        // content boundaries max (roughly (0,0)+Size-Scroll) where Size can be override with SetNextWindowContentSize(), in window coordinates\r\n    IMGUI_API float         GetWindowContentRegionWidth();                                      //\r\n    IMGUI_API ImDrawList*   GetWindowDrawList();                                                // get rendering command-list if you want to append your own draw primitives\r\n    IMGUI_API ImVec2        GetWindowPos();                                                     // get current window position in screen space (useful if you want to do your own drawing via the DrawList api)\r\n    IMGUI_API ImVec2        GetWindowSize();                                                    // get current window size\r\n    IMGUI_API float         GetWindowWidth();\r\n    IMGUI_API float         GetWindowHeight();\r\n    IMGUI_API bool          IsWindowCollapsed();\r\n    IMGUI_API bool          IsWindowAppearing();\r\n    IMGUI_API void          SetWindowFontScale(float scale);                                    // per-window font scale. Adjust IO.FontGlobalScale if you want to scale all windows\r\n\r\n    IMGUI_API void          SetNextWindowPos(const ImVec2& pos, ImGuiCond cond = 0, const ImVec2& pivot = ImVec2(0,0)); // set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.\r\n    IMGUI_API void          SetNextWindowSize(const ImVec2& size, ImGuiCond cond = 0);          // set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()\r\n    IMGUI_API void          SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeConstraintCallback custom_callback = NULL, void* custom_callback_data = NULL); // set next window size limits. use -1,-1 on either X/Y axis to preserve the current size. Use callback to apply non-trivial programmatic constraints.\r\n    IMGUI_API void          SetNextWindowContentSize(const ImVec2& size);                       // set next window content size (~ enforce the range of scrollbars). not including window decorations (title bar, menu bar, etc.). set an axis to 0.0f to leave it automatic. call before Begin()\r\n    IMGUI_API void          SetNextWindowCollapsed(bool collapsed, ImGuiCond cond = 0);         // set next window collapsed state. call before Begin()\r\n    IMGUI_API void          SetNextWindowFocus();                                               // set next window to be focused / front-most. call before Begin()\r\n    IMGUI_API void          SetWindowPos(const ImVec2& pos, ImGuiCond cond = 0);                // (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.\r\n    IMGUI_API void          SetWindowSize(const ImVec2& size, ImGuiCond cond = 0);              // (not recommended) set current window size - call within Begin()/End(). set to ImVec2(0,0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.    \r\n    IMGUI_API void          SetWindowCollapsed(bool collapsed, ImGuiCond cond = 0);             // (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().\r\n    IMGUI_API void          SetWindowFocus();                                                   // (not recommended) set current window to be focused / front-most. prefer using SetNextWindowFocus().\r\n    IMGUI_API void          SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond = 0);      // set named window position.\r\n    IMGUI_API void          SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond = 0);    // set named window size. set axis to 0.0f to force an auto-fit on this axis.\r\n    IMGUI_API void          SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond = 0);   // set named window collapsed state\r\n    IMGUI_API void          SetWindowFocus(const char* name);                                           // set named window to be focused / front-most. use NULL to remove focus.\r\n\r\n    IMGUI_API float         GetScrollX();                                                       // get scrolling amount [0..GetScrollMaxX()]\r\n    IMGUI_API float         GetScrollY();                                                       // get scrolling amount [0..GetScrollMaxY()]\r\n    IMGUI_API float         GetScrollMaxX();                                                    // get maximum scrolling amount ~~ ContentSize.X - WindowSize.X\r\n    IMGUI_API float         GetScrollMaxY();                                                    // get maximum scrolling amount ~~ ContentSize.Y - WindowSize.Y\r\n    IMGUI_API void          SetScrollX(float scroll_x);                                         // set scrolling amount [0..GetScrollMaxX()]\r\n    IMGUI_API void          SetScrollY(float scroll_y);                                         // set scrolling amount [0..GetScrollMaxY()]\r\n    IMGUI_API void          SetScrollHere(float center_y_ratio = 0.5f);                         // adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a \"default/current item\" visible, consider using SetItemDefaultFocus() instead.\r\n    IMGUI_API void          SetScrollFromPosY(float pos_y, float center_y_ratio = 0.5f);        // adjust scrolling amount to make given position valid. use GetCursorPos() or GetCursorStartPos()+offset to get valid positions.\r\n    IMGUI_API void          SetStateStorage(ImGuiStorage* tree);                                // replace tree state storage with our own (if you want to manipulate it yourself, typically clear subsection of it)\r\n    IMGUI_API ImGuiStorage* GetStateStorage();\r\n\r\n    // Parameters stacks (shared)\r\n    IMGUI_API void          PushFont(ImFont* font);                                             // use NULL as a shortcut to push default font\r\n    IMGUI_API void          PopFont();\r\n    IMGUI_API void          PushStyleColor(ImGuiCol idx, ImU32 col);\r\n    IMGUI_API void          PushStyleColor(ImGuiCol idx, const ImVec4& col);\r\n    IMGUI_API void          PopStyleColor(int count = 1);\r\n    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, float val);\r\n    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, const ImVec2& val);\r\n    IMGUI_API void          PopStyleVar(int count = 1);\r\n    IMGUI_API const ImVec4& GetStyleColorVec4(ImGuiCol idx);                                    // retrieve style color as stored in ImGuiStyle structure. use to feed back into PushStyleColor(), otherwhise use GetColorU32() to get style color + style alpha.\r\n    IMGUI_API ImFont*       GetFont();                                                          // get current font\r\n    IMGUI_API float         GetFontSize();                                                      // get current font size (= height in pixels) of current font with current scale applied\r\n    IMGUI_API ImVec2        GetFontTexUvWhitePixel();                                           // get UV coordinate for a while pixel, useful to draw custom shapes via the ImDrawList API\r\n    IMGUI_API ImU32         GetColorU32(ImGuiCol idx, float alpha_mul = 1.0f);                  // retrieve given style color with style alpha applied and optional extra alpha multiplier\r\n    IMGUI_API ImU32         GetColorU32(const ImVec4& col);                                     // retrieve given color with style alpha applied\r\n    IMGUI_API ImU32         GetColorU32(ImU32 col);                                             // retrieve given color with style alpha applied\r\n\r\n    // Parameters stacks (current window)\r\n    IMGUI_API void          PushItemWidth(float item_width);                                    // width of items for the common item+label case, pixels. 0.0f = default to ~2/3 of windows width, >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side)\r\n    IMGUI_API void          PopItemWidth();\r\n    IMGUI_API float         CalcItemWidth();                                                    // width of item given pushed settings and current cursor position\r\n    IMGUI_API void          PushTextWrapPos(float wrap_pos_x = 0.0f);                           // word-wrapping for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space\r\n    IMGUI_API void          PopTextWrapPos();\r\n    IMGUI_API void          PushAllowKeyboardFocus(bool allow_keyboard_focus);                  // allow focusing using TAB/Shift-TAB, enabled by default but you can disable it for certain widgets\r\n    IMGUI_API void          PopAllowKeyboardFocus();\r\n    IMGUI_API void          PushButtonRepeat(bool repeat);                                      // in 'repeat' mode, Button*() functions return repeated true in a typematic manner (using io.KeyRepeatDelay/io.KeyRepeatRate setting). Note that you can call IsItemActive() after any Button() to tell if the button is held in the current frame.\r\n    IMGUI_API void          PopButtonRepeat();\r\n\r\n    // Cursor / Layout\r\n    IMGUI_API void          Separator();                                                        // separator, generally horizontal. inside a menu bar or in horizontal layout mode, this becomes a vertical separator.\r\n    IMGUI_API void          SameLine(float pos_x = 0.0f, float spacing_w = -1.0f);              // call between widgets or groups to layout them horizontally\r\n    IMGUI_API void          NewLine();                                                          // undo a SameLine()\r\n    IMGUI_API void          Spacing();                                                          // add vertical spacing\r\n    IMGUI_API void          Dummy(const ImVec2& size);                                          // add a dummy item of given size\r\n    IMGUI_API void          Indent(float indent_w = 0.0f);                                      // move content position toward the right, by style.IndentSpacing or indent_w if != 0\r\n    IMGUI_API void          Unindent(float indent_w = 0.0f);                                    // move content position back to the left, by style.IndentSpacing or indent_w if != 0\r\n    IMGUI_API void          BeginGroup();                                                       // lock horizontal starting position + capture group bounding box into one \"item\" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)\r\n    IMGUI_API void          EndGroup();\r\n    IMGUI_API ImVec2        GetCursorPos();                                                     // cursor position is relative to window position\r\n    IMGUI_API float         GetCursorPosX();                                                    // \"\r\n    IMGUI_API float         GetCursorPosY();                                                    // \"\r\n    IMGUI_API void          SetCursorPos(const ImVec2& local_pos);                              // \"\r\n    IMGUI_API void          SetCursorPosX(float x);                                             // \"\r\n    IMGUI_API void          SetCursorPosY(float y);                                             // \"\r\n    IMGUI_API ImVec2        GetCursorStartPos();                                                // initial cursor position\r\n    IMGUI_API ImVec2        GetCursorScreenPos();                                               // cursor position in absolute screen coordinates [0..io.DisplaySize] (useful to work with ImDrawList API)\r\n    IMGUI_API void          SetCursorScreenPos(const ImVec2& pos);                              // cursor position in absolute screen coordinates [0..io.DisplaySize]\r\n    IMGUI_API void          AlignTextToFramePadding();                                          // vertically align/lower upcoming text to FramePadding.y so that it will aligns to upcoming widgets (call if you have text on a line before regular widgets)\r\n    IMGUI_API float         GetTextLineHeight();                                                // ~ FontSize\r\n    IMGUI_API float         GetTextLineHeightWithSpacing();                                     // ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text)\r\n    IMGUI_API float         GetFrameHeight();                                                   // ~ FontSize + style.FramePadding.y * 2\r\n    IMGUI_API float         GetFrameHeightWithSpacing();                                        // ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets)\r\n\r\n    // Columns\r\n    // You can also use SameLine(pos_x) for simplified columns. The columns API is still work-in-progress and rather lacking.\r\n    IMGUI_API void          Columns(int count = 1, const char* id = NULL, bool border = true);\r\n    IMGUI_API void          NextColumn();                                                       // next column, defaults to current row or next row if the current row is finished\r\n    IMGUI_API int           GetColumnIndex();                                                   // get current column index\r\n    IMGUI_API float         GetColumnWidth(int column_index = -1);                              // get column width (in pixels). pass -1 to use current column\r\n    IMGUI_API void          SetColumnWidth(int column_index, float width);                      // set column width (in pixels). pass -1 to use current column\r\n    IMGUI_API float         GetColumnOffset(int column_index = -1);                             // get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetColumnsCount() inclusive. column 0 is typically 0.0f\r\n    IMGUI_API void          SetColumnOffset(int column_index, float offset_x);                  // set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column\r\n    IMGUI_API int           GetColumnsCount();\r\n\r\n    // ID scopes\r\n    // If you are creating widgets in a loop you most likely want to push a unique identifier (e.g. object pointer, loop index) so ImGui can differentiate them.\r\n    // You can also use the \"##foobar\" syntax within widget label to distinguish them from each others. Read \"A primer on the use of labels/IDs\" in the FAQ for more details.\r\n    IMGUI_API void          PushID(const char* str_id);                                         // push identifier into the ID stack. IDs are hash of the entire stack!\r\n    IMGUI_API void          PushID(const char* str_id_begin, const char* str_id_end);\r\n    IMGUI_API void          PushID(const void* ptr_id);\r\n    IMGUI_API void          PushID(int int_id);\r\n    IMGUI_API void          PopID();\r\n    IMGUI_API ImGuiID       GetID(const char* str_id);                                          // calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself\r\n    IMGUI_API ImGuiID       GetID(const char* str_id_begin, const char* str_id_end);\r\n    IMGUI_API ImGuiID       GetID(const void* ptr_id);\r\n\r\n    // Widgets: Text\r\n    IMGUI_API void          TextUnformatted(const char* text, const char* text_end = NULL);               // raw text without formatting. Roughly equivalent to Text(\"%s\", text) but: A) doesn't require null terminated string if 'text_end' is specified, B) it's faster, no memory copy is done, no buffer size limits, recommended for long chunks of text.\r\n    IMGUI_API void          Text(const char* fmt, ...)                                     IM_FMTARGS(1); // simple formatted text\r\n    IMGUI_API void          TextV(const char* fmt, va_list args)                           IM_FMTLIST(1);\r\n    IMGUI_API void          TextColored(const ImVec4& col, const char* fmt, ...)           IM_FMTARGS(2); // shortcut for PushStyleColor(ImGuiCol_Text, col); Text(fmt, ...); PopStyleColor();\r\n    IMGUI_API void          TextColoredV(const ImVec4& col, const char* fmt, va_list args) IM_FMTLIST(2);\r\n    IMGUI_API void          TextDisabled(const char* fmt, ...)                             IM_FMTARGS(1); // shortcut for PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]); Text(fmt, ...); PopStyleColor();\r\n    IMGUI_API void          TextDisabledV(const char* fmt, va_list args)                   IM_FMTLIST(1);\r\n    IMGUI_API void          TextWrapped(const char* fmt, ...)                              IM_FMTARGS(1); // shortcut for PushTextWrapPos(0.0f); Text(fmt, ...); PopTextWrapPos();. Note that this won't work on an auto-resizing window if there's no other widgets to extend the window width, yoy may need to set a size using SetNextWindowSize().\r\n    IMGUI_API void          TextWrappedV(const char* fmt, va_list args)                    IM_FMTLIST(1);\r\n    IMGUI_API void          LabelText(const char* label, const char* fmt, ...)             IM_FMTARGS(2); // display text+label aligned the same way as value+label widgets\r\n    IMGUI_API void          LabelTextV(const char* label, const char* fmt, va_list args)   IM_FMTLIST(2);\r\n    IMGUI_API void          BulletText(const char* fmt, ...)                               IM_FMTARGS(1); // shortcut for Bullet()+Text()\r\n    IMGUI_API void          BulletTextV(const char* fmt, va_list args)                     IM_FMTLIST(1);\r\n    IMGUI_API void          Bullet();                                                                     // draw a small circle and keep the cursor on the same line. advance cursor x position by GetTreeNodeToLabelSpacing(), same distance that TreeNode() uses\r\n\r\n    // Widgets: Main\r\n    IMGUI_API bool          Button(const char* label, const ImVec2& size = ImVec2(0,0));            // button\r\n    IMGUI_API bool          SmallButton(const char* label);                                         // button with FramePadding=(0,0) to easily embed within text\r\n    IMGUI_API bool          InvisibleButton(const char* str_id, const ImVec2& size);                // button behavior without the visuals, useful to build custom behaviors using the public api (along with IsItemActive, IsItemHovered, etc.)\r\n    IMGUI_API void          Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), const ImVec4& tint_col = ImVec4(1,1,1,1), const ImVec4& border_col = ImVec4(0,0,0,0));\r\n    IMGUI_API bool          ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0),  const ImVec2& uv1 = ImVec2(1,1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0,0,0,0), const ImVec4& tint_col = ImVec4(1,1,1,1));    // <0 frame_padding uses default frame padding settings. 0 for no padding\r\n    IMGUI_API bool          Checkbox(const char* label, bool* v);\r\n    IMGUI_API bool          CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value);\r\n    IMGUI_API bool          RadioButton(const char* label, bool active);\r\n    IMGUI_API bool          RadioButton(const char* label, int* v, int v_button);\r\n    IMGUI_API void          PlotLines(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float));\r\n    IMGUI_API void          PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0));\r\n    IMGUI_API void          PlotHistogram(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float));\r\n    IMGUI_API void          PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0));\r\n    IMGUI_API void          ProgressBar(float fraction, const ImVec2& size_arg = ImVec2(-1,0), const char* overlay = NULL);\r\n\r\n    // Widgets: Combo Box\r\n    // The new BeginCombo()/EndCombo() api allows you to manage your contents and selection state however you want it. \r\n    // The old Combo() api are helpers over BeginCombo()/EndCombo() which are kept available for convenience purpose.\r\n    IMGUI_API bool          BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags = 0);\r\n    IMGUI_API void          EndCombo();\r\n    IMGUI_API bool          Combo(const char* label, int* current_item, const char* const items[], int items_count, int popup_max_height_in_items = -1);\r\n    IMGUI_API bool          Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int popup_max_height_in_items = -1);      // Separate items with \\0 within a string, end item-list with \\0\\0. e.g. \"One\\0Two\\0Three\\0\"\r\n    IMGUI_API bool          Combo(const char* label, int* current_item, bool(*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int popup_max_height_in_items = -1);\r\n\r\n    // Widgets: Drags (tip: ctrl+click on a drag box to input with keyboard. manually input values aren't clamped, can go off-bounds)\r\n    // For all the Float2/Float3/Float4/Int2/Int3/Int4 versions of every functions, note that a 'float v[X]' function argument is the same as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can pass address of your first element out of a contiguous set, e.g. &myvector.x\r\n    IMGUI_API bool          DragFloat(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = \"%.3f\", float power = 1.0f);     // If v_min >= v_max we have no bound\r\n    IMGUI_API bool          DragFloat2(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = \"%.3f\", float power = 1.0f);\r\n    IMGUI_API bool          DragFloat3(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = \"%.3f\", float power = 1.0f);\r\n    IMGUI_API bool          DragFloat4(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = \"%.3f\", float power = 1.0f);\r\n    IMGUI_API bool          DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = \"%.3f\", const char* display_format_max = NULL, float power = 1.0f);\r\n    IMGUI_API bool          DragInt(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = \"%.0f\");                                       // If v_min >= v_max we have no bound\r\n    IMGUI_API bool          DragInt2(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = \"%.0f\");\r\n    IMGUI_API bool          DragInt3(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = \"%.0f\");\r\n    IMGUI_API bool          DragInt4(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = \"%.0f\");\r\n    IMGUI_API bool          DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = \"%.0f\", const char* display_format_max = NULL);\r\n\r\n    // Widgets: Input with Keyboard\r\n    IMGUI_API bool          InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = NULL, void* user_data = NULL);\r\n    IMGUI_API bool          InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0,0), ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = NULL, void* user_data = NULL);\r\n    IMGUI_API bool          InputFloat(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputFloat2(const char* label, float v[2], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputFloat3(const char* label, float v[3], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputFloat4(const char* label, float v[4], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputInt(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags = 0);\r\n    IMGUI_API bool          InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags = 0);\r\n\r\n    // Widgets: Sliders (tip: ctrl+click on a slider to input with keyboard. manually input values aren't clamped, can go off-bounds)\r\n    IMGUI_API bool          SliderFloat(const char* label, float* v, float v_min, float v_max, const char* display_format = \"%.3f\", float power = 1.0f);     // adjust display_format to decorate the value with a prefix or a suffix for in-slider labels or unit display. Use power!=1.0 for logarithmic sliders\r\n    IMGUI_API bool          SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* display_format = \"%.3f\", float power = 1.0f);\r\n    IMGUI_API bool          SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* display_format = \"%.3f\", float power = 1.0f);\r\n    IMGUI_API bool          SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* display_format = \"%.3f\", float power = 1.0f);\r\n    IMGUI_API bool          SliderAngle(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f);\r\n    IMGUI_API bool          SliderInt(const char* label, int* v, int v_min, int v_max, const char* display_format = \"%.0f\");\r\n    IMGUI_API bool          SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* display_format = \"%.0f\");\r\n    IMGUI_API bool          SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* display_format = \"%.0f\");\r\n    IMGUI_API bool          SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* display_format = \"%.0f\");\r\n    IMGUI_API bool          VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format = \"%.3f\", float power = 1.0f);\r\n    IMGUI_API bool          VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format = \"%.0f\");\r\n\r\n    // Widgets: Color Editor/Picker (tip: the ColorEdit* functions have a little colored preview square that can be left-clicked to open a picker, and right-clicked to open an option menu.)\r\n    // Note that a 'float v[X]' function argument is the same as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can the pass the address of a first float element out of a contiguous structure, e.g. &myvector.x\r\n    IMGUI_API bool          ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);\r\n    IMGUI_API bool          ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0);\r\n    IMGUI_API bool          ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);\r\n    IMGUI_API bool          ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags = 0, const float* ref_col = NULL);\r\n    IMGUI_API bool          ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0,0));  // display a colored square/button, hover for details, return true when pressed.\r\n    IMGUI_API void          SetColorEditOptions(ImGuiColorEditFlags flags);                         // initialize current options (generally on application startup) if you want to select a default format, picker type, etc. User will be able to change many settings, unless you pass the _NoOptions flag to your calls.\r\n\r\n    // Widgets: Trees\r\n    IMGUI_API bool          TreeNode(const char* label);                                            // if returning 'true' the node is open and the tree id is pushed into the id stack. user is responsible for calling TreePop().\r\n    IMGUI_API bool          TreeNode(const char* str_id, const char* fmt, ...) IM_FMTARGS(2);       // read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().\r\n    IMGUI_API bool          TreeNode(const void* ptr_id, const char* fmt, ...) IM_FMTARGS(2);       // \"\r\n    IMGUI_API bool          TreeNodeV(const char* str_id, const char* fmt, va_list args) IM_FMTLIST(2);\r\n    IMGUI_API bool          TreeNodeV(const void* ptr_id, const char* fmt, va_list args) IM_FMTLIST(2);\r\n    IMGUI_API bool          TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags = 0);\r\n    IMGUI_API bool          TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_FMTARGS(3);\r\n    IMGUI_API bool          TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_FMTARGS(3);\r\n    IMGUI_API bool          TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) IM_FMTLIST(3);\r\n    IMGUI_API bool          TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) IM_FMTLIST(3);\r\n    IMGUI_API void          TreePush(const char* str_id);                                           // ~ Indent()+PushId(). Already called by TreeNode() when returning true, but you can call Push/Pop yourself for layout purpose\r\n    IMGUI_API void          TreePush(const void* ptr_id = NULL);                                    // \"\r\n    IMGUI_API void          TreePop();                                                              // ~ Unindent()+PopId()\r\n    IMGUI_API void          TreeAdvanceToLabelPos();                                                // advance cursor x position by GetTreeNodeToLabelSpacing()\r\n    IMGUI_API float         GetTreeNodeToLabelSpacing();                                            // horizontal distance preceding label when using TreeNode*() or Bullet() == (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode\r\n    IMGUI_API void          SetNextTreeNodeOpen(bool is_open, ImGuiCond cond = 0);                  // set next TreeNode/CollapsingHeader open state.\r\n    IMGUI_API bool          CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags = 0);      // if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().\r\n    IMGUI_API bool          CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags = 0); // when 'p_open' isn't NULL, display an additional small close button on upper right of the header\r\n\r\n    // Widgets: Selectable / Lists\r\n    IMGUI_API bool          Selectable(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));  // size.x==0.0: use remaining width, size.x>0.0: specify width. size.y==0.0: use label height, size.y>0.0: specify height\r\n    IMGUI_API bool          Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));\r\n    IMGUI_API bool          ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items = -1);\r\n    IMGUI_API bool          ListBox(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1);\r\n    IMGUI_API bool          ListBoxHeader(const char* label, const ImVec2& size = ImVec2(0,0));     // use if you want to reimplement ListBox() will custom data or interactions. make sure to call ListBoxFooter() afterwards.\r\n    IMGUI_API bool          ListBoxHeader(const char* label, int items_count, int height_in_items = -1); // \"\r\n    IMGUI_API void          ListBoxFooter();                                                        // terminate the scrolling region\r\n\r\n    // Widgets: Value() Helpers. Output single value in \"name: value\" format (tip: freely declare more in your code to handle your types. you can add functions to the ImGui namespace)\r\n    IMGUI_API void          Value(const char* prefix, bool b);\r\n    IMGUI_API void          Value(const char* prefix, int v);\r\n    IMGUI_API void          Value(const char* prefix, unsigned int v);\r\n    IMGUI_API void          Value(const char* prefix, float v, const char* float_format = NULL);\r\n\r\n    // Tooltips\r\n    IMGUI_API void          SetTooltip(const char* fmt, ...) IM_FMTARGS(1);                     // set text tooltip under mouse-cursor, typically use with ImGui::IsItemHovered(). overidde any previous call to SetTooltip().\r\n    IMGUI_API void          SetTooltipV(const char* fmt, va_list args) IM_FMTLIST(1);\r\n    IMGUI_API void          BeginTooltip();                                                     // begin/append a tooltip window. to create full-featured tooltip (with any kind of contents).\r\n    IMGUI_API void          EndTooltip();\r\n\r\n    // Menus\r\n    IMGUI_API bool          BeginMainMenuBar();                                                 // create and append to a full screen menu-bar. only call EndMainMenuBar() if this returns true!\r\n    IMGUI_API void          EndMainMenuBar();\r\n    IMGUI_API bool          BeginMenuBar();                                                     // append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set on parent window). only call EndMenuBar() if this returns true!\r\n    IMGUI_API void          EndMenuBar();\r\n    IMGUI_API bool          BeginMenu(const char* label, bool enabled = true);                  // create a sub-menu entry. only call EndMenu() if this returns true!\r\n    IMGUI_API void          EndMenu();\r\n    IMGUI_API bool          MenuItem(const char* label, const char* shortcut = NULL, bool selected = false, bool enabled = true);  // return true when activated. shortcuts are displayed for convenience but not processed by ImGui at the moment\r\n    IMGUI_API bool          MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled = true);              // return true when activated + toggle (*p_selected) if p_selected != NULL\r\n\r\n    // Popups\r\n    IMGUI_API void          OpenPopup(const char* str_id);                                      // call to mark popup as open (don't call every frame!). popups are closed when user click outside, or if CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block. By default, Selectable()/MenuItem() are calling CloseCurrentPopup(). Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).\r\n    IMGUI_API bool          OpenPopupOnItemClick(const char* str_id = NULL, int mouse_button = 1);                                  // helper to open popup when clicked on last item. return true when just opened.\r\n    IMGUI_API bool          BeginPopup(const char* str_id);                                     // return true if the popup is open, and you can start outputting to it. only call EndPopup() if BeginPopup() returned true!\r\n    IMGUI_API bool          BeginPopupModal(const char* name, bool* p_open = NULL, ImGuiWindowFlags extra_flags = 0);               // modal dialog (block interactions behind the modal window, can't close the modal window by clicking outside)\r\n    IMGUI_API bool          BeginPopupContextItem(const char* str_id = NULL, int mouse_button = 1);                                 // helper to open and begin popup when clicked on last item. if you can pass a NULL str_id only if the previous item had an id. If you want to use that on a non-interactive item such as Text() you need to pass in an explicit ID here. read comments in .cpp!\r\n    IMGUI_API bool          BeginPopupContextWindow(const char* str_id = NULL, int mouse_button = 1, bool also_over_items = true);  // helper to open and begin popup when clicked on current window.\r\n    IMGUI_API bool          BeginPopupContextVoid(const char* str_id = NULL, int mouse_button = 1);                                 // helper to open and begin popup when clicked in void (where there are no imgui windows).\r\n    IMGUI_API void          EndPopup();\r\n    IMGUI_API bool          IsPopupOpen(const char* str_id);                                    // return true if the popup is open\r\n    IMGUI_API void          CloseCurrentPopup();                                                // close the popup we have begin-ed into. clicking on a MenuItem or Selectable automatically close the current popup.\r\n\r\n    // Logging/Capture: all text output from interface is captured to tty/file/clipboard. By default, tree nodes are automatically opened during logging.\r\n    IMGUI_API void          LogToTTY(int max_depth = -1);                                       // start logging to tty\r\n    IMGUI_API void          LogToFile(int max_depth = -1, const char* filename = NULL);         // start logging to file\r\n    IMGUI_API void          LogToClipboard(int max_depth = -1);                                 // start logging to OS clipboard\r\n    IMGUI_API void          LogFinish();                                                        // stop logging (close file, etc.)\r\n    IMGUI_API void          LogButtons();                                                       // helper to display buttons for logging to tty/file/clipboard\r\n    IMGUI_API void          LogText(const char* fmt, ...) IM_FMTARGS(1);                        // pass text data straight to log (without being displayed)\r\n\r\n    // Drag and Drop\r\n    // [BETA API] Missing Demo code. API may evolve.\r\n    IMGUI_API bool          BeginDragDropSource(ImGuiDragDropFlags flags = 0, int mouse_button = 0);                // call when the current item is active. If this return true, you can call SetDragDropPayload() + EndDragDropSource()\r\n    IMGUI_API bool          SetDragDropPayload(const char* type, const void* data, size_t size, ImGuiCond cond = 0);// type is a user defined string of maximum 8 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui.\r\n    IMGUI_API void          EndDragDropSource();\r\n    IMGUI_API bool          BeginDragDropTarget();                                                                  // call after submitting an item that may receive an item. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()\r\n    IMGUI_API const ImGuiPayload* AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags = 0);            // accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.\r\n    IMGUI_API void          EndDragDropTarget();\r\n\r\n    // Clipping\r\n    IMGUI_API void          PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect);\r\n    IMGUI_API void          PopClipRect();\r\n\r\n    // Styles\r\n    IMGUI_API void          StyleColorsClassic(ImGuiStyle* dst = NULL);\r\n    IMGUI_API void          StyleColorsDark(ImGuiStyle* dst = NULL);\r\n    IMGUI_API void          StyleColorsLight(ImGuiStyle* dst = NULL);\r\n\r\n    // Focus\r\n    // (FIXME: Those functions will be reworked after we merge the navigation branch + have a pass at focusing/tabbing features.)\r\n    // (Prefer using \"SetItemDefaultFocus()\" over \"if (IsWindowAppearing()) SetScrollHere()\" when applicable, to make your code more forward compatible when navigation branch is merged)\r\n    IMGUI_API void          SetItemDefaultFocus();                                              // make last item the default focused item of a window (WIP navigation branch only). Pleaase use instead of SetScrollHere().\r\n    IMGUI_API void          SetKeyboardFocusHere(int offset = 0);                               // focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.\r\n\r\n    // Utilities\r\n    IMGUI_API bool          IsItemHovered(ImGuiHoveredFlags flags = 0);                         // is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.\r\n    IMGUI_API bool          IsItemActive();                                                     // is the last item active? (e.g. button being held, text field being edited- items that don't interact will always return false)\r\n    IMGUI_API bool          IsItemClicked(int mouse_button = 0);                                // is the last item clicked? (e.g. button/node just clicked on)\r\n    IMGUI_API bool          IsItemVisible();                                                    // is the last item visible? (aka not out of sight due to clipping/scrolling.)\r\n    IMGUI_API bool          IsAnyItemHovered();\r\n    IMGUI_API bool          IsAnyItemActive();\r\n    IMGUI_API ImVec2        GetItemRectMin();                                                   // get bounding rectangle of last item, in screen space\r\n    IMGUI_API ImVec2        GetItemRectMax();                                                   // \"\r\n    IMGUI_API ImVec2        GetItemRectSize();                                                  // get size of last item, in screen space\r\n    IMGUI_API void          SetItemAllowOverlap();                                              // allow last item to be overlapped by a subsequent item. sometimes useful with invisible buttons, selectables, etc. to catch unused area.\r\n    IMGUI_API bool          IsWindowFocused(ImGuiFocusedFlags flags = 0);                       // is current window focused? or its root/child, depending on flags. see flags for options.\r\n    IMGUI_API bool          IsWindowHovered(ImGuiHoveredFlags flags = 0);                       // is current window hovered (and typically: not blocked by a popup/modal)? see flags for options.\r\n    IMGUI_API bool          IsAnyWindowFocused();\r\n    IMGUI_API bool          IsAnyWindowHovered();                                               // is mouse hovering any visible window\r\n    IMGUI_API bool          IsRectVisible(const ImVec2& size);                                  // test if rectangle (of given size, starting from cursor position) is visible / not clipped.\r\n    IMGUI_API bool          IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max);      // test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.\r\n    IMGUI_API float         GetTime();\r\n    IMGUI_API int           GetFrameCount();\r\n    IMGUI_API ImDrawList*   GetOverlayDrawList();                                               // this draw list will be the last rendered one, useful to quickly draw overlays shapes/text\r\n    IMGUI_API ImDrawListSharedData* GetDrawListSharedData();\r\n    IMGUI_API const char*   GetStyleColorName(ImGuiCol idx);\r\n    IMGUI_API ImVec2        CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge = false, float outward = +0.0f);   // utility to find the closest point the last item bounding rectangle edge. useful to visually link items\r\n    IMGUI_API ImVec2        CalcTextSize(const char* text, const char* text_end = NULL, bool hide_text_after_double_hash = false, float wrap_width = -1.0f);\r\n    IMGUI_API void          CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end);    // calculate coarse clipping for large list of evenly sized items. Prefer using the ImGuiListClipper higher-level helper if you can.\r\n\r\n    IMGUI_API bool          BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags = 0);    // helper to create a child window / scrolling region that looks like a normal widget frame\r\n    IMGUI_API void          EndChildFrame();\r\n\r\n    IMGUI_API ImVec4        ColorConvertU32ToFloat4(ImU32 in);\r\n    IMGUI_API ImU32         ColorConvertFloat4ToU32(const ImVec4& in);\r\n    IMGUI_API void          ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v);\r\n    IMGUI_API void          ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b);\r\n\r\n    // Inputs\r\n    IMGUI_API int           GetKeyIndex(ImGuiKey imgui_key);                                    // map ImGuiKey_* values into user's key index. == io.KeyMap[key]\r\n    IMGUI_API bool          IsKeyDown(int user_key_index);                                      // is key being held. == io.KeysDown[user_key_index]. note that imgui doesn't know the semantic of each entry of io.KeyDown[]. Use your own indices/enums according to how your backend/engine stored them into KeyDown[]!\r\n    IMGUI_API bool          IsKeyPressed(int user_key_index, bool repeat = true);               // was key pressed (went from !Down to Down). if repeat=true, uses io.KeyRepeatDelay / KeyRepeatRate\r\n    IMGUI_API bool          IsKeyReleased(int user_key_index);                                  // was key released (went from Down to !Down)..\r\n    IMGUI_API int           GetKeyPressedAmount(int key_index, float repeat_delay, float rate); // uses provided repeat rate/delay. return a count, most often 0 or 1 but might be >1 if RepeatRate is small enough that DeltaTime > RepeatRate\r\n    IMGUI_API bool          IsMouseDown(int button);                                            // is mouse button held\r\n    IMGUI_API bool          IsMouseClicked(int button, bool repeat = false);                    // did mouse button clicked (went from !Down to Down)\r\n    IMGUI_API bool          IsMouseDoubleClicked(int button);                                   // did mouse button double-clicked. a double-click returns false in IsMouseClicked(). uses io.MouseDoubleClickTime.\r\n    IMGUI_API bool          IsMouseReleased(int button);                                        // did mouse button released (went from Down to !Down)\r\n    IMGUI_API bool          IsMouseDragging(int button = 0, float lock_threshold = -1.0f);      // is mouse dragging. if lock_threshold < -1.0f uses io.MouseDraggingThreshold\r\n    IMGUI_API bool          IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip = true);  // is mouse hovering given bounding rect (in screen space). clipped by current clipping settings. disregarding of consideration of focus/window ordering/blocked by a popup.\r\n    IMGUI_API bool          IsMousePosValid(const ImVec2* mouse_pos = NULL);                    //\r\n    IMGUI_API ImVec2        GetMousePos();                                                      // shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls\r\n    IMGUI_API ImVec2        GetMousePosOnOpeningCurrentPopup();                                 // retrieve backup of mouse positioning at the time of opening popup we have BeginPopup() into\r\n    IMGUI_API ImVec2        GetMouseDragDelta(int button = 0, float lock_threshold = -1.0f);    // dragging amount since clicking. if lock_threshold < -1.0f uses io.MouseDraggingThreshold\r\n    IMGUI_API void          ResetMouseDragDelta(int button = 0);                                //\r\n    IMGUI_API ImGuiMouseCursor GetMouseCursor();                                                // get desired cursor type, reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you\r\n    IMGUI_API void          SetMouseCursor(ImGuiMouseCursor type);                              // set desired cursor type\r\n    IMGUI_API void          CaptureKeyboardFromApp(bool capture = true);                        // manually override io.WantCaptureKeyboard flag next frame (said flag is entirely left for your application handle). e.g. force capture keyboard when your widget is being hovered.\r\n    IMGUI_API void          CaptureMouseFromApp(bool capture = true);                           // manually override io.WantCaptureMouse flag next frame (said flag is entirely left for your application handle).\r\n\r\n    // Helpers functions to access functions pointers in ImGui::GetIO()\r\n    IMGUI_API void*         MemAlloc(size_t sz);\r\n    IMGUI_API void          MemFree(void* ptr);\r\n    IMGUI_API const char*   GetClipboardText();\r\n    IMGUI_API void          SetClipboardText(const char* text);\r\n\r\n    // Internal context access - if you want to use multiple context, share context between modules (e.g. DLL). There is a default context created and active by default.\r\n    // All contexts share a same ImFontAtlas by default. If you want different font atlas, you can new() them and overwrite the GetIO().Fonts variable of an ImGui context.\r\n    IMGUI_API const char*   GetVersion();\r\n    IMGUI_API ImGuiContext* CreateContext(void* (*malloc_fn)(size_t) = NULL, void (*free_fn)(void*) = NULL);\r\n    IMGUI_API void          DestroyContext(ImGuiContext* ctx);\r\n    IMGUI_API ImGuiContext* GetCurrentContext();\r\n    IMGUI_API void          SetCurrentContext(ImGuiContext* ctx);\r\n\r\n} // namespace ImGui\r\n\r\n// Flags for ImGui::Begin()\r\nenum ImGuiWindowFlags_\r\n{\r\n    ImGuiWindowFlags_NoTitleBar             = 1 << 0,   // Disable title-bar\r\n    ImGuiWindowFlags_NoResize               = 1 << 1,   // Disable user resizing with the lower-right grip\r\n    ImGuiWindowFlags_NoMove                 = 1 << 2,   // Disable user moving the window\r\n    ImGuiWindowFlags_NoScrollbar            = 1 << 3,   // Disable scrollbars (window can still scroll with mouse or programatically)\r\n    ImGuiWindowFlags_NoScrollWithMouse      = 1 << 4,   // Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.\r\n    ImGuiWindowFlags_NoCollapse             = 1 << 5,   // Disable user collapsing window by double-clicking on it\r\n    ImGuiWindowFlags_AlwaysAutoResize       = 1 << 6,   // Resize every window to its content every frame\r\n    //ImGuiWindowFlags_ShowBorders          = 1 << 7,   // Show borders around windows and items (OBSOLETE! Use e.g. style.FrameBorderSize=1.0f to enable borders).\r\n    ImGuiWindowFlags_NoSavedSettings        = 1 << 8,   // Never load/save settings in .ini file\r\n    ImGuiWindowFlags_NoInputs               = 1 << 9,   // Disable catching mouse or keyboard inputs, hovering test with pass through.\r\n    ImGuiWindowFlags_MenuBar                = 1 << 10,  // Has a menu-bar\r\n    ImGuiWindowFlags_HorizontalScrollbar    = 1 << 11,  // Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the \"Horizontal Scrolling\" section.\r\n    ImGuiWindowFlags_NoFocusOnAppearing     = 1 << 12,  // Disable taking focus when transitioning from hidden to visible state\r\n    ImGuiWindowFlags_NoBringToFrontOnFocus  = 1 << 13,  // Disable bringing window to front when taking focus (e.g. clicking on it or programatically giving it focus)\r\n    ImGuiWindowFlags_AlwaysVerticalScrollbar= 1 << 14,  // Always show vertical scrollbar (even if ContentSize.y < Size.y)\r\n    ImGuiWindowFlags_AlwaysHorizontalScrollbar=1<< 15,  // Always show horizontal scrollbar (even if ContentSize.x < Size.x)\r\n    ImGuiWindowFlags_AlwaysUseWindowPadding = 1 << 16,  // Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)\r\n    ImGuiWindowFlags_ResizeFromAnySide      = 1 << 17,  // (WIP) Enable resize from any corners and borders. Your back-end needs to honor the different values of io.MouseCursor set by imgui.\r\n\r\n    // [Internal]\r\n    ImGuiWindowFlags_ChildWindow            = 1 << 24,  // Don't use! For internal use by BeginChild()\r\n    ImGuiWindowFlags_Tooltip                = 1 << 25,  // Don't use! For internal use by BeginTooltip()\r\n    ImGuiWindowFlags_Popup                  = 1 << 26,  // Don't use! For internal use by BeginPopup()\r\n    ImGuiWindowFlags_Modal                  = 1 << 27,  // Don't use! For internal use by BeginPopupModal()\r\n    ImGuiWindowFlags_ChildMenu              = 1 << 28   // Don't use! For internal use by BeginMenu()\r\n};\r\n\r\n// Flags for ImGui::InputText()\r\nenum ImGuiInputTextFlags_\r\n{\r\n    ImGuiInputTextFlags_CharsDecimal        = 1 << 0,   // Allow 0123456789.+-*/\r\n    ImGuiInputTextFlags_CharsHexadecimal    = 1 << 1,   // Allow 0123456789ABCDEFabcdef\r\n    ImGuiInputTextFlags_CharsUppercase      = 1 << 2,   // Turn a..z into A..Z\r\n    ImGuiInputTextFlags_CharsNoBlank        = 1 << 3,   // Filter out spaces, tabs\r\n    ImGuiInputTextFlags_AutoSelectAll       = 1 << 4,   // Select entire text when first taking mouse focus\r\n    ImGuiInputTextFlags_EnterReturnsTrue    = 1 << 5,   // Return 'true' when Enter is pressed (as opposed to when the value was modified)\r\n    ImGuiInputTextFlags_CallbackCompletion  = 1 << 6,   // Call user function on pressing TAB (for completion handling)\r\n    ImGuiInputTextFlags_CallbackHistory     = 1 << 7,   // Call user function on pressing Up/Down arrows (for history handling)\r\n    ImGuiInputTextFlags_CallbackAlways      = 1 << 8,   // Call user function every time. User code may query cursor position, modify text buffer.\r\n    ImGuiInputTextFlags_CallbackCharFilter  = 1 << 9,   // Call user function to filter character. Modify data->EventChar to replace/filter input, or return 1 to discard character.\r\n    ImGuiInputTextFlags_AllowTabInput       = 1 << 10,  // Pressing TAB input a '\\t' character into the text field\r\n    ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 11,  // In multi-line mode, unfocus with Enter, add new line with Ctrl+Enter (default is opposite: unfocus with Ctrl+Enter, add line with Enter).\r\n    ImGuiInputTextFlags_NoHorizontalScroll  = 1 << 12,  // Disable following the cursor horizontally\r\n    ImGuiInputTextFlags_AlwaysInsertMode    = 1 << 13,  // Insert mode\r\n    ImGuiInputTextFlags_ReadOnly            = 1 << 14,  // Read-only mode\r\n    ImGuiInputTextFlags_Password            = 1 << 15,  // Password mode, display all characters as '*'\r\n    ImGuiInputTextFlags_NoUndoRedo          = 1 << 16,  // Disable undo/redo. Note that input text owns the text data while active, if you want to provide your own undo/redo stack you need e.g. to call ClearActiveID().\r\n    // [Internal]\r\n    ImGuiInputTextFlags_Multiline           = 1 << 20   // For internal use by InputTextMultiline()\r\n};\r\n\r\n// Flags for ImGui::TreeNodeEx(), ImGui::CollapsingHeader*()\r\nenum ImGuiTreeNodeFlags_\r\n{\r\n    ImGuiTreeNodeFlags_Selected             = 1 << 0,   // Draw as selected\r\n    ImGuiTreeNodeFlags_Framed               = 1 << 1,   // Full colored frame (e.g. for CollapsingHeader)\r\n    ImGuiTreeNodeFlags_AllowItemOverlap     = 1 << 2,   // Hit testing to allow subsequent widgets to overlap this one\r\n    ImGuiTreeNodeFlags_NoTreePushOnOpen     = 1 << 3,   // Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack\r\n    ImGuiTreeNodeFlags_NoAutoOpenOnLog      = 1 << 4,   // Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)\r\n    ImGuiTreeNodeFlags_DefaultOpen          = 1 << 5,   // Default node to be open\r\n    ImGuiTreeNodeFlags_OpenOnDoubleClick    = 1 << 6,   // Need double-click to open node\r\n    ImGuiTreeNodeFlags_OpenOnArrow          = 1 << 7,   // Only open when clicking on the arrow part. If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set, single-click arrow or double-click all box to open.\r\n    ImGuiTreeNodeFlags_Leaf                 = 1 << 8,   // No collapsing, no arrow (use as a convenience for leaf nodes). \r\n    ImGuiTreeNodeFlags_Bullet               = 1 << 9,   // Display a bullet instead of arrow\r\n    ImGuiTreeNodeFlags_FramePadding         = 1 << 10,  // Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding().\r\n    //ImGuITreeNodeFlags_SpanAllAvailWidth  = 1 << 11,  // FIXME: TODO: Extend hit box horizontally even if not framed\r\n    //ImGuiTreeNodeFlags_NoScrollOnOpen     = 1 << 12,  // FIXME: TODO: Disable automatic scroll on TreePop() if node got just open and contents is not visible\r\n    ImGuiTreeNodeFlags_CollapsingHeader     = ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoAutoOpenOnLog\r\n\r\n    // Obsolete names (will be removed)\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n    , ImGuiTreeNodeFlags_AllowOverlapMode = ImGuiTreeNodeFlags_AllowItemOverlap\r\n#endif\r\n};\r\n\r\n// Flags for ImGui::Selectable()\r\nenum ImGuiSelectableFlags_\r\n{\r\n    ImGuiSelectableFlags_DontClosePopups    = 1 << 0,   // Clicking this don't close parent popup window\r\n    ImGuiSelectableFlags_SpanAllColumns     = 1 << 1,   // Selectable frame can span all columns (text will still fit in current column)\r\n    ImGuiSelectableFlags_AllowDoubleClick   = 1 << 2    // Generate press events on double clicks too\r\n};\r\n\r\n// Flags for ImGui::BeginCombo()\r\nenum ImGuiComboFlags_\r\n{\r\n    ImGuiComboFlags_PopupAlignLeft          = 1 << 0,   // Align the popup toward the left by default\r\n    ImGuiComboFlags_HeightSmall             = 1 << 1,   // Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo()\r\n    ImGuiComboFlags_HeightRegular           = 1 << 2,   // Max ~8 items visible (default)\r\n    ImGuiComboFlags_HeightLarge             = 1 << 3,   // Max ~20 items visible\r\n    ImGuiComboFlags_HeightLargest           = 1 << 4,   // As many fitting items as possible\r\n    ImGuiComboFlags_HeightMask_             = ImGuiComboFlags_HeightSmall | ImGuiComboFlags_HeightRegular | ImGuiComboFlags_HeightLarge | ImGuiComboFlags_HeightLargest\r\n};\r\n\r\n// Flags for ImGui::IsWindowFocused()\r\nenum ImGuiFocusedFlags_\r\n{\r\n    ImGuiFocusedFlags_ChildWindows                  = 1 << 0,   // IsWindowFocused(): Return true if any children of the window is focused\r\n    ImGuiFocusedFlags_RootWindow                    = 1 << 1,   // IsWindowFocused(): Test from root window (top most parent of the current hierarchy)\r\n    ImGuiFocusedFlags_RootAndChildWindows           = ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows\r\n};\r\n\r\n// Flags for ImGui::IsItemHovered(), ImGui::IsWindowHovered()\r\nenum ImGuiHoveredFlags_\r\n{\r\n    ImGuiHoveredFlags_Default                       = 0,        // Return true if directly over the item/window, not obstructed by another window, not obstructed by an active popup or modal blocking inputs under them.\r\n    ImGuiHoveredFlags_ChildWindows                  = 1 << 0,   // IsWindowHovered() only: Return true if any children of the window is hovered\r\n    ImGuiHoveredFlags_RootWindow                    = 1 << 1,   // IsWindowHovered() only: Test from root window (top most parent of the current hierarchy)\r\n    ImGuiHoveredFlags_AllowWhenBlockedByPopup       = 1 << 2,   // Return true even if a popup window is normally blocking access to this item/window\r\n    //ImGuiHoveredFlags_AllowWhenBlockedByModal     = 1 << 3,   // Return true even if a modal popup window is normally blocking access to this item/window. FIXME-TODO: Unavailable yet.\r\n    ImGuiHoveredFlags_AllowWhenBlockedByActiveItem  = 1 << 4,   // Return true even if an active item is blocking access to this item/window. Useful for Drag and Drop patterns.\r\n    ImGuiHoveredFlags_AllowWhenOverlapped           = 1 << 5,   // Return true even if the position is overlapped by another window\r\n    ImGuiHoveredFlags_RectOnly                      = ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped,\r\n    ImGuiHoveredFlags_RootAndChildWindows           = ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows\r\n};\r\n\r\n// Flags for ImGui::BeginDragDropSource(), ImGui::AcceptDragDropPayload()\r\nenum ImGuiDragDropFlags_\r\n{\r\n    // BeginDragDropSource() flags\r\n    ImGuiDragDropFlags_SourceNoPreviewTooltip       = 1 << 0,       // By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents. This flag disable this behavior.\r\n    ImGuiDragDropFlags_SourceNoDisableHover         = 1 << 1,       // By default, when dragging we clear data so that IsItemHovered() will return true, to avoid subsequent user code submitting tooltips. This flag disable this behavior so you can still call IsItemHovered() on the source item.\r\n    ImGuiDragDropFlags_SourceNoHoldToOpenOthers     = 1 << 2,       // Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item.\r\n    ImGuiDragDropFlags_SourceAllowNullID            = 1 << 3,       // Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position. This is extremely unusual within the dear imgui ecosystem and so we made it explicit.\r\n    ImGuiDragDropFlags_SourceExtern                 = 1 << 4,       // External source (from outside of imgui), won't attempt to read current item/window info. Will always return true. Only one Extern source can be active simultaneously.\r\n    // AcceptDragDropPayload() flags\r\n    ImGuiDragDropFlags_AcceptBeforeDelivery         = 1 << 10,      // AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered.\r\n    ImGuiDragDropFlags_AcceptNoDrawDefaultRect      = 1 << 11,      // Do not draw the default highlight rectangle when hovering over target.\r\n    ImGuiDragDropFlags_AcceptPeekOnly               = ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect  // For peeking ahead and inspecting the payload before delivery.\r\n};\r\n\r\n// Standard Drag and Drop payload types. You can define you own payload types using 8-characters long strings. Types starting with '_' are defined by Dear ImGui.\r\n#define IMGUI_PAYLOAD_TYPE_COLOR_3F     \"_COL3F\"    // float[3]     // Standard type for colors, without alpha. User code may use this type. \r\n#define IMGUI_PAYLOAD_TYPE_COLOR_4F     \"_COL4F\"    // float[4]     // Standard type for colors. User code may use this type.\r\n\r\n// User fill ImGuiIO.KeyMap[] array with indices into the ImGuiIO.KeysDown[512] array\r\nenum ImGuiKey_\r\n{\r\n    ImGuiKey_Tab,       // for tabbing through fields\r\n    ImGuiKey_LeftArrow, // for text edit\r\n    ImGuiKey_RightArrow,// for text edit\r\n    ImGuiKey_UpArrow,   // for text edit\r\n    ImGuiKey_DownArrow, // for text edit\r\n    ImGuiKey_PageUp,\r\n    ImGuiKey_PageDown,\r\n    ImGuiKey_Home,      // for text edit\r\n    ImGuiKey_End,       // for text edit\r\n    ImGuiKey_Delete,    // for text edit\r\n    ImGuiKey_Backspace, // for text edit\r\n    ImGuiKey_Enter,     // for text edit\r\n    ImGuiKey_Escape,    // for text edit\r\n    ImGuiKey_A,         // for text edit CTRL+A: select all\r\n    ImGuiKey_C,         // for text edit CTRL+C: copy\r\n    ImGuiKey_V,         // for text edit CTRL+V: paste\r\n    ImGuiKey_X,         // for text edit CTRL+X: cut\r\n    ImGuiKey_Y,         // for text edit CTRL+Y: redo\r\n    ImGuiKey_Z,         // for text edit CTRL+Z: undo\r\n    ImGuiKey_COUNT\r\n};\r\n\r\n// Enumeration for PushStyleColor() / PopStyleColor()\r\nenum ImGuiCol_\r\n{\r\n    ImGuiCol_Text,\r\n    ImGuiCol_TextDisabled,\r\n    ImGuiCol_WindowBg,              // Background of normal windows\r\n    ImGuiCol_ChildBg,               // Background of child windows\r\n    ImGuiCol_PopupBg,               // Background of popups, menus, tooltips windows\r\n    ImGuiCol_Border,\r\n    ImGuiCol_BorderShadow,\r\n    ImGuiCol_FrameBg,               // Background of checkbox, radio button, plot, slider, text input\r\n    ImGuiCol_FrameBgHovered,\r\n    ImGuiCol_FrameBgActive,\r\n    ImGuiCol_TitleBg,\r\n    ImGuiCol_TitleBgActive,\r\n    ImGuiCol_TitleBgCollapsed,\r\n    ImGuiCol_MenuBarBg,\r\n    ImGuiCol_ScrollbarBg,\r\n    ImGuiCol_ScrollbarGrab,\r\n    ImGuiCol_ScrollbarGrabHovered,\r\n    ImGuiCol_ScrollbarGrabActive,\r\n    ImGuiCol_CheckMark,\r\n    ImGuiCol_SliderGrab,\r\n    ImGuiCol_SliderGrabActive,\r\n    ImGuiCol_Button,\r\n    ImGuiCol_ButtonHovered,\r\n    ImGuiCol_ButtonActive,\r\n    ImGuiCol_Header,\r\n    ImGuiCol_HeaderHovered,\r\n    ImGuiCol_HeaderActive,\r\n    ImGuiCol_Separator,\r\n    ImGuiCol_SeparatorHovered,\r\n    ImGuiCol_SeparatorActive,\r\n    ImGuiCol_ResizeGrip,\r\n    ImGuiCol_ResizeGripHovered,\r\n    ImGuiCol_ResizeGripActive,\r\n    ImGuiCol_CloseButton,\r\n    ImGuiCol_CloseButtonHovered,\r\n    ImGuiCol_CloseButtonActive,\r\n    ImGuiCol_PlotLines,\r\n    ImGuiCol_PlotLinesHovered,\r\n    ImGuiCol_PlotHistogram,\r\n    ImGuiCol_PlotHistogramHovered,\r\n    ImGuiCol_TextSelectedBg,\r\n    ImGuiCol_ModalWindowDarkening,  // darken entire screen when a modal window is active\r\n    ImGuiCol_DragDropTarget,\r\n    ImGuiCol_COUNT\r\n\r\n    // Obsolete names (will be removed)\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n    //, ImGuiCol_ComboBg = ImGuiCol_PopupBg     // ComboBg has been merged with PopupBg, so a redirect isn't accurate.\r\n    , ImGuiCol_ChildWindowBg = ImGuiCol_ChildBg, ImGuiCol_Column = ImGuiCol_Separator, ImGuiCol_ColumnHovered = ImGuiCol_SeparatorHovered, ImGuiCol_ColumnActive = ImGuiCol_SeparatorActive\r\n#endif\r\n};\r\n\r\n// Enumeration for PushStyleVar() / PopStyleVar() to temporarily modify the ImGuiStyle structure.\r\n// NB: the enum only refers to fields of ImGuiStyle which makes sense to be pushed/popped inside UI code. During initialization, feel free to just poke into ImGuiStyle directly.\r\n// NB: if changing this enum, you need to update the associated internal table GStyleVarInfo[] accordingly. This is where we link enum values to members offset/type.\r\nenum ImGuiStyleVar_\r\n{\r\n    // Enum name ......................// Member in ImGuiStyle structure (see ImGuiStyle for descriptions)\r\n    ImGuiStyleVar_Alpha,               // float     Alpha\r\n    ImGuiStyleVar_WindowPadding,       // ImVec2    WindowPadding\r\n    ImGuiStyleVar_WindowRounding,      // float     WindowRounding\r\n    ImGuiStyleVar_WindowBorderSize,    // float     WindowBorderSize\r\n    ImGuiStyleVar_WindowMinSize,       // ImVec2    WindowMinSize\r\n    ImGuiStyleVar_ChildRounding,       // float     ChildRounding\r\n    ImGuiStyleVar_ChildBorderSize,     // float     ChildBorderSize\r\n    ImGuiStyleVar_PopupRounding,       // float     PopupRounding\r\n    ImGuiStyleVar_PopupBorderSize,     // float     PopupBorderSize\r\n    ImGuiStyleVar_FramePadding,        // ImVec2    FramePadding\r\n    ImGuiStyleVar_FrameRounding,       // float     FrameRounding\r\n    ImGuiStyleVar_FrameBorderSize,     // float     FrameBorderSize\r\n    ImGuiStyleVar_ItemSpacing,         // ImVec2    ItemSpacing\r\n    ImGuiStyleVar_ItemInnerSpacing,    // ImVec2    ItemInnerSpacing\r\n    ImGuiStyleVar_IndentSpacing,       // float     IndentSpacing\r\n    ImGuiStyleVar_GrabMinSize,         // float     GrabMinSize\r\n    ImGuiStyleVar_ButtonTextAlign,     // ImVec2    ButtonTextAlign\r\n    ImGuiStyleVar_Count_\r\n\r\n    // Obsolete names (will be removed)\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n    , ImGuiStyleVar_ChildWindowRounding = ImGuiStyleVar_ChildRounding\r\n#endif\r\n};\r\n\r\n// Enumeration for ColorEdit3() / ColorEdit4() / ColorPicker3() / ColorPicker4() / ColorButton()\r\nenum ImGuiColorEditFlags_\r\n{\r\n    ImGuiColorEditFlags_NoAlpha         = 1 << 1,   //              // ColorEdit, ColorPicker, ColorButton: ignore Alpha component (read 3 components from the input pointer).\r\n    ImGuiColorEditFlags_NoPicker        = 1 << 2,   //              // ColorEdit: disable picker when clicking on colored square.\r\n    ImGuiColorEditFlags_NoOptions       = 1 << 3,   //              // ColorEdit: disable toggling options menu when right-clicking on inputs/small preview.\r\n    ImGuiColorEditFlags_NoSmallPreview  = 1 << 4,   //              // ColorEdit, ColorPicker: disable colored square preview next to the inputs. (e.g. to show only the inputs)\r\n    ImGuiColorEditFlags_NoInputs        = 1 << 5,   //              // ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview colored square).\r\n    ImGuiColorEditFlags_NoTooltip       = 1 << 6,   //              // ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.\r\n    ImGuiColorEditFlags_NoLabel         = 1 << 7,   //              // ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).\r\n    ImGuiColorEditFlags_NoSidePreview   = 1 << 8,   //              // ColorPicker: disable bigger color preview on right side of the picker, use small colored square preview instead.\r\n    // User Options (right-click on widget to change some of them). You can set application defaults using SetColorEditOptions(). The idea is that you probably don't want to override them in most of your calls, let the user choose and/or call SetColorEditOptions() during startup.\r\n    ImGuiColorEditFlags_AlphaBar        = 1 << 9,   //              // ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker.\r\n    ImGuiColorEditFlags_AlphaPreview    = 1 << 10,  //              // ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.\r\n    ImGuiColorEditFlags_AlphaPreviewHalf= 1 << 11,  //              // ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque.\r\n    ImGuiColorEditFlags_HDR             = 1 << 12,  //              // (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well).\r\n    ImGuiColorEditFlags_RGB             = 1 << 13,  // [Inputs]     // ColorEdit: choose one among RGB/HSV/HEX. ColorPicker: choose any combination using RGB/HSV/HEX.\r\n    ImGuiColorEditFlags_HSV             = 1 << 14,  // [Inputs]     // \"\r\n    ImGuiColorEditFlags_HEX             = 1 << 15,  // [Inputs]     // \"\r\n    ImGuiColorEditFlags_Uint8           = 1 << 16,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255. \r\n    ImGuiColorEditFlags_Float           = 1 << 17,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.\r\n    ImGuiColorEditFlags_PickerHueBar    = 1 << 18,  // [PickerMode] // ColorPicker: bar for Hue, rectangle for Sat/Value.\r\n    ImGuiColorEditFlags_PickerHueWheel  = 1 << 19,  // [PickerMode] // ColorPicker: wheel for Hue, triangle for Sat/Value.\r\n    // Internals/Masks\r\n    ImGuiColorEditFlags__InputsMask     = ImGuiColorEditFlags_RGB|ImGuiColorEditFlags_HSV|ImGuiColorEditFlags_HEX,\r\n    ImGuiColorEditFlags__DataTypeMask   = ImGuiColorEditFlags_Uint8|ImGuiColorEditFlags_Float,\r\n    ImGuiColorEditFlags__PickerMask     = ImGuiColorEditFlags_PickerHueWheel|ImGuiColorEditFlags_PickerHueBar,\r\n    ImGuiColorEditFlags__OptionsDefault = ImGuiColorEditFlags_Uint8|ImGuiColorEditFlags_RGB|ImGuiColorEditFlags_PickerHueBar    // Change application default using SetColorEditOptions()\r\n};\r\n\r\n// Enumeration for GetMouseCursor()\r\nenum ImGuiMouseCursor_\r\n{\r\n    ImGuiMouseCursor_None = -1,\r\n    ImGuiMouseCursor_Arrow = 0,\r\n    ImGuiMouseCursor_TextInput,         // When hovering over InputText, etc.\r\n    ImGuiMouseCursor_Move,              // Unused\r\n    ImGuiMouseCursor_ResizeNS,          // When hovering over an horizontal border\r\n    ImGuiMouseCursor_ResizeEW,          // When hovering over a vertical border or a column\r\n    ImGuiMouseCursor_ResizeNESW,        // When hovering over the bottom-left corner of a window\r\n    ImGuiMouseCursor_ResizeNWSE,        // When hovering over the bottom-right corner of a window\r\n    ImGuiMouseCursor_Count_\r\n};\r\n\r\n// Condition for ImGui::SetWindow***(), SetNextWindow***(), SetNextTreeNode***() functions\r\n// All those functions treat 0 as a shortcut to ImGuiCond_Always. From the point of view of the user use this as an enum (don't combine multiple values into flags).\r\nenum ImGuiCond_\r\n{\r\n    ImGuiCond_Always        = 1 << 0,   // Set the variable\r\n    ImGuiCond_Once          = 1 << 1,   // Set the variable once per runtime session (only the first call with succeed)\r\n    ImGuiCond_FirstUseEver  = 1 << 2,   // Set the variable if the window has no saved data (if doesn't exist in the .ini file)\r\n    ImGuiCond_Appearing     = 1 << 3    // Set the variable if the window is appearing after being hidden/inactive (or the first time)\r\n\r\n    // Obsolete names (will be removed)\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n    , ImGuiSetCond_Always = ImGuiCond_Always, ImGuiSetCond_Once = ImGuiCond_Once, ImGuiSetCond_FirstUseEver = ImGuiCond_FirstUseEver, ImGuiSetCond_Appearing = ImGuiCond_Appearing\r\n#endif\r\n};\r\n\r\nstruct ImGuiStyle\r\n{\r\n    float       Alpha;                      // Global alpha applies to everything in ImGui\r\n    ImVec2      WindowPadding;              // Padding within a window\r\n    float       WindowRounding;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows\r\n    float       WindowBorderSize;           // Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly)\r\n    ImVec2      WindowMinSize;              // Minimum window size\r\n    ImVec2      WindowTitleAlign;           // Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.\r\n    float       ChildRounding;              // Radius of child window corners rounding. Set to 0.0f to have rectangular windows.\r\n    float       ChildBorderSize;            // Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly)\r\n    float       PopupRounding;              // Radius of popup window corners rounding.\r\n    float       PopupBorderSize;            // Thickness of border around popup windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly)\r\n    ImVec2      FramePadding;               // Padding within a framed rectangle (used by most widgets)\r\n    float       FrameRounding;              // Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).\r\n    float       FrameBorderSize;            // Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly)\r\n    ImVec2      ItemSpacing;                // Horizontal and vertical spacing between widgets/lines\r\n    ImVec2      ItemInnerSpacing;           // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)\r\n    ImVec2      TouchExtraPadding;          // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!\r\n    float       IndentSpacing;              // Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).\r\n    float       ColumnsMinSpacing;          // Minimum horizontal spacing between two columns\r\n    float       ScrollbarSize;              // Width of the vertical scrollbar, Height of the horizontal scrollbar\r\n    float       ScrollbarRounding;          // Radius of grab corners for scrollbar\r\n    float       GrabMinSize;                // Minimum width/height of a grab box for slider/scrollbar.\r\n    float       GrabRounding;               // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.\r\n    ImVec2      ButtonTextAlign;            // Alignment of button text when button is larger than text. Defaults to (0.5f,0.5f) for horizontally+vertically centered.\r\n    ImVec2      DisplayWindowPadding;       // Window positions are clamped to be visible within the display area by at least this amount. Only covers regular windows.\r\n    ImVec2      DisplaySafeAreaPadding;     // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.\r\n    bool        AntiAliasedLines;           // Enable anti-aliasing on lines/borders. Disable if you are really tight on CPU/GPU.\r\n    bool        AntiAliasedFill;            // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)\r\n    float       CurveTessellationTol;       // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.\r\n    ImVec4      Colors[ImGuiCol_COUNT];\r\n\r\n    IMGUI_API ImGuiStyle();\r\n    IMGUI_API void ScaleAllSizes(float scale_factor);\r\n};\r\n\r\n// This is where your app communicate with ImGui. Access via ImGui::GetIO().\r\n// Read 'Programmer guide' section in .cpp file for general usage.\r\nstruct ImGuiIO\r\n{\r\n    //------------------------------------------------------------------\r\n    // Settings (fill once)                 // Default value:\r\n    //------------------------------------------------------------------\r\n\r\n    ImVec2        DisplaySize;              // <unset>              // Display size, in pixels. For clamping windows positions.\r\n    float         DeltaTime;                // = 1.0f/60.0f         // Time elapsed since last frame, in seconds.\r\n    float         IniSavingRate;            // = 5.0f               // Maximum time between saving positions/sizes to .ini file, in seconds.\r\n    const char*   IniFilename;              // = \"imgui.ini\"        // Path to .ini file. NULL to disable .ini saving.\r\n    const char*   LogFilename;              // = \"imgui_log.txt\"    // Path to .log file (default parameter to ImGui::LogToFile when no file is specified).\r\n    float         MouseDoubleClickTime;     // = 0.30f              // Time for a double-click, in seconds.\r\n    float         MouseDoubleClickMaxDist;  // = 6.0f               // Distance threshold to stay in to validate a double-click, in pixels.\r\n    float         MouseDragThreshold;       // = 6.0f               // Distance threshold before considering we are dragging\r\n    int           KeyMap[ImGuiKey_COUNT];   // <unset>              // Map of indices into the KeysDown[512] entries array\r\n    float         KeyRepeatDelay;           // = 0.250f             // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).\r\n    float         KeyRepeatRate;            // = 0.050f             // When holding a key/button, rate at which it repeats, in seconds.\r\n    void*         UserData;                 // = NULL               // Store your own data for retrieval by callbacks.\r\n\r\n    ImFontAtlas*  Fonts;                    // <auto>               // Load and assemble one or more fonts into a single tightly packed texture. Output to Fonts array.\r\n    float         FontGlobalScale;          // = 1.0f               // Global scale all fonts\r\n    bool          FontAllowUserScaling;     // = false              // Allow user scaling text of individual window with CTRL+Wheel.\r\n    ImFont*       FontDefault;              // = NULL               // Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].\r\n    ImVec2        DisplayFramebufferScale;  // = (1.0f,1.0f)        // For retina display or other situations where window coordinates are different from framebuffer coordinates. User storage only, presently not used by ImGui.\r\n    ImVec2        DisplayVisibleMin;        // <unset> (0.0f,0.0f)  // If you use DisplaySize as a virtual space larger than your screen, set DisplayVisibleMin/Max to the visible area.\r\n    ImVec2        DisplayVisibleMax;        // <unset> (0.0f,0.0f)  // If the values are the same, we defaults to Min=(0.0f) and Max=DisplaySize\r\n\r\n    // Advanced/subtle behaviors\r\n    bool          OptMacOSXBehaviors;       // = defined(__APPLE__) // OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl\r\n    bool          OptCursorBlink;           // = true               // Enable blinking cursor, for users who consider it annoying.\r\n\r\n    //------------------------------------------------------------------\r\n    // Settings (User Functions)\r\n    //------------------------------------------------------------------\r\n\r\n    // Rendering function, will be called in Render().\r\n    // Alternatively you can keep this to NULL and call GetDrawData() after Render() to get the same pointer.\r\n    // See example applications if you are unsure of how to implement this.\r\n    void        (*RenderDrawListsFn)(ImDrawData* data);\r\n\r\n    // Optional: access OS clipboard\r\n    // (default to use native Win32 clipboard on Windows, otherwise uses a private clipboard. Override to access OS clipboard on other architectures)\r\n    const char* (*GetClipboardTextFn)(void* user_data);\r\n    void        (*SetClipboardTextFn)(void* user_data, const char* text);\r\n    void*       ClipboardUserData;\r\n\r\n    // Optional: override memory allocations. MemFreeFn() may be called with a NULL pointer.\r\n    // (default to posix malloc/free)\r\n    void*       (*MemAllocFn)(size_t sz);\r\n    void        (*MemFreeFn)(void* ptr);\r\n\r\n    // Optional: notify OS Input Method Editor of the screen position of your cursor for text input position (e.g. when using Japanese/Chinese IME in Windows)\r\n    // (default to use native imm32 api on Windows)\r\n    void        (*ImeSetInputScreenPosFn)(int x, int y);\r\n    void*       ImeWindowHandle;            // (Windows) Set this to your HWND to get automatic IME cursor positioning.\r\n\r\n    //------------------------------------------------------------------\r\n    // Input - Fill before calling NewFrame()\r\n    //------------------------------------------------------------------\r\n\r\n    ImVec2      MousePos;                   // Mouse position, in pixels. Set to ImVec2(-FLT_MAX,-FLT_MAX) if mouse is unavailable (on another screen, etc.)\r\n    bool        MouseDown[5];               // Mouse buttons: left, right, middle + extras. ImGui itself mostly only uses left button (BeginPopupContext** are using right button). Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.\r\n    float       MouseWheel;                 // Mouse wheel: 1 unit scrolls about 5 lines text.\r\n    bool        MouseDrawCursor;            // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor).\r\n    bool        KeyCtrl;                    // Keyboard modifier pressed: Control\r\n    bool        KeyShift;                   // Keyboard modifier pressed: Shift\r\n    bool        KeyAlt;                     // Keyboard modifier pressed: Alt\r\n    bool        KeySuper;                   // Keyboard modifier pressed: Cmd/Super/Windows\r\n    bool        KeysDown[512];              // Keyboard keys that are pressed (in whatever storage order you naturally have access to keyboard data)\r\n    ImWchar     InputCharacters[16+1];      // List of characters input (translated by user from keypress+keyboard state). Fill using AddInputCharacter() helper.\r\n\r\n    // Functions\r\n    IMGUI_API void AddInputCharacter(ImWchar c);                        // Add new character into InputCharacters[]\r\n    IMGUI_API void AddInputCharactersUTF8(const char* utf8_chars);      // Add new characters into InputCharacters[] from an UTF-8 string\r\n    inline void    ClearInputCharacters() { InputCharacters[0] = 0; }   // Clear the text input buffer manually\r\n\r\n    //------------------------------------------------------------------\r\n    // Output - Retrieve after calling NewFrame()\r\n    //------------------------------------------------------------------\r\n\r\n    bool        WantCaptureMouse;           // When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application. This is set by ImGui when it wants to use your mouse (e.g. unclicked mouse is hovering a window, or a widget is active). \r\n    bool        WantCaptureKeyboard;        // When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application. This is set by ImGui when it wants to use your keyboard inputs.\r\n    bool        WantTextInput;              // Mobile/console: when io.WantTextInput is true, you may display an on-screen keyboard. This is set by ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).\r\n    bool        WantMoveMouse;              // [BETA-NAV] MousePos has been altered, back-end should reposition mouse on next frame. Set only when 'NavMovesMouse=true'.\r\n    float       Framerate;                  // Application framerate estimation, in frame per second. Solely for convenience. Rolling average estimation based on IO.DeltaTime over 120 frames\r\n    int         MetricsAllocs;              // Number of active memory allocations\r\n    int         MetricsRenderVertices;      // Vertices output during last call to Render()\r\n    int         MetricsRenderIndices;       // Indices output during last call to Render() = number of triangles * 3\r\n    int         MetricsActiveWindows;       // Number of visible root windows (exclude child windows)\r\n    ImVec2      MouseDelta;                 // Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.\r\n\r\n    //------------------------------------------------------------------\r\n    // [Internal] ImGui will maintain those fields. Forward compatibility not guaranteed!\r\n    //------------------------------------------------------------------\r\n\r\n    ImVec2      MousePosPrev;               // Previous mouse position temporary storage (nb: not for public use, set to MousePos in NewFrame())\r\n    ImVec2      MouseClickedPos[5];         // Position at time of clicking\r\n    float       MouseClickedTime[5];        // Time of last click (used to figure out double-click)\r\n    bool        MouseClicked[5];            // Mouse button went from !Down to Down\r\n    bool        MouseDoubleClicked[5];      // Has mouse button been double-clicked?\r\n    bool        MouseReleased[5];           // Mouse button went from Down to !Down\r\n    bool        MouseDownOwned[5];          // Track if button was clicked inside a window. We don't request mouse capture from the application if click started outside ImGui bounds.\r\n    float       MouseDownDuration[5];       // Duration the mouse button has been down (0.0f == just clicked)\r\n    float       MouseDownDurationPrev[5];   // Previous time the mouse button has been down\r\n    ImVec2      MouseDragMaxDistanceAbs[5]; // Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point\r\n    float       MouseDragMaxDistanceSqr[5]; // Squared maximum distance of how much mouse has traveled from the clicking point\r\n    float       KeysDownDuration[512];      // Duration the keyboard key has been down (0.0f == just pressed)\r\n    float       KeysDownDurationPrev[512];  // Previous duration the key has been down\r\n\r\n    IMGUI_API   ImGuiIO();\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// Obsolete functions (Will be removed! Also see 'API BREAKING CHANGES' section in imgui.cpp)\r\n//-----------------------------------------------------------------------------\r\n\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\nnamespace ImGui\r\n{\r\n    static inline void  ShowTestWindow() { return ShowDemoWindow(); } // OBSOLETE 1.53+\r\n    static inline bool  IsRootWindowFocused() { return IsWindowFocused(ImGuiFocusedFlags_RootWindow); } // OBSOLETE 1.53+\r\n    static inline bool  IsRootWindowOrAnyChildFocused() { return IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows); } // OBSOLETE 1.53+\r\n    static inline void  SetNextWindowContentWidth(float width) { SetNextWindowContentSize(ImVec2(width, 0.0f)); } // OBSOLETE 1.53+ (nb: original version preserved last Y value set by SetNextWindowContentSize())\r\n    static inline bool  IsRootWindowOrAnyChildHovered(ImGuiHoveredFlags flags = 0) { return IsItemHovered(flags | ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows); } // OBSOLETE 1.53+ use flags directly\r\n    bool                Begin(const char* name, bool* p_open, const ImVec2& size_on_first_use, float bg_alpha_override = -1.0f, ImGuiWindowFlags flags = 0); // OBSOLETE 1.52+. use SetNextWindowSize() instead if you want to set a window size.\r\n    static inline void  AlignFirstTextHeightToWidgets() { AlignTextToFramePadding(); }     // OBSOLETE 1.52+\r\n    static inline void  SetNextWindowPosCenter(ImGuiCond cond = 0) { SetNextWindowPos(ImVec2(GetIO().DisplaySize.x * 0.5f, GetIO().DisplaySize.y * 0.5f), cond, ImVec2(0.5f, 0.5f)); } // OBSOLETE 1.52+\r\n    static inline bool  IsItemHoveredRect() { return IsItemHovered(ImGuiHoveredFlags_RectOnly); } // OBSOLETE 1.51+\r\n    static inline bool  IsPosHoveringAnyWindow(const ImVec2&) { IM_ASSERT(0); return false; } // OBSOLETE 1.51+. This was partly broken. You probably wanted to use ImGui::GetIO().WantCaptureMouse instead.\r\n    static inline bool  IsMouseHoveringAnyWindow() { return IsAnyWindowHovered(); }        // OBSOLETE 1.51+\r\n    static inline bool  IsMouseHoveringWindow() { return IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem); } // OBSOLETE 1.51+\r\n    static inline bool  CollapsingHeader(const char* label, const char* str_id, bool framed = true, bool default_open = false) { (void)str_id; (void)framed; ImGuiTreeNodeFlags default_open_flags = 1 << 5; return CollapsingHeader(label, (default_open ? default_open_flags : 0)); } // OBSOLETE 1.49+\r\n}\r\n#endif\r\n\r\n//-----------------------------------------------------------------------------\r\n// Helpers\r\n//-----------------------------------------------------------------------------\r\n\r\n// Lightweight std::vector<> like class to avoid dragging dependencies (also: windows implementation of STL with debug enabled is absurdly slow, so let's bypass it so our code runs fast in debug).\r\n// Our implementation does NOT call C++ constructors/destructors. This is intentional and we do not require it. Do not use this class as a straight std::vector replacement in your code!\r\ntemplate<typename T>\r\nclass ImVector\r\n{\r\npublic:\r\n    int                         Size;\r\n    int                         Capacity;\r\n    T*                          Data;\r\n\r\n    typedef T                   value_type;\r\n    typedef value_type*         iterator;\r\n    typedef const value_type*   const_iterator;\r\n\r\n    inline ImVector()           { Size = Capacity = 0; Data = NULL; }\r\n    inline ~ImVector()          { if (Data) ImGui::MemFree(Data); }\r\n\r\n    inline bool                 empty() const                   { return Size == 0; }\r\n    inline int                  size() const                    { return Size; }\r\n    inline int                  capacity() const                { return Capacity; }\r\n\r\n    inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }\r\n    inline const value_type&    operator[](int i) const         { IM_ASSERT(i < Size); return Data[i]; }\r\n\r\n    inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }\r\n    inline iterator             begin()                         { return Data; }\r\n    inline const_iterator       begin() const                   { return Data; }\r\n    inline iterator             end()                           { return Data + Size; }\r\n    inline const_iterator       end() const                     { return Data + Size; }\r\n    inline value_type&          front()                         { IM_ASSERT(Size > 0); return Data[0]; }\r\n    inline const value_type&    front() const                   { IM_ASSERT(Size > 0); return Data[0]; }\r\n    inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size - 1]; }\r\n    inline const value_type&    back() const                    { IM_ASSERT(Size > 0); return Data[Size - 1]; }\r\n    inline void                 swap(ImVector<T>& rhs)          { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; value_type* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }\r\n\r\n    inline int                  _grow_capacity(int sz) const    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }\r\n\r\n    inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }\r\n    inline void                 resize(int new_size, const T& v){ if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) Data[n] = v; Size = new_size; }\r\n    inline void                 reserve(int new_capacity)\r\n    {\r\n        if (new_capacity <= Capacity) \r\n            return;\r\n        T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T));\r\n        if (Data)\r\n            memcpy(new_data, Data, (size_t)Size * sizeof(T));\r\n        ImGui::MemFree(Data);\r\n        Data = new_data;\r\n        Capacity = new_capacity;\r\n    }\r\n\r\n    inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); Data[Size++] = v; }\r\n    inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }\r\n    inline void                 push_front(const value_type& v) { if (Size == 0) push_back(v); else insert(Data, v); }\r\n\r\n    inline iterator             erase(const_iterator it)        { IM_ASSERT(it >= Data && it < Data+Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(value_type)); Size--; return Data + off; }\r\n    inline iterator             insert(const_iterator it, const value_type& v)  { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(value_type)); Data[off] = v; Size++; return Data + off; }\r\n    inline bool                 contains(const value_type& v) const             { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }\r\n};\r\n\r\n// Helper: execute a block of code at maximum once a frame. Convenient if you want to quickly create an UI within deep-nested code that runs multiple times every frame.\r\n// Usage:\r\n//   static ImGuiOnceUponAFrame oaf;\r\n//   if (oaf)\r\n//       ImGui::Text(\"This will be called only once per frame\");\r\nstruct ImGuiOnceUponAFrame\r\n{\r\n    ImGuiOnceUponAFrame() { RefFrame = -1; }\r\n    mutable int RefFrame;\r\n    operator bool() const { int current_frame = ImGui::GetFrameCount(); if (RefFrame == current_frame) return false; RefFrame = current_frame; return true; }\r\n};\r\n\r\n// Helper macro for ImGuiOnceUponAFrame. Attention: The macro expands into 2 statement so make sure you don't use it within e.g. an if() statement without curly braces.\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS    // Will obsolete\r\n#define IMGUI_ONCE_UPON_A_FRAME     static ImGuiOnceUponAFrame imgui_oaf; if (imgui_oaf)\r\n#endif\r\n\r\n// Helper: Parse and apply text filters. In format \"aaaaa[,bbbb][,ccccc]\"\r\nstruct ImGuiTextFilter\r\n{\r\n    struct TextRange\r\n    {\r\n        const char* b;\r\n        const char* e;\r\n\r\n        TextRange() { b = e = NULL; }\r\n        TextRange(const char* _b, const char* _e) { b = _b; e = _e; }\r\n        const char* begin() const { return b; }\r\n        const char* end() const { return e; }\r\n        bool empty() const { return b == e; }\r\n        char front() const { return *b; }\r\n        static bool is_blank(char c) { return c == ' ' || c == '\\t'; }\r\n        void trim_blanks() { while (b < e && is_blank(*b)) b++; while (e > b && is_blank(*(e-1))) e--; }\r\n        IMGUI_API void split(char separator, ImVector<TextRange>& out);\r\n    };\r\n\r\n    char                InputBuf[256];\r\n    ImVector<TextRange> Filters;\r\n    int                 CountGrep;\r\n\r\n    IMGUI_API           ImGuiTextFilter(const char* default_filter = \"\");\r\n    IMGUI_API bool      Draw(const char* label = \"Filter (inc,-exc)\", float width = 0.0f);    // Helper calling InputText+Build\r\n    IMGUI_API bool      PassFilter(const char* text, const char* text_end = NULL) const;\r\n    IMGUI_API void      Build();\r\n    void                Clear() { InputBuf[0] = 0; Build(); }\r\n    bool                IsActive() const { return !Filters.empty(); }\r\n};\r\n\r\n// Helper: Text buffer for logging/accumulating text\r\nstruct ImGuiTextBuffer\r\n{\r\n    ImVector<char>      Buf;\r\n\r\n    ImGuiTextBuffer()   { Buf.push_back(0); }\r\n    inline char         operator[](int i) { return Buf.Data[i]; }\r\n    const char*         begin() const { return &Buf.front(); }\r\n    const char*         end() const { return &Buf.back(); }      // Buf is zero-terminated, so end() will point on the zero-terminator\r\n    int                 size() const { return Buf.Size - 1; }\r\n    bool                empty() { return Buf.Size <= 1; }\r\n    void                clear() { Buf.clear(); Buf.push_back(0); }\r\n    void                reserve(int capacity) { Buf.reserve(capacity); }\r\n    const char*         c_str() const { return Buf.Data; }\r\n    IMGUI_API void      appendf(const char* fmt, ...) IM_FMTARGS(2);\r\n    IMGUI_API void      appendfv(const char* fmt, va_list args) IM_FMTLIST(2);\r\n};\r\n\r\n// Helper: Simple Key->value storage\r\n// Typically you don't have to worry about this since a storage is held within each Window.\r\n// We use it to e.g. store collapse state for a tree (Int 0/1), store color edit options. \r\n// This is optimized for efficient reading (dichotomy into a contiguous buffer), rare writing (typically tied to user interactions)\r\n// You can use it as custom user storage for temporary values. Declare your own storage if, for example:\r\n// - You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state).\r\n// - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient)\r\n// Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.\r\nstruct ImGuiStorage\r\n{\r\n    struct Pair\r\n    {\r\n        ImGuiID key;\r\n        union { int val_i; float val_f; void* val_p; };\r\n        Pair(ImGuiID _key, int _val_i)   { key = _key; val_i = _val_i; }\r\n        Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; }\r\n        Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }\r\n    };\r\n    ImVector<Pair>      Data;\r\n\r\n    // - Get***() functions find pair, never add/allocate. Pairs are sorted so a query is O(log N)\r\n    // - Set***() functions find pair, insertion on demand if missing.\r\n    // - Sorted insertion is costly, paid once. A typical frame shouldn't need to insert any new pair.\r\n    void                Clear() { Data.clear(); }\r\n    IMGUI_API int       GetInt(ImGuiID key, int default_val = 0) const;\r\n    IMGUI_API void      SetInt(ImGuiID key, int val);\r\n    IMGUI_API bool      GetBool(ImGuiID key, bool default_val = false) const;\r\n    IMGUI_API void      SetBool(ImGuiID key, bool val);\r\n    IMGUI_API float     GetFloat(ImGuiID key, float default_val = 0.0f) const;\r\n    IMGUI_API void      SetFloat(ImGuiID key, float val);\r\n    IMGUI_API void*     GetVoidPtr(ImGuiID key) const; // default_val is NULL\r\n    IMGUI_API void      SetVoidPtr(ImGuiID key, void* val);\r\n\r\n    // - Get***Ref() functions finds pair, insert on demand if missing, return pointer. Useful if you intend to do Get+Set.\r\n    // - References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.\r\n    // - A typical use case where this is convenient for quick hacking (e.g. add storage during a live Edit&Continue session if you can't modify existing struct)\r\n    //      float* pvar = ImGui::GetFloatRef(key); ImGui::SliderFloat(\"var\", pvar, 0, 100.0f); some_var += *pvar;\r\n    IMGUI_API int*      GetIntRef(ImGuiID key, int default_val = 0);\r\n    IMGUI_API bool*     GetBoolRef(ImGuiID key, bool default_val = false);\r\n    IMGUI_API float*    GetFloatRef(ImGuiID key, float default_val = 0.0f);\r\n    IMGUI_API void**    GetVoidPtrRef(ImGuiID key, void* default_val = NULL);\r\n\r\n    // Use on your own storage if you know only integer are being stored (open/close all tree nodes)\r\n    IMGUI_API void      SetAllInt(int val);\r\n\r\n    // For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.\r\n    IMGUI_API void      BuildSortByKey();\r\n};\r\n\r\n// Shared state of InputText(), passed to callback when a ImGuiInputTextFlags_Callback* flag is used and the corresponding callback is triggered.\r\nstruct ImGuiTextEditCallbackData\r\n{\r\n    ImGuiInputTextFlags EventFlag;      // One of ImGuiInputTextFlags_Callback* // Read-only\r\n    ImGuiInputTextFlags Flags;          // What user passed to InputText()      // Read-only\r\n    void*               UserData;       // What user passed to InputText()      // Read-only\r\n    bool                ReadOnly;       // Read-only mode                       // Read-only\r\n\r\n    // CharFilter event:\r\n    ImWchar             EventChar;      // Character input                      // Read-write (replace character or set to zero)\r\n\r\n    // Completion,History,Always events:\r\n    // If you modify the buffer contents make sure you update 'BufTextLen' and set 'BufDirty' to true.\r\n    ImGuiKey            EventKey;       // Key pressed (Up/Down/TAB)            // Read-only\r\n    char*               Buf;            // Current text buffer                  // Read-write (pointed data only, can't replace the actual pointer)\r\n    int                 BufTextLen;     // Current text length in bytes         // Read-write\r\n    int                 BufSize;        // Maximum text length in bytes         // Read-only\r\n    bool                BufDirty;       // Set if you modify Buf/BufTextLen!!   // Write\r\n    int                 CursorPos;      //                                      // Read-write\r\n    int                 SelectionStart; //                                      // Read-write (== to SelectionEnd when no selection)\r\n    int                 SelectionEnd;   //                                      // Read-write\r\n\r\n    // NB: Helper functions for text manipulation. Calling those function loses selection.\r\n    IMGUI_API void    DeleteChars(int pos, int bytes_count);\r\n    IMGUI_API void    InsertChars(int pos, const char* text, const char* text_end = NULL);\r\n    bool              HasSelection() const { return SelectionStart != SelectionEnd; }\r\n};\r\n\r\n// Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin().\r\n// NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.\r\nstruct ImGuiSizeConstraintCallbackData\r\n{\r\n    void*   UserData;       // Read-only.   What user passed to SetNextWindowSizeConstraints()\r\n    ImVec2  Pos;            // Read-only.   Window position, for reference.\r\n    ImVec2  CurrentSize;    // Read-only.   Current window size.\r\n    ImVec2  DesiredSize;    // Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.\r\n};\r\n\r\n// Data payload for Drag and Drop operations\r\nstruct ImGuiPayload\r\n{\r\n    // Members\r\n    const void*     Data;               // Data (copied and owned by dear imgui)\r\n    int             DataSize;           // Data size\r\n\r\n    // [Internal]\r\n    ImGuiID         SourceId;           // Source item id\r\n    ImGuiID         SourceParentId;     // Source parent id (if available)\r\n    int             DataFrameCount;     // Data timestamp\r\n    char            DataType[8 + 1];    // Data type tag (short user-supplied string)\r\n    bool            Preview;            // Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)\r\n    bool            Delivery;           // Set when AcceptDragDropPayload() was called and mouse button is released over the target item.\r\n\r\n    ImGuiPayload()  { Clear(); }\r\n    void Clear()    { SourceId = SourceParentId = 0; Data = NULL; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }\r\n    bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }\r\n    bool IsPreview() const                  { return Preview; }\r\n    bool IsDelivery() const                 { return Delivery; }\r\n};\r\n\r\n// Helpers macros to generate 32-bits encoded colors\r\n#ifdef IMGUI_USE_BGRA_PACKED_COLOR\r\n#define IM_COL32_R_SHIFT    16\r\n#define IM_COL32_G_SHIFT    8\r\n#define IM_COL32_B_SHIFT    0\r\n#define IM_COL32_A_SHIFT    24\r\n#define IM_COL32_A_MASK     0xFF000000\r\n#else\r\n#define IM_COL32_R_SHIFT    0\r\n#define IM_COL32_G_SHIFT    8\r\n#define IM_COL32_B_SHIFT    16\r\n#define IM_COL32_A_SHIFT    24\r\n#define IM_COL32_A_MASK     0xFF000000\r\n#endif\r\n#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))\r\n#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF\r\n#define IM_COL32_BLACK       IM_COL32(0,0,0,255)        // Opaque black\r\n#define IM_COL32_BLACK_TRANS IM_COL32(0,0,0,0)          // Transparent black = 0x00000000\r\n\r\n// ImColor() helper to implicity converts colors to either ImU32 (packed 4x1 byte) or ImVec4 (4x1 float)\r\n// Prefer using IM_COL32() macros if you want a guaranteed compile-time ImU32 for usage with ImDrawList API.\r\n// **Avoid storing ImColor! Store either u32 of ImVec4. This is not a full-featured color class. MAY OBSOLETE.\r\n// **None of the ImGui API are using ImColor directly but you can use it as a convenience to pass colors in either ImU32 or ImVec4 formats. Explicitly cast to ImU32 or ImVec4 if needed.\r\nstruct ImColor\r\n{\r\n    ImVec4              Value;\r\n\r\n    ImColor()                                                       { Value.x = Value.y = Value.z = Value.w = 0.0f; }\r\n    ImColor(int r, int g, int b, int a = 255)                       { float sc = 1.0f/255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }\r\n    ImColor(ImU32 rgba)                                             { float sc = 1.0f/255.0f; Value.x = (float)((rgba>>IM_COL32_R_SHIFT)&0xFF) * sc; Value.y = (float)((rgba>>IM_COL32_G_SHIFT)&0xFF) * sc; Value.z = (float)((rgba>>IM_COL32_B_SHIFT)&0xFF) * sc; Value.w = (float)((rgba>>IM_COL32_A_SHIFT)&0xFF) * sc; }\r\n    ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }\r\n    ImColor(const ImVec4& col)                                      { Value = col; }\r\n    inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }\r\n    inline operator ImVec4() const                                  { return Value; }\r\n\r\n    // FIXME-OBSOLETE: May need to obsolete/cleanup those helpers.\r\n    inline void    SetHSV(float h, float s, float v, float a = 1.0f){ ImGui::ColorConvertHSVtoRGB(h, s, v, Value.x, Value.y, Value.z); Value.w = a; }\r\n    static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }\r\n};\r\n\r\n// Helper: Manually clip large list of items.\r\n// If you are submitting lots of evenly spaced items and you have a random access to the list, you can perform coarse clipping based on visibility to save yourself from processing those items at all.\r\n// The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped. \r\n// ImGui already clip items based on their bounds but it needs to measure text size to do so. Coarse clipping before submission makes this cost and your own data fetching/submission cost null.\r\n// Usage:\r\n//     ImGuiListClipper clipper(1000);  // we have 1000 elements, evenly spaced.\r\n//     while (clipper.Step())\r\n//         for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)\r\n//             ImGui::Text(\"line number %d\", i);\r\n// - Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height (step skipped if we passed a known height as second arg to constructor).\r\n// - Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element.\r\n// - (Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user call Step(). Does nothing and switch to Step 3.)\r\n// - Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.\r\nstruct ImGuiListClipper\r\n{\r\n    float   StartPosY;\r\n    float   ItemsHeight;\r\n    int     ItemsCount, StepNo, DisplayStart, DisplayEnd;\r\n\r\n    // items_count:  Use -1 to ignore (you can call Begin later). Use INT_MAX if you don't know how many items you have (in which case the cursor won't be advanced in the final step).\r\n    // items_height: Use -1.0f to be calculated automatically on first step. Otherwise pass in the distance between your items, typically GetTextLineHeightWithSpacing() or GetFrameHeightWithSpacing().\r\n    // If you don't specify an items_height, you NEED to call Step(). If you specify items_height you may call the old Begin()/End() api directly, but prefer calling Step().\r\n    ImGuiListClipper(int items_count = -1, float items_height = -1.0f)  { Begin(items_count, items_height); } // NB: Begin() initialize every fields (as we allow user to call Begin/End multiple times on a same instance if they want).\r\n    ~ImGuiListClipper()                                                 { IM_ASSERT(ItemsCount == -1); }      // Assert if user forgot to call End() or Step() until false.\r\n\r\n    IMGUI_API bool Step();                                              // Call until it returns false. The DisplayStart/DisplayEnd fields will be set and you can process/draw those items.\r\n    IMGUI_API void Begin(int items_count, float items_height = -1.0f);  // Automatically called by constructor if you passed 'items_count' or by Step() in Step 1.\r\n    IMGUI_API void End();                                               // Automatically called on the last call of Step() that returns false.\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// Draw List\r\n// Hold a series of drawing commands. The user provides a renderer for ImDrawData which essentially contains an array of ImDrawList.\r\n//-----------------------------------------------------------------------------\r\n\r\n// Draw callbacks for advanced uses.\r\n// NB- You most likely do NOT need to use draw callbacks just to create your own widget or customized UI rendering (you can poke into the draw list for that)\r\n// Draw callback may be useful for example, A) Change your GPU render state, B) render a complex 3D scene inside a UI element (without an intermediate texture/render target), etc.\r\n// The expected behavior from your rendering function is 'if (cmd.UserCallback != NULL) cmd.UserCallback(parent_list, cmd); else RenderTriangles()'\r\ntypedef void (*ImDrawCallback)(const ImDrawList* parent_list, const ImDrawCmd* cmd);\r\n\r\n// Typically, 1 command = 1 GPU draw call (unless command is a callback)\r\nstruct ImDrawCmd\r\n{\r\n    unsigned int    ElemCount;              // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].\r\n    ImVec4          ClipRect;               // Clipping rectangle (x1, y1, x2, y2)\r\n    ImTextureID     TextureId;              // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.\r\n    ImDrawCallback  UserCallback;           // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.\r\n    void*           UserCallbackData;       // The draw callback code can access this.\r\n\r\n    ImDrawCmd() { ElemCount = 0; ClipRect.x = ClipRect.y = ClipRect.z = ClipRect.w = 0.0f; TextureId = NULL; UserCallback = NULL; UserCallbackData = NULL; }\r\n};\r\n\r\n// Vertex index (override with '#define ImDrawIdx unsigned int' inside in imconfig.h)\r\n#ifndef ImDrawIdx\r\ntypedef unsigned short ImDrawIdx;\r\n#endif\r\n\r\n// Vertex layout\r\n#ifndef IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT\r\nstruct ImDrawVert\r\n{\r\n    ImVec2  pos;\r\n    ImVec2  uv;\r\n    ImU32   col;\r\n};\r\n#else\r\n// You can override the vertex format layout by defining IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT in imconfig.h\r\n// The code expect ImVec2 pos (8 bytes), ImVec2 uv (8 bytes), ImU32 col (4 bytes), but you can re-order them or add other fields as needed to simplify integration in your engine.\r\n// The type has to be described within the macro (you can either declare the struct or use a typedef)\r\n// NOTE: IMGUI DOESN'T CLEAR THE STRUCTURE AND DOESN'T CALL A CONSTRUCTOR SO ANY CUSTOM FIELD WILL BE UNINITIALIZED. IF YOU ADD EXTRA FIELDS (SUCH AS A 'Z' COORDINATES) YOU WILL NEED TO CLEAR THEM DURING RENDER OR TO IGNORE THEM. \r\nIMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT;\r\n#endif\r\n\r\n// Draw channels are used by the Columns API to \"split\" the render list into different channels while building, so items of each column can be batched together.\r\n// You can also use them to simulate drawing layers and submit primitives in a different order than how they will be rendered.\r\nstruct ImDrawChannel\r\n{\r\n    ImVector<ImDrawCmd>     CmdBuffer;\r\n    ImVector<ImDrawIdx>     IdxBuffer;\r\n};\r\n\r\nenum ImDrawCornerFlags_\r\n{\r\n    ImDrawCornerFlags_TopLeft   = 1 << 0, // 0x1\r\n    ImDrawCornerFlags_TopRight  = 1 << 1, // 0x2\r\n    ImDrawCornerFlags_BotLeft   = 1 << 2, // 0x4\r\n    ImDrawCornerFlags_BotRight  = 1 << 3, // 0x8\r\n    ImDrawCornerFlags_Top       = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_TopRight,   // 0x3\r\n    ImDrawCornerFlags_Bot       = ImDrawCornerFlags_BotLeft | ImDrawCornerFlags_BotRight,   // 0xC\r\n    ImDrawCornerFlags_Left      = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_BotLeft,    // 0x5\r\n    ImDrawCornerFlags_Right     = ImDrawCornerFlags_TopRight | ImDrawCornerFlags_BotRight,  // 0xA\r\n    ImDrawCornerFlags_All       = 0xF     // In your function calls you may use ~0 (= all bits sets) instead of ImDrawCornerFlags_All, as a convenience\r\n};\r\n\r\nenum ImDrawListFlags_\r\n{\r\n    ImDrawListFlags_AntiAliasedLines = 1 << 0,\r\n    ImDrawListFlags_AntiAliasedFill  = 1 << 1\r\n};\r\n\r\n// Draw command list\r\n// This is the low-level list of polygons that ImGui functions are filling. At the end of the frame, all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.\r\n// Each ImGui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to access the current window draw list and draw custom primitives.\r\n// You can interleave normal ImGui:: calls and adding primitives to the current draw list.\r\n// All positions are generally in pixel coordinates (top-left at (0,0), bottom-right at io.DisplaySize), however you are totally free to apply whatever transformation matrix to want to the data (if you apply such transformation you'll want to apply it to ClipRect as well)\r\n// Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.\r\nstruct ImDrawList\r\n{\r\n    // This is what you have to render\r\n    ImVector<ImDrawCmd>     CmdBuffer;          // Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.\r\n    ImVector<ImDrawIdx>     IdxBuffer;          // Index buffer. Each command consume ImDrawCmd::ElemCount of those\r\n    ImVector<ImDrawVert>    VtxBuffer;          // Vertex buffer.\r\n\r\n    // [Internal, used while building lists]\r\n    ImDrawListFlags         Flags;              // Flags, you may poke into these to adjust anti-aliasing settings per-primitive.\r\n    const ImDrawListSharedData* _Data;          // Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)\r\n    const char*             _OwnerName;         // Pointer to owner window's name for debugging\r\n    unsigned int            _VtxCurrentIdx;     // [Internal] == VtxBuffer.Size\r\n    ImDrawVert*             _VtxWritePtr;       // [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)\r\n    ImDrawIdx*              _IdxWritePtr;       // [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)\r\n    ImVector<ImVec4>        _ClipRectStack;     // [Internal]\r\n    ImVector<ImTextureID>   _TextureIdStack;    // [Internal]\r\n    ImVector<ImVec2>        _Path;              // [Internal] current path building\r\n    int                     _ChannelsCurrent;   // [Internal] current channel number (0)\r\n    int                     _ChannelsCount;     // [Internal] number of active channels (1+)\r\n    ImVector<ImDrawChannel> _Channels;          // [Internal] draw channels for columns API (not resized down so _ChannelsCount may be smaller than _Channels.Size)\r\n\r\n    ImDrawList(const ImDrawListSharedData* shared_data) { _Data = shared_data; _OwnerName = NULL; Clear(); }\r\n    ~ImDrawList() { ClearFreeMemory(); }\r\n    IMGUI_API void  PushClipRect(ImVec2 clip_rect_min, ImVec2 clip_rect_max, bool intersect_with_current_clip_rect = false);  // Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)\r\n    IMGUI_API void  PushClipRectFullScreen();\r\n    IMGUI_API void  PopClipRect();\r\n    IMGUI_API void  PushTextureID(const ImTextureID& texture_id);\r\n    IMGUI_API void  PopTextureID();\r\n    inline ImVec2   GetClipRectMin() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.x, cr.y); }\r\n    inline ImVec2   GetClipRectMax() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.z, cr.w); }\r\n\r\n    // Primitives\r\n    IMGUI_API void  AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness = 1.0f);\r\n    IMGUI_API void  AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All, float thickness = 1.0f);   // a: upper-left, b: lower-right, rounding_corners_flags: 4-bits corresponding to which corner to round\r\n    IMGUI_API void  AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);                     // a: upper-left, b: lower-right\r\n    IMGUI_API void  AddRectFilledMultiColor(const ImVec2& a, const ImVec2& b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);\r\n    IMGUI_API void  AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness = 1.0f);\r\n    IMGUI_API void  AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col);\r\n    IMGUI_API void  AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness = 1.0f);\r\n    IMGUI_API void  AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col);\r\n    IMGUI_API void  AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12, float thickness = 1.0f);\r\n    IMGUI_API void  AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12);\r\n    IMGUI_API void  AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL);\r\n    IMGUI_API void  AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = NULL);\r\n    IMGUI_API void  AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,1), ImU32 col = 0xFFFFFFFF);\r\n    IMGUI_API void  AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,0), const ImVec2& uv_c = ImVec2(1,1), const ImVec2& uv_d = ImVec2(0,1), ImU32 col = 0xFFFFFFFF);\r\n    IMGUI_API void  AddImageRounded(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col, float rounding, int rounding_corners = ImDrawCornerFlags_All);\r\n    IMGUI_API void  AddPolyline(const ImVec2* points, const int num_points, ImU32 col, bool closed, float thickness);\r\n    IMGUI_API void  AddConvexPolyFilled(const ImVec2* points, const int num_points, ImU32 col);\r\n    IMGUI_API void  AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments = 0);\r\n\r\n    // Stateful path API, add points then finish with PathFill() or PathStroke()\r\n    inline    void  PathClear()                                                 { _Path.resize(0); }\r\n    inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }\r\n    inline    void  PathLineToMergeDuplicate(const ImVec2& pos)                 { if (_Path.Size == 0 || memcmp(&_Path[_Path.Size-1], &pos, 8) != 0) _Path.push_back(pos); }\r\n    inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); PathClear(); }\r\n    inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness); PathClear(); }\r\n    IMGUI_API void  PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments = 10);\r\n    IMGUI_API void  PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12);                                // Use precomputed angles for a 12 steps circle\r\n    IMGUI_API void  PathBezierCurveTo(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, int num_segments = 0);\r\n    IMGUI_API void  PathRect(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);\r\n\r\n    // Channels\r\n    // - Use to simulate layers. By switching channels to can render out-of-order (e.g. submit foreground primitives before background primitives)\r\n    // - Use to minimize draw calls (e.g. if going back-and-forth between multiple non-overlapping clipping rectangles, prefer to append into separate channels then merge at the end)\r\n    IMGUI_API void  ChannelsSplit(int channels_count);\r\n    IMGUI_API void  ChannelsMerge();\r\n    IMGUI_API void  ChannelsSetCurrent(int channel_index);\r\n\r\n    // Advanced\r\n    IMGUI_API void  AddCallback(ImDrawCallback callback, void* callback_data);  // Your rendering function must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles.\r\n    IMGUI_API void  AddDrawCmd();                                               // This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible\r\n\r\n    // Internal helpers\r\n    // NB: all primitives needs to be reserved via PrimReserve() beforehand!\r\n    IMGUI_API void  Clear();\r\n    IMGUI_API void  ClearFreeMemory();\r\n    IMGUI_API void  PrimReserve(int idx_count, int vtx_count);\r\n    IMGUI_API void  PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);      // Axis aligned rectangle (composed of two triangles)\r\n    IMGUI_API void  PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);\r\n    IMGUI_API void  PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col);\r\n    inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }\r\n    inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }\r\n    inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)     { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }\r\n    IMGUI_API void  UpdateClipRect();\r\n    IMGUI_API void  UpdateTextureID();\r\n};\r\n\r\n// All draw data to render an ImGui frame\r\nstruct ImDrawData\r\n{\r\n    bool            Valid;                  // Only valid after Render() is called and before the next NewFrame() is called.\r\n    ImDrawList**    CmdLists;\r\n    int             CmdListsCount;\r\n    int             TotalVtxCount;          // For convenience, sum of all cmd_lists vtx_buffer.Size\r\n    int             TotalIdxCount;          // For convenience, sum of all cmd_lists idx_buffer.Size\r\n\r\n    // Functions\r\n    ImDrawData() { Valid = false; CmdLists = NULL; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; }\r\n    IMGUI_API void DeIndexAllBuffers();               // For backward compatibility or convenience: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!\r\n    IMGUI_API void ScaleClipRects(const ImVec2& sc);  // Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.\r\n};\r\n\r\nstruct ImFontConfig\r\n{\r\n    void*           FontData;                   //          // TTF/OTF data\r\n    int             FontDataSize;               //          // TTF/OTF data size\r\n    bool            FontDataOwnedByAtlas;       // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).\r\n    int             FontNo;                     // 0        // Index of font within TTF/OTF file\r\n    float           SizePixels;                 //          // Size in pixels for rasterizer.\r\n    int             OversampleH, OversampleV;   // 3, 1     // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.\r\n    bool            PixelSnapH;                 // false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.\r\n    ImVec2          GlyphExtraSpacing;          // 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.\r\n    ImVec2          GlyphOffset;                // 0, 0     // Offset all glyphs from this font input.\r\n    const ImWchar*  GlyphRanges;                // NULL     // Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.\r\n    bool            MergeMode;                  // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.\r\n    unsigned int    RasterizerFlags;            // 0x00     // Settings for custom font rasterizer (e.g. ImGuiFreeType). Leave as zero if you aren't using one.\r\n    float           RasterizerMultiply;         // 1.0f     // Brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.\r\n\r\n    // [Internal]\r\n    char            Name[32];                               // Name (strictly to ease debugging)\r\n    ImFont*         DstFont;\r\n\r\n    IMGUI_API ImFontConfig();\r\n};\r\n\r\nstruct ImFontGlyph\r\n{\r\n    ImWchar         Codepoint;          // 0x0000..0xFFFF\r\n    float           AdvanceX;           // Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)\r\n    float           X0, Y0, X1, Y1;     // Glyph corners\r\n    float           U0, V0, U1, V1;     // Texture coordinates\r\n};\r\n\r\n// Load and rasterize multiple TTF/OTF fonts into a same texture.\r\n// Sharing a texture for multiple fonts allows us to reduce the number of draw calls during rendering.\r\n// We also add custom graphic data into the texture that serves for ImGui.\r\n//  1. (Optional) Call AddFont*** functions. If you don't call any, the default font will be loaded for you.\r\n//  2. Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data.\r\n//  3. Upload the pixels data into a texture within your graphics system.\r\n//  4. Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture. This value will be passed back to you during rendering to identify the texture.\r\n// IMPORTANT: If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the ImFont is build (when calling GetTextData*** or Build()). We only copy the pointer, not the data.\r\nstruct ImFontAtlas\r\n{\r\n    IMGUI_API ImFontAtlas();\r\n    IMGUI_API ~ImFontAtlas();\r\n    IMGUI_API ImFont*           AddFont(const ImFontConfig* font_cfg);\r\n    IMGUI_API ImFont*           AddFontDefault(const ImFontConfig* font_cfg = NULL);\r\n    IMGUI_API ImFont*           AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);\r\n    IMGUI_API ImFont*           AddFontFromMemoryTTF(void* font_data, int font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after Build(). Set font_cfg->FontDataOwnedByAtlas to false to keep ownership.\r\n    IMGUI_API ImFont*           AddFontFromMemoryCompressedTTF(const void* compressed_font_data, int compressed_font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.\r\n    IMGUI_API ImFont*           AddFontFromMemoryCompressedBase85TTF(const char* compressed_font_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);              // 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.\r\n    IMGUI_API void              ClearTexData();             // Clear the CPU-side texture data. Saves RAM once the texture has been copied to graphics memory.\r\n    IMGUI_API void              ClearInputData();           // Clear the input TTF data (inc sizes, glyph ranges)\r\n    IMGUI_API void              ClearFonts();               // Clear the ImGui-side font data (glyphs storage, UV coordinates)\r\n    IMGUI_API void              Clear();                    // Clear all\r\n\r\n    // Build atlas, retrieve pixel data.\r\n    // User is in charge of copying the pixels into graphics memory (e.g. create a texture with your engine). Then store your texture handle with SetTexID().\r\n    // RGBA32 format is provided for convenience and compatibility, but note that unless you use CustomRect to draw color data, the RGB pixels emitted from Fonts will all be white (~75% of waste). \r\n    // Pitch = Width * BytesPerPixels\r\n    IMGUI_API bool              Build();                    // Build pixels data. This is called automatically for you by the GetTexData*** functions.\r\n    IMGUI_API void              GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 1 byte per-pixel\r\n    IMGUI_API void              GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 4 bytes-per-pixel\r\n    void                        SetTexID(ImTextureID id)    { TexID = id; }\r\n\r\n    //-------------------------------------------\r\n    // Glyph Ranges\r\n    //-------------------------------------------\r\n\r\n    // Helpers to retrieve list of common Unicode ranges (2 value per range, values are inclusive, zero-terminated list)\r\n    // NB: Make sure that your string are UTF-8 and NOT in your local code page. In C++11, you can create UTF-8 string literal using the u8\"Hello world\" syntax. See FAQ for details.\r\n    IMGUI_API const ImWchar*    GetGlyphRangesDefault();    // Basic Latin, Extended Latin\r\n    IMGUI_API const ImWchar*    GetGlyphRangesKorean();     // Default + Korean characters\r\n    IMGUI_API const ImWchar*    GetGlyphRangesJapanese();   // Default + Hiragana, Katakana, Half-Width, Selection of 1946 Ideographs\r\n    IMGUI_API const ImWchar*    GetGlyphRangesChinese();    // Default + Japanese + full set of about 21000 CJK Unified Ideographs\r\n    IMGUI_API const ImWchar*    GetGlyphRangesCyrillic();   // Default + about 400 Cyrillic characters\r\n    IMGUI_API const ImWchar*    GetGlyphRangesThai();       // Default + Thai characters\r\n\r\n    // Helpers to build glyph ranges from text data. Feed your application strings/characters to it then call BuildRanges().\r\n    struct GlyphRangesBuilder\r\n    {\r\n        ImVector<unsigned char> UsedChars;  // Store 1-bit per Unicode code point (0=unused, 1=used)\r\n        GlyphRangesBuilder()                { UsedChars.resize(0x10000 / 8); memset(UsedChars.Data, 0, 0x10000 / 8); }\r\n        bool           GetBit(int n)        { return (UsedChars[n >> 3] & (1 << (n & 7))) != 0; }\r\n        void           SetBit(int n)        { UsedChars[n >> 3] |= 1 << (n & 7); }  // Set bit 'c' in the array\r\n        void           AddChar(ImWchar c)   { SetBit(c); }                          // Add character\r\n        IMGUI_API void AddText(const char* text, const char* text_end = NULL);      // Add string (each character of the UTF-8 string are added)\r\n        IMGUI_API void AddRanges(const ImWchar* ranges);                            // Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault) to force add all of ASCII/Latin+Ext\r\n        IMGUI_API void BuildRanges(ImVector<ImWchar>* out_ranges);                  // Output new ranges\r\n    };\r\n\r\n    //-------------------------------------------\r\n    // Custom Rectangles/Glyphs API\r\n    //-------------------------------------------\r\n\r\n    // You can request arbitrary rectangles to be packed into the atlas, for your own purposes. After calling Build(), you can query the rectangle position and render your pixels.\r\n    // You can also request your rectangles to be mapped as font glyph (given a font + Unicode point), so you can render e.g. custom colorful icons and use them as regular glyphs.\r\n    struct CustomRect\r\n    {\r\n        unsigned int    ID;             // Input    // User ID. Use <0x10000 to map into a font glyph, >=0x10000 for other/internal/custom texture data.\r\n        unsigned short  Width, Height;  // Input    // Desired rectangle dimension\r\n        unsigned short  X, Y;           // Output   // Packed position in Atlas\r\n        float           GlyphAdvanceX;  // Input    // For custom font glyphs only (ID<0x10000): glyph xadvance\r\n        ImVec2          GlyphOffset;    // Input    // For custom font glyphs only (ID<0x10000): glyph display offset\r\n        ImFont*         Font;           // Input    // For custom font glyphs only (ID<0x10000): target font\r\n        CustomRect()            { ID = 0xFFFFFFFF; Width = Height = 0; X = Y = 0xFFFF; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0,0); Font = NULL; }\r\n        bool IsPacked() const   { return X != 0xFFFF; }\r\n    };\r\n\r\n    IMGUI_API int       AddCustomRectRegular(unsigned int id, int width, int height);                                                                   // Id needs to be >= 0x10000. Id >= 0x80000000 are reserved for ImGui and ImDrawList\r\n    IMGUI_API int       AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset = ImVec2(0,0));   // Id needs to be < 0x10000 to register a rectangle to map into a specific font.\r\n    IMGUI_API void      CalcCustomRectUV(const CustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max);\r\n    const CustomRect*   GetCustomRectByIndex(int index) const { if (index < 0) return NULL; return &CustomRects[index]; }\r\n\r\n    //-------------------------------------------\r\n    // Members\r\n    //-------------------------------------------\r\n\r\n    ImTextureID                 TexID;              // User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.\r\n    int                         TexDesiredWidth;    // Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.\r\n    int                         TexGlyphPadding;    // Padding between glyphs within texture in pixels. Defaults to 1.\r\n\r\n    // [Internal]\r\n    // NB: Access texture data via GetTexData*() calls! Which will setup a default font for you.\r\n    unsigned char*              TexPixelsAlpha8;    // 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight\r\n    unsigned int*               TexPixelsRGBA32;    // 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4\r\n    int                         TexWidth;           // Texture width calculated during Build().\r\n    int                         TexHeight;          // Texture height calculated during Build().\r\n    ImVec2                      TexUvWhitePixel;    // Texture coordinates to a white pixel\r\n    ImVector<ImFont*>           Fonts;              // Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.\r\n    ImVector<CustomRect>        CustomRects;        // Rectangles for packing custom texture data into the atlas.\r\n    ImVector<ImFontConfig>      ConfigData;         // Internal data\r\n    int                         CustomRectIds[1];   // Identifiers of custom texture rectangle used by ImFontAtlas/ImDrawList\r\n};\r\n\r\n// Font runtime data and rendering\r\n// ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().\r\nstruct ImFont\r\n{\r\n    // Members: Hot ~62/78 bytes\r\n    float                       FontSize;           // <user set>   // Height of characters, set during loading (don't change after loading)\r\n    float                       Scale;              // = 1.f        // Base font scale, multiplied by the per-window font scale which you can adjust with SetFontScale()\r\n    ImVec2                      DisplayOffset;      // = (0.f,1.f)  // Offset font rendering by xx pixels\r\n    ImVector<ImFontGlyph>       Glyphs;             //              // All glyphs.\r\n    ImVector<float>             IndexAdvanceX;      //              // Sparse. Glyphs->AdvanceX in a directly indexable way (more cache-friendly, for CalcTextSize functions which are often bottleneck in large UI).\r\n    ImVector<unsigned short>    IndexLookup;        //              // Sparse. Index glyphs by Unicode code-point.\r\n    const ImFontGlyph*          FallbackGlyph;      // == FindGlyph(FontFallbackChar)\r\n    float                       FallbackAdvanceX;   // == FallbackGlyph->AdvanceX\r\n    ImWchar                     FallbackChar;       // = '?'        // Replacement glyph if one isn't found. Only set via SetFallbackChar()\r\n\r\n    // Members: Cold ~18/26 bytes\r\n    short                       ConfigDataCount;    // ~ 1          // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.\r\n    ImFontConfig*               ConfigData;         //              // Pointer within ContainerAtlas->ConfigData\r\n    ImFontAtlas*                ContainerAtlas;     //              // What we has been loaded into\r\n    float                       Ascent, Descent;    //              // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]\r\n    int                         MetricsTotalSurface;//              // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)\r\n\r\n    // Methods\r\n    IMGUI_API ImFont();\r\n    IMGUI_API ~ImFont();\r\n    IMGUI_API void              ClearOutputData();\r\n    IMGUI_API void              BuildLookupTable();\r\n    IMGUI_API const ImFontGlyph*FindGlyph(ImWchar c) const;\r\n    IMGUI_API void              SetFallbackChar(ImWchar c);\r\n    float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }\r\n    bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }\r\n    const char*                 GetDebugName() const                { return ConfigData ? ConfigData->Name : \"<unknown>\"; }\r\n\r\n    // 'max_width' stops rendering after a certain width (could be turned into a 2d size). FLT_MAX to disable.\r\n    // 'wrap_width' enable automatic word-wrapping across multiple lines to fit into given width. 0.0f to disable.\r\n    IMGUI_API ImVec2            CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const; // utf8\r\n    IMGUI_API const char*       CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;\r\n    IMGUI_API void              RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, unsigned short c) const;\r\n    IMGUI_API void              RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;\r\n\r\n    // [Internal]\r\n    IMGUI_API void              GrowIndex(int new_size);\r\n    IMGUI_API void              AddGlyph(ImWchar c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);\r\n    IMGUI_API void              AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst = true); // Makes 'dst' character/glyph points to 'src' character/glyph. Currently needs to be called AFTER fonts have been built.\r\n\r\n#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS\r\n    typedef ImFontGlyph Glyph; // OBSOLETE 1.52+\r\n#endif\r\n};\r\n\r\n#if defined(__clang__)\r\n#pragma clang diagnostic pop\r\n#endif\r\n\r\n// Include imgui_user.h at the end of imgui.h (convenient for user to only explicitly include vanilla imgui.h)\r\n#ifdef IMGUI_INCLUDE_IMGUI_USER_H\r\n#include \"imgui_user.h\"\r\n#endif\r\n","// dear imgui, v1.53\r\n// (drawing and font code)\r\n\r\n// Contains implementation for\r\n// - Default styles\r\n// - ImDrawList\r\n// - ImDrawData\r\n// - ImFontAtlas\r\n// - ImFont\r\n// - Default font data\r\n\r\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\r\n#define _CRT_SECURE_NO_WARNINGS\r\n#endif\r\n\r\n#include \"imgui.h\"\r\n#define IMGUI_DEFINE_MATH_OPERATORS\r\n#include \"imgui_internal.h\"\r\n\r\n#include <stdio.h>      // vsnprintf, sscanf, printf\r\n#if !defined(alloca)\r\n#ifdef _WIN32\r\n#include <malloc.h>     // alloca\r\n#if !defined(alloca)\r\n#define alloca _alloca  // for clang with MS Codegen\r\n#endif\r\n#elif defined(__GLIBC__) || defined(__sun)\r\n#include <alloca.h>     // alloca\r\n#else\r\n#include <stdlib.h>     // alloca\r\n#endif\r\n#endif\r\n\r\n#ifdef _MSC_VER\r\n#pragma warning (disable: 4505) // unreferenced local function has been removed (stb stuff)\r\n#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\r\n#define snprintf _snprintf\r\n#endif\r\n\r\n#ifdef __clang__\r\n#pragma clang diagnostic ignored \"-Wold-style-cast\"         // warning : use of old-style cast                              // yes, they are more terse.\r\n#pragma clang diagnostic ignored \"-Wfloat-equal\"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants ok.\r\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"    // warning : declaration requires a global destructor           // similar to above, not sure what the exact difference it.\r\n#pragma clang diagnostic ignored \"-Wsign-conversion\"        // warning : implicit conversion changes signedness             //\r\n#pragma clang diagnostic ignored \"-Wcomma\"                  // warning : possible misuse of comma operator here             //\r\n#if __has_warning(\"-Wreserved-id-macro\")\r\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"      // warning : macro name is a reserved identifier                //\r\n#endif\r\n#if __has_warning(\"-Wdouble-promotion\")\r\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"       // warning: implicit conversion from 'float' to 'double' when passing argument to function\r\n#endif\r\n#elif defined(__GNUC__)\r\n#pragma GCC diagnostic ignored \"-Wunused-function\"          // warning: 'xxxx' defined but not used\r\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"         // warning: implicit conversion from 'float' to 'double' when passing argument to function\r\n#pragma GCC diagnostic ignored \"-Wconversion\"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value\r\n#pragma GCC diagnostic ignored \"-Wcast-qual\"                // warning: cast from type 'xxxx' to type 'xxxx' casts away qualifiers\r\n#endif\r\n\r\n//-------------------------------------------------------------------------\r\n// STB libraries implementation\r\n//-------------------------------------------------------------------------\r\n\r\n//#define IMGUI_STB_NAMESPACE     ImGuiStb\r\n//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION\r\n//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION\r\n\r\n#ifdef IMGUI_STB_NAMESPACE\r\nnamespace IMGUI_STB_NAMESPACE\r\n{\r\n#endif\r\n\r\n#ifdef _MSC_VER\r\n#pragma warning (push)\r\n#pragma warning (disable: 4456)                             // declaration of 'xx' hides previous local declaration\r\n#endif\r\n\r\n#ifdef __clang__\r\n#pragma clang diagnostic push\r\n#pragma clang diagnostic ignored \"-Wunused-function\"\r\n#pragma clang diagnostic ignored \"-Wmissing-prototypes\"\r\n#pragma clang diagnostic ignored \"-Wimplicit-fallthrough\"\r\n#endif\r\n\r\n#ifdef __GNUC__\r\n#pragma GCC diagnostic push\r\n#pragma GCC diagnostic ignored \"-Wtype-limits\"              // warning: comparison is always true due to limited range of data type [-Wtype-limits]\r\n#endif\r\n\r\n#define STBRP_ASSERT(x)    IM_ASSERT(x)\r\n#ifndef IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION\r\n#define STBRP_STATIC\r\n#define STB_RECT_PACK_IMPLEMENTATION\r\n#endif\r\n#include \"stb_rect_pack.h\"\r\n\r\n#define STBTT_malloc(x,u)  ((void)(u), ImGui::MemAlloc(x))\r\n#define STBTT_free(x,u)    ((void)(u), ImGui::MemFree(x))\r\n#define STBTT_assert(x)    IM_ASSERT(x)\r\n#ifndef IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION\r\n#define STBTT_STATIC\r\n#define STB_TRUETYPE_IMPLEMENTATION\r\n#else\r\n#define STBTT_DEF extern\r\n#endif\r\n#include \"stb_truetype.h\"\r\n\r\n#ifdef __GNUC__\r\n#pragma GCC diagnostic pop\r\n#endif\r\n\r\n#ifdef __clang__\r\n#pragma clang diagnostic pop\r\n#endif\r\n\r\n#ifdef _MSC_VER\r\n#pragma warning (pop)\r\n#endif\r\n\r\n#ifdef IMGUI_STB_NAMESPACE\r\n} // namespace ImGuiStb\r\nusing namespace IMGUI_STB_NAMESPACE;\r\n#endif\r\n\r\n//-----------------------------------------------------------------------------\r\n// Style functions\r\n//-----------------------------------------------------------------------------\r\n\r\nvoid ImGui::StyleColorsClassic(ImGuiStyle* dst)\r\n{\r\n    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();\r\n    ImVec4* colors = style->Colors;\r\n\r\n    colors[ImGuiCol_Text]                   = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);\r\n    colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);\r\n    colors[ImGuiCol_WindowBg]               = ImVec4(0.00f, 0.00f, 0.00f, 0.70f);\r\n    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\r\n    colors[ImGuiCol_PopupBg]                = ImVec4(0.11f, 0.11f, 0.14f, 0.92f);\r\n    colors[ImGuiCol_Border]                 = ImVec4(0.50f, 0.50f, 0.50f, 0.50f);\r\n    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\r\n    colors[ImGuiCol_FrameBg]                = ImVec4(0.43f, 0.43f, 0.43f, 0.39f);\r\n    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.47f, 0.47f, 0.69f, 0.40f);\r\n    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.42f, 0.41f, 0.64f, 0.69f);\r\n    colors[ImGuiCol_TitleBg]                = ImVec4(0.27f, 0.27f, 0.54f, 0.83f);\r\n    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.32f, 0.32f, 0.63f, 0.87f);\r\n    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.40f, 0.40f, 0.80f, 0.20f);\r\n    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.40f, 0.40f, 0.55f, 0.80f);\r\n    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.20f, 0.25f, 0.30f, 0.60f);\r\n    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.40f, 0.40f, 0.80f, 0.30f);\r\n    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.40f, 0.40f, 0.80f, 0.40f);\r\n    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);\r\n    colors[ImGuiCol_CheckMark]              = ImVec4(0.90f, 0.90f, 0.90f, 0.50f);\r\n    colors[ImGuiCol_SliderGrab]             = ImVec4(1.00f, 1.00f, 1.00f, 0.30f);\r\n    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);\r\n    colors[ImGuiCol_Button]                 = ImVec4(0.35f, 0.40f, 0.61f, 0.62f);\r\n    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.40f, 0.48f, 0.71f, 0.79f);\r\n    colors[ImGuiCol_ButtonActive]           = ImVec4(0.46f, 0.54f, 0.80f, 1.00f);\r\n    colors[ImGuiCol_Header]                 = ImVec4(0.40f, 0.40f, 0.90f, 0.45f);\r\n    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.45f, 0.45f, 0.90f, 0.80f);\r\n    colors[ImGuiCol_HeaderActive]           = ImVec4(0.53f, 0.53f, 0.87f, 0.80f);\r\n    colors[ImGuiCol_Separator]              = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);\r\n    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.60f, 0.60f, 0.70f, 1.00f);\r\n    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.70f, 0.70f, 0.90f, 1.00f);\r\n    colors[ImGuiCol_ResizeGrip]             = ImVec4(1.00f, 1.00f, 1.00f, 0.16f);\r\n    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.78f, 0.82f, 1.00f, 0.60f);\r\n    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.78f, 0.82f, 1.00f, 0.90f);\r\n    colors[ImGuiCol_CloseButton]            = ImVec4(0.50f, 0.50f, 0.90f, 0.50f);\r\n    colors[ImGuiCol_CloseButtonHovered]     = ImVec4(0.70f, 0.70f, 0.90f, 0.60f);\r\n    colors[ImGuiCol_CloseButtonActive]      = ImVec4(0.70f, 0.70f, 0.70f, 1.00f);\r\n    colors[ImGuiCol_PlotLines]              = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);\r\n    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);\r\n    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);\r\n    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);\r\n    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.00f, 0.00f, 1.00f, 0.35f);\r\n    colors[ImGuiCol_ModalWindowDarkening]   = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);\r\n    colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);\r\n}\r\n\r\nvoid ImGui::StyleColorsDark(ImGuiStyle* dst)\r\n{\r\n    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();\r\n    ImVec4* colors = style->Colors;\r\n\r\n    colors[ImGuiCol_Text]                   = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);\r\n    colors[ImGuiCol_TextDisabled]           = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);\r\n    colors[ImGuiCol_WindowBg]               = ImVec4(0.06f, 0.06f, 0.06f, 0.94f);\r\n    colors[ImGuiCol_ChildBg]                = ImVec4(1.00f, 1.00f, 1.00f, 0.00f);\r\n    colors[ImGuiCol_PopupBg]                = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);\r\n    colors[ImGuiCol_Border]                 = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);\r\n    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\r\n    colors[ImGuiCol_FrameBg]                = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);\r\n    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);\r\n    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);\r\n    colors[ImGuiCol_TitleBg]                = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);\r\n    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.16f, 0.29f, 0.48f, 1.00f);\r\n    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);\r\n    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);\r\n    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);\r\n    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);\r\n    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);\r\n    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);\r\n    colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\r\n    colors[ImGuiCol_SliderGrab]             = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);\r\n    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\r\n    colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);\r\n    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\r\n    colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);\r\n    colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);\r\n    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);\r\n    colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\r\n    colors[ImGuiCol_Separator]              = colors[ImGuiCol_Border];//ImVec4(0.61f, 0.61f, 0.61f, 1.00f);\r\n    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);\r\n    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);\r\n    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.26f, 0.59f, 0.98f, 0.25f);\r\n    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);\r\n    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);\r\n    colors[ImGuiCol_CloseButton]            = ImVec4(0.41f, 0.41f, 0.41f, 0.50f);\r\n    colors[ImGuiCol_CloseButtonHovered]     = ImVec4(0.98f, 0.39f, 0.36f, 1.00f);\r\n    colors[ImGuiCol_CloseButtonActive]      = ImVec4(0.98f, 0.39f, 0.36f, 1.00f);\r\n    colors[ImGuiCol_PlotLines]              = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);\r\n    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);\r\n    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);\r\n    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);\r\n    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);\r\n    colors[ImGuiCol_ModalWindowDarkening]   = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);\r\n    colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);\r\n}\r\n\r\n// Those light colors are better suited with a thicker font than the default one + FrameBorder\r\nvoid ImGui::StyleColorsLight(ImGuiStyle* dst)\r\n{\r\n    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();\r\n    ImVec4* colors = style->Colors;\r\n\r\n    colors[ImGuiCol_Text]                   = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);\r\n    colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);\r\n    //colors[ImGuiCol_TextHovered]          = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);\r\n    //colors[ImGuiCol_TextActive]           = ImVec4(1.00f, 1.00f, 0.00f, 1.00f);\r\n    colors[ImGuiCol_WindowBg]               = ImVec4(0.94f, 0.94f, 0.94f, 1.00f);\r\n    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\r\n    colors[ImGuiCol_PopupBg]                = ImVec4(1.00f, 1.00f, 1.00f, 0.98f);\r\n    colors[ImGuiCol_Border]                 = ImVec4(0.00f, 0.00f, 0.00f, 0.30f);\r\n    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);\r\n    colors[ImGuiCol_FrameBg]                = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);\r\n    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);\r\n    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);\r\n    colors[ImGuiCol_TitleBg]                = ImVec4(0.96f, 0.96f, 0.96f, 1.00f);\r\n    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.82f, 0.82f, 0.82f, 1.00f);\r\n    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(1.00f, 1.00f, 1.00f, 0.51f);\r\n    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.86f, 0.86f, 0.86f, 1.00f);\r\n    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.98f, 0.98f, 0.98f, 0.53f);\r\n    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.69f, 0.69f, 0.69f, 0.80f);\r\n    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.49f, 0.49f, 0.49f, 0.80f);\r\n    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.49f, 0.49f, 0.49f, 1.00f);\r\n    colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\r\n    colors[ImGuiCol_SliderGrab]             = ImVec4(0.26f, 0.59f, 0.98f, 0.78f);\r\n    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.46f, 0.54f, 0.80f, 0.60f);\r\n    colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);\r\n    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\r\n    colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);\r\n    colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);\r\n    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);\r\n    colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);\r\n    colors[ImGuiCol_Separator]              = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);\r\n    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.14f, 0.44f, 0.80f, 0.78f);\r\n    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.14f, 0.44f, 0.80f, 1.00f);\r\n    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.80f, 0.80f, 0.80f, 0.56f);\r\n    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);\r\n    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);\r\n    colors[ImGuiCol_CloseButton]            = ImVec4(0.59f, 0.59f, 0.59f, 0.50f);\r\n    colors[ImGuiCol_CloseButtonHovered]     = ImVec4(0.98f, 0.39f, 0.36f, 1.00f);\r\n    colors[ImGuiCol_CloseButtonActive]      = ImVec4(0.98f, 0.39f, 0.36f, 1.00f);\r\n    colors[ImGuiCol_PlotLines]              = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);\r\n    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);\r\n    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);\r\n    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.45f, 0.00f, 1.00f);\r\n    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);\r\n    colors[ImGuiCol_ModalWindowDarkening]   = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);\r\n    colors[ImGuiCol_DragDropTarget]         = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// ImDrawListData\r\n//-----------------------------------------------------------------------------\r\n\r\nImDrawListSharedData::ImDrawListSharedData()\r\n{\r\n    Font = NULL;\r\n    FontSize = 0.0f;\r\n    CurveTessellationTol = 0.0f;\r\n    ClipRectFullscreen = ImVec4(-8192.0f, -8192.0f, +8192.0f, +8192.0f);\r\n    \r\n    // Const data\r\n    for (int i = 0; i < IM_ARRAYSIZE(CircleVtx12); i++)\r\n    {\r\n        const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(CircleVtx12);\r\n        CircleVtx12[i] = ImVec2(cosf(a), sinf(a));\r\n    }\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// ImDrawList\r\n//-----------------------------------------------------------------------------\r\n\r\nvoid ImDrawList::Clear()\r\n{\r\n    CmdBuffer.resize(0);\r\n    IdxBuffer.resize(0);\r\n    VtxBuffer.resize(0);\r\n    Flags = ImDrawListFlags_AntiAliasedLines | ImDrawListFlags_AntiAliasedFill;\r\n    _VtxCurrentIdx = 0;\r\n    _VtxWritePtr = NULL;\r\n    _IdxWritePtr = NULL;\r\n    _ClipRectStack.resize(0);\r\n    _TextureIdStack.resize(0);\r\n    _Path.resize(0);\r\n    _ChannelsCurrent = 0;\r\n    _ChannelsCount = 1;\r\n    // NB: Do not clear channels so our allocations are re-used after the first frame.\r\n}\r\n\r\nvoid ImDrawList::ClearFreeMemory()\r\n{\r\n    CmdBuffer.clear();\r\n    IdxBuffer.clear();\r\n    VtxBuffer.clear();\r\n    _VtxCurrentIdx = 0;\r\n    _VtxWritePtr = NULL;\r\n    _IdxWritePtr = NULL;\r\n    _ClipRectStack.clear();\r\n    _TextureIdStack.clear();\r\n    _Path.clear();\r\n    _ChannelsCurrent = 0;\r\n    _ChannelsCount = 1;\r\n    for (int i = 0; i < _Channels.Size; i++)\r\n    {\r\n        if (i == 0) memset(&_Channels[0], 0, sizeof(_Channels[0]));  // channel 0 is a copy of CmdBuffer/IdxBuffer, don't destruct again\r\n        _Channels[i].CmdBuffer.clear();\r\n        _Channels[i].IdxBuffer.clear();\r\n    }\r\n    _Channels.clear();\r\n}\r\n\r\n// Using macros because C++ is a terrible language, we want guaranteed inline, no code in header, and no overhead in Debug builds\r\n#define GetCurrentClipRect()    (_ClipRectStack.Size ? _ClipRectStack.Data[_ClipRectStack.Size-1]  : _Data->ClipRectFullscreen)\r\n#define GetCurrentTextureId()   (_TextureIdStack.Size ? _TextureIdStack.Data[_TextureIdStack.Size-1] : NULL)\r\n\r\nvoid ImDrawList::AddDrawCmd()\r\n{\r\n    ImDrawCmd draw_cmd;\r\n    draw_cmd.ClipRect = GetCurrentClipRect();\r\n    draw_cmd.TextureId = GetCurrentTextureId();\r\n\r\n    IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);\r\n    CmdBuffer.push_back(draw_cmd);\r\n}\r\n\r\nvoid ImDrawList::AddCallback(ImDrawCallback callback, void* callback_data)\r\n{\r\n    ImDrawCmd* current_cmd = CmdBuffer.Size ? &CmdBuffer.back() : NULL;\r\n    if (!current_cmd || current_cmd->ElemCount != 0 || current_cmd->UserCallback != NULL)\r\n    {\r\n        AddDrawCmd();\r\n        current_cmd = &CmdBuffer.back();\r\n    }\r\n    current_cmd->UserCallback = callback;\r\n    current_cmd->UserCallbackData = callback_data;\r\n\r\n    AddDrawCmd(); // Force a new command after us (see comment below)\r\n}\r\n\r\n// Our scheme may appears a bit unusual, basically we want the most-common calls AddLine AddRect etc. to not have to perform any check so we always have a command ready in the stack.\r\n// The cost of figuring out if a new command has to be added or if we can merge is paid in those Update** functions only.\r\nvoid ImDrawList::UpdateClipRect()\r\n{\r\n    // If current command is used with different settings we need to add a new command\r\n    const ImVec4 curr_clip_rect = GetCurrentClipRect();\r\n    ImDrawCmd* curr_cmd = CmdBuffer.Size > 0 ? &CmdBuffer.Data[CmdBuffer.Size-1] : NULL;\r\n    if (!curr_cmd || (curr_cmd->ElemCount != 0 && memcmp(&curr_cmd->ClipRect, &curr_clip_rect, sizeof(ImVec4)) != 0) || curr_cmd->UserCallback != NULL)\r\n    {\r\n        AddDrawCmd();\r\n        return;\r\n    }\r\n\r\n    // Try to merge with previous command if it matches, else use current command\r\n    ImDrawCmd* prev_cmd = CmdBuffer.Size > 1 ? curr_cmd - 1 : NULL;\r\n    if (curr_cmd->ElemCount == 0 && prev_cmd && memcmp(&prev_cmd->ClipRect, &curr_clip_rect, sizeof(ImVec4)) == 0 && prev_cmd->TextureId == GetCurrentTextureId() && prev_cmd->UserCallback == NULL)\r\n        CmdBuffer.pop_back();\r\n    else\r\n        curr_cmd->ClipRect = curr_clip_rect;\r\n}\r\n\r\nvoid ImDrawList::UpdateTextureID()\r\n{\r\n    // If current command is used with different settings we need to add a new command\r\n    const ImTextureID curr_texture_id = GetCurrentTextureId();\r\n    ImDrawCmd* curr_cmd = CmdBuffer.Size ? &CmdBuffer.back() : NULL;\r\n    if (!curr_cmd || (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != curr_texture_id) || curr_cmd->UserCallback != NULL)\r\n    {\r\n        AddDrawCmd();\r\n        return;\r\n    }\r\n\r\n    // Try to merge with previous command if it matches, else use current command\r\n    ImDrawCmd* prev_cmd = CmdBuffer.Size > 1 ? curr_cmd - 1 : NULL;\r\n    if (curr_cmd->ElemCount == 0 && prev_cmd && prev_cmd->TextureId == curr_texture_id && memcmp(&prev_cmd->ClipRect, &GetCurrentClipRect(), sizeof(ImVec4)) == 0 && prev_cmd->UserCallback == NULL)\r\n        CmdBuffer.pop_back();\r\n    else\r\n        curr_cmd->TextureId = curr_texture_id;\r\n}\r\n\r\n#undef GetCurrentClipRect\r\n#undef GetCurrentTextureId\r\n\r\n// Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)\r\nvoid ImDrawList::PushClipRect(ImVec2 cr_min, ImVec2 cr_max, bool intersect_with_current_clip_rect)\r\n{\r\n    ImVec4 cr(cr_min.x, cr_min.y, cr_max.x, cr_max.y);\r\n    if (intersect_with_current_clip_rect && _ClipRectStack.Size)\r\n    {\r\n        ImVec4 current = _ClipRectStack.Data[_ClipRectStack.Size-1];\r\n        if (cr.x < current.x) cr.x = current.x;\r\n        if (cr.y < current.y) cr.y = current.y;\r\n        if (cr.z > current.z) cr.z = current.z;\r\n        if (cr.w > current.w) cr.w = current.w;\r\n    }\r\n    cr.z = ImMax(cr.x, cr.z);\r\n    cr.w = ImMax(cr.y, cr.w);\r\n\r\n    _ClipRectStack.push_back(cr);\r\n    UpdateClipRect();\r\n}\r\n\r\nvoid ImDrawList::PushClipRectFullScreen()\r\n{\r\n    PushClipRect(ImVec2(_Data->ClipRectFullscreen.x, _Data->ClipRectFullscreen.y), ImVec2(_Data->ClipRectFullscreen.z, _Data->ClipRectFullscreen.w));\r\n}\r\n\r\nvoid ImDrawList::PopClipRect()\r\n{\r\n    IM_ASSERT(_ClipRectStack.Size > 0);\r\n    _ClipRectStack.pop_back();\r\n    UpdateClipRect();\r\n}\r\n\r\nvoid ImDrawList::PushTextureID(const ImTextureID& texture_id)\r\n{\r\n    _TextureIdStack.push_back(texture_id);\r\n    UpdateTextureID();\r\n}\r\n\r\nvoid ImDrawList::PopTextureID()\r\n{\r\n    IM_ASSERT(_TextureIdStack.Size > 0);\r\n    _TextureIdStack.pop_back();\r\n    UpdateTextureID();\r\n}\r\n\r\nvoid ImDrawList::ChannelsSplit(int channels_count)\r\n{\r\n    IM_ASSERT(_ChannelsCurrent == 0 && _ChannelsCount == 1);\r\n    int old_channels_count = _Channels.Size;\r\n    if (old_channels_count < channels_count)\r\n        _Channels.resize(channels_count);\r\n    _ChannelsCount = channels_count;\r\n\r\n    // _Channels[] (24/32 bytes each) hold storage that we'll swap with this->_CmdBuffer/_IdxBuffer\r\n    // The content of _Channels[0] at this point doesn't matter. We clear it to make state tidy in a debugger but we don't strictly need to.\r\n    // When we switch to the next channel, we'll copy _CmdBuffer/_IdxBuffer into _Channels[0] and then _Channels[1] into _CmdBuffer/_IdxBuffer\r\n    memset(&_Channels[0], 0, sizeof(ImDrawChannel));\r\n    for (int i = 1; i < channels_count; i++)\r\n    {\r\n        if (i >= old_channels_count)\r\n        {\r\n            IM_PLACEMENT_NEW(&_Channels[i]) ImDrawChannel();\r\n        }\r\n        else\r\n        {\r\n            _Channels[i].CmdBuffer.resize(0);\r\n            _Channels[i].IdxBuffer.resize(0);\r\n        }\r\n        if (_Channels[i].CmdBuffer.Size == 0)\r\n        {\r\n            ImDrawCmd draw_cmd;\r\n            draw_cmd.ClipRect = _ClipRectStack.back();\r\n            draw_cmd.TextureId = _TextureIdStack.back();\r\n            _Channels[i].CmdBuffer.push_back(draw_cmd);\r\n        }\r\n    }\r\n}\r\n\r\nvoid ImDrawList::ChannelsMerge()\r\n{\r\n    // Note that we never use or rely on channels.Size because it is merely a buffer that we never shrink back to 0 to keep all sub-buffers ready for use.\r\n    if (_ChannelsCount <= 1)\r\n        return;\r\n\r\n    ChannelsSetCurrent(0);\r\n    if (CmdBuffer.Size && CmdBuffer.back().ElemCount == 0)\r\n        CmdBuffer.pop_back();\r\n\r\n    int new_cmd_buffer_count = 0, new_idx_buffer_count = 0;\r\n    for (int i = 1; i < _ChannelsCount; i++)\r\n    {\r\n        ImDrawChannel& ch = _Channels[i];\r\n        if (ch.CmdBuffer.Size && ch.CmdBuffer.back().ElemCount == 0)\r\n            ch.CmdBuffer.pop_back();\r\n        new_cmd_buffer_count += ch.CmdBuffer.Size;\r\n        new_idx_buffer_count += ch.IdxBuffer.Size;\r\n    }\r\n    CmdBuffer.resize(CmdBuffer.Size + new_cmd_buffer_count);\r\n    IdxBuffer.resize(IdxBuffer.Size + new_idx_buffer_count);\r\n\r\n    ImDrawCmd* cmd_write = CmdBuffer.Data + CmdBuffer.Size - new_cmd_buffer_count;\r\n    _IdxWritePtr = IdxBuffer.Data + IdxBuffer.Size - new_idx_buffer_count;\r\n    for (int i = 1; i < _ChannelsCount; i++)\r\n    {\r\n        ImDrawChannel& ch = _Channels[i];\r\n        if (int sz = ch.CmdBuffer.Size) { memcpy(cmd_write, ch.CmdBuffer.Data, sz * sizeof(ImDrawCmd)); cmd_write += sz; }\r\n        if (int sz = ch.IdxBuffer.Size) { memcpy(_IdxWritePtr, ch.IdxBuffer.Data, sz * sizeof(ImDrawIdx)); _IdxWritePtr += sz; }\r\n    }\r\n    UpdateClipRect(); // We call this instead of AddDrawCmd(), so that empty channels won't produce an extra draw call.\r\n    _ChannelsCount = 1;\r\n}\r\n\r\nvoid ImDrawList::ChannelsSetCurrent(int idx)\r\n{\r\n    IM_ASSERT(idx < _ChannelsCount);\r\n    if (_ChannelsCurrent == idx) return;\r\n    memcpy(&_Channels.Data[_ChannelsCurrent].CmdBuffer, &CmdBuffer, sizeof(CmdBuffer)); // copy 12 bytes, four times\r\n    memcpy(&_Channels.Data[_ChannelsCurrent].IdxBuffer, &IdxBuffer, sizeof(IdxBuffer));\r\n    _ChannelsCurrent = idx;\r\n    memcpy(&CmdBuffer, &_Channels.Data[_ChannelsCurrent].CmdBuffer, sizeof(CmdBuffer));\r\n    memcpy(&IdxBuffer, &_Channels.Data[_ChannelsCurrent].IdxBuffer, sizeof(IdxBuffer));\r\n    _IdxWritePtr = IdxBuffer.Data + IdxBuffer.Size;\r\n}\r\n\r\n// NB: this can be called with negative count for removing primitives (as long as the result does not underflow)\r\nvoid ImDrawList::PrimReserve(int idx_count, int vtx_count)\r\n{\r\n    ImDrawCmd& draw_cmd = CmdBuffer.Data[CmdBuffer.Size-1];\r\n    draw_cmd.ElemCount += idx_count;\r\n\r\n    int vtx_buffer_old_size = VtxBuffer.Size;\r\n    VtxBuffer.resize(vtx_buffer_old_size + vtx_count);\r\n    _VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;\r\n\r\n    int idx_buffer_old_size = IdxBuffer.Size;\r\n    IdxBuffer.resize(idx_buffer_old_size + idx_count);\r\n    _IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;\r\n}\r\n\r\n// Fully unrolled with inline call to keep our debug builds decently fast.\r\nvoid ImDrawList::PrimRect(const ImVec2& a, const ImVec2& c, ImU32 col)\r\n{\r\n    ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);\r\n    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;\r\n    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);\r\n    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);\r\n    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;\r\n    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;\r\n    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;\r\n    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;\r\n    _VtxWritePtr += 4;\r\n    _VtxCurrentIdx += 4;\r\n    _IdxWritePtr += 6;\r\n}\r\n\r\nvoid ImDrawList::PrimRectUV(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)\r\n{\r\n    ImVec2 b(c.x, a.y), d(a.x, c.y), uv_b(uv_c.x, uv_a.y), uv_d(uv_a.x, uv_c.y);\r\n    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;\r\n    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);\r\n    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);\r\n    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;\r\n    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;\r\n    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;\r\n    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;\r\n    _VtxWritePtr += 4;\r\n    _VtxCurrentIdx += 4;\r\n    _IdxWritePtr += 6;\r\n}\r\n\r\nvoid ImDrawList::PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)\r\n{\r\n    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;\r\n    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);\r\n    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);\r\n    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;\r\n    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;\r\n    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;\r\n    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;\r\n    _VtxWritePtr += 4;\r\n    _VtxCurrentIdx += 4;\r\n    _IdxWritePtr += 6;\r\n}\r\n\r\n// TODO: Thickness anti-aliased lines cap are missing their AA fringe.\r\nvoid ImDrawList::AddPolyline(const ImVec2* points, const int points_count, ImU32 col, bool closed, float thickness)\r\n{\r\n    if (points_count < 2)\r\n        return;\r\n\r\n    const ImVec2 uv = _Data->TexUvWhitePixel;\r\n\r\n    int count = points_count;\r\n    if (!closed)\r\n        count = points_count-1;\r\n\r\n    const bool thick_line = thickness > 1.0f;\r\n    if (Flags & ImDrawListFlags_AntiAliasedLines)\r\n    {\r\n        // Anti-aliased stroke\r\n        const float AA_SIZE = 1.0f;\r\n        const ImU32 col_trans = col & ~IM_COL32_A_MASK;\r\n\r\n        const int idx_count = thick_line ? count*18 : count*12;\r\n        const int vtx_count = thick_line ? points_count*4 : points_count*3;\r\n        PrimReserve(idx_count, vtx_count);\r\n\r\n        // Temporary buffer\r\n        ImVec2* temp_normals = (ImVec2*)alloca(points_count * (thick_line ? 5 : 3) * sizeof(ImVec2));\r\n        ImVec2* temp_points = temp_normals + points_count;\r\n\r\n        for (int i1 = 0; i1 < count; i1++)\r\n        {\r\n            const int i2 = (i1+1) == points_count ? 0 : i1+1;\r\n            ImVec2 diff = points[i2] - points[i1];\r\n            diff *= ImInvLength(diff, 1.0f);\r\n            temp_normals[i1].x = diff.y;\r\n            temp_normals[i1].y = -diff.x;\r\n        }\r\n        if (!closed)\r\n            temp_normals[points_count-1] = temp_normals[points_count-2];\r\n\r\n        if (!thick_line)\r\n        {\r\n            if (!closed)\r\n            {\r\n                temp_points[0] = points[0] + temp_normals[0] * AA_SIZE;\r\n                temp_points[1] = points[0] - temp_normals[0] * AA_SIZE;\r\n                temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * AA_SIZE;\r\n                temp_points[(points_count-1)*2+1] = points[points_count-1] - temp_normals[points_count-1] * AA_SIZE;\r\n            }\r\n\r\n            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.\r\n            unsigned int idx1 = _VtxCurrentIdx;\r\n            for (int i1 = 0; i1 < count; i1++)\r\n            {\r\n                const int i2 = (i1+1) == points_count ? 0 : i1+1;\r\n                unsigned int idx2 = (i1+1) == points_count ? _VtxCurrentIdx : idx1+3;\r\n\r\n                // Average normals\r\n                ImVec2 dm = (temp_normals[i1] + temp_normals[i2]) * 0.5f;\r\n                float dmr2 = dm.x*dm.x + dm.y*dm.y;\r\n                if (dmr2 > 0.000001f)\r\n                {\r\n                    float scale = 1.0f / dmr2;\r\n                    if (scale > 100.0f) scale = 100.0f;\r\n                    dm *= scale;\r\n                }\r\n                dm *= AA_SIZE;\r\n                temp_points[i2*2+0] = points[i2] + dm;\r\n                temp_points[i2*2+1] = points[i2] - dm;\r\n\r\n                // Add indexes\r\n                _IdxWritePtr[0] = (ImDrawIdx)(idx2+0); _IdxWritePtr[1] = (ImDrawIdx)(idx1+0); _IdxWritePtr[2] = (ImDrawIdx)(idx1+2);\r\n                _IdxWritePtr[3] = (ImDrawIdx)(idx1+2); _IdxWritePtr[4] = (ImDrawIdx)(idx2+2); _IdxWritePtr[5] = (ImDrawIdx)(idx2+0);\r\n                _IdxWritePtr[6] = (ImDrawIdx)(idx2+1); _IdxWritePtr[7] = (ImDrawIdx)(idx1+1); _IdxWritePtr[8] = (ImDrawIdx)(idx1+0);\r\n                _IdxWritePtr[9] = (ImDrawIdx)(idx1+0); _IdxWritePtr[10]= (ImDrawIdx)(idx2+0); _IdxWritePtr[11]= (ImDrawIdx)(idx2+1);\r\n                _IdxWritePtr += 12;\r\n\r\n                idx1 = idx2;\r\n            }\r\n\r\n            // Add vertexes\r\n            for (int i = 0; i < points_count; i++)\r\n            {\r\n                _VtxWritePtr[0].pos = points[i];          _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;\r\n                _VtxWritePtr[1].pos = temp_points[i*2+0]; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;\r\n                _VtxWritePtr[2].pos = temp_points[i*2+1]; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col_trans;\r\n                _VtxWritePtr += 3;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;\r\n            if (!closed)\r\n            {\r\n                temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);\r\n                temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);\r\n                temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);\r\n                temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);\r\n                temp_points[(points_count-1)*4+0] = points[points_count-1] + temp_normals[points_count-1] * (half_inner_thickness + AA_SIZE);\r\n                temp_points[(points_count-1)*4+1] = points[points_count-1] + temp_normals[points_count-1] * (half_inner_thickness);\r\n                temp_points[(points_count-1)*4+2] = points[points_count-1] - temp_normals[points_count-1] * (half_inner_thickness);\r\n                temp_points[(points_count-1)*4+3] = points[points_count-1] - temp_normals[points_count-1] * (half_inner_thickness + AA_SIZE);\r\n            }\r\n\r\n            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.\r\n            unsigned int idx1 = _VtxCurrentIdx;\r\n            for (int i1 = 0; i1 < count; i1++)\r\n            {\r\n                const int i2 = (i1+1) == points_count ? 0 : i1+1;\r\n                unsigned int idx2 = (i1+1) == points_count ? _VtxCurrentIdx : idx1+4;\r\n\r\n                // Average normals\r\n                ImVec2 dm = (temp_normals[i1] + temp_normals[i2]) * 0.5f;\r\n                float dmr2 = dm.x*dm.x + dm.y*dm.y;\r\n                if (dmr2 > 0.000001f)\r\n                {\r\n                    float scale = 1.0f / dmr2;\r\n                    if (scale > 100.0f) scale = 100.0f;\r\n                    dm *= scale;\r\n                }\r\n                ImVec2 dm_out = dm * (half_inner_thickness + AA_SIZE);\r\n                ImVec2 dm_in = dm * half_inner_thickness;\r\n                temp_points[i2*4+0] = points[i2] + dm_out;\r\n                temp_points[i2*4+1] = points[i2] + dm_in;\r\n                temp_points[i2*4+2] = points[i2] - dm_in;\r\n                temp_points[i2*4+3] = points[i2] - dm_out;\r\n\r\n                // Add indexes\r\n                _IdxWritePtr[0]  = (ImDrawIdx)(idx2+1); _IdxWritePtr[1]  = (ImDrawIdx)(idx1+1); _IdxWritePtr[2]  = (ImDrawIdx)(idx1+2);\r\n                _IdxWritePtr[3]  = (ImDrawIdx)(idx1+2); _IdxWritePtr[4]  = (ImDrawIdx)(idx2+2); _IdxWritePtr[5]  = (ImDrawIdx)(idx2+1);\r\n                _IdxWritePtr[6]  = (ImDrawIdx)(idx2+1); _IdxWritePtr[7]  = (ImDrawIdx)(idx1+1); _IdxWritePtr[8]  = (ImDrawIdx)(idx1+0);\r\n                _IdxWritePtr[9]  = (ImDrawIdx)(idx1+0); _IdxWritePtr[10] = (ImDrawIdx)(idx2+0); _IdxWritePtr[11] = (ImDrawIdx)(idx2+1);\r\n                _IdxWritePtr[12] = (ImDrawIdx)(idx2+2); _IdxWritePtr[13] = (ImDrawIdx)(idx1+2); _IdxWritePtr[14] = (ImDrawIdx)(idx1+3);\r\n                _IdxWritePtr[15] = (ImDrawIdx)(idx1+3); _IdxWritePtr[16] = (ImDrawIdx)(idx2+3); _IdxWritePtr[17] = (ImDrawIdx)(idx2+2);\r\n                _IdxWritePtr += 18;\r\n\r\n                idx1 = idx2;\r\n            }\r\n\r\n            // Add vertexes\r\n            for (int i = 0; i < points_count; i++)\r\n            {\r\n                _VtxWritePtr[0].pos = temp_points[i*4+0]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col_trans;\r\n                _VtxWritePtr[1].pos = temp_points[i*4+1]; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;\r\n                _VtxWritePtr[2].pos = temp_points[i*4+2]; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;\r\n                _VtxWritePtr[3].pos = temp_points[i*4+3]; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col_trans;\r\n                _VtxWritePtr += 4;\r\n            }\r\n        }\r\n        _VtxCurrentIdx += (ImDrawIdx)vtx_count;\r\n    }\r\n    else\r\n    {\r\n        // Non Anti-aliased Stroke\r\n        const int idx_count = count*6;\r\n        const int vtx_count = count*4;      // FIXME-OPT: Not sharing edges\r\n        PrimReserve(idx_count, vtx_count);\r\n\r\n        for (int i1 = 0; i1 < count; i1++)\r\n        {\r\n            const int i2 = (i1+1) == points_count ? 0 : i1+1;\r\n            const ImVec2& p1 = points[i1];\r\n            const ImVec2& p2 = points[i2];\r\n            ImVec2 diff = p2 - p1;\r\n            diff *= ImInvLength(diff, 1.0f);\r\n\r\n            const float dx = diff.x * (thickness * 0.5f);\r\n            const float dy = diff.y * (thickness * 0.5f);\r\n            _VtxWritePtr[0].pos.x = p1.x + dy; _VtxWritePtr[0].pos.y = p1.y - dx; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;\r\n            _VtxWritePtr[1].pos.x = p2.x + dy; _VtxWritePtr[1].pos.y = p2.y - dx; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;\r\n            _VtxWritePtr[2].pos.x = p2.x - dy; _VtxWritePtr[2].pos.y = p2.y + dx; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;\r\n            _VtxWritePtr[3].pos.x = p1.x - dy; _VtxWritePtr[3].pos.y = p1.y + dx; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;\r\n            _VtxWritePtr += 4;\r\n\r\n            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx+1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx+2);\r\n            _IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx+2); _IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx+3);\r\n            _IdxWritePtr += 6;\r\n            _VtxCurrentIdx += 4;\r\n        }\r\n    }\r\n}\r\n\r\nvoid ImDrawList::AddConvexPolyFilled(const ImVec2* points, const int points_count, ImU32 col)\r\n{\r\n    const ImVec2 uv = _Data->TexUvWhitePixel;\r\n\r\n    if (Flags & ImDrawListFlags_AntiAliasedFill)\r\n    {\r\n        // Anti-aliased Fill\r\n        const float AA_SIZE = 1.0f;\r\n        const ImU32 col_trans = col & ~IM_COL32_A_MASK;\r\n        const int idx_count = (points_count-2)*3 + points_count*6;\r\n        const int vtx_count = (points_count*2);\r\n        PrimReserve(idx_count, vtx_count);\r\n\r\n        // Add indexes for fill\r\n        unsigned int vtx_inner_idx = _VtxCurrentIdx;\r\n        unsigned int vtx_outer_idx = _VtxCurrentIdx+1;\r\n        for (int i = 2; i < points_count; i++)\r\n        {\r\n            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx+((i-1)<<1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx+(i<<1));\r\n            _IdxWritePtr += 3;\r\n        }\r\n\r\n        // Compute normals\r\n        ImVec2* temp_normals = (ImVec2*)alloca(points_count * sizeof(ImVec2));\r\n        for (int i0 = points_count-1, i1 = 0; i1 < points_count; i0 = i1++)\r\n        {\r\n            const ImVec2& p0 = points[i0];\r\n            const ImVec2& p1 = points[i1];\r\n            ImVec2 diff = p1 - p0;\r\n            diff *= ImInvLength(diff, 1.0f);\r\n            temp_normals[i0].x = diff.y;\r\n            temp_normals[i0].y = -diff.x;\r\n        }\r\n\r\n        for (int i0 = points_count-1, i1 = 0; i1 < points_count; i0 = i1++)\r\n        {\r\n            // Average normals\r\n            const ImVec2& n0 = temp_normals[i0];\r\n            const ImVec2& n1 = temp_normals[i1];\r\n            ImVec2 dm = (n0 + n1) * 0.5f;\r\n            float dmr2 = dm.x*dm.x + dm.y*dm.y;\r\n            if (dmr2 > 0.000001f)\r\n            {\r\n                float scale = 1.0f / dmr2;\r\n                if (scale > 100.0f) scale = 100.0f;\r\n                dm *= scale;\r\n            }\r\n            dm *= AA_SIZE * 0.5f;\r\n\r\n            // Add vertices\r\n            _VtxWritePtr[0].pos = (points[i1] - dm); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner\r\n            _VtxWritePtr[1].pos = (points[i1] + dm); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer\r\n            _VtxWritePtr += 2;\r\n\r\n            // Add indexes for fringes\r\n            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx+(i1<<1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx+(i0<<1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx+(i0<<1));\r\n            _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx+(i0<<1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx+(i1<<1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx+(i1<<1));\r\n            _IdxWritePtr += 6;\r\n        }\r\n        _VtxCurrentIdx += (ImDrawIdx)vtx_count;\r\n    }\r\n    else\r\n    {\r\n        // Non Anti-aliased Fill\r\n        const int idx_count = (points_count-2)*3;\r\n        const int vtx_count = points_count;\r\n        PrimReserve(idx_count, vtx_count);\r\n        for (int i = 0; i < vtx_count; i++)\r\n        {\r\n            _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;\r\n            _VtxWritePtr++;\r\n        }\r\n        for (int i = 2; i < points_count; i++)\r\n        {\r\n            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx+i-1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx+i);\r\n            _IdxWritePtr += 3;\r\n        }\r\n        _VtxCurrentIdx += (ImDrawIdx)vtx_count;\r\n    }\r\n}\r\n\r\nvoid ImDrawList::PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12)\r\n{\r\n    if (radius == 0.0f || a_min_of_12 > a_max_of_12)\r\n    {\r\n        _Path.push_back(centre);\r\n        return;\r\n    }\r\n    _Path.reserve(_Path.Size + (a_max_of_12 - a_min_of_12 + 1));\r\n    for (int a = a_min_of_12; a <= a_max_of_12; a++)\r\n    {\r\n        const ImVec2& c = _Data->CircleVtx12[a % IM_ARRAYSIZE(_Data->CircleVtx12)];\r\n        _Path.push_back(ImVec2(centre.x + c.x * radius, centre.y + c.y * radius));\r\n    }\r\n}\r\n\r\nvoid ImDrawList::PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments)\r\n{\r\n    if (radius == 0.0f)\r\n    {\r\n        _Path.push_back(centre);\r\n        return;\r\n    }\r\n    _Path.reserve(_Path.Size + (num_segments + 1));\r\n    for (int i = 0; i <= num_segments; i++)\r\n    {\r\n        const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);\r\n        _Path.push_back(ImVec2(centre.x + cosf(a) * radius, centre.y + sinf(a) * radius));\r\n    }\r\n}\r\n\r\nstatic void PathBezierToCasteljau(ImVector<ImVec2>* path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level)\r\n{\r\n    float dx = x4 - x1;\r\n    float dy = y4 - y1;\r\n    float d2 = ((x2 - x4) * dy - (y2 - y4) * dx);\r\n    float d3 = ((x3 - x4) * dy - (y3 - y4) * dx);\r\n    d2 = (d2 >= 0) ? d2 : -d2;\r\n    d3 = (d3 >= 0) ? d3 : -d3;\r\n    if ((d2+d3) * (d2+d3) < tess_tol * (dx*dx + dy*dy))\r\n    {\r\n        path->push_back(ImVec2(x4, y4));\r\n    }\r\n    else if (level < 10)\r\n    {\r\n        float x12 = (x1+x2)*0.5f,       y12 = (y1+y2)*0.5f;\r\n        float x23 = (x2+x3)*0.5f,       y23 = (y2+y3)*0.5f;\r\n        float x34 = (x3+x4)*0.5f,       y34 = (y3+y4)*0.5f;\r\n        float x123 = (x12+x23)*0.5f,    y123 = (y12+y23)*0.5f;\r\n        float x234 = (x23+x34)*0.5f,    y234 = (y23+y34)*0.5f;\r\n        float x1234 = (x123+x234)*0.5f, y1234 = (y123+y234)*0.5f;\r\n\r\n        PathBezierToCasteljau(path, x1,y1,        x12,y12,    x123,y123,  x1234,y1234, tess_tol, level+1);\r\n        PathBezierToCasteljau(path, x1234,y1234,  x234,y234,  x34,y34,    x4,y4,       tess_tol, level+1);\r\n    }\r\n}\r\n\r\nvoid ImDrawList::PathBezierCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments)\r\n{\r\n    ImVec2 p1 = _Path.back();\r\n    if (num_segments == 0)\r\n    {\r\n        // Auto-tessellated\r\n        PathBezierToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, _Data->CurveTessellationTol, 0);\r\n    }\r\n    else\r\n    {\r\n        float t_step = 1.0f / (float)num_segments;\r\n        for (int i_step = 1; i_step <= num_segments; i_step++)\r\n        {\r\n            float t = t_step * i_step;\r\n            float u = 1.0f - t;\r\n            float w1 = u*u*u;\r\n            float w2 = 3*u*u*t;\r\n            float w3 = 3*u*t*t;\r\n            float w4 = t*t*t;\r\n            _Path.push_back(ImVec2(w1*p1.x + w2*p2.x + w3*p3.x + w4*p4.x, w1*p1.y + w2*p2.y + w3*p3.y + w4*p4.y));\r\n        }\r\n    }\r\n}\r\n\r\nvoid ImDrawList::PathRect(const ImVec2& a, const ImVec2& b, float rounding, int rounding_corners)\r\n{\r\n    rounding = ImMin(rounding, fabsf(b.x - a.x) * ( ((rounding_corners & ImDrawCornerFlags_Top)  == ImDrawCornerFlags_Top)  || ((rounding_corners & ImDrawCornerFlags_Bot)   == ImDrawCornerFlags_Bot)   ? 0.5f : 1.0f ) - 1.0f);\r\n    rounding = ImMin(rounding, fabsf(b.y - a.y) * ( ((rounding_corners & ImDrawCornerFlags_Left) == ImDrawCornerFlags_Left) || ((rounding_corners & ImDrawCornerFlags_Right) == ImDrawCornerFlags_Right) ? 0.5f : 1.0f ) - 1.0f);\r\n\r\n    if (rounding <= 0.0f || rounding_corners == 0)\r\n    {\r\n        PathLineTo(a);\r\n        PathLineTo(ImVec2(b.x, a.y));\r\n        PathLineTo(b);\r\n        PathLineTo(ImVec2(a.x, b.y));\r\n    }\r\n    else\r\n    {\r\n        const float rounding_tl = (rounding_corners & ImDrawCornerFlags_TopLeft) ? rounding : 0.0f;\r\n        const float rounding_tr = (rounding_corners & ImDrawCornerFlags_TopRight) ? rounding : 0.0f;\r\n        const float rounding_br = (rounding_corners & ImDrawCornerFlags_BotRight) ? rounding : 0.0f;\r\n        const float rounding_bl = (rounding_corners & ImDrawCornerFlags_BotLeft) ? rounding : 0.0f;\r\n        PathArcToFast(ImVec2(a.x + rounding_tl, a.y + rounding_tl), rounding_tl, 6, 9);\r\n        PathArcToFast(ImVec2(b.x - rounding_tr, a.y + rounding_tr), rounding_tr, 9, 12);\r\n        PathArcToFast(ImVec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0, 3);\r\n        PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);\r\n    }\r\n}\r\n\r\nvoid ImDrawList::AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n    PathLineTo(a + ImVec2(0.5f,0.5f));\r\n    PathLineTo(b + ImVec2(0.5f,0.5f));\r\n    PathStroke(col, false, thickness);\r\n}\r\n\r\n// a: upper-left, b: lower-right. we don't render 1 px sized rectangles properly.\r\nvoid ImDrawList::AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners_flags, float thickness)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n    PathRect(a + ImVec2(0.5f,0.5f), b - ImVec2(0.5f,0.5f), rounding, rounding_corners_flags);\r\n    PathStroke(col, true, thickness);\r\n}\r\n\r\nvoid ImDrawList::AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners_flags)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n    if (rounding > 0.0f)\r\n    {\r\n        PathRect(a, b, rounding, rounding_corners_flags);\r\n        PathFillConvex(col);\r\n    }\r\n    else\r\n    {\r\n        PrimReserve(6, 4);\r\n        PrimRect(a, b, col);\r\n    }\r\n}\r\n\r\nvoid ImDrawList::AddRectFilledMultiColor(const ImVec2& a, const ImVec2& c, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)\r\n{\r\n    if (((col_upr_left | col_upr_right | col_bot_right | col_bot_left) & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    const ImVec2 uv = _Data->TexUvWhitePixel;\r\n    PrimReserve(6, 4);\r\n    PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+1)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+2));\r\n    PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+2)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+3));\r\n    PrimWriteVtx(a, uv, col_upr_left);\r\n    PrimWriteVtx(ImVec2(c.x, a.y), uv, col_upr_right);\r\n    PrimWriteVtx(c, uv, col_bot_right);\r\n    PrimWriteVtx(ImVec2(a.x, c.y), uv, col_bot_left);\r\n}\r\n\r\nvoid ImDrawList::AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    PathLineTo(a);\r\n    PathLineTo(b);\r\n    PathLineTo(c);\r\n    PathLineTo(d);\r\n    PathStroke(col, true, thickness);\r\n}\r\n\r\nvoid ImDrawList::AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    PathLineTo(a);\r\n    PathLineTo(b);\r\n    PathLineTo(c);\r\n    PathLineTo(d);\r\n    PathFillConvex(col);\r\n}\r\n\r\nvoid ImDrawList::AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    PathLineTo(a);\r\n    PathLineTo(b);\r\n    PathLineTo(c);\r\n    PathStroke(col, true, thickness);\r\n}\r\n\r\nvoid ImDrawList::AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    PathLineTo(a);\r\n    PathLineTo(b);\r\n    PathLineTo(c);\r\n    PathFillConvex(col);\r\n}\r\n\r\nvoid ImDrawList::AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments, float thickness)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    const float a_max = IM_PI*2.0f * ((float)num_segments - 1.0f) / (float)num_segments;\r\n    PathArcTo(centre, radius-0.5f, 0.0f, a_max, num_segments);\r\n    PathStroke(col, true, thickness);\r\n}\r\n\r\nvoid ImDrawList::AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    const float a_max = IM_PI*2.0f * ((float)num_segments - 1.0f) / (float)num_segments;\r\n    PathArcTo(centre, radius, 0.0f, a_max, num_segments);\r\n    PathFillConvex(col);\r\n}\r\n\r\nvoid ImDrawList::AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    PathLineTo(pos0);\r\n    PathBezierCurveTo(cp0, cp1, pos1, num_segments);\r\n    PathStroke(col, false, thickness);\r\n}\r\n\r\nvoid ImDrawList::AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    if (text_end == NULL)\r\n        text_end = text_begin + strlen(text_begin);\r\n    if (text_begin == text_end)\r\n        return;\r\n\r\n    // Pull default font/size from the shared ImDrawListSharedData instance\r\n    if (font == NULL)\r\n        font = _Data->Font;\r\n    if (font_size == 0.0f)\r\n        font_size = _Data->FontSize;\r\n\r\n    IM_ASSERT(font->ContainerAtlas->TexID == _TextureIdStack.back());  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.\r\n\r\n    ImVec4 clip_rect = _ClipRectStack.back();\r\n    if (cpu_fine_clip_rect)\r\n    {\r\n        clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);\r\n        clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);\r\n        clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);\r\n        clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);\r\n    }\r\n    font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);\r\n}\r\n\r\nvoid ImDrawList::AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)\r\n{\r\n    AddText(NULL, 0.0f, pos, col, text_begin, text_end);\r\n}\r\n\r\nvoid ImDrawList::AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();\r\n    if (push_texture_id)\r\n        PushTextureID(user_texture_id);\r\n\r\n    PrimReserve(6, 4);\r\n    PrimRectUV(a, b, uv_a, uv_b, col);\r\n\r\n    if (push_texture_id)\r\n        PopTextureID();\r\n}\r\n\r\nvoid ImDrawList::AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();\r\n    if (push_texture_id)\r\n        PushTextureID(user_texture_id);\r\n\r\n    PrimReserve(6, 4);\r\n    PrimQuadUV(a, b, c, d, uv_a, uv_b, uv_c, uv_d, col);\r\n\r\n    if (push_texture_id)\r\n        PopTextureID();\r\n}\r\n\r\nvoid ImDrawList::AddImageRounded(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col, float rounding, int rounding_corners)\r\n{\r\n    if ((col & IM_COL32_A_MASK) == 0)\r\n        return;\r\n\r\n    if (rounding <= 0.0f || (rounding_corners & ImDrawCornerFlags_All) == 0)\r\n    {\r\n        AddImage(user_texture_id, a, b, uv_a, uv_b, col);\r\n        return;\r\n    }\r\n\r\n    const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();\r\n    if (push_texture_id)\r\n        PushTextureID(user_texture_id);\r\n\r\n    int vert_start_idx = VtxBuffer.Size;\r\n    PathRect(a, b, rounding, rounding_corners);\r\n    PathFillConvex(col);\r\n    int vert_end_idx = VtxBuffer.Size;\r\n    ImGui::ShadeVertsLinearUV(VtxBuffer.Data + vert_start_idx, VtxBuffer.Data + vert_end_idx, a, b, uv_a, uv_b, true);\r\n\r\n    if (push_texture_id)\r\n        PopTextureID();\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// ImDrawData\r\n//-----------------------------------------------------------------------------\r\n\r\n// For backward compatibility: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!\r\nvoid ImDrawData::DeIndexAllBuffers()\r\n{\r\n    ImVector<ImDrawVert> new_vtx_buffer;\r\n    TotalVtxCount = TotalIdxCount = 0;\r\n    for (int i = 0; i < CmdListsCount; i++)\r\n    {\r\n        ImDrawList* cmd_list = CmdLists[i];\r\n        if (cmd_list->IdxBuffer.empty())\r\n            continue;\r\n        new_vtx_buffer.resize(cmd_list->IdxBuffer.Size);\r\n        for (int j = 0; j < cmd_list->IdxBuffer.Size; j++)\r\n            new_vtx_buffer[j] = cmd_list->VtxBuffer[cmd_list->IdxBuffer[j]];\r\n        cmd_list->VtxBuffer.swap(new_vtx_buffer);\r\n        cmd_list->IdxBuffer.resize(0);\r\n        TotalVtxCount += cmd_list->VtxBuffer.Size;\r\n    }\r\n}\r\n\r\n// Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.\r\nvoid ImDrawData::ScaleClipRects(const ImVec2& scale)\r\n{\r\n    for (int i = 0; i < CmdListsCount; i++)\r\n    {\r\n        ImDrawList* cmd_list = CmdLists[i];\r\n        for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)\r\n        {\r\n            ImDrawCmd* cmd = &cmd_list->CmdBuffer[cmd_i];\r\n            cmd->ClipRect = ImVec4(cmd->ClipRect.x * scale.x, cmd->ClipRect.y * scale.y, cmd->ClipRect.z * scale.x, cmd->ClipRect.w * scale.y);\r\n        }\r\n    }\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// Shade functions\r\n//-----------------------------------------------------------------------------\r\n\r\n// Generic linear color gradient, write to RGB fields, leave A untouched.\r\nvoid ImGui::ShadeVertsLinearColorGradientKeepAlpha(ImDrawVert* vert_start, ImDrawVert* vert_end, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1)\r\n{\r\n    ImVec2 gradient_extent = gradient_p1 - gradient_p0;\r\n    float gradient_inv_length2 = 1.0f / ImLengthSqr(gradient_extent);\r\n    for (ImDrawVert* vert = vert_start; vert < vert_end; vert++)\r\n    {\r\n        float d = ImDot(vert->pos - gradient_p0, gradient_extent);\r\n        float t = ImClamp(d * gradient_inv_length2, 0.0f, 1.0f);\r\n        int r = ImLerp((int)(col0 >> IM_COL32_R_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_R_SHIFT) & 0xFF, t);\r\n        int g = ImLerp((int)(col0 >> IM_COL32_G_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_G_SHIFT) & 0xFF, t);\r\n        int b = ImLerp((int)(col0 >> IM_COL32_B_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_B_SHIFT) & 0xFF, t);\r\n        vert->col = (r << IM_COL32_R_SHIFT) | (g << IM_COL32_G_SHIFT) | (b << IM_COL32_B_SHIFT) | (vert->col & IM_COL32_A_MASK);\r\n    }\r\n}\r\n\r\n// Scan and shade backward from the end of given vertices. Assume vertices are text only (= vert_start..vert_end going left to right) so we can break as soon as we are out the gradient bounds.\r\nvoid ImGui::ShadeVertsLinearAlphaGradientForLeftToRightText(ImDrawVert* vert_start, ImDrawVert* vert_end, float gradient_p0_x, float gradient_p1_x)\r\n{\r\n    float gradient_extent_x = gradient_p1_x - gradient_p0_x;\r\n    float gradient_inv_length2 = 1.0f / (gradient_extent_x * gradient_extent_x);\r\n    int full_alpha_count = 0;\r\n    for (ImDrawVert* vert = vert_end - 1; vert >= vert_start; vert--)\r\n    {\r\n        float d = (vert->pos.x - gradient_p0_x) * (gradient_extent_x);\r\n        float alpha_mul = 1.0f - ImClamp(d * gradient_inv_length2, 0.0f, 1.0f);\r\n        if (alpha_mul >= 1.0f && ++full_alpha_count > 2)\r\n            return; // Early out\r\n        int a = (int)(((vert->col >> IM_COL32_A_SHIFT) & 0xFF) * alpha_mul);\r\n        vert->col = (vert->col & ~IM_COL32_A_MASK) | (a << IM_COL32_A_SHIFT);\r\n    }\r\n}\r\n\r\n// Distribute UV over (a, b) rectangle\r\nvoid ImGui::ShadeVertsLinearUV(ImDrawVert* vert_start, ImDrawVert* vert_end, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp)\r\n{\r\n    const ImVec2 size = b - a;\r\n    const ImVec2 uv_size = uv_b - uv_a;\r\n    const ImVec2 scale = ImVec2(\r\n        size.x != 0.0f ? (uv_size.x / size.x) : 0.0f,\r\n        size.y != 0.0f ? (uv_size.y / size.y) : 0.0f);\r\n\r\n    if (clamp)\r\n    {\r\n        const ImVec2 min = ImMin(uv_a, uv_b);\r\n        const ImVec2 max = ImMax(uv_a, uv_b);\r\n\r\n        for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)\r\n            vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);\r\n    }\r\n    else\r\n    {\r\n        for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)\r\n            vertex->uv = uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale);\r\n    }\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// ImFontConfig\r\n//-----------------------------------------------------------------------------\r\n\r\nImFontConfig::ImFontConfig()\r\n{\r\n    FontData = NULL;\r\n    FontDataSize = 0;\r\n    FontDataOwnedByAtlas = true;\r\n    FontNo = 0;\r\n    SizePixels = 0.0f;\r\n    OversampleH = 3;\r\n    OversampleV = 1;\r\n    PixelSnapH = false;\r\n    GlyphExtraSpacing = ImVec2(0.0f, 0.0f);\r\n    GlyphOffset = ImVec2(0.0f, 0.0f);\r\n    GlyphRanges = NULL;\r\n    MergeMode = false;\r\n    RasterizerFlags = 0x00;\r\n    RasterizerMultiply = 1.0f;\r\n    memset(Name, 0, sizeof(Name));\r\n    DstFont = NULL;\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// ImFontAtlas\r\n//-----------------------------------------------------------------------------\r\n\r\n// A work of art lies ahead! (. = white layer, X = black layer, others are blank)\r\n// The white texels on the top left are the ones we'll use everywhere in ImGui to render filled shapes.\r\nconst int FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF = 90;\r\nconst int FONT_ATLAS_DEFAULT_TEX_DATA_H      = 27;\r\nconst unsigned int FONT_ATLAS_DEFAULT_TEX_DATA_ID = 0x80000000;\r\nstatic const char FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF * FONT_ATLAS_DEFAULT_TEX_DATA_H + 1] =\r\n{\r\n    \"..-         -XXXXXXX-    X    -           X           -XXXXXXX          -          XXXXXXX\"\r\n    \"..-         -X.....X-   X.X   -          X.X          -X.....X          -          X.....X\"\r\n    \"---         -XXX.XXX-  X...X  -         X...X         -X....X           -           X....X\"\r\n    \"X           -  X.X  - X.....X -        X.....X        -X...X            -            X...X\"\r\n    \"XX          -  X.X  -X.......X-       X.......X       -X..X.X           -           X.X..X\"\r\n    \"X.X         -  X.X  -XXXX.XXXX-       XXXX.XXXX       -X.X X.X          -          X.X X.X\"\r\n    \"X..X        -  X.X  -   X.X   -          X.X          -XX   X.X         -         X.X   XX\"\r\n    \"X...X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.X        -        X.X      \"\r\n    \"X....X      -  X.X  -   X.X   -   X.X    X.X    X.X   -       X.X       -       X.X       \"\r\n    \"X.....X     -  X.X  -   X.X   -  X..X    X.X    X..X  -        X.X      -      X.X        \"\r\n    \"X......X    -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -         X.X   XX-XX   X.X         \"\r\n    \"X.......X   -  X.X  -   X.X   -X.....................X-          X.X X.X-X.X X.X          \"\r\n    \"X........X  -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X-X..X.X           \"\r\n    \"X.........X -XXX.XXX-   X.X   -  X..X    X.X    X..X  -            X...X-X...X            \"\r\n    \"X..........X-X.....X-   X.X   -   X.X    X.X    X.X   -           X....X-X....X           \"\r\n    \"X......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX    -          X.....X-X.....X          \"\r\n    \"X...X..X    ---------   X.X   -          X.X          -          XXXXXXX-XXXXXXX          \"\r\n    \"X..X X..X   -       -XXXX.XXXX-       XXXX.XXXX       ------------------------------------\"\r\n    \"X.X  X..X   -       -X.......X-       X.......X       -    XX           XX    -           \"\r\n    \"XX    X..X  -       - X.....X -        X.....X        -   X.X           X.X   -           \"\r\n    \"      X..X          -  X...X  -         X...X         -  X..X           X..X  -           \"\r\n    \"       XX           -   X.X   -          X.X          - X...XXXXXXXXXXXXX...X -           \"\r\n    \"------------        -    X    -           X           -X.....................X-           \"\r\n    \"                    ----------------------------------- X...XXXXXXXXXXXXX...X -           \"\r\n    \"                                                      -  X..X           X..X  -           \"\r\n    \"                                                      -   X.X           X.X   -           \"\r\n    \"                                                      -    XX           XX    -           \"\r\n};\r\n\r\nstatic const ImVec2 FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[ImGuiMouseCursor_Count_][3] =\r\n{\r\n    // Pos ........ Size ......... Offset ......\r\n    { ImVec2(0,3),  ImVec2(12,19), ImVec2( 0, 0) }, // ImGuiMouseCursor_Arrow\r\n    { ImVec2(13,0), ImVec2(7,16),  ImVec2( 4, 8) }, // ImGuiMouseCursor_TextInput\r\n    { ImVec2(31,0), ImVec2(23,23), ImVec2(11,11) }, // ImGuiMouseCursor_Move\r\n    { ImVec2(21,0), ImVec2( 9,23), ImVec2( 5,11) }, // ImGuiMouseCursor_ResizeNS\r\n    { ImVec2(55,18),ImVec2(23, 9), ImVec2(11, 5) }, // ImGuiMouseCursor_ResizeEW\r\n    { ImVec2(73,0), ImVec2(17,17), ImVec2( 9, 9) }, // ImGuiMouseCursor_ResizeNESW\r\n    { ImVec2(55,0), ImVec2(17,17), ImVec2( 9, 9) }, // ImGuiMouseCursor_ResizeNWSE\r\n};\r\n\r\n\r\nImFontAtlas::ImFontAtlas()\r\n{\r\n    TexID = NULL;\r\n    TexDesiredWidth = 0;\r\n    TexGlyphPadding = 1;\r\n    TexPixelsAlpha8 = NULL;\r\n    TexPixelsRGBA32 = NULL;\r\n    TexWidth = TexHeight = 0;\r\n    TexUvWhitePixel = ImVec2(0, 0);\r\n    for (int n = 0; n < IM_ARRAYSIZE(CustomRectIds); n++)\r\n        CustomRectIds[n] = -1;\r\n}\r\n\r\nImFontAtlas::~ImFontAtlas()\r\n{\r\n    Clear();\r\n}\r\n\r\nvoid    ImFontAtlas::ClearInputData()\r\n{\r\n    for (int i = 0; i < ConfigData.Size; i++)\r\n        if (ConfigData[i].FontData && ConfigData[i].FontDataOwnedByAtlas)\r\n        {\r\n            ImGui::MemFree(ConfigData[i].FontData);\r\n            ConfigData[i].FontData = NULL;\r\n        }\r\n\r\n    // When clearing this we lose access to  the font name and other information used to build the font.\r\n    for (int i = 0; i < Fonts.Size; i++)\r\n        if (Fonts[i]->ConfigData >= ConfigData.Data && Fonts[i]->ConfigData < ConfigData.Data + ConfigData.Size)\r\n        {\r\n            Fonts[i]->ConfigData = NULL;\r\n            Fonts[i]->ConfigDataCount = 0;\r\n        }\r\n    ConfigData.clear();\r\n    CustomRects.clear();\r\n    for (int n = 0; n < IM_ARRAYSIZE(CustomRectIds); n++)\r\n        CustomRectIds[n] = -1;\r\n}\r\n\r\nvoid    ImFontAtlas::ClearTexData()\r\n{\r\n    if (TexPixelsAlpha8)\r\n        ImGui::MemFree(TexPixelsAlpha8);\r\n    if (TexPixelsRGBA32)\r\n        ImGui::MemFree(TexPixelsRGBA32);\r\n    TexPixelsAlpha8 = NULL;\r\n    TexPixelsRGBA32 = NULL;\r\n}\r\n\r\nvoid    ImFontAtlas::ClearFonts()\r\n{\r\n    for (int i = 0; i < Fonts.Size; i++)\r\n        IM_DELETE(Fonts[i]);\r\n    Fonts.clear();\r\n}\r\n\r\nvoid    ImFontAtlas::Clear()\r\n{\r\n    ClearInputData();\r\n    ClearTexData();\r\n    ClearFonts();\r\n}\r\n\r\nvoid    ImFontAtlas::GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)\r\n{\r\n    // Build atlas on demand\r\n    if (TexPixelsAlpha8 == NULL)\r\n    {\r\n        if (ConfigData.empty())\r\n            AddFontDefault();\r\n        Build();\r\n    }\r\n\r\n    *out_pixels = TexPixelsAlpha8;\r\n    if (out_width) *out_width = TexWidth;\r\n    if (out_height) *out_height = TexHeight;\r\n    if (out_bytes_per_pixel) *out_bytes_per_pixel = 1;\r\n}\r\n\r\nvoid    ImFontAtlas::GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)\r\n{\r\n    // Convert to RGBA32 format on demand\r\n    // Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp\r\n    if (!TexPixelsRGBA32)\r\n    {\r\n        unsigned char* pixels;\r\n        GetTexDataAsAlpha8(&pixels, NULL, NULL);\r\n        TexPixelsRGBA32 = (unsigned int*)ImGui::MemAlloc((size_t)(TexWidth * TexHeight * 4));\r\n        const unsigned char* src = pixels;\r\n        unsigned int* dst = TexPixelsRGBA32;\r\n        for (int n = TexWidth * TexHeight; n > 0; n--)\r\n            *dst++ = IM_COL32(255, 255, 255, (unsigned int)(*src++));\r\n    }\r\n\r\n    *out_pixels = (unsigned char*)TexPixelsRGBA32;\r\n    if (out_width) *out_width = TexWidth;\r\n    if (out_height) *out_height = TexHeight;\r\n    if (out_bytes_per_pixel) *out_bytes_per_pixel = 4;\r\n}\r\n\r\nImFont* ImFontAtlas::AddFont(const ImFontConfig* font_cfg)\r\n{\r\n    IM_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);\r\n    IM_ASSERT(font_cfg->SizePixels > 0.0f);\r\n\r\n    // Create new font\r\n    if (!font_cfg->MergeMode)\r\n        Fonts.push_back(IM_NEW(ImFont));\r\n    else\r\n        IM_ASSERT(!Fonts.empty()); // When using MergeMode make sure that a font has already been added before. You can use ImGui::GetIO().Fonts->AddFontDefault() to add the default imgui font.\r\n\r\n    ConfigData.push_back(*font_cfg);\r\n    ImFontConfig& new_font_cfg = ConfigData.back();\r\n    if (!new_font_cfg.DstFont)\r\n        new_font_cfg.DstFont = Fonts.back();\r\n    if (!new_font_cfg.FontDataOwnedByAtlas)\r\n    {\r\n        new_font_cfg.FontData = ImGui::MemAlloc(new_font_cfg.FontDataSize);\r\n        new_font_cfg.FontDataOwnedByAtlas = true;\r\n        memcpy(new_font_cfg.FontData, font_cfg->FontData, (size_t)new_font_cfg.FontDataSize);\r\n    }\r\n\r\n    // Invalidate texture\r\n    ClearTexData();\r\n    return new_font_cfg.DstFont;\r\n}\r\n\r\n// Default font TTF is compressed with stb_compress then base85 encoded (see extra_fonts/binary_to_compressed_c.cpp for encoder)\r\nstatic unsigned int stb_decompress_length(unsigned char *input);\r\nstatic unsigned int stb_decompress(unsigned char *output, unsigned char *i, unsigned int length);\r\nstatic const char*  GetDefaultCompressedFontDataTTFBase85();\r\nstatic unsigned int Decode85Byte(char c)                                    { return c >= '\\\\' ? c-36 : c-35; }\r\nstatic void         Decode85(const unsigned char* src, unsigned char* dst)\r\n{\r\n    while (*src)\r\n    {\r\n        unsigned int tmp = Decode85Byte(src[0]) + 85*(Decode85Byte(src[1]) + 85*(Decode85Byte(src[2]) + 85*(Decode85Byte(src[3]) + 85*Decode85Byte(src[4]))));\r\n        dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.\r\n        src += 5;\r\n        dst += 4;\r\n    }\r\n}\r\n\r\n// Load embedded ProggyClean.ttf at size 13, disable oversampling\r\nImFont* ImFontAtlas::AddFontDefault(const ImFontConfig* font_cfg_template)\r\n{\r\n    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();\r\n    if (!font_cfg_template)\r\n    {\r\n        font_cfg.OversampleH = font_cfg.OversampleV = 1;\r\n        font_cfg.PixelSnapH = true;\r\n    }\r\n    if (font_cfg.Name[0] == '\\0') strcpy(font_cfg.Name, \"ProggyClean.ttf, 13px\");\r\n    if (font_cfg.SizePixels <= 0.0f) font_cfg.SizePixels = 13.0f;\r\n\r\n    const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();\r\n    ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, GetGlyphRangesDefault());\r\n    return font;\r\n}\r\n\r\nImFont* ImFontAtlas::AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)\r\n{\r\n    int data_size = 0;\r\n    void* data = ImFileLoadToMemory(filename, \"rb\", &data_size, 0);\r\n    if (!data)\r\n    {\r\n        IM_ASSERT(0); // Could not load file.\r\n        return NULL;\r\n    }\r\n    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();\r\n    if (font_cfg.Name[0] == '\\0')\r\n    {\r\n        // Store a short copy of filename into into the font name for convenience\r\n        const char* p;\r\n        for (p = filename + strlen(filename); p > filename && p[-1] != '/' && p[-1] != '\\\\'; p--) {}\r\n        snprintf(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), \"%s, %.0fpx\", p, size_pixels);\r\n    }\r\n    return AddFontFromMemoryTTF(data, data_size, size_pixels, &font_cfg, glyph_ranges);\r\n}\r\n\r\n// NB: Transfer ownership of 'ttf_data' to ImFontAtlas, unless font_cfg_template->FontDataOwnedByAtlas == false. Owned TTF buffer will be deleted after Build().\r\nImFont* ImFontAtlas::AddFontFromMemoryTTF(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)\r\n{\r\n    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();\r\n    IM_ASSERT(font_cfg.FontData == NULL);\r\n    font_cfg.FontData = ttf_data;\r\n    font_cfg.FontDataSize = ttf_size;\r\n    font_cfg.SizePixels = size_pixels;\r\n    if (glyph_ranges)\r\n        font_cfg.GlyphRanges = glyph_ranges;\r\n    return AddFont(&font_cfg);\r\n}\r\n\r\nImFont* ImFontAtlas::AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)\r\n{\r\n    const unsigned int buf_decompressed_size = stb_decompress_length((unsigned char*)compressed_ttf_data);\r\n    unsigned char* buf_decompressed_data = (unsigned char *)ImGui::MemAlloc(buf_decompressed_size);\r\n    stb_decompress(buf_decompressed_data, (unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);\r\n\r\n    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();\r\n    IM_ASSERT(font_cfg.FontData == NULL);\r\n    font_cfg.FontDataOwnedByAtlas = true;\r\n    return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges);\r\n}\r\n\r\nImFont* ImFontAtlas::AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)\r\n{\r\n    int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;\r\n    void* compressed_ttf = ImGui::MemAlloc((size_t)compressed_ttf_size);\r\n    Decode85((const unsigned char*)compressed_ttf_data_base85, (unsigned char*)compressed_ttf);\r\n    ImFont* font = AddFontFromMemoryCompressedTTF(compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);\r\n    ImGui::MemFree(compressed_ttf);\r\n    return font;\r\n}\r\n\r\nint ImFontAtlas::AddCustomRectRegular(unsigned int id, int width, int height)\r\n{\r\n    IM_ASSERT(id >= 0x10000);\r\n    IM_ASSERT(width > 0 && width <= 0xFFFF);\r\n    IM_ASSERT(height > 0 && height <= 0xFFFF);\r\n    CustomRect r;\r\n    r.ID = id;\r\n    r.Width = (unsigned short)width;\r\n    r.Height = (unsigned short)height;\r\n    CustomRects.push_back(r);\r\n    return CustomRects.Size - 1; // Return index\r\n}\r\n\r\nint ImFontAtlas::AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset)\r\n{\r\n    IM_ASSERT(font != NULL);\r\n    IM_ASSERT(width > 0 && width <= 0xFFFF);\r\n    IM_ASSERT(height > 0 && height <= 0xFFFF);\r\n    CustomRect r;\r\n    r.ID = id;\r\n    r.Width = (unsigned short)width;\r\n    r.Height = (unsigned short)height;\r\n    r.GlyphAdvanceX = advance_x;\r\n    r.GlyphOffset = offset;\r\n    r.Font = font;\r\n    CustomRects.push_back(r);\r\n    return CustomRects.Size - 1; // Return index\r\n}\r\n\r\nvoid ImFontAtlas::CalcCustomRectUV(const CustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max)\r\n{\r\n    IM_ASSERT(TexWidth > 0 && TexHeight > 0);   // Font atlas needs to be built before we can calculate UV coordinates\r\n    IM_ASSERT(rect->IsPacked());                // Make sure the rectangle has been packed\r\n    *out_uv_min = ImVec2((float)rect->X / TexWidth, (float)rect->Y / TexHeight);\r\n    *out_uv_max = ImVec2((float)(rect->X + rect->Width) / TexWidth, (float)(rect->Y + rect->Height) / TexHeight);\r\n}\r\n\r\nbool    ImFontAtlas::Build()\r\n{\r\n    return ImFontAtlasBuildWithStbTruetype(this);\r\n}\r\n\r\nvoid    ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_brighten_factor)\r\n{\r\n    for (unsigned int i = 0; i < 256; i++)\r\n    {\r\n        unsigned int value = (unsigned int)(i * in_brighten_factor);\r\n        out_table[i] = value > 255 ? 255 : (value & 0xFF);\r\n    }\r\n}\r\n\r\nvoid    ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride)\r\n{\r\n    unsigned char* data = pixels + x + y * stride;\r\n    for (int j = h; j > 0; j--, data += stride)\r\n        for (int i = 0; i < w; i++)\r\n            data[i] = table[data[i]];\r\n}\r\n\r\nbool    ImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas)\r\n{\r\n    IM_ASSERT(atlas->ConfigData.Size > 0);\r\n\r\n    ImFontAtlasBuildRegisterDefaultCustomRects(atlas);\r\n\r\n    atlas->TexID = NULL;\r\n    atlas->TexWidth = atlas->TexHeight = 0;\r\n    atlas->TexUvWhitePixel = ImVec2(0, 0);\r\n    atlas->ClearTexData();\r\n\r\n    // Count glyphs/ranges\r\n    int total_glyphs_count = 0;\r\n    int total_ranges_count = 0;\r\n    for (int input_i = 0; input_i < atlas->ConfigData.Size; input_i++)\r\n    {\r\n        ImFontConfig& cfg = atlas->ConfigData[input_i];\r\n        if (!cfg.GlyphRanges)\r\n            cfg.GlyphRanges = atlas->GetGlyphRangesDefault();\r\n        for (const ImWchar* in_range = cfg.GlyphRanges; in_range[0] && in_range[1]; in_range += 2, total_ranges_count++)\r\n            total_glyphs_count += (in_range[1] - in_range[0]) + 1;\r\n    }\r\n\r\n    // We need a width for the skyline algorithm. Using a dumb heuristic here to decide of width. User can override TexDesiredWidth and TexGlyphPadding if they wish.\r\n    // Width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.\r\n    atlas->TexWidth = (atlas->TexDesiredWidth > 0) ? atlas->TexDesiredWidth : (total_glyphs_count > 4000) ? 4096 : (total_glyphs_count > 2000) ? 2048 : (total_glyphs_count > 1000) ? 1024 : 512;\r\n    atlas->TexHeight = 0;\r\n\r\n    // Start packing\r\n    const int max_tex_height = 1024*32;\r\n    stbtt_pack_context spc = {};\r\n    stbtt_PackBegin(&spc, NULL, atlas->TexWidth, max_tex_height, 0, atlas->TexGlyphPadding, NULL);\r\n    stbtt_PackSetOversampling(&spc, 1, 1);\r\n\r\n    // Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).\r\n    ImFontAtlasBuildPackCustomRects(atlas, spc.pack_info);\r\n\r\n    // Initialize font information (so we can error without any cleanup)\r\n    struct ImFontTempBuildData\r\n    {\r\n        stbtt_fontinfo      FontInfo;\r\n        stbrp_rect*         Rects;\r\n        int                 RectsCount;\r\n        stbtt_pack_range*   Ranges;\r\n        int                 RangesCount;\r\n    };\r\n    ImFontTempBuildData* tmp_array = (ImFontTempBuildData*)ImGui::MemAlloc((size_t)atlas->ConfigData.Size * sizeof(ImFontTempBuildData));\r\n    for (int input_i = 0; input_i < atlas->ConfigData.Size; input_i++)\r\n    {\r\n        ImFontConfig& cfg = atlas->ConfigData[input_i];\r\n        ImFontTempBuildData& tmp = tmp_array[input_i];\r\n        IM_ASSERT(cfg.DstFont && (!cfg.DstFont->IsLoaded() || cfg.DstFont->ContainerAtlas == atlas));\r\n\r\n        const int font_offset = stbtt_GetFontOffsetForIndex((unsigned char*)cfg.FontData, cfg.FontNo);\r\n        IM_ASSERT(font_offset >= 0);\r\n        if (!stbtt_InitFont(&tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))\r\n        {\r\n            ImGui::MemFree(tmp_array);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Allocate packing character data and flag packed characters buffer as non-packed (x0=y0=x1=y1=0)\r\n    int buf_packedchars_n = 0, buf_rects_n = 0, buf_ranges_n = 0;\r\n    stbtt_packedchar* buf_packedchars = (stbtt_packedchar*)ImGui::MemAlloc(total_glyphs_count * sizeof(stbtt_packedchar));\r\n    stbrp_rect* buf_rects = (stbrp_rect*)ImGui::MemAlloc(total_glyphs_count * sizeof(stbrp_rect));\r\n    stbtt_pack_range* buf_ranges = (stbtt_pack_range*)ImGui::MemAlloc(total_ranges_count * sizeof(stbtt_pack_range));\r\n    memset(buf_packedchars, 0, total_glyphs_count * sizeof(stbtt_packedchar));\r\n    memset(buf_rects, 0, total_glyphs_count * sizeof(stbrp_rect));              // Unnecessary but let's clear this for the sake of sanity.\r\n    memset(buf_ranges, 0, total_ranges_count * sizeof(stbtt_pack_range));\r\n\r\n    // First font pass: pack all glyphs (no rendering at this point, we are working with rectangles in an infinitely tall texture at this point)\r\n    for (int input_i = 0; input_i < atlas->ConfigData.Size; input_i++)\r\n    {\r\n        ImFontConfig& cfg = atlas->ConfigData[input_i];\r\n        ImFontTempBuildData& tmp = tmp_array[input_i];\r\n\r\n        // Setup ranges\r\n        int font_glyphs_count = 0;\r\n        int font_ranges_count = 0;\r\n        for (const ImWchar* in_range = cfg.GlyphRanges; in_range[0] && in_range[1]; in_range += 2, font_ranges_count++)\r\n            font_glyphs_count += (in_range[1] - in_range[0]) + 1;\r\n        tmp.Ranges = buf_ranges + buf_ranges_n;\r\n        tmp.RangesCount = font_ranges_count;\r\n        buf_ranges_n += font_ranges_count;\r\n        for (int i = 0; i < font_ranges_count; i++)\r\n        {\r\n            const ImWchar* in_range = &cfg.GlyphRanges[i * 2];\r\n            stbtt_pack_range& range = tmp.Ranges[i];\r\n            range.font_size = cfg.SizePixels;\r\n            range.first_unicode_codepoint_in_range = in_range[0];\r\n            range.num_chars = (in_range[1] - in_range[0]) + 1;\r\n            range.chardata_for_range = buf_packedchars + buf_packedchars_n;\r\n            buf_packedchars_n += range.num_chars;\r\n        }\r\n\r\n        // Pack\r\n        tmp.Rects = buf_rects + buf_rects_n;\r\n        tmp.RectsCount = font_glyphs_count;\r\n        buf_rects_n += font_glyphs_count;\r\n        stbtt_PackSetOversampling(&spc, cfg.OversampleH, cfg.OversampleV);\r\n        int n = stbtt_PackFontRangesGatherRects(&spc, &tmp.FontInfo, tmp.Ranges, tmp.RangesCount, tmp.Rects);\r\n        IM_ASSERT(n == font_glyphs_count);\r\n        stbrp_pack_rects((stbrp_context*)spc.pack_info, tmp.Rects, n);\r\n\r\n        // Extend texture height\r\n        for (int i = 0; i < n; i++)\r\n            if (tmp.Rects[i].was_packed)\r\n                atlas->TexHeight = ImMax(atlas->TexHeight, tmp.Rects[i].y + tmp.Rects[i].h);\r\n    }\r\n    IM_ASSERT(buf_rects_n == total_glyphs_count);\r\n    IM_ASSERT(buf_packedchars_n == total_glyphs_count);\r\n    IM_ASSERT(buf_ranges_n == total_ranges_count);\r\n\r\n    // Create texture\r\n    atlas->TexHeight = ImUpperPowerOfTwo(atlas->TexHeight);\r\n    atlas->TexPixelsAlpha8 = (unsigned char*)ImGui::MemAlloc(atlas->TexWidth * atlas->TexHeight);\r\n    memset(atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight);\r\n    spc.pixels = atlas->TexPixelsAlpha8;\r\n    spc.height = atlas->TexHeight;\r\n\r\n    // Second pass: render font characters\r\n    for (int input_i = 0; input_i < atlas->ConfigData.Size; input_i++)\r\n    {\r\n        ImFontConfig& cfg = atlas->ConfigData[input_i];\r\n        ImFontTempBuildData& tmp = tmp_array[input_i];\r\n        stbtt_PackSetOversampling(&spc, cfg.OversampleH, cfg.OversampleV);\r\n        stbtt_PackFontRangesRenderIntoRects(&spc, &tmp.FontInfo, tmp.Ranges, tmp.RangesCount, tmp.Rects);\r\n        if (cfg.RasterizerMultiply != 1.0f)\r\n        {\r\n            unsigned char multiply_table[256];\r\n            ImFontAtlasBuildMultiplyCalcLookupTable(multiply_table, cfg.RasterizerMultiply);\r\n            for (const stbrp_rect* r = tmp.Rects; r != tmp.Rects + tmp.RectsCount; r++)\r\n                if (r->was_packed)\r\n                    ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, spc.pixels, r->x, r->y, r->w, r->h, spc.stride_in_bytes);\r\n        }\r\n        tmp.Rects = NULL;\r\n    }\r\n\r\n    // End packing\r\n    stbtt_PackEnd(&spc);\r\n    ImGui::MemFree(buf_rects);\r\n    buf_rects = NULL;\r\n\r\n    // Third pass: setup ImFont and glyphs for runtime\r\n    for (int input_i = 0; input_i < atlas->ConfigData.Size; input_i++)\r\n    {\r\n        ImFontConfig& cfg = atlas->ConfigData[input_i];\r\n        ImFontTempBuildData& tmp = tmp_array[input_i];\r\n        ImFont* dst_font = cfg.DstFont; // We can have multiple input fonts writing into a same destination font (when using MergeMode=true)\r\n\r\n        const float font_scale = stbtt_ScaleForPixelHeight(&tmp.FontInfo, cfg.SizePixels);\r\n        int unscaled_ascent, unscaled_descent, unscaled_line_gap;\r\n        stbtt_GetFontVMetrics(&tmp.FontInfo, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap);\r\n\r\n        const float ascent = unscaled_ascent * font_scale;\r\n        const float descent = unscaled_descent * font_scale;\r\n        ImFontAtlasBuildSetupFont(atlas, dst_font, &cfg, ascent, descent);\r\n        const float off_x = cfg.GlyphOffset.x;\r\n        const float off_y = cfg.GlyphOffset.y + (float)(int)(dst_font->Ascent + 0.5f);\r\n\r\n        for (int i = 0; i < tmp.RangesCount; i++)\r\n        {\r\n            stbtt_pack_range& range = tmp.Ranges[i];\r\n            for (int char_idx = 0; char_idx < range.num_chars; char_idx += 1)\r\n            {\r\n                const stbtt_packedchar& pc = range.chardata_for_range[char_idx];\r\n                if (!pc.x0 && !pc.x1 && !pc.y0 && !pc.y1)\r\n                    continue;\r\n\r\n                const int codepoint = range.first_unicode_codepoint_in_range + char_idx;\r\n                if (cfg.MergeMode && dst_font->FindGlyph((unsigned short)codepoint))\r\n                    continue;\r\n\r\n                stbtt_aligned_quad q;\r\n                float dummy_x = 0.0f, dummy_y = 0.0f;\r\n                stbtt_GetPackedQuad(range.chardata_for_range, atlas->TexWidth, atlas->TexHeight, char_idx, &dummy_x, &dummy_y, &q, 0);\r\n                dst_font->AddGlyph((ImWchar)codepoint, q.x0 + off_x, q.y0 + off_y, q.x1 + off_x, q.y1 + off_y, q.s0, q.t0, q.s1, q.t1, pc.xadvance);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Cleanup temporaries\r\n    ImGui::MemFree(buf_packedchars);\r\n    ImGui::MemFree(buf_ranges);\r\n    ImGui::MemFree(tmp_array);\r\n\r\n    ImFontAtlasBuildFinish(atlas);\r\n\r\n    return true;\r\n}\r\n\r\nvoid ImFontAtlasBuildRegisterDefaultCustomRects(ImFontAtlas* atlas)\r\n{\r\n    if (atlas->CustomRectIds[0] < 0)\r\n        atlas->CustomRectIds[0] = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_ID, FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF*2+1, FONT_ATLAS_DEFAULT_TEX_DATA_H);\r\n}\r\n\r\nvoid ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent)\r\n{\r\n    if (!font_config->MergeMode)\r\n    {\r\n        font->ClearOutputData();\r\n        font->FontSize = font_config->SizePixels;\r\n        font->ConfigData = font_config;\r\n        font->ContainerAtlas = atlas;\r\n        font->Ascent = ascent;\r\n        font->Descent = descent;\r\n    }\r\n    font->ConfigDataCount++;\r\n}\r\n\r\nvoid ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* pack_context_opaque)\r\n{\r\n    stbrp_context* pack_context = (stbrp_context*)pack_context_opaque;\r\n\r\n    ImVector<ImFontAtlas::CustomRect>& user_rects = atlas->CustomRects;\r\n    IM_ASSERT(user_rects.Size >= 1); // We expect at least the default custom rects to be registered, else something went wrong.\r\n\r\n    ImVector<stbrp_rect> pack_rects;\r\n    pack_rects.resize(user_rects.Size);\r\n    memset(pack_rects.Data, 0, sizeof(stbrp_rect) * user_rects.Size);\r\n    for (int i = 0; i < user_rects.Size; i++)\r\n    {\r\n        pack_rects[i].w = user_rects[i].Width;\r\n        pack_rects[i].h = user_rects[i].Height;\r\n    }\r\n    stbrp_pack_rects(pack_context, &pack_rects[0], pack_rects.Size);\r\n    for (int i = 0; i < pack_rects.Size; i++)\r\n        if (pack_rects[i].was_packed)\r\n        {\r\n            user_rects[i].X = pack_rects[i].x;\r\n            user_rects[i].Y = pack_rects[i].y;\r\n            IM_ASSERT(pack_rects[i].w == user_rects[i].Width && pack_rects[i].h == user_rects[i].Height);\r\n            atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);\r\n        }\r\n}\r\n\r\nstatic void ImFontAtlasBuildRenderDefaultTexData(ImFontAtlas* atlas)\r\n{\r\n    IM_ASSERT(atlas->CustomRectIds[0] >= 0);\r\n    ImFontAtlas::CustomRect& r = atlas->CustomRects[atlas->CustomRectIds[0]];\r\n    IM_ASSERT(r.ID == FONT_ATLAS_DEFAULT_TEX_DATA_ID);\r\n    IM_ASSERT(r.Width == FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF*2+1);\r\n    IM_ASSERT(r.Height == FONT_ATLAS_DEFAULT_TEX_DATA_H);\r\n    IM_ASSERT(r.IsPacked());\r\n    IM_ASSERT(atlas->TexPixelsAlpha8 != NULL);\r\n\r\n    // Render/copy pixels\r\n    for (int y = 0, n = 0; y < FONT_ATLAS_DEFAULT_TEX_DATA_H; y++)\r\n        for (int x = 0; x < FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF; x++, n++)\r\n        {\r\n            const int offset0 = (int)(r.X + x) + (int)(r.Y + y) * atlas->TexWidth;\r\n            const int offset1 = offset0 + FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF + 1;\r\n            atlas->TexPixelsAlpha8[offset0] = FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[n] == '.' ? 0xFF : 0x00;\r\n            atlas->TexPixelsAlpha8[offset1] = FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[n] == 'X' ? 0xFF : 0x00;\r\n        }\r\n    const ImVec2 tex_uv_scale(1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight);\r\n    atlas->TexUvWhitePixel = ImVec2((r.X + 0.5f) * tex_uv_scale.x, (r.Y + 0.5f) * tex_uv_scale.y);\r\n\r\n    // Setup mouse cursors\r\n    for (int type = 0; type < ImGuiMouseCursor_Count_; type++)\r\n    {\r\n        ImGuiMouseCursorData& cursor_data = GImGui->MouseCursorData[type];\r\n        ImVec2 pos = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[type][0] + ImVec2((float)r.X, (float)r.Y);\r\n        const ImVec2 size = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[type][1];\r\n        cursor_data.Type = type;\r\n        cursor_data.Size = size;\r\n        cursor_data.HotOffset = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[type][2];\r\n        cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;\r\n        cursor_data.TexUvMax[0] = (pos + size) * tex_uv_scale;\r\n        pos.x += FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF + 1;\r\n        cursor_data.TexUvMin[1] = (pos) * tex_uv_scale;\r\n        cursor_data.TexUvMax[1] = (pos + size) * tex_uv_scale;\r\n    }\r\n}\r\n\r\nvoid ImFontAtlasBuildFinish(ImFontAtlas* atlas)\r\n{\r\n    // Render into our custom data block\r\n    ImFontAtlasBuildRenderDefaultTexData(atlas);\r\n\r\n    // Register custom rectangle glyphs\r\n    for (int i = 0; i < atlas->CustomRects.Size; i++)\r\n    {\r\n        const ImFontAtlas::CustomRect& r = atlas->CustomRects[i];\r\n        if (r.Font == NULL || r.ID > 0x10000)\r\n            continue;\r\n\r\n        IM_ASSERT(r.Font->ContainerAtlas == atlas);\r\n        ImVec2 uv0, uv1;\r\n        atlas->CalcCustomRectUV(&r, &uv0, &uv1);\r\n        r.Font->AddGlyph((ImWchar)r.ID, r.GlyphOffset.x, r.GlyphOffset.y, r.GlyphOffset.x + r.Width, r.GlyphOffset.y + r.Height, uv0.x, uv0.y, uv1.x, uv1.y, r.GlyphAdvanceX);\r\n    }\r\n\r\n    // Build all fonts lookup tables\r\n    for (int i = 0; i < atlas->Fonts.Size; i++)\r\n        atlas->Fonts[i]->BuildLookupTable();\r\n}\r\n\r\n// Retrieve list of range (2 int per range, values are inclusive)\r\nconst ImWchar*   ImFontAtlas::GetGlyphRangesDefault()\r\n{\r\n    static const ImWchar ranges[] =\r\n    {\r\n        0x0020, 0x00FF, // Basic Latin + Latin Supplement\r\n        0,\r\n    };\r\n    return &ranges[0];\r\n}\r\n\r\nconst ImWchar*  ImFontAtlas::GetGlyphRangesKorean()\r\n{\r\n    static const ImWchar ranges[] =\r\n    {\r\n        0x0020, 0x00FF, // Basic Latin + Latin Supplement\r\n        0x3131, 0x3163, // Korean alphabets\r\n        0xAC00, 0xD79D, // Korean characters\r\n        0,\r\n    };\r\n    return &ranges[0];\r\n}\r\n\r\nconst ImWchar*  ImFontAtlas::GetGlyphRangesChinese()\r\n{\r\n    static const ImWchar ranges[] =\r\n    {\r\n        0x0020, 0x00FF, // Basic Latin + Latin Supplement\r\n        0x3000, 0x30FF, // Punctuations, Hiragana, Katakana\r\n        0x31F0, 0x31FF, // Katakana Phonetic Extensions\r\n        0xFF00, 0xFFEF, // Half-width characters\r\n        0x4e00, 0x9FAF, // CJK Ideograms\r\n        0,\r\n    };\r\n    return &ranges[0];\r\n}\r\n\r\nconst ImWchar*  ImFontAtlas::GetGlyphRangesJapanese()\r\n{\r\n    // Store the 1946 ideograms code points as successive offsets from the initial unicode codepoint 0x4E00. Each offset has an implicit +1.\r\n    // This encoding is designed to helps us reduce the source code size.\r\n    // FIXME: Source a list of the revised 2136 joyo kanji list from 2010 and rebuild this.\r\n    // The current list was sourced from http://theinstructionlimit.com/author/renaudbedardrenaudbedard/page/3\r\n    // Note that you may use ImFontAtlas::GlyphRangesBuilder to create your own ranges, by merging existing ranges or adding new characters.\r\n    static const short offsets_from_0x4E00[] =\r\n    {\r\n        -1,0,1,3,0,0,0,0,1,0,5,1,1,0,7,4,6,10,0,1,9,9,7,1,3,19,1,10,7,1,0,1,0,5,1,0,6,4,2,6,0,0,12,6,8,0,3,5,0,1,0,9,0,0,8,1,1,3,4,5,13,0,0,8,2,17,\r\n        4,3,1,1,9,6,0,0,0,2,1,3,2,22,1,9,11,1,13,1,3,12,0,5,9,2,0,6,12,5,3,12,4,1,2,16,1,1,4,6,5,3,0,6,13,15,5,12,8,14,0,0,6,15,3,6,0,18,8,1,6,14,1,\r\n        5,4,12,24,3,13,12,10,24,0,0,0,1,0,1,1,2,9,10,2,2,0,0,3,3,1,0,3,8,0,3,2,4,4,1,6,11,10,14,6,15,3,4,15,1,0,0,5,2,2,0,0,1,6,5,5,6,0,3,6,5,0,0,1,0,\r\n        11,2,2,8,4,7,0,10,0,1,2,17,19,3,0,2,5,0,6,2,4,4,6,1,1,11,2,0,3,1,2,1,2,10,7,6,3,16,0,8,24,0,0,3,1,1,3,0,1,6,0,0,0,2,0,1,5,15,0,1,0,0,2,11,19,\r\n        1,4,19,7,6,5,1,0,0,0,0,5,1,0,1,9,0,0,5,0,2,0,1,0,3,0,11,3,0,2,0,0,0,0,0,9,3,6,4,12,0,14,0,0,29,10,8,0,14,37,13,0,31,16,19,0,8,30,1,20,8,3,48,\r\n        21,1,0,12,0,10,44,34,42,54,11,18,82,0,2,1,2,12,1,0,6,2,17,2,12,7,0,7,17,4,2,6,24,23,8,23,39,2,16,23,1,0,5,1,2,15,14,5,6,2,11,0,8,6,2,2,2,14,\r\n        20,4,15,3,4,11,10,10,2,5,2,1,30,2,1,0,0,22,5,5,0,3,1,5,4,1,0,0,2,2,21,1,5,1,2,16,2,1,3,4,0,8,4,0,0,5,14,11,2,16,1,13,1,7,0,22,15,3,1,22,7,14,\r\n        22,19,11,24,18,46,10,20,64,45,3,2,0,4,5,0,1,4,25,1,0,0,2,10,0,0,0,1,0,1,2,0,0,9,1,2,0,0,0,2,5,2,1,1,5,5,8,1,1,1,5,1,4,9,1,3,0,1,0,1,1,2,0,0,\r\n        2,0,1,8,22,8,1,0,0,0,0,4,2,1,0,9,8,5,0,9,1,30,24,2,6,4,39,0,14,5,16,6,26,179,0,2,1,1,0,0,0,5,2,9,6,0,2,5,16,7,5,1,1,0,2,4,4,7,15,13,14,0,0,\r\n        3,0,1,0,0,0,2,1,6,4,5,1,4,9,0,3,1,8,0,0,10,5,0,43,0,2,6,8,4,0,2,0,0,9,6,0,9,3,1,6,20,14,6,1,4,0,7,2,3,0,2,0,5,0,3,1,0,3,9,7,0,3,4,0,4,9,1,6,0,\r\n        9,0,0,2,3,10,9,28,3,6,2,4,1,2,32,4,1,18,2,0,3,1,5,30,10,0,2,2,2,0,7,9,8,11,10,11,7,2,13,7,5,10,0,3,40,2,0,1,6,12,0,4,5,1,5,11,11,21,4,8,3,7,\r\n        8,8,33,5,23,0,0,19,8,8,2,3,0,6,1,1,1,5,1,27,4,2,5,0,3,5,6,3,1,0,3,1,12,5,3,3,2,0,7,7,2,1,0,4,0,1,1,2,0,10,10,6,2,5,9,7,5,15,15,21,6,11,5,20,\r\n        4,3,5,5,2,5,0,2,1,0,1,7,28,0,9,0,5,12,5,5,18,30,0,12,3,3,21,16,25,32,9,3,14,11,24,5,66,9,1,2,0,5,9,1,5,1,8,0,8,3,3,0,1,15,1,4,8,1,2,7,0,7,2,\r\n        8,3,7,5,3,7,10,2,1,0,0,2,25,0,6,4,0,10,0,4,2,4,1,12,5,38,4,0,4,1,10,5,9,4,0,14,4,2,5,18,20,21,1,3,0,5,0,7,0,3,7,1,3,1,1,8,1,0,0,0,3,2,5,2,11,\r\n        6,0,13,1,3,9,1,12,0,16,6,2,1,0,2,1,12,6,13,11,2,0,28,1,7,8,14,13,8,13,0,2,0,5,4,8,10,2,37,42,19,6,6,7,4,14,11,18,14,80,7,6,0,4,72,12,36,27,\r\n        7,7,0,14,17,19,164,27,0,5,10,7,3,13,6,14,0,2,2,5,3,0,6,13,0,0,10,29,0,4,0,3,13,0,3,1,6,51,1,5,28,2,0,8,0,20,2,4,0,25,2,10,13,10,0,16,4,0,1,0,\r\n        2,1,7,0,1,8,11,0,0,1,2,7,2,23,11,6,6,4,16,2,2,2,0,22,9,3,3,5,2,0,15,16,21,2,9,20,15,15,5,3,9,1,0,0,1,7,7,5,4,2,2,2,38,24,14,0,0,15,5,6,24,14,\r\n        5,5,11,0,21,12,0,3,8,4,11,1,8,0,11,27,7,2,4,9,21,59,0,1,39,3,60,62,3,0,12,11,0,3,30,11,0,13,88,4,15,5,28,13,1,4,48,17,17,4,28,32,46,0,16,0,\r\n        18,11,1,8,6,38,11,2,6,11,38,2,0,45,3,11,2,7,8,4,30,14,17,2,1,1,65,18,12,16,4,2,45,123,12,56,33,1,4,3,4,7,0,0,0,3,2,0,16,4,2,4,2,0,7,4,5,2,26,\r\n        2,25,6,11,6,1,16,2,6,17,77,15,3,35,0,1,0,5,1,0,38,16,6,3,12,3,3,3,0,9,3,1,3,5,2,9,0,18,0,25,1,3,32,1,72,46,6,2,7,1,3,14,17,0,28,1,40,13,0,20,\r\n        15,40,6,38,24,12,43,1,1,9,0,12,6,0,6,2,4,19,3,7,1,48,0,9,5,0,5,6,9,6,10,15,2,11,19,3,9,2,0,1,10,1,27,8,1,3,6,1,14,0,26,0,27,16,3,4,9,6,2,23,\r\n        9,10,5,25,2,1,6,1,1,48,15,9,15,14,3,4,26,60,29,13,37,21,1,6,4,0,2,11,22,23,16,16,2,2,1,3,0,5,1,6,4,0,0,4,0,0,8,3,0,2,5,0,7,1,7,3,13,2,4,10,\r\n        3,0,2,31,0,18,3,0,12,10,4,1,0,7,5,7,0,5,4,12,2,22,10,4,2,15,2,8,9,0,23,2,197,51,3,1,1,4,13,4,3,21,4,19,3,10,5,40,0,4,1,1,10,4,1,27,34,7,21,\r\n        2,17,2,9,6,4,2,3,0,4,2,7,8,2,5,1,15,21,3,4,4,2,2,17,22,1,5,22,4,26,7,0,32,1,11,42,15,4,1,2,5,0,19,3,1,8,6,0,10,1,9,2,13,30,8,2,24,17,19,1,4,\r\n        4,25,13,0,10,16,11,39,18,8,5,30,82,1,6,8,18,77,11,13,20,75,11,112,78,33,3,0,0,60,17,84,9,1,1,12,30,10,49,5,32,158,178,5,5,6,3,3,1,3,1,4,7,6,\r\n        19,31,21,0,2,9,5,6,27,4,9,8,1,76,18,12,1,4,0,3,3,6,3,12,2,8,30,16,2,25,1,5,5,4,3,0,6,10,2,3,1,0,5,1,19,3,0,8,1,5,2,6,0,0,0,19,1,2,0,5,1,2,5,\r\n        1,3,7,0,4,12,7,3,10,22,0,9,5,1,0,2,20,1,1,3,23,30,3,9,9,1,4,191,14,3,15,6,8,50,0,1,0,0,4,0,0,1,0,2,4,2,0,2,3,0,2,0,2,2,8,7,0,1,1,1,3,3,17,11,\r\n        91,1,9,3,2,13,4,24,15,41,3,13,3,1,20,4,125,29,30,1,0,4,12,2,21,4,5,5,19,11,0,13,11,86,2,18,0,7,1,8,8,2,2,22,1,2,6,5,2,0,1,2,8,0,2,0,5,2,1,0,\r\n        2,10,2,0,5,9,2,1,2,0,1,0,4,0,0,10,2,5,3,0,6,1,0,1,4,4,33,3,13,17,3,18,6,4,7,1,5,78,0,4,1,13,7,1,8,1,0,35,27,15,3,0,0,0,1,11,5,41,38,15,22,6,\r\n        14,14,2,1,11,6,20,63,5,8,27,7,11,2,2,40,58,23,50,54,56,293,8,8,1,5,1,14,0,1,12,37,89,8,8,8,2,10,6,0,0,0,4,5,2,1,0,1,1,2,7,0,3,3,0,4,6,0,3,2,\r\n        19,3,8,0,0,0,4,4,16,0,4,1,5,1,3,0,3,4,6,2,17,10,10,31,6,4,3,6,10,126,7,3,2,2,0,9,0,0,5,20,13,0,15,0,6,0,2,5,8,64,50,3,2,12,2,9,0,0,11,8,20,\r\n        109,2,18,23,0,0,9,61,3,0,28,41,77,27,19,17,81,5,2,14,5,83,57,252,14,154,263,14,20,8,13,6,57,39,38,\r\n    };\r\n    static ImWchar base_ranges[] =\r\n    {\r\n        0x0020, 0x00FF, // Basic Latin + Latin Supplement\r\n        0x3000, 0x30FF, // Punctuations, Hiragana, Katakana\r\n        0x31F0, 0x31FF, // Katakana Phonetic Extensions\r\n        0xFF00, 0xFFEF, // Half-width characters\r\n    };\r\n    static bool full_ranges_unpacked = false;\r\n    static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(offsets_from_0x4E00)*2 + 1];\r\n    if (!full_ranges_unpacked)\r\n    {\r\n        // Unpack\r\n        int codepoint = 0x4e00;\r\n        memcpy(full_ranges, base_ranges, sizeof(base_ranges));\r\n        ImWchar* dst = full_ranges + IM_ARRAYSIZE(base_ranges);;\r\n        for (int n = 0; n < IM_ARRAYSIZE(offsets_from_0x4E00); n++, dst += 2)\r\n            dst[0] = dst[1] = (ImWchar)(codepoint += (offsets_from_0x4E00[n] + 1));\r\n        dst[0] = 0;\r\n        full_ranges_unpacked = true;\r\n    }\r\n    return &full_ranges[0];\r\n}\r\n\r\nconst ImWchar*  ImFontAtlas::GetGlyphRangesCyrillic()\r\n{\r\n    static const ImWchar ranges[] =\r\n    {\r\n        0x0020, 0x00FF, // Basic Latin + Latin Supplement\r\n        0x0400, 0x052F, // Cyrillic + Cyrillic Supplement\r\n        0x2DE0, 0x2DFF, // Cyrillic Extended-A\r\n        0xA640, 0xA69F, // Cyrillic Extended-B\r\n        0,\r\n    };\r\n    return &ranges[0];\r\n}\r\n\r\nconst ImWchar*  ImFontAtlas::GetGlyphRangesThai()\r\n{\r\n    static const ImWchar ranges[] =\r\n    {\r\n        0x0020, 0x00FF, // Basic Latin\r\n        0x2010, 0x205E, // Punctuations\r\n        0x0E00, 0x0E7F, // Thai\r\n        0,\r\n    };\r\n    return &ranges[0];\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// ImFontAtlas::GlyphRangesBuilder\r\n//-----------------------------------------------------------------------------\r\n\r\nvoid ImFontAtlas::GlyphRangesBuilder::AddText(const char* text, const char* text_end)\r\n{\r\n    while (text_end ? (text < text_end) : *text)\r\n    {\r\n        unsigned int c = 0;\r\n        int c_len = ImTextCharFromUtf8(&c, text, text_end);\r\n        text += c_len;\r\n        if (c_len == 0)\r\n            break;\r\n        if (c < 0x10000)\r\n            AddChar((ImWchar)c);\r\n    }\r\n}\r\n\r\nvoid ImFontAtlas::GlyphRangesBuilder::AddRanges(const ImWchar* ranges)\r\n{\r\n    for (; ranges[0]; ranges += 2)\r\n        for (ImWchar c = ranges[0]; c <= ranges[1]; c++)\r\n            AddChar(c);\r\n}\r\n\r\nvoid ImFontAtlas::GlyphRangesBuilder::BuildRanges(ImVector<ImWchar>* out_ranges)\r\n{\r\n    for (int n = 0; n < 0x10000; n++)\r\n        if (GetBit(n))\r\n        {\r\n            out_ranges->push_back((ImWchar)n);\r\n            while (n < 0x10000 && GetBit(n + 1))\r\n                n++;\r\n            out_ranges->push_back((ImWchar)n);\r\n        }\r\n    out_ranges->push_back(0);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// ImFont\r\n//-----------------------------------------------------------------------------\r\n\r\nImFont::ImFont()\r\n{\r\n    Scale = 1.0f;\r\n    FallbackChar = (ImWchar)'?';\r\n    DisplayOffset = ImVec2(0.0f, 1.0f);\r\n    ClearOutputData();\r\n}\r\n\r\nImFont::~ImFont()\r\n{\r\n    // Invalidate active font so that the user gets a clear crash instead of a dangling pointer.\r\n    // If you want to delete fonts you need to do it between Render() and NewFrame().\r\n    // FIXME-CLEANUP\r\n    /*\r\n    ImGuiContext& g = *GImGui;\r\n    if (g.Font == this)\r\n        g.Font = NULL;\r\n    */\r\n    ClearOutputData();\r\n}\r\n\r\nvoid    ImFont::ClearOutputData()\r\n{\r\n    FontSize = 0.0f;\r\n    Glyphs.clear();\r\n    IndexAdvanceX.clear();\r\n    IndexLookup.clear();\r\n    FallbackGlyph = NULL;\r\n    FallbackAdvanceX = 0.0f;\r\n    ConfigDataCount = 0;\r\n    ConfigData = NULL;\r\n    ContainerAtlas = NULL;\r\n    Ascent = Descent = 0.0f;\r\n    MetricsTotalSurface = 0;\r\n}\r\n\r\nvoid ImFont::BuildLookupTable()\r\n{\r\n    int max_codepoint = 0;\r\n    for (int i = 0; i != Glyphs.Size; i++)\r\n        max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);\r\n\r\n    IM_ASSERT(Glyphs.Size < 0xFFFF); // -1 is reserved\r\n    IndexAdvanceX.clear();\r\n    IndexLookup.clear();\r\n    GrowIndex(max_codepoint + 1);\r\n    for (int i = 0; i < Glyphs.Size; i++)\r\n    {\r\n        int codepoint = (int)Glyphs[i].Codepoint;\r\n        IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;\r\n        IndexLookup[codepoint] = (unsigned short)i;\r\n    }\r\n\r\n    // Create a glyph to handle TAB\r\n    // FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at \"column 0\" ?)\r\n    if (FindGlyph((unsigned short)' '))\r\n    {\r\n        if (Glyphs.back().Codepoint != '\\t')   // So we can call this function multiple times\r\n            Glyphs.resize(Glyphs.Size + 1);\r\n        ImFontGlyph& tab_glyph = Glyphs.back();\r\n        tab_glyph = *FindGlyph((unsigned short)' ');\r\n        tab_glyph.Codepoint = '\\t';\r\n        tab_glyph.AdvanceX *= 4;\r\n        IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;\r\n        IndexLookup[(int)tab_glyph.Codepoint] = (unsigned short)(Glyphs.Size-1);\r\n    }\r\n\r\n    FallbackGlyph = NULL;\r\n    FallbackGlyph = FindGlyph(FallbackChar);\r\n    FallbackAdvanceX = FallbackGlyph ? FallbackGlyph->AdvanceX : 0.0f;\r\n    for (int i = 0; i < max_codepoint + 1; i++)\r\n        if (IndexAdvanceX[i] < 0.0f)\r\n            IndexAdvanceX[i] = FallbackAdvanceX;\r\n}\r\n\r\nvoid ImFont::SetFallbackChar(ImWchar c)\r\n{\r\n    FallbackChar = c;\r\n    BuildLookupTable();\r\n}\r\n\r\nvoid ImFont::GrowIndex(int new_size)\r\n{\r\n    IM_ASSERT(IndexAdvanceX.Size == IndexLookup.Size);\r\n    if (new_size <= IndexLookup.Size)\r\n        return;\r\n    IndexAdvanceX.resize(new_size, -1.0f);\r\n    IndexLookup.resize(new_size, (unsigned short)-1);\r\n}\r\n\r\nvoid ImFont::AddGlyph(ImWchar codepoint, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x)\r\n{\r\n    Glyphs.resize(Glyphs.Size + 1);\r\n    ImFontGlyph& glyph = Glyphs.back();\r\n    glyph.Codepoint = (ImWchar)codepoint;\r\n    glyph.X0 = x0; \r\n    glyph.Y0 = y0; \r\n    glyph.X1 = x1; \r\n    glyph.Y1 = y1;\r\n    glyph.U0 = u0; \r\n    glyph.V0 = v0; \r\n    glyph.U1 = u1; \r\n    glyph.V1 = v1;\r\n    glyph.AdvanceX = advance_x + ConfigData->GlyphExtraSpacing.x;  // Bake spacing into AdvanceX\r\n\r\n    if (ConfigData->PixelSnapH)\r\n        glyph.AdvanceX = (float)(int)(glyph.AdvanceX + 0.5f);\r\n    \r\n    // Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)\r\n    MetricsTotalSurface += (int)((glyph.U1 - glyph.U0) * ContainerAtlas->TexWidth + 1.99f) * (int)((glyph.V1 - glyph.V0) * ContainerAtlas->TexHeight + 1.99f);\r\n}\r\n\r\nvoid ImFont::AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst)\r\n{\r\n    IM_ASSERT(IndexLookup.Size > 0);    // Currently this can only be called AFTER the font has been built, aka after calling ImFontAtlas::GetTexDataAs*() function.\r\n    int index_size = IndexLookup.Size;\r\n\r\n    if (dst < index_size && IndexLookup.Data[dst] == (unsigned short)-1 && !overwrite_dst) // 'dst' already exists\r\n        return;\r\n    if (src >= index_size && dst >= index_size) // both 'dst' and 'src' don't exist -> no-op\r\n        return;\r\n\r\n    GrowIndex(dst + 1);\r\n    IndexLookup[dst] = (src < index_size) ? IndexLookup.Data[src] : (unsigned short)-1;\r\n    IndexAdvanceX[dst] = (src < index_size) ? IndexAdvanceX.Data[src] : 1.0f;\r\n}\r\n\r\nconst ImFontGlyph* ImFont::FindGlyph(ImWchar c) const\r\n{\r\n    if (c < IndexLookup.Size)\r\n    {\r\n        const unsigned short i = IndexLookup[c];\r\n        if (i != (unsigned short)-1)\r\n            return &Glyphs.Data[i];\r\n    }\r\n    return FallbackGlyph;\r\n}\r\n\r\nconst char* ImFont::CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const\r\n{\r\n    // Simple word-wrapping for English, not full-featured. Please submit failing cases!\r\n    // FIXME: Much possible improvements (don't cut things like \"word !\", \"word!!!\" but cut within \"word,,,,\", more sensible support for punctuations, support for Unicode punctuations, etc.)\r\n\r\n    // For references, possible wrap point marked with ^\r\n    //  \"aaa bbb, ccc,ddd. eee   fff. ggg!\"\r\n    //      ^    ^    ^   ^   ^__    ^    ^\r\n\r\n    // List of hardcoded separators: .,;!?'\"\r\n\r\n    // Skip extra blanks after a line returns (that includes not counting them in width computation)\r\n    // e.g. \"Hello    world\" --> \"Hello\" \"World\"\r\n\r\n    // Cut words that cannot possibly fit within one line.\r\n    // e.g.: \"The tropical fish\" with ~5 characters worth of width --> \"The tr\" \"opical\" \"fish\"\r\n\r\n    float line_width = 0.0f;\r\n    float word_width = 0.0f;\r\n    float blank_width = 0.0f;\r\n    wrap_width /= scale; // We work with unscaled widths to avoid scaling every characters\r\n\r\n    const char* word_end = text;\r\n    const char* prev_word_end = NULL;\r\n    bool inside_word = true;\r\n\r\n    const char* s = text;\r\n    while (s < text_end)\r\n    {\r\n        unsigned int c = (unsigned int)*s;\r\n        const char* next_s;\r\n        if (c < 0x80)\r\n            next_s = s + 1;\r\n        else\r\n            next_s = s + ImTextCharFromUtf8(&c, s, text_end);\r\n        if (c == 0)\r\n            break;\r\n\r\n        if (c < 32)\r\n        {\r\n            if (c == '\\n')\r\n            {\r\n                line_width = word_width = blank_width = 0.0f;\r\n                inside_word = true;\r\n                s = next_s;\r\n                continue;\r\n            }\r\n            if (c == '\\r')\r\n            {\r\n                s = next_s;\r\n                continue;\r\n            }\r\n        }\r\n\r\n        const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX[(int)c] : FallbackAdvanceX);\r\n        if (ImCharIsSpace(c))\r\n        {\r\n            if (inside_word)\r\n            {\r\n                line_width += blank_width;\r\n                blank_width = 0.0f;\r\n                word_end = s;\r\n            }\r\n            blank_width += char_width;\r\n            inside_word = false;\r\n        }\r\n        else\r\n        {\r\n            word_width += char_width;\r\n            if (inside_word)\r\n            {\r\n                word_end = next_s;\r\n            }\r\n            else\r\n            {\r\n                prev_word_end = word_end;\r\n                line_width += word_width + blank_width;\r\n                word_width = blank_width = 0.0f;\r\n            }\r\n\r\n            // Allow wrapping after punctuation.\r\n            inside_word = !(c == '.' || c == ',' || c == ';' || c == '!' || c == '?' || c == '\\\"');\r\n        }\r\n\r\n        // We ignore blank width at the end of the line (they can be skipped)\r\n        if (line_width + word_width >= wrap_width)\r\n        {\r\n            // Words that cannot possibly fit within an entire line will be cut anywhere.\r\n            if (word_width < wrap_width)\r\n                s = prev_word_end ? prev_word_end : word_end;\r\n            break;\r\n        }\r\n\r\n        s = next_s;\r\n    }\r\n\r\n    return s;\r\n}\r\n\r\nImVec2 ImFont::CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining) const\r\n{\r\n    if (!text_end)\r\n        text_end = text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.\r\n\r\n    const float line_height = size;\r\n    const float scale = size / FontSize;\r\n\r\n    ImVec2 text_size = ImVec2(0,0);\r\n    float line_width = 0.0f;\r\n\r\n    const bool word_wrap_enabled = (wrap_width > 0.0f);\r\n    const char* word_wrap_eol = NULL;\r\n\r\n    const char* s = text_begin;\r\n    while (s < text_end)\r\n    {\r\n        if (word_wrap_enabled)\r\n        {\r\n            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.\r\n            if (!word_wrap_eol)\r\n            {\r\n                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);\r\n                if (word_wrap_eol == s) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.\r\n                    word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below\r\n            }\r\n\r\n            if (s >= word_wrap_eol)\r\n            {\r\n                if (text_size.x < line_width)\r\n                    text_size.x = line_width;\r\n                text_size.y += line_height;\r\n                line_width = 0.0f;\r\n                word_wrap_eol = NULL;\r\n\r\n                // Wrapping skips upcoming blanks\r\n                while (s < text_end)\r\n                {\r\n                    const char c = *s;\r\n                    if (ImCharIsSpace(c)) { s++; } else if (c == '\\n') { s++; break; } else { break; }\r\n                }\r\n                continue;\r\n            }\r\n        }\r\n\r\n        // Decode and advance source\r\n        const char* prev_s = s;\r\n        unsigned int c = (unsigned int)*s;\r\n        if (c < 0x80)\r\n        {\r\n            s += 1;\r\n        }\r\n        else\r\n        {\r\n            s += ImTextCharFromUtf8(&c, s, text_end);\r\n            if (c == 0) // Malformed UTF-8?\r\n                break;\r\n        }\r\n\r\n        if (c < 32)\r\n        {\r\n            if (c == '\\n')\r\n            {\r\n                text_size.x = ImMax(text_size.x, line_width);\r\n                text_size.y += line_height;\r\n                line_width = 0.0f;\r\n                continue;\r\n            }\r\n            if (c == '\\r')\r\n                continue;\r\n        }\r\n\r\n        const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX[(int)c] : FallbackAdvanceX) * scale;\r\n        if (line_width + char_width >= max_width)\r\n        {\r\n            s = prev_s;\r\n            break;\r\n        }\r\n\r\n        line_width += char_width;\r\n    }\r\n\r\n    if (text_size.x < line_width)\r\n        text_size.x = line_width;\r\n\r\n    if (line_width > 0 || text_size.y == 0.0f)\r\n        text_size.y += line_height;\r\n\r\n    if (remaining)\r\n        *remaining = s;\r\n\r\n    return text_size;\r\n}\r\n\r\nvoid ImFont::RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, unsigned short c) const\r\n{\r\n    if (c == ' ' || c == '\\t' || c == '\\n' || c == '\\r') // Match behavior of RenderText(), those 4 codepoints are hard-coded.\r\n        return;\r\n    if (const ImFontGlyph* glyph = FindGlyph(c))\r\n    {\r\n        float scale = (size >= 0.0f) ? (size / FontSize) : 1.0f;\r\n        pos.x = (float)(int)pos.x + DisplayOffset.x;\r\n        pos.y = (float)(int)pos.y + DisplayOffset.y;\r\n        draw_list->PrimReserve(6, 4);\r\n        draw_list->PrimRectUV(ImVec2(pos.x + glyph->X0 * scale, pos.y + glyph->Y0 * scale), ImVec2(pos.x + glyph->X1 * scale, pos.y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);\r\n    }\r\n}\r\n\r\nvoid ImFont::RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width, bool cpu_fine_clip) const\r\n{\r\n    if (!text_end)\r\n        text_end = text_begin + strlen(text_begin); // ImGui functions generally already provides a valid text_end, so this is merely to handle direct calls.\r\n\r\n    // Align to be pixel perfect\r\n    pos.x = (float)(int)pos.x + DisplayOffset.x;\r\n    pos.y = (float)(int)pos.y + DisplayOffset.y;\r\n    float x = pos.x;\r\n    float y = pos.y;\r\n    if (y > clip_rect.w)\r\n        return;\r\n\r\n    const float scale = size / FontSize;\r\n    const float line_height = FontSize * scale;\r\n    const bool word_wrap_enabled = (wrap_width > 0.0f);\r\n    const char* word_wrap_eol = NULL;\r\n\r\n    // Skip non-visible lines\r\n    const char* s = text_begin;\r\n    if (!word_wrap_enabled && y + line_height < clip_rect.y)\r\n        while (s < text_end && *s != '\\n')  // Fast-forward to next line\r\n            s++;\r\n\r\n    // Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)\r\n    const int vtx_count_max = (int)(text_end - s) * 4;\r\n    const int idx_count_max = (int)(text_end - s) * 6;\r\n    const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;\r\n    draw_list->PrimReserve(idx_count_max, vtx_count_max);\r\n\r\n    ImDrawVert* vtx_write = draw_list->_VtxWritePtr;\r\n    ImDrawIdx* idx_write = draw_list->_IdxWritePtr;\r\n    unsigned int vtx_current_idx = draw_list->_VtxCurrentIdx;\r\n\r\n    while (s < text_end)\r\n    {\r\n        if (word_wrap_enabled)\r\n        {\r\n            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.\r\n            if (!word_wrap_eol)\r\n            {\r\n                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - (x - pos.x));\r\n                if (word_wrap_eol == s) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.\r\n                    word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below\r\n            }\r\n\r\n            if (s >= word_wrap_eol)\r\n            {\r\n                x = pos.x;\r\n                y += line_height;\r\n                word_wrap_eol = NULL;\r\n\r\n                // Wrapping skips upcoming blanks\r\n                while (s < text_end)\r\n                {\r\n                    const char c = *s;\r\n                    if (ImCharIsSpace(c)) { s++; } else if (c == '\\n') { s++; break; } else { break; }\r\n                }\r\n                continue;\r\n            }\r\n        }\r\n\r\n        // Decode and advance source\r\n        unsigned int c = (unsigned int)*s;\r\n        if (c < 0x80)\r\n        {\r\n            s += 1;\r\n        }\r\n        else\r\n        {\r\n            s += ImTextCharFromUtf8(&c, s, text_end);\r\n            if (c == 0) // Malformed UTF-8?\r\n                break;\r\n        }\r\n\r\n        if (c < 32)\r\n        {\r\n            if (c == '\\n')\r\n            {\r\n                x = pos.x;\r\n                y += line_height;\r\n\r\n                if (y > clip_rect.w)\r\n                    break;\r\n                if (!word_wrap_enabled && y + line_height < clip_rect.y)\r\n                    while (s < text_end && *s != '\\n')  // Fast-forward to next line\r\n                        s++;\r\n                continue;\r\n            }\r\n            if (c == '\\r')\r\n                continue;\r\n        }\r\n\r\n        float char_width = 0.0f;\r\n        if (const ImFontGlyph* glyph = FindGlyph((unsigned short)c))\r\n        {\r\n            char_width = glyph->AdvanceX * scale;\r\n\r\n            // Arbitrarily assume that both space and tabs are empty glyphs as an optimization\r\n            if (c != ' ' && c != '\\t')\r\n            {\r\n                // We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w\r\n                float x1 = x + glyph->X0 * scale;\r\n                float x2 = x + glyph->X1 * scale;\r\n                float y1 = y + glyph->Y0 * scale;\r\n                float y2 = y + glyph->Y1 * scale;\r\n                if (x1 <= clip_rect.z && x2 >= clip_rect.x)\r\n                {\r\n                    // Render a character\r\n                    float u1 = glyph->U0;\r\n                    float v1 = glyph->V0;\r\n                    float u2 = glyph->U1;\r\n                    float v2 = glyph->V1;\r\n\r\n                    // CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.\r\n                    if (cpu_fine_clip)\r\n                    {\r\n                        if (x1 < clip_rect.x)\r\n                        {\r\n                            u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);\r\n                            x1 = clip_rect.x;\r\n                        }\r\n                        if (y1 < clip_rect.y)\r\n                        {\r\n                            v1 = v1 + (1.0f - (y2 - clip_rect.y) / (y2 - y1)) * (v2 - v1);\r\n                            y1 = clip_rect.y;\r\n                        }\r\n                        if (x2 > clip_rect.z)\r\n                        {\r\n                            u2 = u1 + ((clip_rect.z - x1) / (x2 - x1)) * (u2 - u1);\r\n                            x2 = clip_rect.z;\r\n                        }\r\n                        if (y2 > clip_rect.w)\r\n                        {\r\n                            v2 = v1 + ((clip_rect.w - y1) / (y2 - y1)) * (v2 - v1);\r\n                            y2 = clip_rect.w;\r\n                        }\r\n                        if (y1 >= y2)\r\n                        {\r\n                            x += char_width;\r\n                            continue;\r\n                        }\r\n                    }\r\n\r\n                    // We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:\r\n                    {\r\n                        idx_write[0] = (ImDrawIdx)(vtx_current_idx); idx_write[1] = (ImDrawIdx)(vtx_current_idx+1); idx_write[2] = (ImDrawIdx)(vtx_current_idx+2);\r\n                        idx_write[3] = (ImDrawIdx)(vtx_current_idx); idx_write[4] = (ImDrawIdx)(vtx_current_idx+2); idx_write[5] = (ImDrawIdx)(vtx_current_idx+3);\r\n                        vtx_write[0].pos.x = x1; vtx_write[0].pos.y = y1; vtx_write[0].col = col; vtx_write[0].uv.x = u1; vtx_write[0].uv.y = v1;\r\n                        vtx_write[1].pos.x = x2; vtx_write[1].pos.y = y1; vtx_write[1].col = col; vtx_write[1].uv.x = u2; vtx_write[1].uv.y = v1;\r\n                        vtx_write[2].pos.x = x2; vtx_write[2].pos.y = y2; vtx_write[2].col = col; vtx_write[2].uv.x = u2; vtx_write[2].uv.y = v2;\r\n                        vtx_write[3].pos.x = x1; vtx_write[3].pos.y = y2; vtx_write[3].col = col; vtx_write[3].uv.x = u1; vtx_write[3].uv.y = v2;\r\n                        vtx_write += 4;\r\n                        vtx_current_idx += 4;\r\n                        idx_write += 6;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        x += char_width;\r\n    }\r\n\r\n    // Give back unused vertices\r\n    draw_list->VtxBuffer.resize((int)(vtx_write - draw_list->VtxBuffer.Data));\r\n    draw_list->IdxBuffer.resize((int)(idx_write - draw_list->IdxBuffer.Data));\r\n    draw_list->CmdBuffer[draw_list->CmdBuffer.Size-1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);\r\n    draw_list->_VtxWritePtr = vtx_write;\r\n    draw_list->_IdxWritePtr = idx_write;\r\n    draw_list->_VtxCurrentIdx = (unsigned int)draw_list->VtxBuffer.Size;\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// Internals Drawing Helpers\r\n//-----------------------------------------------------------------------------\r\n\r\nstatic inline float ImAcos01(float x)\r\n{\r\n    if (x <= 0.0f) return IM_PI * 0.5f;\r\n    if (x >= 1.0f) return 0.0f;\r\n    return acosf(x);\r\n    //return (-0.69813170079773212f * x * x - 0.87266462599716477f) * x + 1.5707963267948966f; // Cheap approximation, may be enough for what we do.\r\n}\r\n\r\n// FIXME: Cleanup and move code to ImDrawList.\r\nvoid ImGui::RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding)\r\n{\r\n    if (x_end_norm == x_start_norm)\r\n        return;\r\n    if (x_start_norm > x_end_norm)\r\n        ImSwap(x_start_norm, x_end_norm);\r\n\r\n    ImVec2 p0 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_start_norm), rect.Min.y);\r\n    ImVec2 p1 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_end_norm), rect.Max.y);\r\n    if (rounding == 0.0f)\r\n    {\r\n        draw_list->AddRectFilled(p0, p1, col, 0.0f);\r\n        return;\r\n    }\r\n\r\n    rounding = ImClamp(ImMin((rect.Max.x - rect.Min.x) * 0.5f, (rect.Max.y - rect.Min.y) * 0.5f) - 1.0f, 0.0f, rounding);\r\n    const float inv_rounding = 1.0f / rounding;\r\n    const float arc0_b = ImAcos01(1.0f - (p0.x - rect.Min.x) * inv_rounding);\r\n    const float arc0_e = ImAcos01(1.0f - (p1.x - rect.Min.x) * inv_rounding);\r\n    const float x0 = ImMax(p0.x, rect.Min.x + rounding);\r\n    if (arc0_b == arc0_e)\r\n    {\r\n        draw_list->PathLineTo(ImVec2(x0, p1.y));\r\n        draw_list->PathLineTo(ImVec2(x0, p0.y));\r\n    }\r\n    else if (arc0_b == 0.0f && arc0_e == IM_PI*0.5f)\r\n    {\r\n        draw_list->PathArcToFast(ImVec2(x0, p1.y - rounding), rounding, 3, 6); // BL\r\n        draw_list->PathArcToFast(ImVec2(x0, p0.y + rounding), rounding, 6, 9); // TR\r\n    }\r\n    else\r\n    {\r\n        draw_list->PathArcTo(ImVec2(x0, p1.y - rounding), rounding, IM_PI - arc0_e, IM_PI - arc0_b, 3); // BL\r\n        draw_list->PathArcTo(ImVec2(x0, p0.y + rounding), rounding, IM_PI + arc0_b, IM_PI + arc0_e, 3); // TR\r\n    }\r\n    if (p1.x > rect.Min.x + rounding)\r\n    {\r\n        const float arc1_b = ImAcos01(1.0f - (rect.Max.x - p1.x) * inv_rounding);\r\n        const float arc1_e = ImAcos01(1.0f - (rect.Max.x - p0.x) * inv_rounding);\r\n        const float x1 = ImMin(p1.x, rect.Max.x - rounding);\r\n        if (arc1_b == arc1_e)\r\n        {\r\n            draw_list->PathLineTo(ImVec2(x1, p0.y));\r\n            draw_list->PathLineTo(ImVec2(x1, p1.y));\r\n        }\r\n        else if (arc1_b == 0.0f && arc1_e == IM_PI*0.5f)\r\n        {\r\n            draw_list->PathArcToFast(ImVec2(x1, p0.y + rounding), rounding, 9, 12); // TR\r\n            draw_list->PathArcToFast(ImVec2(x1, p1.y - rounding), rounding, 0, 3);  // BR\r\n        }\r\n        else\r\n        {\r\n            draw_list->PathArcTo(ImVec2(x1, p0.y + rounding), rounding, -arc1_e, -arc1_b, 3); // TR\r\n            draw_list->PathArcTo(ImVec2(x1, p1.y - rounding), rounding, +arc1_b, +arc1_e, 3); // BR\r\n        }\r\n    }\r\n    draw_list->PathFillConvex(col);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// DEFAULT FONT DATA\r\n//-----------------------------------------------------------------------------\r\n// Compressed with stb_compress() then converted to a C array.\r\n// Use the program in extra_fonts/binary_to_compressed_c.cpp to create the array from a TTF file.\r\n// Decompression from stb.h (public domain) by Sean Barrett https://github.com/nothings/stb/blob/master/stb.h\r\n//-----------------------------------------------------------------------------\r\n\r\nstatic unsigned int stb_decompress_length(unsigned char *input)\r\n{\r\n    return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];\r\n}\r\n\r\nstatic unsigned char *stb__barrier, *stb__barrier2, *stb__barrier3, *stb__barrier4;\r\nstatic unsigned char *stb__dout;\r\nstatic void stb__match(unsigned char *data, unsigned int length)\r\n{\r\n    // INVERSE of memmove... write each byte before copying the next...\r\n    IM_ASSERT (stb__dout + length <= stb__barrier);\r\n    if (stb__dout + length > stb__barrier) { stb__dout += length; return; }\r\n    if (data < stb__barrier4) { stb__dout = stb__barrier+1; return; }\r\n    while (length--) *stb__dout++ = *data++;\r\n}\r\n\r\nstatic void stb__lit(unsigned char *data, unsigned int length)\r\n{\r\n    IM_ASSERT (stb__dout + length <= stb__barrier);\r\n    if (stb__dout + length > stb__barrier) { stb__dout += length; return; }\r\n    if (data < stb__barrier2) { stb__dout = stb__barrier+1; return; }\r\n    memcpy(stb__dout, data, length);\r\n    stb__dout += length;\r\n}\r\n\r\n#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])\r\n#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))\r\n#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))\r\n\r\nstatic unsigned char *stb_decompress_token(unsigned char *i)\r\n{\r\n    if (*i >= 0x20) { // use fewer if's for cases that expand small\r\n        if (*i >= 0x80)       stb__match(stb__dout-i[1]-1, i[0] - 0x80 + 1), i += 2;\r\n        else if (*i >= 0x40)  stb__match(stb__dout-(stb__in2(0) - 0x4000 + 1), i[2]+1), i += 3;\r\n        else /* *i >= 0x20 */ stb__lit(i+1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);\r\n    } else { // more ifs for cases that expand large, since overhead is amortized\r\n        if (*i >= 0x18)       stb__match(stb__dout-(stb__in3(0) - 0x180000 + 1), i[3]+1), i += 4;\r\n        else if (*i >= 0x10)  stb__match(stb__dout-(stb__in3(0) - 0x100000 + 1), stb__in2(3)+1), i += 5;\r\n        else if (*i >= 0x08)  stb__lit(i+2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);\r\n        else if (*i == 0x07)  stb__lit(i+3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);\r\n        else if (*i == 0x06)  stb__match(stb__dout-(stb__in3(1)+1), i[4]+1), i += 5;\r\n        else if (*i == 0x04)  stb__match(stb__dout-(stb__in3(1)+1), stb__in2(4)+1), i += 6;\r\n    }\r\n    return i;\r\n}\r\n\r\nstatic unsigned int stb_adler32(unsigned int adler32, unsigned char *buffer, unsigned int buflen)\r\n{\r\n    const unsigned long ADLER_MOD = 65521;\r\n    unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;\r\n    unsigned long blocklen, i;\r\n\r\n    blocklen = buflen % 5552;\r\n    while (buflen) {\r\n        for (i=0; i + 7 < blocklen; i += 8) {\r\n            s1 += buffer[0], s2 += s1;\r\n            s1 += buffer[1], s2 += s1;\r\n            s1 += buffer[2], s2 += s1;\r\n            s1 += buffer[3], s2 += s1;\r\n            s1 += buffer[4], s2 += s1;\r\n            s1 += buffer[5], s2 += s1;\r\n            s1 += buffer[6], s2 += s1;\r\n            s1 += buffer[7], s2 += s1;\r\n\r\n            buffer += 8;\r\n        }\r\n\r\n        for (; i < blocklen; ++i)\r\n            s1 += *buffer++, s2 += s1;\r\n\r\n        s1 %= ADLER_MOD, s2 %= ADLER_MOD;\r\n        buflen -= blocklen;\r\n        blocklen = 5552;\r\n    }\r\n    return (unsigned int)(s2 << 16) + (unsigned int)s1;\r\n}\r\n\r\nstatic unsigned int stb_decompress(unsigned char *output, unsigned char *i, unsigned int length)\r\n{\r\n    unsigned int olen;\r\n    if (stb__in4(0) != 0x57bC0000) return 0;\r\n    if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB\r\n    olen = stb_decompress_length(i);\r\n    stb__barrier2 = i;\r\n    stb__barrier3 = i+length;\r\n    stb__barrier = output + olen;\r\n    stb__barrier4 = output;\r\n    i += 16;\r\n\r\n    stb__dout = output;\r\n    for (;;) {\r\n        unsigned char *old_i = i;\r\n        i = stb_decompress_token(i);\r\n        if (i == old_i) {\r\n            if (*i == 0x05 && i[1] == 0xfa) {\r\n                IM_ASSERT(stb__dout == output + olen);\r\n                if (stb__dout != output + olen) return 0;\r\n                if (stb_adler32(1, output, olen) != (unsigned int) stb__in4(2))\r\n                    return 0;\r\n                return olen;\r\n            } else {\r\n                IM_ASSERT(0); /* NOTREACHED */\r\n                return 0;\r\n            }\r\n        }\r\n        IM_ASSERT(stb__dout <= output + olen);\r\n        if (stb__dout > output + olen)\r\n            return 0;\r\n    }\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// ProggyClean.ttf\r\n// Copyright (c) 2004, 2005 Tristan Grimmer\r\n// MIT license (see License.txt in http://www.upperbounds.net/download/ProggyClean.ttf.zip)\r\n// Download and more information at http://upperbounds.net\r\n//-----------------------------------------------------------------------------\r\n// File: 'ProggyClean.ttf' (41208 bytes)\r\n// Exported using binary_to_compressed_c.cpp\r\n//-----------------------------------------------------------------------------\r\nstatic const char proggy_clean_ttf_compressed_data_base85[11980+1] =\r\n    \"7])#######hV0qs'/###[),##/l:$#Q6>##5[n42>c-TH`->>#/e>11NNV=Bv(*:.F?uu#(gRU.o0XGH`$vhLG1hxt9?W`#,5LsCp#-i>.r$<$6pD>Lb';9Crc6tgXmKVeU2cD4Eo3R/\"\r\n    \"2*>]b(MC;$jPfY.;h^`IWM9<Lh2TlS+f-s$o6Q<BWH`YiU.xfLq$N;$0iR/GX:U(jcW2p/W*q?-qmnUCI;jHSAiFWM.R*kU@C=GH?a9wp8f$e.-4^Qg1)Q-GL(lf(r/7GrRgwV%MS=C#\"\r\n    \"`8ND>Qo#t'X#(v#Y9w0#1D$CIf;W'#pWUPXOuxXuU(H9M(1<q-UE31#^-V'8IRUo7Qf./L>=Ke$$'5F%)]0^#0X@U.a<r:QLtFsLcL6##lOj)#.Y5<-R&KgLwqJfLgN&;Q?gI^#DY2uL\"\r\n    \"i@^rMl9t=cWq6##weg>$FBjVQTSDgEKnIS7EM9>ZY9w0#L;>>#Mx&4Mvt//L[MkA#W@lK.N'[0#7RL_&#w+F%HtG9M#XL`N&.,GM4Pg;-<nLENhvx>-VsM.M0rJfLH2eTM`*oJMHRC`N\"\r\n    \"kfimM2J,W-jXS:)r0wK#@Fge$U>`w'N7G#$#fB#$E^$#:9:hk+eOe--6x)F7*E%?76%^GMHePW-Z5l'&GiF#$956:rS?dA#fiK:)Yr+`&#0j@'DbG&#^$PG.Ll+DNa<XCMKEV*N)LN/N\"\r\n    \"*b=%Q6pia-Xg8I$<MR&,VdJe$<(7G;Ckl'&hF;;$<_=X(b.RS%%)###MPBuuE1V:v&cX&#2m#(&cV]`k9OhLMbn%s$G2,B$BfD3X*sp5#l,$R#]x_X1xKX%b5U*[r5iMfUo9U`N99hG)\"\r\n    \"tm+/Us9pG)XPu`<0s-)WTt(gCRxIg(%6sfh=ktMKn3j)<6<b5Sk_/0(^]AaN#(p/L>&VZ>1i%h1S9u5o@YaaW$e+b<TWFn/Z:Oh(Cx2$lNEoN^e)#CFY@@I;BOQ*sRwZtZxRcU7uW6CX\"\r\n    \"ow0i(?$Q[cjOd[P4d)]>ROPOpxTO7Stwi1::iB1q)C_=dV26J;2,]7op$]uQr@_V7$q^%lQwtuHY]=DX,n3L#0PHDO4f9>dC@O>HBuKPpP*E,N+b3L#lpR/MrTEH.IAQk.a>D[.e;mc.\"\r\n    \"x]Ip.PH^'/aqUO/$1WxLoW0[iLA<QT;5HKD+@qQ'NQ(3_PLhE48R.qAPSwQ0/WK?Z,[x?-J;jQTWA0X@KJ(_Y8N-:/M74:/-ZpKrUss?d#dZq]DAbkU*JqkL+nwX@@47`5>w=4h(9.`G\"\r\n    \"CRUxHPeR`5Mjol(dUWxZa(>STrPkrJiWx`5U7F#.g*jrohGg`cg:lSTvEY/EV_7H4Q9[Z%cnv;JQYZ5q.l7Zeas:HOIZOB?G<Nald$qs]@]L<J7bR*>gv:[7MI2k).'2($5FNP&EQ(,)\"\r\n    \"U]W]+fh18.vsai00);D3@4ku5P?DP8aJt+;qUM]=+b'8@;mViBKx0DE[-auGl8:PJ&Dj+M6OC]O^((##]`0i)drT;-7X`=-H3[igUnPG-NZlo.#k@h#=Ork$m>a>$-?Tm$UV(?#P6YY#\"\r\n    \"'/###xe7q.73rI3*pP/$1>s9)W,JrM7SN]'/4C#v$U`0#V.[0>xQsH$fEmPMgY2u7Kh(G%siIfLSoS+MK2eTM$=5,M8p`A.;_R%#u[K#$x4AG8.kK/HSB==-'Ie/QTtG?-.*^N-4B/ZM\"\r\n    \"_3YlQC7(p7q)&](`6_c)$/*JL(L-^(]$wIM`dPtOdGA,U3:w2M-0<q-]L_?^)1vw'.,MRsqVr.L;aN&#/EgJ)PBc[-f>+WomX2u7lqM2iEumMTcsF?-aT=Z-97UEnXglEn1K-bnEO`gu\"\r\n    \"Ft(c%=;Am_Qs@jLooI&NX;]0#j4#F14;gl8-GQpgwhrq8'=l_f-b49'UOqkLu7-##oDY2L(te+Mch&gLYtJ,MEtJfLh'x'M=$CS-ZZ%P]8bZ>#S?YY#%Q&q'3^Fw&?D)UDNrocM3A76/\"\r\n    \"/oL?#h7gl85[qW/NDOk%16ij;+:1a'iNIdb-ou8.P*w,v5#EI$TWS>Pot-R*H'-SEpA:g)f+O$%%`kA#G=8RMmG1&O`>to8bC]T&$,n.LoO>29sp3dt-52U%VM#q7'DHpg+#Z9%H[K<L\"\r\n    \"%a2E-grWVM3@2=-k22tL]4$##6We'8UJCKE[d_=%wI;'6X-GsLX4j^SgJ$##R*w,vP3wK#iiW&#*h^D&R?jp7+/u&#(AP##XU8c$fSYW-J95_-Dp[g9wcO&#M-h1OcJlc-*vpw0xUX&#\"\r\n    \"OQFKNX@QI'IoPp7nb,QU//MQ&ZDkKP)X<WSVL(68uVl&#c'[0#(s1X&xm$Y%B7*K:eDA323j998GXbA#pwMs-jgD$9QISB-A_(aN4xoFM^@C58D0+Q+q3n0#3U1InDjF682-SjMXJK)(\"\r\n    \"h$hxua_K]ul92%'BOU&#BRRh-slg8KDlr:%L71Ka:.A;%YULjDPmL<LYs8i#XwJOYaKPKc1h:'9Ke,g)b),78=I39B;xiY$bgGw-&.Zi9InXDuYa%G*f2Bq7mn9^#p1vv%#(Wi-;/Z5h\"\r\n    \"o;#2:;%d&#x9v68C5g?ntX0X)pT`;%pB3q7mgGN)3%(P8nTd5L7GeA-GL@+%J3u2:(Yf>et`e;)f#Km8&+DC$I46>#Kr]]u-[=99tts1.qb#q72g1WJO81q+eN'03'eM>&1XxY-caEnO\"\r\n    \"j%2n8)),?ILR5^.Ibn<-X-Mq7[a82Lq:F&#ce+S9wsCK*x`569E8ew'He]h:sI[2LM$[guka3ZRd6:t%IG:;$%YiJ:Nq=?eAw;/:nnDq0(CYcMpG)qLN4$##&J<j$UpK<Q4a1]MupW^-\"\r\n    \"sj_$%[HK%'F####QRZJ::Y3EGl4'@%FkiAOg#p[##O`gukTfBHagL<LHw%q&OV0##F=6/:chIm0@eCP8X]:kFI%hl8hgO@RcBhS-@Qb$%+m=hPDLg*%K8ln(wcf3/'DW-$.lR?n[nCH-\"\r\n    \"eXOONTJlh:.RYF%3'p6sq:UIMA945&^HFS87@$EP2iG<-lCO$%c`uKGD3rC$x0BL8aFn--`ke%#HMP'vh1/R&O_J9'um,.<tx[@%wsJk&bUT2`0uMv7gg#qp/ij.L56'hl;.s5CUrxjO\"\r\n    \"M7-##.l+Au'A&O:-T72L]P`&=;ctp'XScX*rU.>-XTt,%OVU4)S1+R-#dg0/Nn?Ku1^0f$B*P:Rowwm-`0PKjYDDM'3]d39VZHEl4,.j']Pk-M.h^&:0FACm$maq-&sgw0t7/6(^xtk%\"\r\n    \"LuH88Fj-ekm>GA#_>568x6(OFRl-IZp`&b,_P'$M<Jnq79VsJW/mWS*PUiq76;]/NM_>hLbxfc$mj`,O;&%W2m`Zh:/)Uetw:aJ%]K9h:TcF]u_-Sj9,VK3M.*'&0D[Ca]J9gp8,kAW]\"\r\n    \"%(?A%R$f<->Zts'^kn=-^@c4%-pY6qI%J%1IGxfLU9CP8cbPlXv);C=b),<2mOvP8up,UVf3839acAWAW-W?#ao/^#%KYo8fRULNd2.>%m]UK:n%r$'sw]J;5pAoO_#2mO3n,'=H5(et\"\r\n    \"Hg*`+RLgv>=4U8guD$I%D:W>-r5V*%j*W:Kvej.Lp$<M-SGZ':+Q_k+uvOSLiEo(<aD/K<CCc`'Lx>'?;++O'>()jLR-^u68PHm8ZFWe+ej8h:9r6L*0//c&iH&R8pRbA#Kjm%upV1g:\"\r\n    \"a_#Ur7FuA#(tRh#.Y5K+@?3<-8m0$PEn;J:rh6?I6uG<-`wMU'ircp0LaE_OtlMb&1#6T.#FDKu#1Lw%u%+GM+X'e?YLfjM[VO0MbuFp7;>Q&#WIo)0@F%q7c#4XAXN-U&VB<HFF*qL(\"\r\n    \"$/V,;(kXZejWO`<[5?\\?ewY(*9=%wDc;,u<'9t3W-(H1th3+G]ucQ]kLs7df($/*JL]@*t7Bu_G3_7mp7<iaQjO@.kLg;x3B0lqp7Hf,^Ze7-##@/c58Mo(3;knp0%)A7?-W+eI'o8)b<\"\r\n    \"nKnw'Ho8C=Y>pqB>0ie&jhZ[?iLR@@_AvA-iQC(=ksRZRVp7`.=+NpBC%rh&3]R:8XDmE5^V8O(x<<aG/1N$#FX$0V5Y6x'aErI3I$7x%E`v<-BY,)%-?Psf*l?%C3.mM(=/M0:JxG'?\"\r\n    \"7WhH%o'a<-80g0NBxoO(GH<dM]n.+%q@jH?f.UsJ2Ggs&4<-e47&Kl+f//9@`b+?.TeN_&B8Ss?v;^Trk;f#YvJkl&w$]>-+k?'(<S:68tq*WoDfZu';mM?8X[ma8W%*`-=;D.(nc7/;\"\r\n    \")g:T1=^J$&BRV(-lTmNB6xqB[@0*o.erM*<SWF]u2=st-*(6v>^](H.aREZSi,#1:[IXaZFOm<-ui#qUq2$##Ri;u75OK#(RtaW-K-F`S+cF]uN`-KMQ%rP/Xri.LRcB##=YL3BgM/3M\"\r\n    \"D?@f&1'BW-)Ju<L25gl8uhVm1hL$##*8###'A3/LkKW+(^rWX?5W_8g)a(m&K8P>#bmmWCMkk&#TR`C,5d>g)F;t,4:@_l8G/5h4vUd%&%950:VXD'QdWoY-F$BtUwmfe$YqL'8(PWX(\"\r\n    \"P?^@Po3$##`MSs?DWBZ/S>+4%>fX,VWv/w'KD`LP5IbH;rTV>n3cEK8U#bX]l-/V+^lj3;vlMb&[5YQ8#pekX9JP3XUC72L,,?+Ni&co7ApnO*5NK,((W-i:$,kp'UDAO(G0Sq7MVjJs\"\r\n    \"bIu)'Z,*[>br5fX^:FPAWr-m2KgL<LUN098kTF&#lvo58=/vjDo;.;)Ka*hLR#/k=rKbxuV`>Q_nN6'8uTG&#1T5g)uLv:873UpTLgH+#FgpH'_o1780Ph8KmxQJ8#H72L4@768@Tm&Q\"\r\n    \"h4CB/5OvmA&,Q&QbUoi$a_%3M01H)4x7I^&KQVgtFnV+;[Pc>[m4k//,]1?#`VY[Jr*3&&slRfLiVZJ:]?=K3Sw=[$=uRB?3xk48@aeg<Z'<$#4H)6,>e0jT6'N#(q%.O=?2S]u*(m<-\"\r\n    \"V8J'(1)G][68hW$5'q[GC&5j`TE?m'esFGNRM)j,ffZ?-qx8;->g4t*:CIP/[Qap7/9'#(1sao7w-.qNUdkJ)tCF&#B^;xGvn2r9FEPFFFcL@.iFNkTve$m%#QvQS8U@)2Z+3K:AKM5i\"\r\n    \"sZ88+dKQ)W6>J%CL<KE>`.d*(B`-n8D9oK<Up]c$X$(,)M8Zt7/[rdkqTgl-0cuGMv'?>-XV1q['-5k'cAZ69e;D_?$ZPP&s^+7])$*$#@QYi9,5P&#9r+$%CE=68>K8r0=dSC%%(@p7\"\r\n    \".m7jilQ02'0-VWAg<a/''3u.=4L$Y)6k/K:_[3=&jvL<L0C/2'v:^;-DIBW,B4E68:kZ;%?8(Q8BH=kO65BW?xSG&#@uU,DS*,?.+(o(#1vCS8#CHF>TlGW'b)Tq7VT9q^*^$$.:&N@@\"\r\n    \"$&)WHtPm*5_rO0&e%K&#-30j(E4#'Zb.o/(Tpm$>K'f@[PvFl,hfINTNU6u'0pao7%XUp9]5.>%h`8_=VYbxuel.NTSsJfLacFu3B'lQSu/m6-Oqem8T+oE--$0a/k]uj9EwsG>%veR*\"\r\n    \"hv^BFpQj:K'#SJ,sB-'#](j.Lg92rTw-*n%@/;39rrJF,l#qV%OrtBeC6/,;qB3ebNW[?,Hqj2L.1NP&GjUR=1D8QaS3Up&@*9wP?+lo7b?@%'k4`p0Z$22%K3+iCZj?XJN4Nm&+YF]u\"\r\n    \"@-W$U%VEQ/,,>>#)D<h#`)h0:<Q6909ua+&VU%n2:cG3FJ-%@Bj-DgLr`Hw&HAKjKjseK</xKT*)B,N9X3]krc12t'pgTV(Lv-tL[xg_%=M_q7a^x?7Ubd>#%8cY#YZ?=,`Wdxu/ae&#\"\r\n    \"w6)R89tI#6@s'(6Bf7a&?S=^ZI_kS&ai`&=tE72L_D,;^R)7[$s<Eh#c&)q.MXI%#v9ROa5FZO%sF7q7Nwb&#ptUJ:aqJe$Sl68%.D###EC><?-aF&#RNQv>o8lKN%5/$(vdfq7+ebA#\"\r\n    \"u1p]ovUKW&Y%q]'>$1@-[xfn$7ZTp7mM,G,Ko7a&Gu%G[RMxJs[0MM%wci.LFDK)(<c`Q8N)jEIF*+?P2a8g%)$q]o2aH8C&<SibC/q,(e:v;-b#6[$NtDZ84Je2KNvB#$P5?tQ3nt(0\"\r\n    \"d=j.LQf./Ll33+(;q3L-w=8dX$#WF&uIJ@-bfI>%:_i2B5CsR8&9Z&#=mPEnm0f`<&c)QL5uJ#%u%lJj+D-r;BoF&#4DoS97h5g)E#o:&S4weDF,9^Hoe`h*L+_a*NrLW-1pG_&2UdB8\"\r\n    \"6e%B/:=>)N4xeW.*wft-;$'58-ESqr<b?UI(_%@[P46>#U`'6AQ]m&6/`Z>#S?YY#Vc;r7U2&326d=w&H####?TZ`*4?&.MK?LP8Vxg>$[QXc%QJv92.(Db*B)gb*BM9dM*hJMAo*c&#\"\r\n    \"b0v=Pjer]$gG&JXDf->'StvU7505l9$AFvgYRI^&<^b68?j#q9QX4SM'RO#&sL1IM.rJfLUAj221]d##DW=m83u5;'bYx,*Sl0hL(W;;$doB&O/TQ:(Z^xBdLjL<Lni;''X.`$#8+1GD\"\r\n    \":k$YUWsbn8ogh6rxZ2Z9]%nd+>V#*8U_72Lh+2Q8Cj0i:6hp&$C/:p(HK>T8Y[gHQ4`4)'$Ab(Nof%V'8hL&#<NEdtg(n'=S1A(Q1/I&4([%dM`,Iu'1:_hL>SfD07&6D<fp8dHM7/g+\"\r\n    \"tlPN9J*rKaPct&?'uBCem^jn%9_K)<,C5K3s=5g&GmJb*[SYq7K;TRLGCsM-$$;S%:Y@r7AK0pprpL<Lrh,q7e/%KWK:50I^+m'vi`3?%Zp+<-d+$L-Sv:@.o19n$s0&39;kn;S%BSq*\"\r\n    \"$3WoJSCLweV[aZ'MQIjO<7;X-X;&+dMLvu#^UsGEC9WEc[X(wI7#2.(F0jV*eZf<-Qv3J-c+J5AlrB#$p(H68LvEA'q3n0#m,[`*8Ft)FcYgEud]CWfm68,(aLA$@EFTgLXoBq/UPlp7\"\r\n    \":d[/;r_ix=:TF`S5H-b<LI&HY(K=h#)]Lk$K14lVfm:x$H<3^Ql<M`$OhapBnkup'D#L$Pb_`N*g]2e;X/Dtg,bsj&K#2[-:iYr'_wgH)NUIR8a1n#S?Yej'h8^58UbZd+^FKD*T@;6A\"\r\n    \"7aQC[K8d-(v6GI$x:T<&'Gp5Uf>@M.*J:;$-rv29'M]8qMv-tLp,'886iaC=Hb*YJoKJ,(j%K=H`K.v9HggqBIiZu'QvBT.#=)0ukruV&.)3=(^1`o*Pj4<-<aN((^7('#Z0wK#5GX@7\"\r\n    \"u][`*S^43933A4rl][`*O4CgLEl]v$1Q3AeF37dbXk,.)vj#x'd`;qgbQR%FW,2(?LO=s%Sc68%NP'##Aotl8x=BE#j1UD([3$M(]UI2LX3RpKN@;/#f'f/&_mt&F)XdF<9t4)Qa.*kT\"\r\n    \"LwQ'(TTB9.xH'>#MJ+gLq9-##@HuZPN0]u:h7.T..G:;$/Usj(T7`Q8tT72LnYl<-qx8;-HV7Q-&Xdx%1a,hC=0u+HlsV>nuIQL-5<N?)NBS)QN*_I,?&)2'IM%L3I)X((e/dl2&8'<M\"\r\n    \":^#M*Q+[T.Xri.LYS3v%fF`68h;b-X[/En'CR.q7E)p'/kle2HM,u;^%OKC-N+Ll%F9CF<Nf'^#t2L,;27W:0O@6##U6W7:$rJfLWHj$#)woqBefIZ.PK<b*t7ed;p*_m;4ExK#h@&]>\"\r\n    \"_>@kXQtMacfD.m-VAb8;IReM3$wf0''hra*so568'Ip&vRs849'MRYSp%:t:h5qSgwpEr$B>Q,;s(C#$)`svQuF$##-D,##,g68@2[T;.XSdN9Qe)rpt._K-#5wF)sP'##p#C0c%-Gb%\"\r\n    \"hd+<-j'Ai*x&&HMkT]C'OSl##5RG[JXaHN;d'uA#x._U;.`PU@(Z3dt4r152@:v,'R.Sj'w#0<-;kPI)FfJ&#AYJ&#//)>-k=m=*XnK$>=)72L]0I%>.G690a:$##<,);?;72#?x9+d;\"\r\n    \"^V'9;jY@;)br#q^YQpx:X#Te$Z^'=-=bGhLf:D6&bNwZ9-ZD#n^9HhLMr5G;']d&6'wYmTFmL<LD)F^%[tC'8;+9E#C$g%#5Y>q9wI>P(9mI[>kC-ekLC/R&CH+s'B;K-M6$EB%is00:\"\r\n    \"+A4[7xks.LrNk0&E)wILYF@2L'0Nb$+pv<(2.768/FrY&h$^3i&@+G%JT'<-,v`3;_)I9M^AE]CN?Cl2AZg+%4iTpT3<n-&%H%b<FDj2M<hH=&Eh<2Len$b*aTX=-8QxN)k11IM1c^j%\"\r\n    \"9s<L<NFSo)B?+<-(GxsF,^-Eh@$4dXhN$+#rxK8'je'D7k`e;)2pYwPA'_p9&@^18ml1^[@g4t*[JOa*[=Qp7(qJ_oOL^('7fB&Hq-:sf,sNj8xq^>$U4O]GKx'm9)b@p7YsvK3w^YR-\"\r\n    \"CdQ*:Ir<($u&)#(&?L9Rg3H)4fiEp^iI9O8KnTj,]H?D*r7'M;PwZ9K0E^k&-cpI;.p/6_vwoFMV<->#%Xi.LxVnrU(4&8/P+:hLSKj$#U%]49t'I:rgMi'FL@a:0Y-uA[39',(vbma*\"\r\n    \"hU%<-SRF`Tt:542R_VV$p@[p8DV[A,?1839FWdF<TddF<9Ah-6&9tWoDlh]&1SpGMq>Ti1O*H&#(AL8[_P%.M>v^-))qOT*F5Cq0`Ye%+$B6i:7@0IX<N+T+0MlMBPQ*Vj>SsD<U4JHY\"\r\n    \"8kD2)2fU/M#$e.)T4,_=8hLim[&);?UkK'-x?'(:siIfL<$pFM`i<?%W(mGDHM%>iWP,##P`%/L<eXi:@Z9C.7o=@(pXdAO/NLQ8lPl+HPOQa8wD8=^GlPa8TKI1CjhsCTSLJM'/Wl>-\"\r\n    \"S(qw%sf/@%#B6;/U7K]uZbi^Oc^2n<bhPmUkMw>%t<)'mEVE''n`WnJra$^TKvX5B>;_aSEK',(hwa0:i4G?.Bci.(X[?b*($,=-n<.Q%`(X=?+@Am*Js0&=3bh8K]mL<LoNs'6,'85`\"\r\n    \"0?t/'_U59@]ddF<#LdF<eWdF<OuN/45rY<-L@&#+fm>69=Lb,OcZV/);TTm8VI;?%OtJ<(b4mq7M6:u?KRdF<gR@2L=FNU-<b[(9c/ML3m;Z[$oF3g)GAWqpARc=<ROu7cL5l;-[A]%/\"\r\n    \"+fsd;l#SafT/f*W]0=O'$(Tb<[)*@e775R-:Yob%g*>l*:xP?Yb.5)%w_I?7uk5JC+FS(m#i'k.'a0i)9<7b'fs'59hq$*5Uhv##pi^8+hIEBF`nvo`;'l0.^S1<-wUK2/Coh58KKhLj\"\r\n    \"M=SO*rfO`+qC`W-On.=AJ56>>i2@2LH6A:&5q`?9I3@@'04&p2/LVa*T-4<-i3;M9UvZd+N7>b*eIwg:CC)c<>nO&#<IGe;__.thjZl<%w(Wk2xmp4Q@I#I9,DF]u7-P=.-_:YJ]aS@V\"\r\n    \"?6*C()dOp7:WL,b&3Rg/.cmM9&r^>$(>.Z-I&J(Q0Hd5Q%7Co-b`-c<N(6r@ip+AurK<m86QIth*#v;-OBqi+L7wDE-Ir8K['m+DDSLwK&/.?-V%U_%3:qKNu$_b*B-kp7NaD'QdWQPK\"\r\n    \"Yq[@>P)hI;*_F]u`Rb[.j8_Q/<&>uu+VsH$sM9TA%?)(vmJ80),P7E>)tjD%2L=-t#fK[%`v=Q8<FfNkgg^oIbah*#8/Qt$F&:K*-(N/'+1vMB,u()-a.VUU*#[e%gAAO(S>WlA2);Sa\"\r\n    \">gXm8YB`1d@K#n]76-a$U,mF<fX]idqd)<3,]J7JmW4`6]uks=4-72L(jEk+:bJ0M^q-8Dm_Z?0olP1C9Sa&H[d&c$ooQUj]Exd*3ZM@-WGW2%s',B-_M%>%Ul:#/'xoFM9QX-$.QN'>\"\r\n    \"[%$Z$uF6pA6Ki2O5:8w*vP1<-1`[G,)-m#>0`P&#eb#.3i)rtB61(o'$?X3B</R90;eZ]%Ncq;-Tl]#F>2Qft^ae_5tKL9MUe9b*sLEQ95C&`=G?@Mj=wh*'3E>=-<)Gt*Iw)'QG:`@I\"\r\n    \"wOf7&]1i'S01B+Ev/Nac#9S;=;YQpg_6U`*kVY39xK,[/6Aj7:'1Bm-_1EYfa1+o&o4hp7KN_Q(OlIo@S%;jVdn0'1<Vc52=u`3^o-n1'g4v58Hj&6_t7$##?M)c<$bgQ_'SY((-xkA#\"\r\n    \"Y(,p'H9rIVY-b,'%bCPF7.J<Up^,(dU1VY*5#WkTU>h19w,WQhLI)3S#f$2(eb,jr*b;3Vw]*7NH%$c4Vs,eD9>XW8?N]o+(*pgC%/72LV-u<Hp,3@e^9UB1J+ak9-TN/mhKPg+AJYd$\"\r\n    \"MlvAF_jCK*.O-^(63adMT->W%iewS8W6m2rtCpo'RS1R84=@paTKt)>=%&1[)*vp'u+x,VrwN;&]kuO9JDbg=pO$J*.jVe;u'm0dr9l,<*wMK*Oe=g8lV_KEBFkO'oU]^=[-792#ok,)\"\r\n    \"i]lR8qQ2oA8wcRCZ^7w/Njh;?.stX?Q1>S1q4Bn$)K1<-rGdO'$Wr.Lc.CG)$/*JL4tNR/,SVO3,aUw'DJN:)Ss;wGn9A32ijw%FL+Z0Fn.U9;reSq)bmI32U==5ALuG&#Vf1398/pVo\"\r\n    \"1*c-(aY168o<`JsSbk-,1N;$>0:OUas(3:8Z972LSfF8eb=c-;>SPw7.6hn3m`9^Xkn(r.qS[0;T%&Qc=+STRxX'q1BNk3&*eu2;&8q$&x>Q#Q7^Tf+6<(d%ZVmj2bDi%.3L2n+4W'$P\"\r\n    \"iDDG)g,r%+?,$@?uou5tSe2aN_AQU*<h`e-GI7)?OK2A.d7_c)?wQ5AS@DL3r#7fSkgl6-++D:'A,uq7SvlB$pcpH'q3n0#_%dY#xCpr-l<F0NR@-##FEV6NTF6##$l84N1w?AO>'IAO\"\r\n    \"URQ##V^Fv-XFbGM7Fl(N<3DhLGF%q.1rC$#:T__&Pi68%0xi_&[qFJ(77j_&JWoF.V735&T,[R*:xFR*K5>>#`bW-?4Ne_&6Ne_&6Ne_&n`kr-#GJcM6X;uM6X;uM(.a..^2TkL%oR(#\"\r\n    \";u.T%fAr%4tJ8&><1=GHZ_+m9/#H1F^R#SC#*N=BA9(D?v[UiFY>>^8p,KKF.W]L29uLkLlu/+4T<XoIB&hx=T1PcDaB&;HH+-AFr?(m9HZV)FKS8JCw;SD=6[^/DZUL`EUDf]GGlG&>\"\r\n    \"w$)F./^n3+rlo+DB;5sIYGNk+i1t-69Jg--0pao7Sm#K)pdHW&;LuDNH@H>#/X-TI(;P>#,Gc>#0Su>#4`1?#8lC?#<xU?#@.i?#D:%@#HF7@#LRI@#P_[@#Tkn@#Xw*A#]-=A#a9OA#\"\r\n    \"d<F&#*;G##.GY##2Sl##6`($#:l:$#>xL$#B.`$#F:r$#JF.%#NR@%#R_R%#Vke%#Zww%#_-4&#3^Rh%Sflr-k'MS.o?.5/sWel/wpEM0%3'/1)K^f1-d>G21&v(35>V`39V7A4=onx4\"\r\n    \"A1OY5EI0;6Ibgr6M$HS7Q<)58C5w,;WoA*#[%T*#`1g*#d=#+#hI5+#lUG+#pbY+#tnl+#x$),#&1;,#*=M,#.I`,#2Ur,#6b.-#;w[H#iQtA#m^0B#qjBB#uvTB##-hB#'9$C#+E6C#\"\r\n    \"/QHC#3^ZC#7jmC#;v)D#?,<D#C8ND#GDaD#KPsD#O]/E#g1A5#KA*1#gC17#MGd;#8(02#L-d3#rWM4#Hga1#,<w0#T.j<#O#'2#CYN1#qa^:#_4m3#o@/=#eG8=#t8J5#`+78#4uI-#\"\r\n    \"m3B2#SB[8#Q0@8#i[*9#iOn8#1Nm;#^sN9#qh<9#:=x-#P;K2#$%X9#bC+.#Rg;<#mN=.#MTF.#RZO.#2?)4#Y#(/#[)1/#b;L/#dAU/#0Sv;#lY$0#n`-0#sf60#(F24#wrH0#%/e0#\"\r\n    \"TmD<#%JSMFove:CTBEXI:<eh2g)B,3h2^G3i;#d3jD>)4kMYD4lVu`4m`:&5niUA5@(A5BA1]PBB:xlBCC=2CDLXMCEUtiCf&0g2'tN?PGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CP\"\r\n    \"GT4CPGT4CPGT4CPGT4CPGT4CPGT4CP-qekC`.9kEg^+F$kwViFJTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5o,^<-28ZI'O?;xp\"\r\n    \"O?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xp;7q-#lLYI:xvD=#\";\r\n\r\nstatic const char* GetDefaultCompressedFontDataTTFBase85()\r\n{\r\n    return proggy_clean_ttf_compressed_data_base85;\r\n}\r\n","// ImGui SDL2 binding with OpenGL3\r\n// In this binding, ImTextureID is used to store an OpenGL 'GLuint' texture identifier. Read the FAQ about ImTextureID in imgui.cpp.\r\n// (SDL is a cross-platform general purpose library for handling windows, inputs, OpenGL/Vulkan graphics context creation, etc.)\r\n// (GL3W is a helper library to access OpenGL functions since there is no standard header to access modern OpenGL functions easily. Alternatives are GLEW, Glad, etc.)\r\n\r\n// You can copy and use unmodified imgui_impl_* files in your project. See main.cpp for an example of using this.\r\n// If you use this binding you'll need to call 4 functions: ImGui_ImplXXXX_Init(), ImGui_ImplXXXX_NewFrame(), ImGui::Render() and ImGui_ImplXXXX_Shutdown().\r\n// If you are new to ImGui, see examples/README.txt and documentation at the top of imgui.cpp.\r\n// https://github.com/ocornut/imgui\r\n\r\n#include \"imgui.h\"\r\n#include \"imgui_impl_sdl_gl3.h\"\r\n\r\n// SDL,GL3W\r\n#include <SDL2/SDL.h>\r\n\r\n#if _WIN32\r\n#include <SDL2/SDL_syswm.h>\r\n#endif\r\n\r\n#ifndef __EMSCRIPTEN__\r\n#include <glad/glad.h>\r\n#else\r\n#undef  glBindVertexArray\r\n#define glBindVertexArray glBindVertexArrayOES\r\n#endif\r\n// #include <GL/gl3w.h>    // This example is using gl3w to access OpenGL functions (because it is small). You may use glew/glad/glLoadGen/etc. whatever already works for you.\r\n\r\n// Data\r\nstatic double       g_Time = 0.0f;\r\nstatic bool         g_MousePressed[3] = { false, false, false };\r\nstatic float        g_MouseWheel = 0.0f;\r\nstatic GLuint       g_FontTexture = 0;\r\nstatic int          g_ShaderHandle = 0, g_VertHandle = 0, g_FragHandle = 0;\r\nstatic int          g_AttribLocationTex = 0, g_AttribLocationProjMtx = 0;\r\nstatic int          g_AttribLocationPosition = 0, g_AttribLocationUV = 0, g_AttribLocationColor = 0;\r\nstatic unsigned int g_VboHandle = 0, g_VaoHandle = 0, g_ElementsHandle = 0;\r\n\r\n// This is the main rendering function that you have to implement and provide to ImGui (via setting up 'RenderDrawListsFn' in the ImGuiIO structure)\r\n// Note that this implementation is little overcomplicated because we are saving/setting up/restoring every OpenGL state explicitly, in order to be able to run within any OpenGL engine that doesn't do so. \r\n// If text or lines are blurry when integrating ImGui in your engine: in your Render function, try translating your projection matrix by (0.5f,0.5f) or (0.375f,0.375f)\r\nvoid ImGui_ImplSdlGL3_RenderDrawLists(ImDrawData* draw_data)\r\n{\r\n    // Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer coordinates)\r\n    ImGuiIO& io = ImGui::GetIO();\r\n    int fb_width = (int)(io.DisplaySize.x * io.DisplayFramebufferScale.x);\r\n    int fb_height = (int)(io.DisplaySize.y * io.DisplayFramebufferScale.y);\r\n    if (fb_width == 0 || fb_height == 0)\r\n        return;\r\n    draw_data->ScaleClipRects(io.DisplayFramebufferScale);\r\n\r\n    // Backup GL state\r\n    GLenum last_active_texture; glGetIntegerv(GL_ACTIVE_TEXTURE, (GLint*)&last_active_texture);\r\n    glActiveTexture(GL_TEXTURE0);\r\n    GLint last_program; glGetIntegerv(GL_CURRENT_PROGRAM, &last_program);\r\n    GLint last_texture; glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture);\r\n\r\n#ifndef __EMSCRIPTEN__\r\n    GLint last_sampler; glGetIntegerv(GL_SAMPLER_BINDING, &last_sampler);\r\n    GLint last_array_buffer; glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &last_array_buffer);\r\n    GLint last_element_array_buffer; glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &last_element_array_buffer);\r\n    GLint last_vertex_array; glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &last_vertex_array);\r\n    GLint last_polygon_mode[2]; glGetIntegerv(GL_POLYGON_MODE, last_polygon_mode);\r\n#endif\r\n    GLint last_viewport[4]; glGetIntegerv(GL_VIEWPORT, last_viewport);\r\n    GLint last_scissor_box[4]; glGetIntegerv(GL_SCISSOR_BOX, last_scissor_box);\r\n    GLenum last_blend_src_rgb; glGetIntegerv(GL_BLEND_SRC_RGB, (GLint*)&last_blend_src_rgb);\r\n    GLenum last_blend_dst_rgb; glGetIntegerv(GL_BLEND_DST_RGB, (GLint*)&last_blend_dst_rgb);\r\n    GLenum last_blend_src_alpha; glGetIntegerv(GL_BLEND_SRC_ALPHA, (GLint*)&last_blend_src_alpha);\r\n    GLenum last_blend_dst_alpha; glGetIntegerv(GL_BLEND_DST_ALPHA, (GLint*)&last_blend_dst_alpha);\r\n    GLenum last_blend_equation_rgb; glGetIntegerv(GL_BLEND_EQUATION_RGB, (GLint*)&last_blend_equation_rgb);\r\n    GLenum last_blend_equation_alpha; glGetIntegerv(GL_BLEND_EQUATION_ALPHA, (GLint*)&last_blend_equation_alpha);\r\n    GLboolean last_enable_blend = glIsEnabled(GL_BLEND);\r\n    GLboolean last_enable_cull_face = glIsEnabled(GL_CULL_FACE);\r\n    GLboolean last_enable_depth_test = glIsEnabled(GL_DEPTH_TEST);\r\n    GLboolean last_enable_scissor_test = glIsEnabled(GL_SCISSOR_TEST);\r\n\r\n    // Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled, polygon fill\r\n    glEnable(GL_BLEND);\r\n    glBlendEquation(GL_FUNC_ADD);\r\n    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\r\n    glDisable(GL_CULL_FACE);\r\n#ifndef __EMSCRIPTEN__\r\n    glDisable(GL_DEPTH_TEST);\r\n#endif\r\n    glEnable(GL_SCISSOR_TEST);\r\n#ifndef __EMSCRIPTEN__\r\n    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);\r\n#endif\r\n\r\n    // Setup viewport, orthographic projection matrix\r\n    glViewport(0, 0, (GLsizei)fb_width, (GLsizei)fb_height);\r\n    const float ortho_projection[4][4] =\r\n    {\r\n        { 2.0f/io.DisplaySize.x, 0.0f,                   0.0f, 0.0f },\r\n        { 0.0f,                  2.0f/-io.DisplaySize.y, 0.0f, 0.0f },\r\n        { 0.0f,                  0.0f,                  -1.0f, 0.0f },\r\n        {-1.0f,                  1.0f,                   0.0f, 1.0f },\r\n    };\r\n    glUseProgram(g_ShaderHandle);\r\n    glUniform1i(g_AttribLocationTex, 0);\r\n    glUniformMatrix4fv(g_AttribLocationProjMtx, 1, GL_FALSE, &ortho_projection[0][0]);\r\n#ifndef __EMSCRIPTEN__\r\n    glBindVertexArray(g_VaoHandle);\r\n    glBindSampler(0, 0); // Rely on combined texture/sampler state.\r\n#else\r\n\tglBindVertexArrayOES(g_VaoHandle);\r\n#endif\r\n\r\n    for (int n = 0; n < draw_data->CmdListsCount; n++)\r\n    {\r\n        const ImDrawList* cmd_list = draw_data->CmdLists[n];\r\n        const ImDrawIdx* idx_buffer_offset = 0;\r\n\r\n        glBindBuffer(GL_ARRAY_BUFFER, g_VboHandle);\r\n        glBufferData(GL_ARRAY_BUFFER, (GLsizeiptr)cmd_list->VtxBuffer.Size * sizeof(ImDrawVert), (const GLvoid*)cmd_list->VtxBuffer.Data, GL_STREAM_DRAW);\r\n\r\n        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_ElementsHandle);\r\n        glBufferData(GL_ELEMENT_ARRAY_BUFFER, (GLsizeiptr)cmd_list->IdxBuffer.Size * sizeof(ImDrawIdx), (const GLvoid*)cmd_list->IdxBuffer.Data, GL_STREAM_DRAW);\r\n\r\n        for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)\r\n        {\r\n            const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];\r\n            if (pcmd->UserCallback)\r\n            {\r\n                pcmd->UserCallback(cmd_list, pcmd);\r\n            }\r\n            else\r\n            {\r\n                glBindTexture(GL_TEXTURE_2D, (GLuint)(intptr_t)pcmd->TextureId);\r\n                glScissor((int)pcmd->ClipRect.x, (int)(fb_height - pcmd->ClipRect.w), (int)(pcmd->ClipRect.z - pcmd->ClipRect.x), (int)(pcmd->ClipRect.w - pcmd->ClipRect.y));\r\n                glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);\r\n            }\r\n            idx_buffer_offset += pcmd->ElemCount;\r\n        }\r\n    }\r\n\r\n    // Restore modified GL state\r\n    glUseProgram(last_program);\r\n    glBindTexture(GL_TEXTURE_2D, last_texture);\r\n#ifndef __EMSCRIPTEN__\r\n    glBindSampler(0, last_sampler);\r\n#endif\r\n    glActiveTexture(last_active_texture);\r\n#ifndef __EMSCRIPTEN__\r\n    glBindVertexArray(last_vertex_array);\r\n    glBindBuffer(GL_ARRAY_BUFFER, last_array_buffer);\r\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, last_element_array_buffer);\r\n#endif\r\n    glBlendEquationSeparate(last_blend_equation_rgb, last_blend_equation_alpha);\r\n    glBlendFuncSeparate(last_blend_src_rgb, last_blend_dst_rgb, last_blend_src_alpha, last_blend_dst_alpha);\r\n    if (last_enable_blend) glEnable(GL_BLEND); else glDisable(GL_BLEND);\r\n    if (last_enable_cull_face) glEnable(GL_CULL_FACE); else glDisable(GL_CULL_FACE);\r\n    if (last_enable_depth_test) glEnable(GL_DEPTH_TEST); else glDisable(GL_DEPTH_TEST);\r\n    if (last_enable_scissor_test) glEnable(GL_SCISSOR_TEST); else glDisable(GL_SCISSOR_TEST);\r\n#ifndef __EMSCRIPTEN__\r\n    glPolygonMode(GL_FRONT_AND_BACK, last_polygon_mode[0]);\r\n#endif\r\n    glViewport(last_viewport[0], last_viewport[1], (GLsizei)last_viewport[2], (GLsizei)last_viewport[3]);\r\n    glScissor(last_scissor_box[0], last_scissor_box[1], (GLsizei)last_scissor_box[2], (GLsizei)last_scissor_box[3]);\r\n}\r\n\r\nstatic const char* ImGui_ImplSdlGL3_GetClipboardText(void*)\r\n{\r\n    return SDL_GetClipboardText();\r\n}\r\n\r\nstatic void ImGui_ImplSdlGL3_SetClipboardText(void*, const char* text)\r\n{\r\n    SDL_SetClipboardText(text);\r\n}\r\n\r\n// You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if dear imgui wants to use your inputs.\r\n// - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application.\r\n// - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application.\r\n// Generally you may always pass all inputs to dear imgui, and hide them from your application based on those two flags.\r\nbool ImGui_ImplSdlGL3_ProcessEvent(SDL_Event* event)\r\n{\r\n    ImGuiIO& io = ImGui::GetIO();\r\n    switch (event->type)\r\n    {\r\n    case SDL_MOUSEWHEEL:\r\n        {\r\n            if (event->wheel.y > 0)\r\n                g_MouseWheel = 1;\r\n            if (event->wheel.y < 0)\r\n                g_MouseWheel = -1;\r\n            return true;\r\n        }\r\n    case SDL_MOUSEBUTTONDOWN:\r\n        {\r\n            if (event->button.button == SDL_BUTTON_LEFT) g_MousePressed[0] = true;\r\n            if (event->button.button == SDL_BUTTON_RIGHT) g_MousePressed[1] = true;\r\n            if (event->button.button == SDL_BUTTON_MIDDLE) g_MousePressed[2] = true;\r\n            return true;\r\n        }\r\n    case SDL_TEXTINPUT:\r\n        {\r\n            io.AddInputCharactersUTF8(event->text.text);\r\n            return true;\r\n        }\r\n    case SDL_KEYDOWN:\r\n    case SDL_KEYUP:\r\n        {\r\n            int key = event->key.keysym.sym & ~SDLK_SCANCODE_MASK;\r\n            io.KeysDown[key] = (event->type == SDL_KEYDOWN);\r\n            io.KeyShift = ((SDL_GetModState() & KMOD_SHIFT) != 0);\r\n            io.KeyCtrl = ((SDL_GetModState() & KMOD_CTRL) != 0);\r\n            io.KeyAlt = ((SDL_GetModState() & KMOD_ALT) != 0);\r\n            io.KeySuper = ((SDL_GetModState() & KMOD_GUI) != 0);\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nvoid ImGui_ImplSdlGL3_CreateFontsTexture()\r\n{\r\n    // Build texture atlas\r\n    ImGuiIO& io = ImGui::GetIO();\r\n    unsigned char* pixels;\r\n    int width, height;\r\n    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);   // Load as RGBA 32-bits for OpenGL3 demo because it is more likely to be compatible with user's existing shader.\r\n\r\n    // Upload texture to graphics system\r\n    GLint last_texture;\r\n    glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture);\r\n    glGenTextures(1, &g_FontTexture);\r\n    glBindTexture(GL_TEXTURE_2D, g_FontTexture);\r\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\r\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\r\n#ifndef __EMSCRIPTEN__\r\n    glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);\r\n#else\r\n#endif\r\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels);\r\n\r\n    // Store our identifier\r\n    io.Fonts->TexID = (void *)(intptr_t)g_FontTexture;\r\n\r\n    // Restore state\r\n    glBindTexture(GL_TEXTURE_2D, last_texture);\r\n}\r\n\r\nbool ImGui_ImplSdlGL3_CreateDeviceObjects()\r\n{\r\n    // Backup GL state\r\n    GLint last_texture, last_array_buffer, last_vertex_array;\r\n    glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture);\r\n#ifndef __EMSCRIPTEN__\r\n    glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &last_array_buffer);\r\n    glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &last_vertex_array);\r\n#endif\r\n\r\n#ifndef __EMSCRIPTEN__\r\n    const GLchar *vertex_shader =\r\n        \"#version 330\\n\"\r\n        \"uniform mat4 ProjMtx;\\n\"\r\n        \"in vec2 Position;\\n\"\r\n        \"in vec2 UV;\\n\"\r\n        \"in vec4 Color;\\n\"\r\n        \"out vec2 Frag_UV;\\n\"\r\n        \"out vec4 Frag_Color;\\n\"\r\n        \"void main()\\n\"\r\n        \"{\\n\"\r\n        \"\tFrag_UV = UV;\\n\"\r\n        \"\tFrag_Color = Color;\\n\"\r\n        \"\tgl_Position = ProjMtx * vec4(Position.xy,0,1);\\n\"\r\n        \"}\\n\";\r\n\r\n    const GLchar* fragment_shader =\r\n        \"#version 330\\n\"\r\n        \"uniform sampler2D Texture;\\n\"\r\n        \"in vec2 Frag_UV;\\n\"\r\n        \"in vec4 Frag_Color;\\n\"\r\n        \"out vec4 Out_Color;\\n\"\r\n        \"void main()\\n\"\r\n        \"{\\n\"\r\n        \"\tOut_Color = Frag_Color * texture( Texture, Frag_UV.st);\\n\"\r\n        \"}\\n\";\r\n#else\r\n    const GLchar *vertex_shader =\r\n        \"precision mediump;\\n\"\r\n        \"uniform mat4 ProjMtx;\\n\"\r\n        \"attribute vec2 Position;\\n\"\r\n        \"attribute vec2 UV;\\n\"\r\n        \"attribute vec4 Color;\\n\"\r\n        \"varying vec2 Frag_UV;\\n\"\r\n        \"varying vec4 Frag_Color;\\n\"\r\n        \"void main()\\n\"\r\n        \"{\\n\"\r\n        \"\tFrag_UV = UV;\\n\"\r\n        \"\tFrag_Color = Color;\\n\"\r\n        \"\tgl_Position = ProjMtx * vec4(Position.xy,0,1);\\n\"\r\n        \"}\\n\";\r\n\r\n    const GLchar* fragment_shader =\r\n        \"precision mediump;\\n\"\r\n        \"uniform sampler2D Texture;\\n\"\r\n        \"varying vec2 Frag_UV;\\n\"\r\n        \"varying vec4 Frag_Color;\\n\"\r\n        // \"out vec4 Out_Color;\\n\"\r\n        \"void main()\\n\"\r\n        \"{\\n\"\r\n        \"\t// Out_Color = Frag_Color * texture( Texture, Frag_UV.st);\\n\"\r\n\t\t\"   gl_FragColor = Frag_Color * texture2D(Texture, Frag_UV.st);\\n\"\r\n        \"}\\n\";\r\n#endif\r\n\r\n    g_ShaderHandle = glCreateProgram();\r\n    g_VertHandle = glCreateShader(GL_VERTEX_SHADER);\r\n    g_FragHandle = glCreateShader(GL_FRAGMENT_SHADER);\r\n    glShaderSource(g_VertHandle, 1, &vertex_shader, 0);\r\n    glShaderSource(g_FragHandle, 1, &fragment_shader, 0);\r\n    glCompileShader(g_VertHandle);\r\n    glCompileShader(g_FragHandle);\r\n    glAttachShader(g_ShaderHandle, g_VertHandle);\r\n    glAttachShader(g_ShaderHandle, g_FragHandle);\r\n    glLinkProgram(g_ShaderHandle);\r\n\r\n    g_AttribLocationTex = glGetUniformLocation(g_ShaderHandle, \"Texture\");\r\n    g_AttribLocationProjMtx = glGetUniformLocation(g_ShaderHandle, \"ProjMtx\");\r\n    g_AttribLocationPosition = glGetAttribLocation(g_ShaderHandle, \"Position\");\r\n    g_AttribLocationUV = glGetAttribLocation(g_ShaderHandle, \"UV\");\r\n    g_AttribLocationColor = glGetAttribLocation(g_ShaderHandle, \"Color\");\r\n\r\n    glGenBuffers(1, &g_VboHandle);\r\n    glGenBuffers(1, &g_ElementsHandle);\r\n\r\n#ifndef __EMSCRIPTEN__\r\n    glGenVertexArrays(1, &g_VaoHandle);\r\n    glBindVertexArray(g_VaoHandle);\r\n#else\r\n    glGenVertexArraysOES(1, &g_VaoHandle);\r\n    glBindVertexArrayOES(g_VaoHandle);\r\n#endif\r\n    glBindBuffer(GL_ARRAY_BUFFER, g_VboHandle);\r\n    glEnableVertexAttribArray(g_AttribLocationPosition);\r\n    glEnableVertexAttribArray(g_AttribLocationUV);\r\n    glEnableVertexAttribArray(g_AttribLocationColor);\r\n\r\n#define OFFSETOF(TYPE, ELEMENT) ((size_t)&(((TYPE *)0)->ELEMENT))\r\n    glVertexAttribPointer(g_AttribLocationPosition, 2, GL_FLOAT, GL_FALSE, sizeof(ImDrawVert), (GLvoid*)OFFSETOF(ImDrawVert, pos));\r\n    glVertexAttribPointer(g_AttribLocationUV, 2, GL_FLOAT, GL_FALSE, sizeof(ImDrawVert), (GLvoid*)OFFSETOF(ImDrawVert, uv));\r\n    glVertexAttribPointer(g_AttribLocationColor, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(ImDrawVert), (GLvoid*)OFFSETOF(ImDrawVert, col));\r\n#undef OFFSETOF\r\n\r\n    ImGui_ImplSdlGL3_CreateFontsTexture();\r\n\r\n    // Restore modified GL state\r\n    glBindTexture(GL_TEXTURE_2D, last_texture);\r\n    glBindBuffer(GL_ARRAY_BUFFER, last_array_buffer);\r\n    glBindVertexArray(last_vertex_array);\r\n\r\n    glGetError();\r\n    glGetError();\r\n    return true;\r\n}\r\n\r\nvoid    ImGui_ImplSdlGL3_InvalidateDeviceObjects()\r\n{\r\n#ifndef __EMSCRIPTEN__\r\n    if (g_VaoHandle) glDeleteVertexArrays(1, &g_VaoHandle);\r\n#else\r\n    if (g_VaoHandle) glDeleteVertexArraysOES(1, &g_VaoHandle);\r\n#endif\r\n    if (g_VboHandle) glDeleteBuffers(1, &g_VboHandle);\r\n    if (g_ElementsHandle) glDeleteBuffers(1, &g_ElementsHandle);\r\n    g_VaoHandle = g_VboHandle = g_ElementsHandle = 0;\r\n\r\n    if (g_ShaderHandle && g_VertHandle) glDetachShader(g_ShaderHandle, g_VertHandle);\r\n    if (g_VertHandle) glDeleteShader(g_VertHandle);\r\n    g_VertHandle = 0;\r\n\r\n    if (g_ShaderHandle && g_FragHandle) glDetachShader(g_ShaderHandle, g_FragHandle);\r\n    if (g_FragHandle) glDeleteShader(g_FragHandle);\r\n    g_FragHandle = 0;\r\n\r\n    if (g_ShaderHandle) glDeleteProgram(g_ShaderHandle);\r\n    g_ShaderHandle = 0;\r\n\r\n    if (g_FontTexture)\r\n    {\r\n        glDeleteTextures(1, &g_FontTexture);\r\n        ImGui::GetIO().Fonts->TexID = 0;\r\n        g_FontTexture = 0;\r\n    }\r\n}\r\n\r\nbool    ImGui_ImplSdlGL3_Init(SDL_Window* window)\r\n{\r\n    ImGuiIO& io = ImGui::GetIO();\r\n    io.KeyMap[ImGuiKey_Tab] = SDLK_TAB;                     // Keyboard mapping. ImGui will use those indices to peek into the io.KeyDown[] array.\r\n    io.KeyMap[ImGuiKey_LeftArrow] = SDL_SCANCODE_LEFT;\r\n    io.KeyMap[ImGuiKey_RightArrow] = SDL_SCANCODE_RIGHT;\r\n    io.KeyMap[ImGuiKey_UpArrow] = SDL_SCANCODE_UP;\r\n    io.KeyMap[ImGuiKey_DownArrow] = SDL_SCANCODE_DOWN;\r\n    io.KeyMap[ImGuiKey_PageUp] = SDL_SCANCODE_PAGEUP;\r\n    io.KeyMap[ImGuiKey_PageDown] = SDL_SCANCODE_PAGEDOWN;\r\n    io.KeyMap[ImGuiKey_Home] = SDL_SCANCODE_HOME;\r\n    io.KeyMap[ImGuiKey_End] = SDL_SCANCODE_END;\r\n    io.KeyMap[ImGuiKey_Delete] = SDLK_DELETE;\r\n    io.KeyMap[ImGuiKey_Backspace] = SDLK_BACKSPACE;\r\n    io.KeyMap[ImGuiKey_Enter] = SDLK_RETURN;\r\n    io.KeyMap[ImGuiKey_Escape] = SDLK_ESCAPE;\r\n    io.KeyMap[ImGuiKey_A] = SDLK_a;\r\n    io.KeyMap[ImGuiKey_C] = SDLK_c;\r\n    io.KeyMap[ImGuiKey_V] = SDLK_v;\r\n    io.KeyMap[ImGuiKey_X] = SDLK_x;\r\n    io.KeyMap[ImGuiKey_Y] = SDLK_y;\r\n    io.KeyMap[ImGuiKey_Z] = SDLK_z;\r\n\r\n    io.RenderDrawListsFn = ImGui_ImplSdlGL3_RenderDrawLists;   // Alternatively you can set this to NULL and call ImGui::GetDrawData() after ImGui::Render() to get the same ImDrawData pointer.\r\n    io.SetClipboardTextFn = ImGui_ImplSdlGL3_SetClipboardText;\r\n    io.GetClipboardTextFn = ImGui_ImplSdlGL3_GetClipboardText;\r\n    io.ClipboardUserData = NULL;\r\n\r\n#ifdef _WIN32\r\n    SDL_SysWMinfo wmInfo;\r\n    SDL_VERSION(&wmInfo.version);\r\n    SDL_GetWindowWMInfo(window, &wmInfo);\r\n    io.ImeWindowHandle = wmInfo.info.win.window;\r\n#else\r\n    (void)window;\r\n#endif\r\n\r\n    return true;\r\n}\r\n\r\nvoid ImGui_ImplSdlGL3_Shutdown()\r\n{\r\n    ImGui_ImplSdlGL3_InvalidateDeviceObjects();\r\n    ImGui::Shutdown();\r\n}\r\n\r\nvoid ImGui_ImplSdlGL3_NewFrame(SDL_Window* window)\r\n{\r\n    if (!g_FontTexture)\r\n        ImGui_ImplSdlGL3_CreateDeviceObjects();\r\n\r\n    ImGuiIO& io = ImGui::GetIO();\r\n\r\n    // Setup display size (every frame to accommodate for window resizing)\r\n    int w, h;\r\n    int display_w, display_h;\r\n    SDL_GetWindowSize(window, &w, &h);\r\n    SDL_GL_GetDrawableSize(window, &display_w, &display_h);\r\n    io.DisplaySize = ImVec2((float)w, (float)h);\r\n    io.DisplayFramebufferScale = ImVec2(w > 0 ? ((float)display_w / w) : 0, h > 0 ? ((float)display_h / h) : 0);\r\n\r\n    // Setup time step\r\n    Uint32\ttime = SDL_GetTicks();\r\n    double current_time = time / 1000.0;\r\n    io.DeltaTime = g_Time > 0.0 ? (float)(current_time - g_Time) : (float)(1.0f / 60.0f);\r\n    g_Time = current_time;\r\n\r\n    // Setup inputs\r\n    // (we already got mouse wheel, keyboard keys & characters from SDL_PollEvent())\r\n    int mx, my;\r\n    Uint32 mouseMask = SDL_GetMouseState(&mx, &my);\r\n    if (SDL_GetWindowFlags(window) & SDL_WINDOW_MOUSE_FOCUS)\r\n        io.MousePos = ImVec2((float)mx, (float)my);   // Mouse position, in pixels (set to -1,-1 if no mouse / on another screen, etc.)\r\n    else\r\n        io.MousePos = ImVec2(-FLT_MAX, -FLT_MAX);\r\n\r\n    io.MouseDown[0] = g_MousePressed[0] || (mouseMask & SDL_BUTTON(SDL_BUTTON_LEFT)) != 0;\t\t// If a mouse press event came, always pass it as \"mouse held this frame\", so we don't miss click-release events that are shorter than 1 frame.\r\n    io.MouseDown[1] = g_MousePressed[1] || (mouseMask & SDL_BUTTON(SDL_BUTTON_RIGHT)) != 0;\r\n    io.MouseDown[2] = g_MousePressed[2] || (mouseMask & SDL_BUTTON(SDL_BUTTON_MIDDLE)) != 0;\r\n    g_MousePressed[0] = g_MousePressed[1] = g_MousePressed[2] = false;\r\n\r\n    io.MouseWheel = g_MouseWheel;\r\n    g_MouseWheel = 0.0f;\r\n\r\n    // Hide OS mouse cursor if ImGui is drawing it\r\n    SDL_ShowCursor(io.MouseDrawCursor ? 0 : 1);\r\n\r\n    // Start the frame. This call will update the io.WantCaptureMouse, io.WantCaptureKeyboard flag that you can use to dispatch inputs (or not) to your application.\r\n    ImGui::NewFrame();\r\n}\r\n","// #include <core/IO.h>\r\n// #include <istream>\r\n\r\n#ifndef DLL_FIX\r\n#include <stdio.h>\r\n#include <fstream>\r\n#include <istream>\r\n#include <string>\r\n#endif\r\n\r\n#if defined(_WIN32) || defined(__EMSCRIPTEN__) || defined(_LINUX) || defined(__linux)\r\n// #include <string>\r\n// #include <stdio.h>\r\n// #include <fstream>\r\n#else\r\n#include <core/ResourceManager.h>\r\n#include <android_native_app_glue.h>\r\n#include <android/asset_manager.h>\r\n#include <android/asset_manager_jni.h>\r\n#endif\r\n\r\n// #include <stdlib.h>\r\n// #include <core/Utils.h>\r\n\r\nnamespace engine\r\n{\r\n\tnamespace io\r\n\t{\r\n#if defined(_WIN32) || defined(__EMSCRIPTEN__) ||  defined(_LINUX)\r\n\t\tchar* ReadEntireFile(const char* path)\r\n\t\t{\r\n\t\t\tchar *result = 0;\r\n\t\t\tFILE *file = fopen(path, \"r\");\r\n\t\t\tif (file)\r\n\t\t\t{\r\n\t\t\t\tfseek(file, 0, SEEK_END);\r\n\t\t\t\tsize_t fileSize = ftell(file);\r\n\t\t\t\tfseek(file, 0, SEEK_SET);\r\n\r\n\t\t\t\tresult = (char *)malloc(fileSize + 1);\r\n\t\t\t\tfread(result, fileSize, 1, file);\r\n\t\t\t\tresult[fileSize] = '\\0';\r\n\r\n\t\t\t\tfclose(file);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\r\n\t\t\t\tprintf(\"failed  %s path \\n\", path);\r\n\t\t\t\tASSERT(false);\r\n\t\t\t\t// logging\r\n\t\t\t}\r\n\t\t\tprintf(\"%s\\n\", result);\r\n\t\t\treturn result;\r\n\r\n\t\t\t// size_t fileLength = AAsset_getLength(assetDescriptor);\r\n\t\t}\r\n\r\n\t\tchar* ReadEntireFile(const char* path, int* size)\r\n\t\t{\r\n\t\t\tchar *result = 0;\r\n\t\t\tFILE *file = fopen(path, \"r\");\r\n\t\t\tif (file)\r\n\t\t\t{\r\n\t\t\t\tfseek(file, 0, SEEK_END);\r\n\t\t\t\tsize_t fileSize = ftell(file);\r\n\t\t\t\tfseek(file, 0, SEEK_SET);\r\n\r\n\t\t\t\tresult = (char *)malloc(fileSize + 1);\r\n\t\t\t\tfread(result, fileSize, 1, file);\r\n\t\t\t\tresult[fileSize] = '\\0';\r\n\r\n\t\t\t\t*size = (int)fileSize;\r\n\t\t\t\tfclose(file);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tprintf(\"failed  %s path \\n\", path);\r\n\t\t\t\tASSERT(false);\r\n\t\t\t\t// logging\r\n\t\t\t}\r\n\t\t\tprintf(\"%s\\n\", result);\r\n\t\t\treturn result;\r\n\r\n\t\t\t// size_t fileLength = AAsset_getLength(assetDescriptor);\r\n\t\t}\r\n\r\n\r\n\r\n#ifndef DLL_FIX\r\n\t\tstd::string ReadEntireFileToString(const char* path)\r\n\t\t{\r\n#if 0\r\n\t\t\tchar* buffer;\r\n\r\n\t\t\tFILE *file = fopen(path, \"r\");\r\n\t\t\tif (file)\r\n\t\t\t{\r\n\t\t\t\tfseek(file, 0, SEEK_END);\r\n\t\t\t\tsize_t fileSize = ftell(file);\r\n\t\t\t\tfseek(file, 0, SEEK_SET);\r\n\r\n\t\t\t\tbuffer = (char *)malloc(fileSize + 1);\r\n\t\t\t\tfread(buffer, fileSize, 1, file);\r\n\t\t\t\tbuffer[fileSize] = '\\0';\r\n\r\n\t\t\t\tfclose(file);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tASSERT(false);\r\n\t\t\t\t// logging\r\n\t\t\t\treturn {};\r\n\t\t\t}\r\n\r\n\t\t\tstd::string result(buffer);\r\n\t\t\tfree(buffer);\r\n\t\t\treturn result;\r\n#else\r\n\t\t\tstd::ifstream ifile(path);\r\n\t\t\tstd::string filetext;\r\n\r\n\t\t\twhile (ifile.good()) {\r\n\t\t\t\tstd::string line;\r\n\t\t\t\tstd::getline(ifile, line);\r\n\t\t\t\tfiletext.append(line + \"\\n\");\r\n\t\t\t}\r\n\r\n\t\t\treturn filetext;\r\n#endif\r\n\t\t}\r\n#endif\r\n\r\n\r\n\t\tvoid WriteBufferToFile(const char* path, const char* buffer, size_t bufferSize)\r\n\t\t{\r\n\t\t\tchar *result = 0;\r\n\t\t\tFILE *file = fopen(path, \"w\");\r\n\t\t\tif (file)\r\n\t\t\t{\r\n\t\t\t\tfwrite(buffer, bufferSize, 1, file);\r\n\t\t\t\tfclose(file);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tASSERT(false);\r\n\t\t\t}\r\n\r\n\t\t\t// Resource\r\n\t\t}\r\n\r\n#else // _WIN32 android\r\n\t\tchar* ReadEntireFile(const char* path)\r\n\t\t{\r\n\t\t\tAAssetManager* mgr = ResourceManager::assetManager;\r\n\r\n\t\t\tchar *result = 0;\r\n\t\t\tFILE *file = fopen(path, \"r\");\r\n\r\n\t\t\t// AAsset* file = AssetManager_open(mgr, path, )\r\n\r\n\r\n\t\t\tAAsset* assetDescriptor = AAssetManager_open(mgr,\r\n\t\t\t\tpath,\r\n\t\t\t\tAASSET_MODE_BUFFER);\r\n\r\n\t\t\t// ASSERT(assetDescriptor, \"%s does not exist in %s\",\r\n\t\t\t//\t   assetName.c_str(), __FUNCTION__);\r\n\r\n\t\t\tsize_t fileLength = AAsset_getLength(assetDescriptor);\r\n\t\t\tresult = (char*)malloc(fileLength * sizeof(char));\r\n\r\n\t\t\t// buf.resize(fileLength);\r\n\t\t\tint64_t readSize = AAsset_read(assetDescriptor, result, fileLength);\r\n\r\n\t\t\tAAsset_close(assetDescriptor);\r\n\r\n\t\t\t// TODO: ASSERT\r\n\t\t\t// return (readSize == buf.size());\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t\t// TODO: optimiointi mahdollisuuus\r\n\t\tstd::string ReadEntireFileToString(const char* path)\r\n\t\t{\r\n\t\t\tchar* file = ReadEntireFile(path);\r\n\t\t\tstd::string result(file);\r\n\t\t\tfree(file);\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t\tchar* ReadEntireFile(const char* path, int* sizeOut)\r\n\t\t{\r\n\t\t\tAAssetManager* mgr = ResourceManager::assetManager;\r\n\r\n\t\t\tchar *result = 0;\r\n\t\t\tFILE *file = fopen(path, \"r\");\r\n\r\n\t\t\t// AAsset* file = AssetManager_open(mgr, path, )\r\n\r\n\r\n\t\t\tAAsset* assetDescriptor = AAssetManager_open(mgr,\r\n\t\t\t\tpath,\r\n\t\t\t\tAASSET_MODE_BUFFER);\r\n\r\n\t\t\t// ASSERT(assetDescriptor, \"%s does not exist in %s\",\r\n\t\t\t//\t   assetName.c_str(), __FUNCTION__);\r\n\r\n\t\t\tsize_t fileLength = AAsset_getLength(assetDescriptor);\r\n\t\t\tresult = (char*)malloc(fileLength * sizeof(char));\r\n\r\n\t\t\t// buf.resize(fileLength);\r\n\t\t\tint64_t readSize = AAsset_read(assetDescriptor, result, fileLength);\r\n\r\n\t\t\tAAsset_close(assetDescriptor);\r\n\t\t\t*sizeOut = fileLength;\r\n\t\t\t// TODO: ASSERT\r\n\t\t\t// return (readSize == buf.size());\r\n\t\t\treturn result;\r\n\t\t}\r\n#endif\r\n\t}\r\n}\r\n","// -*- C++ -*-\n//===------------------------- fstream ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FSTREAM\n#define _LIBCPP_FSTREAM\n\n/*\n    fstream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_filebuf\n    : public basic_streambuf<charT, traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.9.1.2 Constructors/destructor:\n    basic_filebuf();\n    basic_filebuf(basic_filebuf&& rhs);\n    virtual ~basic_filebuf();\n\n    // 27.9.1.3 Assign/swap:\n    basic_filebuf& operator=(basic_filebuf&& rhs);\n    void swap(basic_filebuf& rhs);\n\n    // 27.9.1.4 Members:\n    bool is_open() const;\n    basic_filebuf* open(const char* s, ios_base::openmode mode);\n    basic_filebuf* open(const string& s, ios_base::openmode mode);\n    basic_filebuf* close();\n\nprotected:\n    // 27.9.1.5 Overridden virtual functions:\n    virtual streamsize showmanyc();\n    virtual int_type underflow();\n    virtual int_type uflow();\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n    virtual int_type overflow (int_type c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* s, streamsize n);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual int sync();\n    virtual void imbue(const locale& loc);\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_filebuf<charT, traits>& x, basic_filebuf<charT, traits>& y);\n\ntypedef basic_filebuf<char>    filebuf;\ntypedef basic_filebuf<wchar_t> wfilebuf;\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ifstream\n    : public basic_istream<charT,traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_ifstream();\n    explicit basic_ifstream(const char* s, ios_base::openmode mode = ios_base::in);\n    explicit basic_ifstream(const string& s, ios_base::openmode mode = ios_base::in);\n    basic_ifstream(basic_ifstream&& rhs);\n\n    basic_ifstream& operator=(basic_ifstream&& rhs);\n    void swap(basic_ifstream& rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* s, ios_base::openmode mode = ios_base::in);\n    void open(const string& s, ios_base::openmode mode = ios_base::in);\n    void close();\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_ifstream<charT, traits>& x, basic_ifstream<charT, traits>& y);\n\ntypedef basic_ifstream<char>    ifstream;\ntypedef basic_ifstream<wchar_t> wifstream;\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ofstream\n    : public basic_ostream<charT,traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_ofstream();\n    explicit basic_ofstream(const char* s, ios_base::openmode mode = ios_base::out);\n    explicit basic_ofstream(const string& s, ios_base::openmode mode = ios_base::out);\n    basic_ofstream(basic_ofstream&& rhs);\n\n    basic_ofstream& operator=(basic_ofstream&& rhs);\n    void swap(basic_ofstream& rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* s, ios_base::openmode mode = ios_base::out);\n    void open(const string& s, ios_base::openmode mode = ios_base::out);\n    void close();\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_ofstream<charT, traits>& x, basic_ofstream<charT, traits>& y);\n\ntypedef basic_ofstream<char>    ofstream;\ntypedef basic_ofstream<wchar_t> wofstream;\n\ntemplate <class charT, class traits=char_traits<charT> >\nclass basic_fstream\n    : public basic_iostream<charT,traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_fstream();\n    explicit basic_fstream(const char* s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    explicit basic_fstream(const string& s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    basic_fstream(basic_fstream&& rhs);\n\n    basic_fstream& operator=(basic_fstream&& rhs);\n    void swap(basic_fstream& rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    void open(const string& s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    void close();\n};\n\ntemplate <class charT, class traits>\n  void swap(basic_fstream<charT, traits>& x, basic_fstream<charT, traits>& y);\n\ntypedef basic_fstream<char>    fstream;\ntypedef basic_fstream<wchar_t> wfstream;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ostream>\n#include <istream>\n#include <__locale>\n#include <cstdio>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_filebuf\n    : public basic_streambuf<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                           char_type;\n    typedef _Traits                          traits_type;\n    typedef typename traits_type::int_type   int_type;\n    typedef typename traits_type::pos_type   pos_type;\n    typedef typename traits_type::off_type   off_type;\n    typedef typename traits_type::state_type state_type;\n\n    // 27.9.1.2 Constructors/destructor:\n    basic_filebuf();\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_filebuf(basic_filebuf&& __rhs);\n#endif\n    virtual ~basic_filebuf();\n\n    // 27.9.1.3 Assign/swap:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_filebuf& operator=(basic_filebuf&& __rhs);\n#endif\n    void swap(basic_filebuf& __rhs);\n\n    // 27.9.1.4 Members:\n    _LIBCPP_INLINE_VISIBILITY\n    bool is_open() const;\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    basic_filebuf* open(const char* __s, ios_base::openmode __mode);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_filebuf* open(const string& __s, ios_base::openmode __mode);\n#endif\n    basic_filebuf* close();\n\nprotected:\n    // 27.9.1.5 Overridden virtual functions:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s, streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual int sync();\n    virtual void imbue(const locale& __loc);\n\nprivate:\n    char*       __extbuf_;\n    const char* __extbufnext_;\n    const char* __extbufend_;\n    char __extbuf_min_[8];\n    size_t __ebs_;\n    char_type* __intbuf_;\n    size_t __ibs_;\n    FILE* __file_;\n    const codecvt<char_type, char, state_type>* __cv_;\n    state_type __st_;\n    state_type __st_last_;\n    ios_base::openmode __om_;\n    ios_base::openmode __cm_;\n    bool __owns_eb_;\n    bool __owns_ib_;\n    bool __always_noconv_;\n\n    bool __read_mode();\n    void __write_mode();\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>::basic_filebuf()\n    : __extbuf_(0),\n      __extbufnext_(0),\n      __extbufend_(0),\n      __ebs_(0),\n      __intbuf_(0),\n      __ibs_(0),\n      __file_(0),\n      __cv_(nullptr),\n      __st_(),\n      __st_last_(),\n      __om_(0),\n      __cm_(0),\n      __owns_eb_(false),\n      __owns_ib_(false),\n      __always_noconv_(false)\n{\n    if (has_facet<codecvt<char_type, char, state_type> >(this->getloc()))\n    {\n        __cv_ = &use_facet<codecvt<char_type, char, state_type> >(this->getloc());\n        __always_noconv_ = __cv_->always_noconv();\n    }\n    setbuf(0, 4096);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>::basic_filebuf(basic_filebuf&& __rhs)\n    : basic_streambuf<_CharT, _Traits>(__rhs)\n{\n    if (__rhs.__extbuf_ == __rhs.__extbuf_min_)\n    {\n        __extbuf_ = __extbuf_min_;\n        __extbufnext_ = __extbuf_ + (__rhs.__extbufnext_ - __rhs.__extbuf_);\n        __extbufend_ = __extbuf_ + (__rhs.__extbufend_ - __rhs.__extbuf_);\n    }\n    else\n    {\n        __extbuf_ = __rhs.__extbuf_;\n        __extbufnext_ = __rhs.__extbufnext_;\n        __extbufend_ = __rhs.__extbufend_;\n    }\n    __ebs_ = __rhs.__ebs_;\n    __intbuf_ = __rhs.__intbuf_;\n    __ibs_ = __rhs.__ibs_;\n    __file_ = __rhs.__file_;\n    __cv_ = __rhs.__cv_;\n    __st_ = __rhs.__st_;\n    __st_last_ = __rhs.__st_last_;\n    __om_ = __rhs.__om_;\n    __cm_ = __rhs.__cm_;\n    __owns_eb_ = __rhs.__owns_eb_;\n    __owns_ib_ = __rhs.__owns_ib_;\n    __always_noconv_ = __rhs.__always_noconv_;\n    if (__rhs.pbase())\n    {\n        if (__rhs.pbase() == __rhs.__intbuf_)\n            this->setp(__intbuf_, __intbuf_ + (__rhs. epptr() - __rhs.pbase()));\n        else\n            this->setp((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + (__rhs. epptr() - __rhs.pbase()));\n        this->pbump(__rhs. pptr() - __rhs.pbase());\n    }\n    else if (__rhs.eback())\n    {\n        if (__rhs.eback() == __rhs.__intbuf_)\n            this->setg(__intbuf_, __intbuf_ + (__rhs.gptr() - __rhs.eback()),\n                                  __intbuf_ + (__rhs.egptr() - __rhs.eback()));\n        else\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + (__rhs.gptr() - __rhs.eback()),\n                       (char_type*)__extbuf_ + (__rhs.egptr() - __rhs.eback()));\n    }\n    __rhs.__extbuf_ = 0;\n    __rhs.__extbufnext_ = 0;\n    __rhs.__extbufend_ = 0;\n    __rhs.__ebs_ = 0;\n    __rhs.__intbuf_ = 0;\n    __rhs.__ibs_ = 0;\n    __rhs.__file_ = 0;\n    __rhs.__st_ = state_type();\n    __rhs.__st_last_ = state_type();\n    __rhs.__om_ = 0;\n    __rhs.__cm_ = 0;\n    __rhs.__owns_eb_ = false;\n    __rhs.__owns_ib_ = false;\n    __rhs.setg(0, 0, 0);\n    __rhs.setp(0, 0);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_filebuf<_CharT, _Traits>&\nbasic_filebuf<_CharT, _Traits>::operator=(basic_filebuf&& __rhs)\n{\n    close();\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>::~basic_filebuf()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        close();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_filebuf<_CharT, _Traits>::swap(basic_filebuf& __rhs)\n{\n    basic_streambuf<char_type, traits_type>::swap(__rhs);\n    if (__extbuf_ != __extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_)\n    {\n        _VSTD::swap(__extbuf_, __rhs.__extbuf_);\n        _VSTD::swap(__extbufnext_, __rhs.__extbufnext_);\n        _VSTD::swap(__extbufend_, __rhs.__extbufend_);\n    }\n    else\n    {\n        ptrdiff_t __ln = __extbufnext_ - __extbuf_;\n        ptrdiff_t __le = __extbufend_ - __extbuf_;\n        ptrdiff_t __rn = __rhs.__extbufnext_ - __rhs.__extbuf_;\n        ptrdiff_t __re = __rhs.__extbufend_ - __rhs.__extbuf_;\n        if (__extbuf_ == __extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_)\n        {\n            __extbuf_ = __rhs.__extbuf_;\n            __rhs.__extbuf_ = __rhs.__extbuf_min_;\n        }\n        else if (__extbuf_ != __extbuf_min_ && __rhs.__extbuf_ == __rhs.__extbuf_min_)\n        {\n            __rhs.__extbuf_ = __extbuf_;\n            __extbuf_ = __extbuf_min_;\n        }\n        __extbufnext_ = __extbuf_ + __rn;\n        __extbufend_ = __extbuf_ + __re;\n        __rhs.__extbufnext_ = __rhs.__extbuf_ + __ln;\n        __rhs.__extbufend_ = __rhs.__extbuf_ + __le;\n    }\n    _VSTD::swap(__ebs_, __rhs.__ebs_);\n    _VSTD::swap(__intbuf_, __rhs.__intbuf_);\n    _VSTD::swap(__ibs_, __rhs.__ibs_);\n    _VSTD::swap(__file_, __rhs.__file_);\n    _VSTD::swap(__cv_, __rhs.__cv_);\n    _VSTD::swap(__st_, __rhs.__st_);\n    _VSTD::swap(__st_last_, __rhs.__st_last_);\n    _VSTD::swap(__om_, __rhs.__om_);\n    _VSTD::swap(__cm_, __rhs.__cm_);\n    _VSTD::swap(__owns_eb_, __rhs.__owns_eb_);\n    _VSTD::swap(__owns_ib_, __rhs.__owns_ib_);\n    _VSTD::swap(__always_noconv_, __rhs.__always_noconv_);\n    if (this->eback() == (char_type*)__rhs.__extbuf_min_)\n    {\n        ptrdiff_t __n = this->gptr() - this->eback();\n        ptrdiff_t __e = this->egptr() - this->eback();\n        this->setg((char_type*)__extbuf_min_,\n                   (char_type*)__extbuf_min_ + __n,\n                   (char_type*)__extbuf_min_ + __e);\n    }\n    else if (this->pbase() == (char_type*)__rhs.__extbuf_min_)\n    {\n        ptrdiff_t __n = this->pptr() - this->pbase();\n        ptrdiff_t __e = this->epptr() - this->pbase();\n        this->setp((char_type*)__extbuf_min_,\n                   (char_type*)__extbuf_min_ + __e);\n        this->pbump(__n);\n    }\n    if (__rhs.eback() == (char_type*)__extbuf_min_)\n    {\n        ptrdiff_t __n = __rhs.gptr() - __rhs.eback();\n        ptrdiff_t __e = __rhs.egptr() - __rhs.eback();\n        __rhs.setg((char_type*)__rhs.__extbuf_min_,\n                   (char_type*)__rhs.__extbuf_min_ + __n,\n                   (char_type*)__rhs.__extbuf_min_ + __e);\n    }\n    else if (__rhs.pbase() == (char_type*)__extbuf_min_)\n    {\n        ptrdiff_t __n = __rhs.pptr() - __rhs.pbase();\n        ptrdiff_t __e = __rhs.epptr() - __rhs.pbase();\n        __rhs.setp((char_type*)__rhs.__extbuf_min_,\n                   (char_type*)__rhs.__extbuf_min_ + __e);\n        __rhs.pbump(__n);\n    }\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_filebuf<_CharT, _Traits>& __x, basic_filebuf<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbool\nbasic_filebuf<_CharT, _Traits>::is_open() const\n{\n    return __file_ != 0;\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    basic_filebuf<_CharT, _Traits>* __rt = 0;\n    if (__file_ == 0)\n    {\n        __rt = this;\n        const char* __mdstr;\n        switch (__mode & ~ios_base::ate)\n        {\n        case ios_base::out:\n        case ios_base::out | ios_base::trunc:\n            __mdstr = \"w\";\n            break;\n        case ios_base::out | ios_base::app:\n        case ios_base::app:\n            __mdstr = \"a\";\n            break;\n        case ios_base::in:\n            __mdstr = \"r\";\n            break;\n        case ios_base::in | ios_base::out:\n            __mdstr = \"r+\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::trunc:\n            __mdstr = \"w+\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::app:\n        case ios_base::in | ios_base::app:\n            __mdstr = \"a+\";\n            break;\n        case ios_base::out | ios_base::binary:\n        case ios_base::out | ios_base::trunc | ios_base::binary:\n            __mdstr = \"wb\";\n            break;\n        case ios_base::out | ios_base::app | ios_base::binary:\n        case ios_base::app | ios_base::binary:\n            __mdstr = \"ab\";\n            break;\n        case ios_base::in | ios_base::binary:\n            __mdstr = \"rb\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::binary:\n            __mdstr = \"r+b\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::trunc | ios_base::binary:\n            __mdstr = \"w+b\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::app | ios_base::binary:\n        case ios_base::in | ios_base::app | ios_base::binary:\n            __mdstr = \"a+b\";\n            break;\n        default:\n            __rt = 0;\n            break;\n        }\n        if (__rt)\n        {\n            __file_ = fopen(__s, __mdstr);\n            if (__file_)\n            {\n                __om_ = __mode;\n                if (__mode & ios_base::ate)\n                {\n                    if (fseek(__file_, 0, SEEK_END))\n                    {\n                        fclose(__file_);\n                        __file_ = 0;\n                        __rt = 0;\n                    }\n                }\n            }\n            else\n                __rt = 0;\n        }\n    }\n    return __rt;\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    return open(__s.c_str(), __mode);\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::close()\n{\n    basic_filebuf<_CharT, _Traits>* __rt = 0;\n    if (__file_)\n    {\n        __rt = this;\n        unique_ptr<FILE, int(*)(FILE*)> __h(__file_, fclose);\n        if (sync())\n            __rt = 0;\n        if (fclose(__h.release()) == 0)\n            __file_ = 0;\n        else\n            __rt = 0;\n    }\n    return __rt;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::int_type\nbasic_filebuf<_CharT, _Traits>::underflow()\n{\n    if (__file_ == 0)\n        return traits_type::eof();\n    bool __initial = __read_mode();\n    char_type __1buf;\n    if (this->gptr() == 0)\n        this->setg(&__1buf, &__1buf+1, &__1buf+1);\n    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);\n    int_type __c = traits_type::eof();\n    if (this->gptr() == this->egptr())\n    {\n        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));\n        if (__always_noconv_)\n        {\n            size_t __nmemb = static_cast<size_t>(this->egptr() - this->eback() - __unget_sz);\n            __nmemb = fread(this->eback() + __unget_sz, 1, __nmemb, __file_);\n            if (__nmemb != 0)\n            {\n                this->setg(this->eback(),\n                           this->eback() + __unget_sz,\n                           this->eback() + __unget_sz + __nmemb);\n                __c = traits_type::to_int_type(*this->gptr());\n            }\n        }\n        else\n        {\n            _LIBCPP_ASSERT ( !(__extbufnext_ == NULL && (__extbufend_ != __extbufnext_)), \"underflow moving from NULL\" );\n            if (__extbufend_ != __extbufnext_)\n                memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);\n            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);\n            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);\n            size_t __nmemb = _VSTD::min(static_cast<size_t>(__ibs_ - __unget_sz),\n                                 static_cast<size_t>(__extbufend_ - __extbufnext_));\n            codecvt_base::result __r;\n            __st_last_ = __st_;\n            size_t __nr = fread((void*)__extbufnext_, 1, __nmemb, __file_);\n            if (__nr != 0)\n            {\n                if (!__cv_)\n                    __throw_bad_cast();\n\n                __extbufend_ = __extbufnext_ + __nr;\n                char_type*  __inext;\n                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,\n                                       this->eback() + __unget_sz,\n                                       this->eback() + __ibs_, __inext);\n                if (__r == codecvt_base::noconv)\n                {\n                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, (char_type*)__extbufend_);\n                    __c = traits_type::to_int_type(*this->gptr());\n                }\n                else if (__inext != this->eback() + __unget_sz)\n                {\n                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);\n                    __c = traits_type::to_int_type(*this->gptr());\n                }\n            }\n        }\n    }\n    else\n        __c = traits_type::to_int_type(*this->gptr());\n    if (this->eback() == &__1buf)\n        this->setg(0, 0, 0);\n    return __c;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::int_type\nbasic_filebuf<_CharT, _Traits>::pbackfail(int_type __c)\n{\n    if (__file_ && this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->gbump(-1);\n            return traits_type::not_eof(__c);\n        }\n        if ((__om_ & ios_base::out) ||\n            traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->gbump(-1);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::int_type\nbasic_filebuf<_CharT, _Traits>::overflow(int_type __c)\n{\n    if (__file_ == 0)\n        return traits_type::eof();\n    __write_mode();\n    char_type __1buf;\n    char_type* __pb_save = this->pbase();\n    char_type* __epb_save = this->epptr();\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        if (this->pptr() == 0)\n            this->setp(&__1buf, &__1buf+1);\n        *this->pptr() = traits_type::to_char_type(__c);\n        this->pbump(1);\n    }\n    if (this->pptr() != this->pbase())\n    {\n        if (__always_noconv_)\n        {\n            size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n            if (fwrite(this->pbase(), sizeof(char_type), __nmemb, __file_) != __nmemb)\n                return traits_type::eof();\n        }\n        else\n        {\n            char* __extbe = __extbuf_;\n            codecvt_base::result __r;\n            do\n            {\n                if (!__cv_)\n                    __throw_bad_cast();\n\n                const char_type* __e;\n                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,\n                                        __extbuf_, __extbuf_ + __ebs_, __extbe);\n                if (__e == this->pbase())\n                    return traits_type::eof();\n                if (__r == codecvt_base::noconv)\n                {\n                    size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n                    if (fwrite(this->pbase(), 1, __nmemb, __file_) != __nmemb)\n                        return traits_type::eof();\n                }\n                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)\n                {\n                    size_t __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n                    if (fwrite(__extbuf_, 1, __nmemb, __file_) != __nmemb)\n                        return traits_type::eof();\n                    if (__r == codecvt_base::partial)\n                    {\n                        this->setp((char_type*)__e, this->pptr());\n                        this->pbump(this->epptr() - this->pbase());\n                    }\n                }\n                else\n                    return traits_type::eof();\n            } while (__r == codecvt_base::partial);\n        }\n        this->setp(__pb_save, __epb_save);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::setbuf(char_type* __s, streamsize __n)\n{\n    this->setg(0, 0, 0);\n    this->setp(0, 0);\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n    __ebs_ = __n;\n    if (__ebs_ > sizeof(__extbuf_min_))\n    {\n        if (__always_noconv_ && __s)\n        {\n            __extbuf_ = (char*)__s;\n            __owns_eb_ = false;\n        }\n        else\n        {\n            __extbuf_ = new char[__ebs_];\n            __owns_eb_ = true;\n        }\n    }\n    else\n    {\n        __extbuf_ = __extbuf_min_;\n        __ebs_ = sizeof(__extbuf_min_);\n        __owns_eb_ = false;\n    }\n    if (!__always_noconv_)\n    {\n        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));\n        if (__s && __ibs_ >= sizeof(__extbuf_min_))\n        {\n            __intbuf_ = __s;\n            __owns_ib_ = false;\n        }\n        else\n        {\n            __intbuf_ = new char_type[__ibs_];\n            __owns_ib_ = true;\n        }\n    }\n    else\n    {\n        __ibs_ = 0;\n        __intbuf_ = 0;\n        __owns_ib_ = false;\n    }\n    return this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::pos_type\nbasic_filebuf<_CharT, _Traits>::seekoff(off_type __off, ios_base::seekdir __way,\n                                        ios_base::openmode)\n{\n    if (!__cv_)\n        __throw_bad_cast();\n\n    int __width = __cv_->encoding();\n    if (__file_ == 0 || (__width <= 0 && __off != 0) || sync())\n        return pos_type(off_type(-1));\n    // __width > 0 || __off == 0\n    int __whence;\n    switch (__way)\n    {\n    case ios_base::beg:\n        __whence = SEEK_SET;\n        break;\n    case ios_base::cur:\n        __whence = SEEK_CUR;\n        break;\n    case ios_base::end:\n        __whence = SEEK_END;\n        break;\n    default:\n        return pos_type(off_type(-1));\n    }\n#if defined(_LIBCPP_HAS_NO_OFF_T_FUNCTIONS)\n    if (fseek(__file_, __width > 0 ? __width * __off : 0, __whence))\n        return pos_type(off_type(-1));\n    pos_type __r = ftell(__file_);\n#else\n    if (fseeko(__file_, __width > 0 ? __width * __off : 0, __whence))\n        return pos_type(off_type(-1));\n    pos_type __r = ftello(__file_);\n#endif\n    __r.state(__st_);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::pos_type\nbasic_filebuf<_CharT, _Traits>::seekpos(pos_type __sp, ios_base::openmode)\n{\n    if (__file_ == 0 || sync())\n        return pos_type(off_type(-1));\n#if defined(_LIBCPP_HAS_NO_OFF_T_FUNCTIONS)\n    if (fseek(__file_, __sp, SEEK_SET))\n        return pos_type(off_type(-1));\n#else\n    if (fseeko(__file_, __sp, SEEK_SET))\n        return pos_type(off_type(-1));\n#endif\n    __st_ = __sp.state();\n    return __sp;\n}\n\ntemplate <class _CharT, class _Traits>\nint\nbasic_filebuf<_CharT, _Traits>::sync()\n{\n    if (__file_ == 0)\n        return 0;\n    if (!__cv_)\n        __throw_bad_cast();\n\n    if (__cm_ & ios_base::out)\n    {\n        if (this->pptr() != this->pbase())\n            if (overflow() == traits_type::eof())\n                return -1;\n        codecvt_base::result __r;\n        do\n        {\n            char* __extbe;\n            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);\n            size_t __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n            if (fwrite(__extbuf_, 1, __nmemb, __file_) != __nmemb)\n                return -1;\n        } while (__r == codecvt_base::partial);\n        if (__r == codecvt_base::error)\n            return -1;\n        if (fflush(__file_))\n            return -1;\n    }\n    else if (__cm_ & ios_base::in)\n    {\n        off_type __c;\n        state_type __state = __st_last_;\n        bool __update_st = false;\n        if (__always_noconv_)\n            __c = this->egptr() - this->gptr();\n        else\n        {\n            int __width = __cv_->encoding();\n            __c = __extbufend_ - __extbufnext_;\n            if (__width > 0)\n                __c += __width * (this->egptr() - this->gptr());\n            else\n            {\n                if (this->gptr() != this->egptr())\n                {\n                    const int __off =  __cv_->length(__state, __extbuf_,\n                                                     __extbufnext_,\n                                                     this->gptr() - this->eback());\n                    __c += __extbufnext_ - __extbuf_ - __off;\n                    __update_st = true;\n                }\n            }\n        }\n#if defined(_LIBCPP_HAS_NO_OFF_T_FUNCTIONS)\n        if (fseek(__file_, -__c, SEEK_CUR))\n            return -1;\n#else\n        if (fseeko(__file_, -__c, SEEK_CUR))\n            return -1;\n#endif\n        if (__update_st)\n            __st_ = __state;\n        __extbufnext_ = __extbufend_ = __extbuf_;\n        this->setg(0, 0, 0);\n        __cm_ = 0;\n    }\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_filebuf<_CharT, _Traits>::imbue(const locale& __loc)\n{\n    sync();\n    __cv_ = &use_facet<codecvt<char_type, char, state_type> >(__loc);\n    bool __old_anc = __always_noconv_;\n    __always_noconv_ = __cv_->always_noconv();\n    if (__old_anc != __always_noconv_)\n    {\n        this->setg(0, 0, 0);\n        this->setp(0, 0);\n        // invariant, char_type is char, else we couldn't get here\n        if (__always_noconv_)  // need to dump __intbuf_\n        {\n            if (__owns_eb_)\n                delete [] __extbuf_;\n            __owns_eb_ = __owns_ib_;\n            __ebs_ = __ibs_;\n            __extbuf_ = (char*)__intbuf_;\n            __ibs_ = 0;\n            __intbuf_ = 0;\n            __owns_ib_ = false;\n        }\n        else  // need to obtain an __intbuf_.\n        {     // If __extbuf_ is user-supplied, use it, else new __intbuf_\n            if (!__owns_eb_ && __extbuf_ != __extbuf_min_)\n            {\n                __ibs_ = __ebs_;\n                __intbuf_ = (char_type*)__extbuf_;\n                __owns_ib_ = false;\n                __extbuf_ = new char[__ebs_];\n                __owns_eb_ = true;\n            }\n            else\n            {\n                __ibs_ = __ebs_;\n                __intbuf_ = new char_type[__ibs_];\n                __owns_ib_ = true;\n            }\n        }\n    }\n}\n\ntemplate <class _CharT, class _Traits>\nbool\nbasic_filebuf<_CharT, _Traits>::__read_mode()\n{\n    if (!(__cm_ & ios_base::in))\n    {\n        this->setp(0, 0);\n        if (__always_noconv_)\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + __ebs_,\n                       (char_type*)__extbuf_ + __ebs_);\n        else\n            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);\n        __cm_ = ios_base::in;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_filebuf<_CharT, _Traits>::__write_mode()\n{\n    if (!(__cm_ & ios_base::out))\n    {\n        this->setg(0, 0, 0);\n        if (__ebs_ > sizeof(__extbuf_min_))\n        {\n            if (__always_noconv_)\n                this->setp((char_type*)__extbuf_,\n                           (char_type*)__extbuf_ + (__ebs_ - 1));\n            else\n                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));\n        }\n        else\n            this->setp(0, 0);\n        __cm_ = ios_base::out;\n    }\n}\n\n// basic_ifstream\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_ifstream\n    : public basic_istream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ifstream();\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ifstream(const string& __s, ios_base::openmode __mode = ios_base::in);\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ifstream(basic_ifstream&& __rhs);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ifstream& operator=(basic_ifstream&& __rhs);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_ifstream& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY\n    bool is_open() const;\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    void open(const char* __s, ios_base::openmode __mode = ios_base::in);\n    void open(const string& __s, ios_base::openmode __mode = ios_base::in);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void close();\n\nprivate:\n    basic_filebuf<char_type, traits_type> __sb_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ifstream<_CharT, _Traits>::basic_ifstream()\n    : basic_istream<char_type, traits_type>(&__sb_)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ifstream<_CharT, _Traits>::basic_ifstream(const char* __s, ios_base::openmode __mode)\n    : basic_istream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::in) == 0)\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ifstream<_CharT, _Traits>::basic_ifstream(const string& __s, ios_base::openmode __mode)\n    : basic_istream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::in) == 0)\n        this->setstate(ios_base::failbit);\n}\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ifstream<_CharT, _Traits>::basic_ifstream(basic_ifstream&& __rhs)\n    : basic_istream<char_type, traits_type>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    this->set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ifstream<_CharT, _Traits>&\nbasic_ifstream<_CharT, _Traits>::operator=(basic_ifstream&& __rhs)\n{\n    basic_istream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_ifstream<_CharT, _Traits>::swap(basic_ifstream& __rhs)\n{\n    basic_istream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_ifstream<_CharT, _Traits>& __x, basic_ifstream<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_filebuf<_CharT, _Traits>*\nbasic_ifstream<_CharT, _Traits>::rdbuf() const\n{\n    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbool\nbasic_ifstream<_CharT, _Traits>::is_open() const\n{\n    return __sb_.is_open();\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ifstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::in))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ifstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::in))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_ifstream<_CharT, _Traits>::close()\n{\n    if (__sb_.close() == 0)\n        this->setstate(ios_base::failbit);\n}\n\n// basic_ofstream\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_ofstream\n    : public basic_ostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ofstream();\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ofstream(const char* __s, ios_base::openmode __mode = ios_base::out);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ofstream(const string& __s, ios_base::openmode __mode = ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ofstream(basic_ofstream&& __rhs);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ofstream& operator=(basic_ofstream&& __rhs);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_ofstream& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY\n    bool is_open() const;\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    void open(const char* __s, ios_base::openmode __mode = ios_base::out);\n    void open(const string& __s, ios_base::openmode __mode = ios_base::out);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void close();\n\nprivate:\n    basic_filebuf<char_type, traits_type> __sb_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ofstream<_CharT, _Traits>::basic_ofstream()\n    : basic_ostream<char_type, traits_type>(&__sb_)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ofstream<_CharT, _Traits>::basic_ofstream(const char* __s, ios_base::openmode __mode)\n    : basic_ostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::out) == 0)\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ofstream<_CharT, _Traits>::basic_ofstream(const string& __s, ios_base::openmode __mode)\n    : basic_ostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::out) == 0)\n        this->setstate(ios_base::failbit);\n}\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ofstream<_CharT, _Traits>::basic_ofstream(basic_ofstream&& __rhs)\n    : basic_ostream<char_type, traits_type>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    this->set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_ofstream<_CharT, _Traits>&\nbasic_ofstream<_CharT, _Traits>::operator=(basic_ofstream&& __rhs)\n{\n    basic_ostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_ofstream<_CharT, _Traits>::swap(basic_ofstream& __rhs)\n{\n    basic_ostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_ofstream<_CharT, _Traits>& __x, basic_ofstream<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_filebuf<_CharT, _Traits>*\nbasic_ofstream<_CharT, _Traits>::rdbuf() const\n{\n    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbool\nbasic_ofstream<_CharT, _Traits>::is_open() const\n{\n    return __sb_.is_open();\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ofstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::out))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ofstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::out))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_ofstream<_CharT, _Traits>::close()\n{\n    if (__sb_.close() == 0)\n        this->setstate(ios_base::failbit);\n}\n\n// basic_fstream\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_fstream\n    : public basic_iostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_fstream();\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_fstream(const char* __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_fstream(const string& __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_fstream(basic_fstream&& __rhs);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_fstream& operator=(basic_fstream&& __rhs);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_fstream& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY\n    bool is_open() const;\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\n    void open(const char* __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n    void open(const string& __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void close();\n\nprivate:\n    basic_filebuf<char_type, traits_type> __sb_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_fstream<_CharT, _Traits>::basic_fstream()\n    : basic_iostream<char_type, traits_type>(&__sb_)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\ninline\nbasic_fstream<_CharT, _Traits>::basic_fstream(const char* __s, ios_base::openmode __mode)\n    : basic_iostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode) == 0)\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_fstream<_CharT, _Traits>::basic_fstream(const string& __s, ios_base::openmode __mode)\n    : basic_iostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode) == 0)\n        this->setstate(ios_base::failbit);\n}\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_fstream<_CharT, _Traits>::basic_fstream(basic_fstream&& __rhs)\n    : basic_iostream<char_type, traits_type>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    this->set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_fstream<_CharT, _Traits>&\nbasic_fstream<_CharT, _Traits>::operator=(basic_fstream&& __rhs)\n{\n    basic_iostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_fstream<_CharT, _Traits>::swap(basic_fstream& __rhs)\n{\n    basic_iostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_fstream<_CharT, _Traits>& __x, basic_fstream<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbasic_filebuf<_CharT, _Traits>*\nbasic_fstream<_CharT, _Traits>::rdbuf() const\n{\n    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline\nbool\nbasic_fstream<_CharT, _Traits>::is_open() const\n{\n    return __sb_.is_open();\n}\n\n#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_fstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_fstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n#endif\n\ntemplate <class _CharT, class _Traits>\ninline\nvoid\nbasic_fstream<_CharT, _Traits>::close()\n{\n    if (__sb_.close() == 0)\n        this->setstate(ios_base::failbit);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FSTREAM\n","// -*- C++ -*-\n//===---------------------------- ios -------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOS\n#define _LIBCPP_IOS\n\n/*\n    ios synopsis\n\n#include <iosfwd>\n\nnamespace std\n{\n\ntypedef OFF_T streamoff;\ntypedef SZ_T streamsize;\ntemplate <class stateT> class fpos;\n\nclass ios_base\n{\npublic:\n    class failure;\n\n    typedef T1 fmtflags;\n    static constexpr fmtflags boolalpha;\n    static constexpr fmtflags dec;\n    static constexpr fmtflags fixed;\n    static constexpr fmtflags hex;\n    static constexpr fmtflags internal;\n    static constexpr fmtflags left;\n    static constexpr fmtflags oct;\n    static constexpr fmtflags right;\n    static constexpr fmtflags scientific;\n    static constexpr fmtflags showbase;\n    static constexpr fmtflags showpoint;\n    static constexpr fmtflags showpos;\n    static constexpr fmtflags skipws;\n    static constexpr fmtflags unitbuf;\n    static constexpr fmtflags uppercase;\n    static constexpr fmtflags adjustfield;\n    static constexpr fmtflags basefield;\n    static constexpr fmtflags floatfield;\n\n    typedef T2 iostate;\n    static constexpr iostate badbit;\n    static constexpr iostate eofbit;\n    static constexpr iostate failbit;\n    static constexpr iostate goodbit;\n\n    typedef T3 openmode;\n    static constexpr openmode app;\n    static constexpr openmode ate;\n    static constexpr openmode binary;\n    static constexpr openmode in;\n    static constexpr openmode out;\n    static constexpr openmode trunc;\n\n    typedef T4 seekdir;\n    static constexpr seekdir beg;\n    static constexpr seekdir cur;\n    static constexpr seekdir end;\n\n    class Init;\n\n    // 27.5.2.2 fmtflags state:\n    fmtflags flags() const;\n    fmtflags flags(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl, fmtflags mask);\n    void unsetf(fmtflags mask);\n\n    streamsize precision() const;\n    streamsize precision(streamsize prec);\n    streamsize width() const;\n    streamsize width(streamsize wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int index);\n    void*& pword(int index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int index);\n    void register_callback(event_callback fn, int index);\n\n    ios_base(const ios_base&) = delete;\n    ios_base& operator=(const ios_base&) = delete;\n\n    static bool sync_with_stdio(bool sync = true);\n\nprotected:\n    ios_base();\n};\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef typename traits::int_type int_type;  // removed in C++17\n    typedef typename traits::pos_type pos_type;  // removed in C++17\n    typedef typename traits::off_type off_type;  // removed in C++17\n    typedef traits traits_type;\n\n    operator unspecified-bool-type() const;\n    bool operator!() const;\n    iostate rdstate() const;\n    void clear(iostate state = goodbit);\n    void setstate(iostate state);\n    bool good() const;\n    bool eof() const;\n    bool fail() const;\n    bool bad() const;\n\n    iostate exceptions() const;\n    void exceptions(iostate except);\n\n    // 27.5.4.1 Constructor/destructor:\n    explicit basic_ios(basic_streambuf<charT,traits>* sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    basic_ostream<charT,traits>* tie() const;\n    basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr);\n\n    basic_streambuf<charT,traits>* rdbuf() const;\n    basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb);\n\n    basic_ios& copyfmt(const basic_ios& rhs);\n\n    char_type fill() const;\n    char_type fill(char_type ch);\n\n    locale imbue(const locale& loc);\n\n    char narrow(char_type c, char dfault) const;\n    char_type widen(char c) const;\n\n    basic_ios(const basic_ios& ) = delete;\n    basic_ios& operator=(const basic_ios&) = delete;\n\nprotected:\n    basic_ios();\n    void init(basic_streambuf<charT,traits>* sb);\n    void move(basic_ios& rhs);\n    void swap(basic_ios& rhs) noexcept;\n    void set_rdbuf(basic_streambuf<charT, traits>* sb);\n};\n\n// 27.5.5, manipulators:\nios_base& boolalpha (ios_base& str);\nios_base& noboolalpha(ios_base& str);\nios_base& showbase (ios_base& str);\nios_base& noshowbase (ios_base& str);\nios_base& showpoint (ios_base& str);\nios_base& noshowpoint(ios_base& str);\nios_base& showpos (ios_base& str);\nios_base& noshowpos (ios_base& str);\nios_base& skipws (ios_base& str);\nios_base& noskipws (ios_base& str);\nios_base& uppercase (ios_base& str);\nios_base& nouppercase(ios_base& str);\nios_base& unitbuf (ios_base& str);\nios_base& nounitbuf (ios_base& str);\n\n// 27.5.5.2 adjustfield:\nios_base& internal (ios_base& str);\nios_base& left (ios_base& str);\nios_base& right (ios_base& str);\n\n// 27.5.5.3 basefield:\nios_base& dec (ios_base& str);\nios_base& hex (ios_base& str);\nios_base& oct (ios_base& str);\n\n// 27.5.5.4 floatfield:\nios_base& fixed (ios_base& str);\nios_base& scientific (ios_base& str);\nios_base& hexfloat (ios_base& str);\nios_base& defaultfloat(ios_base& str);\n\n// 27.5.5.5 error reporting:\nenum class io_errc\n{\n    stream = 1\n};\n\nconcept_map ErrorCodeEnum<io_errc> { };\nerror_code make_error_code(io_errc e) noexcept; \nerror_condition make_error_condition(io_errc e) noexcept; \nstorage-class-specifier const error_category& iostream_category() noexcept;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <__locale>\n#include <system_error>\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n#include <atomic>     // for __xindex_\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntypedef ptrdiff_t streamsize;\n\nclass _LIBCPP_TYPE_VIS ios_base\n{\npublic:\n    class _LIBCPP_EXCEPTION_ABI failure;\n\n    typedef unsigned int fmtflags;\n    static const fmtflags boolalpha   = 0x0001;\n    static const fmtflags dec         = 0x0002;\n    static const fmtflags fixed       = 0x0004;\n    static const fmtflags hex         = 0x0008;\n    static const fmtflags internal    = 0x0010;\n    static const fmtflags left        = 0x0020;\n    static const fmtflags oct         = 0x0040;\n    static const fmtflags right       = 0x0080;\n    static const fmtflags scientific  = 0x0100;\n    static const fmtflags showbase    = 0x0200;\n    static const fmtflags showpoint   = 0x0400;\n    static const fmtflags showpos     = 0x0800;\n    static const fmtflags skipws      = 0x1000;\n    static const fmtflags unitbuf     = 0x2000;\n    static const fmtflags uppercase   = 0x4000;\n    static const fmtflags adjustfield = left | right | internal;\n    static const fmtflags basefield   = dec | oct | hex;\n    static const fmtflags floatfield  = scientific | fixed;\n\n    typedef unsigned int iostate;\n    static const iostate badbit  = 0x1;\n    static const iostate eofbit  = 0x2;\n    static const iostate failbit = 0x4;\n    static const iostate goodbit = 0x0;\n\n    typedef unsigned int openmode;\n    static const openmode app    = 0x01;\n    static const openmode ate    = 0x02;\n    static const openmode binary = 0x04;\n    static const openmode in     = 0x08;\n    static const openmode out    = 0x10;\n    static const openmode trunc  = 0x20;\n\n    enum seekdir {beg, cur, end};\n\n#if _LIBCPP_STD_VER <= 14\n    typedef iostate      io_state;\n    typedef openmode     open_mode;\n    typedef seekdir      seek_dir;\n\n    typedef _VSTD::streamoff streamoff;\n    typedef _VSTD::streampos streampos;\n#endif\n\n    class _LIBCPP_TYPE_VIS Init;\n\n    // 27.5.2.2 fmtflags state:\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags() const;\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl, fmtflags __mask);\n    _LIBCPP_INLINE_VISIBILITY void unsetf(fmtflags __mask);\n\n    _LIBCPP_INLINE_VISIBILITY streamsize precision() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize precision(streamsize __prec);\n    _LIBCPP_INLINE_VISIBILITY streamsize width() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize width(streamsize __wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& __loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int __index);\n    void*& pword(int __index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int __index);\n    void register_callback(event_callback __fn, int __index);\n\nprivate:\n    ios_base(const ios_base&); // = delete;\n    ios_base& operator=(const ios_base&); // = delete;\n\npublic:\n    static bool sync_with_stdio(bool __sync = true);\n\n    _LIBCPP_INLINE_VISIBILITY iostate rdstate() const;\n    void clear(iostate __state = goodbit);\n    _LIBCPP_INLINE_VISIBILITY void setstate(iostate __state);\n\n    _LIBCPP_INLINE_VISIBILITY bool good() const;\n    _LIBCPP_INLINE_VISIBILITY bool eof() const;\n    _LIBCPP_INLINE_VISIBILITY bool fail() const;\n    _LIBCPP_INLINE_VISIBILITY bool bad() const;\n\n    _LIBCPP_INLINE_VISIBILITY iostate exceptions() const;\n    _LIBCPP_INLINE_VISIBILITY void exceptions(iostate __iostate);\n\n    void __set_badbit_and_consider_rethrow();\n    void __set_failbit_and_consider_rethrow();\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ios_base() {// purposefully does no initialization\n               }\n\n    void init(void* __sb);\n    _LIBCPP_ALWAYS_INLINE void* rdbuf() const {return __rdbuf_;}\n\n    _LIBCPP_ALWAYS_INLINE\n    void rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n        clear();\n    }\n\n    void __call_callbacks(event);\n    void copyfmt(const ios_base&);\n    void move(ios_base&);\n    void swap(ios_base&) _NOEXCEPT;\n\n    _LIBCPP_ALWAYS_INLINE\n    void set_rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n    }\n\nprivate:\n    // All data members must be scalars\n    fmtflags        __fmtflags_;\n    streamsize      __precision_;\n    streamsize      __width_;\n    iostate         __rdstate_;\n    iostate         __exceptions_;\n    void*           __rdbuf_;\n    void*           __loc_;\n    event_callback* __fn_;\n    int*            __index_;\n    size_t          __event_size_;\n    size_t          __event_cap_;\n// TODO(EricWF): Enable this for both Clang and GCC. Currently it is only\n// enabled with clang.\n#if defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_NO_THREADS)\n    static atomic<int> __xindex_;\n#else\n    static int      __xindex_;\n#endif\n    long*           __iarray_;\n    size_t          __iarray_size_;\n    size_t          __iarray_cap_;\n    void**          __parray_;\n    size_t          __parray_size_;\n    size_t          __parray_cap_;\n};\n\n//enum class io_errc\n_LIBCPP_DECLARE_STRONG_ENUM(io_errc)\n{\n    stream = 1\n};\n_LIBCPP_DECLARE_STRONG_ENUM_EPILOG(io_errc)\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS is_error_code_enum<io_errc> : public true_type { };\n\n#ifdef _LIBCPP_HAS_NO_STRONG_ENUMS\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS is_error_code_enum<io_errc::__lx> : public true_type { };\n#endif\n\n_LIBCPP_FUNC_VIS\nconst error_category& iostream_category() _NOEXCEPT;\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_code\nmake_error_code(io_errc __e) _NOEXCEPT\n{\n    return error_code(static_cast<int>(__e), iostream_category());\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_condition\nmake_error_condition(io_errc __e) _NOEXCEPT\n{\n    return error_condition(static_cast<int>(__e), iostream_category());\n}\n\nclass _LIBCPP_EXCEPTION_ABI ios_base::failure\n    : public system_error\n{\npublic:\n    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);\n    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);\n    virtual ~failure() throw();\n};\n\nclass _LIBCPP_TYPE_VIS ios_base::Init\n{\npublic:\n    Init();\n    ~Init();\n};\n\n// fmtflags\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags() const\n{\n    return __fmtflags_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ = __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ |= __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::unsetf(fmtflags __mask)\n{\n    __fmtflags_ &= ~__mask;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl, fmtflags __mask)\n{\n    fmtflags __r = __fmtflags_;\n    unsetf(__mask);\n    __fmtflags_ |= __fmtfl & __mask;\n    return __r;\n}\n\n// precision\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision() const\n{\n    return __precision_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision(streamsize __prec)\n{\n    streamsize __r = __precision_;\n    __precision_ = __prec;\n    return __r;\n}\n\n// width\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width() const\n{\n    return __width_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width(streamsize __wide)\n{\n    streamsize __r = __width_;\n    __width_ = __wide;\n    return __r;\n}\n\n// iostate\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::rdstate() const\n{\n    return __rdstate_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::setstate(iostate __state)\n{\n    clear(__rdstate_ | __state);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::good() const\n{\n    return __rdstate_ == 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::eof() const\n{\n    return (__rdstate_ & eofbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::fail() const\n{\n    return (__rdstate_ & (failbit | badbit)) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::bad() const\n{\n    return (__rdstate_ & badbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::exceptions() const\n{\n    return __exceptions_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::exceptions(iostate __iostate)\n{\n    __exceptions_ = __iostate;\n    clear(__rdstate_);\n}\n\n#if defined(_LIBCPP_CXX03_LANG)\nstruct _LIBCPP_TYPE_VIS __cxx03_bool {\n  typedef void (__cxx03_bool::*__bool_type)();\n  void __true_value() {}\n};\n#endif\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n#if defined(_LIBCPP_CXX03_LANG)\n    _LIBCPP_ALWAYS_INLINE\n    operator __cxx03_bool::__bool_type() const {\n        return !fail() ? &__cxx03_bool::__true_value : nullptr;\n    }\n#else\n    _LIBCPP_ALWAYS_INLINE\n    _LIBCPP_EXPLICIT operator bool() const {return !fail();}\n#endif\n\n    _LIBCPP_ALWAYS_INLINE bool operator!() const    {return  fail();}\n    _LIBCPP_ALWAYS_INLINE iostate rdstate() const   {return ios_base::rdstate();}\n    _LIBCPP_ALWAYS_INLINE void clear(iostate __state = goodbit) {ios_base::clear(__state);}\n    _LIBCPP_ALWAYS_INLINE void setstate(iostate __state) {ios_base::setstate(__state);}\n    _LIBCPP_ALWAYS_INLINE bool good() const {return ios_base::good();}\n    _LIBCPP_ALWAYS_INLINE bool eof() const  {return ios_base::eof();}\n    _LIBCPP_ALWAYS_INLINE bool fail() const {return ios_base::fail();}\n    _LIBCPP_ALWAYS_INLINE bool bad() const  {return ios_base::bad();}\n\n    _LIBCPP_ALWAYS_INLINE iostate exceptions() const {return ios_base::exceptions();}\n    _LIBCPP_ALWAYS_INLINE void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}\n\n    // 27.5.4.1 Constructor/destructor:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);\n\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);\n\n    basic_ios& copyfmt(const basic_ios& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill() const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill(char_type __ch);\n\n    _LIBCPP_INLINE_VISIBILITY \n    locale imbue(const locale& __loc);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char narrow(char_type __c, char __dfault) const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type widen(char __c) const;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ios() {// purposefully does no initialization\n                }\n    _LIBCPP_INLINE_VISIBILITY \n    void init(basic_streambuf<char_type, traits_type>* __sb);\n\n    _LIBCPP_INLINE_VISIBILITY \n    void move(basic_ios& __rhs);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_ALWAYS_INLINE\n    void move(basic_ios&& __rhs) {move(__rhs);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY \n    void swap(basic_ios& __rhs) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY \n    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);\nprivate:\n    basic_ostream<char_type, traits_type>* __tie_;\n     mutable int_type __fill_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)\n{\n    init(__sb);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>::~basic_ios()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::init(__sb);\n    __tie_ = 0;\n    __fill_ = traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie() const\n{\n    return __tie_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)\n{\n    basic_ostream<char_type, traits_type>* __r = __tie_;\n    __tie_ = __tiestr;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf() const\n{\n    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    basic_streambuf<char_type, traits_type>* __r = rdbuf();\n    ios_base::rdbuf(__sb);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_ios<_CharT, _Traits>::imbue(const locale& __loc)\n{\n    locale __r = getloc();\n    ios_base::imbue(__loc);\n    if (rdbuf())\n        rdbuf()->pubimbue(__loc);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nchar\nbasic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const\n{\n    return use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::widen(char __c) const\n{\n    return use_facet<ctype<char_type> >(getloc()).widen(__c);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill() const\n{\n    if (traits_type::eq_int_type(traits_type::eof(), __fill_))\n        __fill_ = widen(' ');\n    return __fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill(char_type __ch)\n{\n    char_type __r = __fill_;\n    __fill_ = __ch;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>&\nbasic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)\n{\n    if (this != &__rhs)\n    {\n        __call_callbacks(erase_event);\n        ios_base::copyfmt(__rhs);\n        __tie_ = __rhs.__tie_;\n        __fill_ = __rhs.__fill_;\n        __call_callbacks(copyfmt_event);\n        exceptions(__rhs.exceptions());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::move(basic_ios& __rhs)\n{\n    ios_base::move(__rhs);\n    __tie_ = __rhs.__tie_;\n    __rhs.__tie_ = 0;\n    __fill_ = __rhs.__fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) _NOEXCEPT\n{\n    ios_base::swap(__rhs);\n    _VSTD::swap(__tie_, __rhs.__tie_);\n    _VSTD::swap(__fill_, __rhs.__fill_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::set_rdbuf(__sb);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nboolalpha(ios_base& __str)\n{\n    __str.setf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoboolalpha(ios_base& __str)\n{\n    __str.unsetf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowbase(ios_base& __str)\n{\n    __str.setf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowbase(ios_base& __str)\n{\n    __str.unsetf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpoint(ios_base& __str)\n{\n    __str.setf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpoint(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpos(ios_base& __str)\n{\n    __str.setf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpos(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nskipws(ios_base& __str)\n{\n    __str.setf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoskipws(ios_base& __str)\n{\n    __str.unsetf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nuppercase(ios_base& __str)\n{\n    __str.setf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnouppercase(ios_base& __str)\n{\n    __str.unsetf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nunitbuf(ios_base& __str)\n{\n    __str.setf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnounitbuf(ios_base& __str)\n{\n    __str.unsetf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ninternal(ios_base& __str)\n{\n    __str.setf(ios_base::internal, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nleft(ios_base& __str)\n{\n    __str.setf(ios_base::left, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nright(ios_base& __str)\n{\n    __str.setf(ios_base::right, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndec(ios_base& __str)\n{\n    __str.setf(ios_base::dec, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhex(ios_base& __str)\n{\n    __str.setf(ios_base::hex, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\noct(ios_base& __str)\n{\n    __str.setf(ios_base::oct, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nfixed(ios_base& __str)\n{\n    __str.setf(ios_base::fixed, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nscientific(ios_base& __str)\n{\n    __str.setf(ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhexfloat(ios_base& __str)\n{\n    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndefaultfloat(ios_base& __str)\n{\n    __str.unsetf(ios_base::floatfield);\n    return __str;\n}\n\ntemplate <class _CharT, class _Traits>\nclass __save_flags\n{\n    typedef basic_ios<_CharT, _Traits> __stream_type;\n    typedef typename __stream_type::fmtflags fmtflags;\n\n    __stream_type& __stream_;\n    fmtflags       __fmtflags_;\n    _CharT         __fill_;\n\n    __save_flags(const __save_flags&);\n    __save_flags& operator=(const __save_flags&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __save_flags(__stream_type& __stream)\n        : __stream_(__stream),\n          __fmtflags_(__stream.flags()),\n          __fill_(__stream.fill())\n        {}\n    _LIBCPP_INLINE_VISIBILITY\n    ~__save_flags()\n    {\n        __stream_.flags(__fmtflags_);\n        __stream_.fill(__fill_);\n    }\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOS\n","// -*- C++ -*-\n//===--------------------------- istream ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ISTREAM\n#define _LIBCPP_ISTREAM\n\n/*\n    istream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_istream\n    : virtual public basic_ios<charT,traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.1.1.1 Constructor/destructor:\n    explicit basic_istream(basic_streambuf<char_type, traits_type>* sb);\n    basic_istream(basic_istream&& rhs);\n    virtual ~basic_istream();\n\n    // 27.7.1.1.2 Assign/swap:\n    basic_istream& operator=(basic_istream&& rhs);\n    void swap(basic_istream& rhs);\n\n    // 27.7.1.1.3 Prefix/suffix:\n    class sentry;\n\n    // 27.7.1.2 Formatted input:\n    basic_istream& operator>>(basic_istream& (*pf)(basic_istream&));\n    basic_istream& operator>>(basic_ios<char_type, traits_type>&\n                              (*pf)(basic_ios<char_type, traits_type>&));\n    basic_istream& operator>>(ios_base& (*pf)(ios_base&));\n    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* sb);\n    basic_istream& operator>>(bool& n);\n    basic_istream& operator>>(short& n);\n    basic_istream& operator>>(unsigned short& n);\n    basic_istream& operator>>(int& n);\n    basic_istream& operator>>(unsigned int& n);\n    basic_istream& operator>>(long& n);\n    basic_istream& operator>>(unsigned long& n);\n    basic_istream& operator>>(long long& n);\n    basic_istream& operator>>(unsigned long long& n);\n    basic_istream& operator>>(float& f);\n    basic_istream& operator>>(double& f);\n    basic_istream& operator>>(long double& f);\n    basic_istream& operator>>(void*& p);\n\n    // 27.7.1.3 Unformatted input:\n    streamsize gcount() const;\n    int_type get();\n    basic_istream& get(char_type& c);\n    basic_istream& get(char_type* s, streamsize n);\n    basic_istream& get(char_type* s, streamsize n, char_type delim);\n    basic_istream& get(basic_streambuf<char_type,traits_type>& sb);\n    basic_istream& get(basic_streambuf<char_type,traits_type>& sb, char_type delim);\n\n    basic_istream& getline(char_type* s, streamsize n);\n    basic_istream& getline(char_type* s, streamsize n, char_type delim);\n\n    basic_istream& ignore(streamsize n = 1, int_type delim = traits_type::eof());\n    int_type peek();\n    basic_istream& read (char_type* s, streamsize n);\n    streamsize readsome(char_type* s, streamsize n);\n\n    basic_istream& putback(char_type c);\n    basic_istream& unget();\n    int sync();\n\n    pos_type tellg();\n    basic_istream& seekg(pos_type);\n    basic_istream& seekg(off_type, ios_base::seekdir);\nprotected:\n    basic_istream(const basic_istream& rhs) = delete;\n    basic_istream(basic_istream&& rhs);\n    // 27.7.2.1.2 Assign/swap:\n    basic_istream& operator=(const basic_istream& rhs) = delete;\n    basic_istream& operator=(basic_istream&& rhs);\n    void swap(basic_istream& rhs);\n};\n\n// 27.7.1.2.3 character extraction templates:\ntemplate<class charT, class traits>\n  basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&, charT&);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, unsigned char&);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, signed char&);\n\ntemplate<class charT, class traits>\n  basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&, charT*);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, unsigned char*);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, signed char*);\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_istream<charT, traits>& x, basic_istream<charT, traits>& y);\n\ntypedef basic_istream<char> istream;\ntypedef basic_istream<wchar_t> wistream;\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_iostream :\n    public basic_istream<charT,traits>,\n    public basic_ostream<charT,traits>\n{\npublic:\n    // types:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // constructor/destructor\n    explicit basic_iostream(basic_streambuf<char_type, traits_type>* sb);\n    basic_iostream(basic_iostream&& rhs);\n    virtual ~basic_iostream();\n\n    // assign/swap\n    basic_iostream& operator=(basic_iostream&& rhs);\n    void swap(basic_iostream& rhs);\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_iostream<charT, traits>& x, basic_iostream<charT, traits>& y);\n\ntypedef basic_iostream<char> iostream;\ntypedef basic_iostream<wchar_t> wiostream;\n\ntemplate <class charT, class traits>\n  basic_istream<charT,traits>&\n  ws(basic_istream<charT,traits>& is);\n\ntemplate <class charT, class traits, class T>\n  basic_istream<charT, traits>&\n  operator>>(basic_istream<charT, traits>&& is, T& x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ostream>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_istream\n    : virtual public basic_ios<_CharT, _Traits>\n{\n    streamsize __gc_;\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.1.1.1 Constructor/destructor:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    explicit basic_istream(basic_streambuf<char_type, traits_type>* __sb) : __gc_(0)\n    { this->init(__sb); }\n    virtual ~basic_istream();\nprotected:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_istream(basic_istream&& __rhs);\n#endif\n    // 27.7.1.1.2 Assign/swap:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_istream& operator=(basic_istream&& __rhs);\n#endif\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void swap(basic_istream& __rhs) {\n      _VSTD::swap(__gc_, __rhs.__gc_);\n      basic_ios<char_type, traits_type>::swap(__rhs);\n    }\n\n#ifndef _LIBCPP_CXX03_LANG\n    basic_istream           (const basic_istream& __rhs) = delete;\n    basic_istream& operator=(const basic_istream& __rhs) = delete;\n#endif\npublic:\n\n    // 27.7.1.1.3 Prefix/suffix:\n    class _LIBCPP_TEMPLATE_VIS sentry;\n\n    // 27.7.1.2 Formatted input:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_istream& operator>>(basic_istream& (*__pf)(basic_istream&))\n    { return __pf(*this); }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_istream& operator>>(basic_ios<char_type, traits_type>&\n                              (*__pf)(basic_ios<char_type, traits_type>&))\n    { __pf(*this); return *this; }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_istream& operator>>(ios_base& (*__pf)(ios_base&))\n    { __pf(*this); return *this; }\n\n    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* __sb);\n    basic_istream& operator>>(bool& __n);\n    basic_istream& operator>>(short& __n);\n    basic_istream& operator>>(unsigned short& __n);\n    basic_istream& operator>>(int& __n);\n    basic_istream& operator>>(unsigned int& __n);\n    basic_istream& operator>>(long& __n);\n    basic_istream& operator>>(unsigned long& __n);\n    basic_istream& operator>>(long long& __n);\n    basic_istream& operator>>(unsigned long long& __n);\n    basic_istream& operator>>(float& __f);\n    basic_istream& operator>>(double& __f);\n    basic_istream& operator>>(long double& __f);\n    basic_istream& operator>>(void*& __p);\n\n    // 27.7.1.3 Unformatted input:\n    _LIBCPP_INLINE_VISIBILITY\n    streamsize gcount() const {return __gc_;}\n    int_type get();\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_istream& get(char_type& __c) {\n      int_type __ch = get();\n      if (__ch != traits_type::eof())\n        __c = traits_type::to_char_type(__ch);\n      return *this;\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_istream& get(char_type* __s, streamsize __n)\n    { return get(__s, __n, this->widen('\\n')); }\n\n    basic_istream& get(char_type* __s, streamsize __n, char_type __dlm);\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb)\n    { return get(__sb, this->widen('\\n')); }\n\n    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb, char_type __dlm);\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_istream& getline(char_type* __s, streamsize __n)\n    { return getline(__s, __n, this->widen('\\n')); }\n\n    basic_istream& getline(char_type* __s, streamsize __n, char_type __dlm);\n\n    basic_istream& ignore(streamsize __n = 1, int_type __dlm = traits_type::eof());\n    int_type peek();\n    basic_istream& read (char_type* __s, streamsize __n);\n    streamsize readsome(char_type* __s, streamsize __n);\n\n    basic_istream& putback(char_type __c);\n    basic_istream& unget();\n    int sync();\n\n    pos_type tellg();\n    basic_istream& seekg(pos_type __pos);\n    basic_istream& seekg(off_type __off, ios_base::seekdir __dir);\n};\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_istream<_CharT, _Traits>::sentry\n{\n    bool __ok_;\n\n    sentry(const sentry&); // = delete;\n    sentry& operator=(const sentry&); // = delete;\n\npublic:\n    explicit sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);\n//    ~sentry() = default;\n\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT\n        operator bool() const {return __ok_;}\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits>& __is,\n                                               bool __noskipws)\n    : __ok_(false)\n{\n    if (__is.good())\n    {\n        if (__is.tie())\n            __is.tie()->flush();\n        if (!__noskipws && (__is.flags() & ios_base::skipws))\n        {\n            typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            _Ip __i(__is);\n            _Ip __eof;\n            for (; __i != __eof; ++__i)\n                if (!__ct.is(__ct.space, *__i))\n                    break;\n            if (__i == __eof)\n                __is.setstate(ios_base::failbit | ios_base::eofbit);\n        }\n        __ok_ = __is.good();\n    }\n    else\n        __is.setstate(ios_base::failbit);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>::basic_istream(basic_istream&& __rhs)\n    : __gc_(__rhs.__gc_)\n{\n    __rhs.__gc_ = 0;\n    this->move(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator=(basic_istream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>::~basic_istream()\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned short& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned int& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(long& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned long& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(long long& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned long long& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(float& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(double& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(long double& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(bool& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(void*& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(short& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            long __temp;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);\n            if (__temp < numeric_limits<short>::min())\n            {\n                __err |= ios_base::failbit;\n                __n = numeric_limits<short>::min();\n            }\n            else if (__temp > numeric_limits<short>::max())\n            {\n                __err |= ios_base::failbit;\n                __n = numeric_limits<short>::max();\n            }\n            else\n                __n = static_cast<short>(__temp);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(int& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            long __temp;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);\n            if (__temp < numeric_limits<int>::min())\n            {\n                __err |= ios_base::failbit;\n                __n = numeric_limits<int>::min();\n            }\n            else if (__temp > numeric_limits<int>::max())\n            {\n                __err |= ios_base::failbit;\n                __n = numeric_limits<int>::max();\n            }\n            else\n                __n = static_cast<int>(__temp);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, _CharT* __s)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            streamsize __n = __is.width();\n            if (__n <= 0)\n                __n = numeric_limits<streamsize>::max() / sizeof(_CharT) - 1;\n            streamsize __c = 0;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            ios_base::iostate __err = ios_base::goodbit;\n            while (__c < __n-1)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (__ct.is(__ct.space, __ch))\n                    break;\n                *__s++ = __ch;\n                ++__c;\n                 __is.rdbuf()->sbumpc();\n            }\n            *__s = _CharT();\n            __is.width(0);\n            if (__c == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, unsigned char* __s)\n{\n    return __is >> (char*)__s;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, signed char* __s)\n{\n    return __is >> (char*)__s;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, _CharT& __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            typename _Traits::int_type __i = __is.rdbuf()->sbumpc();\n            if (_Traits::eq_int_type(__i, _Traits::eof()))\n                __is.setstate(ios_base::eofbit | ios_base::failbit);\n            else\n                __c = _Traits::to_char_type(__i);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, unsigned char& __c)\n{\n    return __is >> (char&)__c;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, signed char& __c)\n{\n    return __is >> (char&)__c;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(basic_streambuf<char_type, traits_type>* __sb)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this, true);\n        if (__s)\n        {\n            if (__sb)\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                    ios_base::iostate __err = ios_base::goodbit;\n                    while (true)\n                    {\n                        typename traits_type::int_type __i = this->rdbuf()->sgetc();\n                        if (traits_type::eq_int_type(__i, _Traits::eof()))\n                        {\n                           __err |= ios_base::eofbit;\n                           break;\n                        }\n                        if (traits_type::eq_int_type(\n                                __sb->sputc(traits_type::to_char_type(__i)),\n                                traits_type::eof()))\n                            break;\n                        ++__gc_;\n                        this->rdbuf()->sbumpc();\n                    }\n                    if (__gc_ == 0)\n                       __err |= ios_base::failbit;\n                    this->setstate(__err);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    if (__gc_ == 0)\n                        this->__set_failbit_and_consider_rethrow();\n                }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            else\n                this->setstate(ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\ntypename basic_istream<_CharT, _Traits>::int_type\nbasic_istream<_CharT, _Traits>::get()\n{\n    __gc_ = 0;\n    int_type __r = traits_type::eof();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this, true);\n        if (__s)\n        {\n            __r = this->rdbuf()->sbumpc();\n            if (traits_type::eq_int_type(__r, traits_type::eof()))\n               this->setstate(ios_base::failbit | ios_base::eofbit);\n            else\n                __gc_ = 1;\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n, char_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (__n > 0)\n            {\n                ios_base::iostate __err = ios_base::goodbit;\n                while (__gc_ < __n-1)\n                {\n                    int_type __i = this->rdbuf()->sgetc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    char_type __ch = traits_type::to_char_type(__i);\n                    if (traits_type::eq(__ch, __dlm))\n                        break;\n                    *__s++ = __ch;\n                    ++__gc_;\n                     this->rdbuf()->sbumpc();\n                }\n                *__s = char_type();\n                if (__gc_ == 0)\n                   __err |= ios_base::failbit;\n                this->setstate(__err);\n            }\n            else\n                this->setstate(ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb,\n                                    char_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            ios_base::iostate __err = ios_base::goodbit;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                while (true)\n                {\n                    typename traits_type::int_type __i = this->rdbuf()->sgetc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    char_type __ch = traits_type::to_char_type(__i);\n                    if (traits_type::eq(__ch, __dlm))\n                        break;\n                    if (traits_type::eq_int_type(__sb.sputc(__ch), traits_type::eof()))\n                        break;\n                    ++__gc_;\n                    this->rdbuf()->sbumpc();\n                }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__gc_ == 0)\n               __err |= ios_base::failbit;\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n, char_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            ios_base::iostate __err = ios_base::goodbit;\n            while (true)\n            {\n                typename traits_type::int_type __i = this->rdbuf()->sgetc();\n                if (traits_type::eq_int_type(__i, traits_type::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                char_type __ch = traits_type::to_char_type(__i);\n                if (traits_type::eq(__ch, __dlm))\n                {\n                    this->rdbuf()->sbumpc();\n                    ++__gc_;\n                    break;\n                }\n                if (__gc_ >= __n-1)\n                {\n                    __err |= ios_base::failbit;\n                    break;\n                }\n                *__s++ = __ch;\n                this->rdbuf()->sbumpc();\n                ++__gc_;\n            }\n            if (__n > 0)\n                *__s = char_type();\n            if (__gc_ == 0)\n               __err |= ios_base::failbit;\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            ios_base::iostate __err = ios_base::goodbit;\n            if (__n == numeric_limits<streamsize>::max())\n            {\n                while (true)\n                {\n                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    ++__gc_;\n                    if (traits_type::eq_int_type(__i, __dlm))\n                        break;\n                }\n            }\n            else\n            {\n                while (__gc_ < __n)\n                {\n                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    ++__gc_;\n                    if (traits_type::eq_int_type(__i, __dlm))\n                        break;\n                }\n            }\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\ntypename basic_istream<_CharT, _Traits>::int_type\nbasic_istream<_CharT, _Traits>::peek()\n{\n    __gc_ = 0;\n    int_type __r = traits_type::eof();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            __r = this->rdbuf()->sgetc();\n            if (traits_type::eq_int_type(__r, traits_type::eof()))\n                this->setstate(ios_base::eofbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::read(char_type* __s, streamsize __n)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            __gc_ = this->rdbuf()->sgetn(__s, __n);\n            if (__gc_ != __n)\n                this->setstate(ios_base::failbit | ios_base::eofbit);\n        }\n        else\n            this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nstreamsize\nbasic_istream<_CharT, _Traits>::readsome(char_type* __s, streamsize __n)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            streamsize __c = this->rdbuf()->in_avail();\n            switch (__c)\n            {\n            case -1:\n                this->setstate(ios_base::eofbit);\n                break;\n            case 0:\n                break;\n            default:\n                read(__s, _VSTD::min(__c, __n));\n                break;\n            }\n        }\n        else\n            this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __gc_;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::putback(char_type __c)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        this->clear(this->rdstate() & ~ios_base::eofbit);\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf() == 0 || this->rdbuf()->sputbackc(__c) == traits_type::eof())\n                this->setstate(ios_base::badbit);\n        }\n        else\n            this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::unget()\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        this->clear(this->rdstate() & ~ios_base::eofbit);\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf() == 0 || this->rdbuf()->sungetc() == traits_type::eof())\n                this->setstate(ios_base::badbit);\n        }\n        else\n            this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nint\nbasic_istream<_CharT, _Traits>::sync()\n{\n    int __r = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf() == 0)\n                return -1;\n            if (this->rdbuf()->pubsync() == -1)\n            {\n                this->setstate(ios_base::badbit);\n                return -1;\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\ntypename basic_istream<_CharT, _Traits>::pos_type\nbasic_istream<_CharT, _Traits>::tellg()\n{\n    pos_type __r(-1);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n            __r = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::seekg(pos_type __pos)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        this->clear(this->rdstate() & ~ios_base::eofbit);\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf()->pubseekpos(__pos, ios_base::in) == pos_type(-1))\n                this->setstate(ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        this->clear(this->rdstate() & ~ios_base::eofbit);\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::in) == pos_type(-1))\n                this->setstate(ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nws(basic_istream<_CharT, _Traits>& __is)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);\n        if (__sen)\n        {\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            while (true)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __is.setstate(ios_base::eofbit);\n                   break;\n                }\n                if (!__ct.is(__ct.space, _Traits::to_char_type(__i)))\n                    break;\n                __is.rdbuf()->sbumpc();\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>&& __is, _Tp&& __x)\n{\n    __is >> _VSTD::forward<_Tp>(__x);\n    return __is;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_iostream\n    : public basic_istream<_CharT, _Traits>,\n      public basic_ostream<_CharT, _Traits>\n{\npublic:\n    // types:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // constructor/destructor\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    explicit basic_iostream(basic_streambuf<char_type, traits_type>* __sb)\n      : basic_istream<_CharT, _Traits>(__sb)\n    {}\n\n    virtual ~basic_iostream();\nprotected:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_iostream(basic_iostream&& __rhs);\n#endif\n\n    // assign/swap\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_iostream& operator=(basic_iostream&& __rhs);\n#endif\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void swap(basic_iostream& __rhs)\n    { basic_istream<char_type, traits_type>::swap(__rhs); }\npublic:\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_iostream<_CharT, _Traits>::basic_iostream(basic_iostream&& __rhs)\n    : basic_istream<_CharT, _Traits>(_VSTD::move(__rhs))\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_iostream<_CharT, _Traits>&\nbasic_iostream<_CharT, _Traits>::operator=(basic_iostream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_iostream<_CharT, _Traits>::~basic_iostream()\n{\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            __str.clear();\n            streamsize __n = __is.width();\n            if (__n <= 0)\n                __n = __str.max_size();\n            if (__n <= 0)\n                __n = numeric_limits<streamsize>::max();\n            streamsize __c = 0;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            ios_base::iostate __err = ios_base::goodbit;\n            while (__c < __n)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (__ct.is(__ct.space, __ch))\n                    break;\n                __str.push_back(__ch);\n                ++__c;\n                 __is.rdbuf()->sbumpc();\n            }\n            __is.width(0);\n            if (__c == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n        else\n            __is.setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);\n        if (__sen)\n        {\n            __str.clear();\n            ios_base::iostate __err = ios_base::goodbit;\n            streamsize __extr = 0;\n            while (true)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sbumpc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                ++__extr;\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (_Traits::eq(__ch, __dlm))\n                    break;\n                __str.push_back(__ch);\n                if (__str.size() == __str.max_size())\n                {\n                    __err |= ios_base::failbit;\n                    break;\n                }\n            }\n            if (__extr == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n    return getline(__is, __str, __is.widen('\\n'));\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)\n{\n    return getline(__is, __str, __dlm);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n    return getline(__is, __str, __is.widen('\\n'));\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, size_t _Size>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            basic_string<_CharT, _Traits> __str;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            size_t __c = 0;\n            ios_base::iostate __err = ios_base::goodbit;\n            _CharT __zero = __ct.widen('0');\n            _CharT __one = __ct.widen('1');\n            while (__c < _Size)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (!_Traits::eq(__ch, __zero) && !_Traits::eq(__ch, __one))\n                    break;\n                __str.push_back(__ch);\n                ++__c;\n                 __is.rdbuf()->sbumpc();\n            }\n            __x = bitset<_Size>(__str);\n            if (__c == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n        else\n            __is.setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_istream<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_istream<wchar_t>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_iostream<char>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ISTREAM\n","// -*- C++ -*-\n//===-------------------------- memory ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MEMORY\n#define _LIBCPP_MEMORY\n\n/*\n    memory synopsis\n\nnamespace std\n{\n\nstruct allocator_arg_t { };\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n\ntemplate <class T, class Alloc> struct uses_allocator;\n\ntemplate <class Ptr>\nstruct pointer_traits\n{\n    typedef Ptr pointer;\n    typedef <details> element_type;\n    typedef <details> difference_type;\n\n    template <class U> using rebind = <details>;\n\n    static pointer pointer_to(<details>);\n};\n\ntemplate <class T>\nstruct pointer_traits<T*>\n{\n    typedef T* pointer;\n    typedef T element_type;\n    typedef ptrdiff_t difference_type;\n\n    template <class U> using rebind = U*;\n\n    static pointer pointer_to(<details>) noexcept;\n};\n\ntemplate <class Alloc>\nstruct allocator_traits\n{\n    typedef Alloc                        allocator_type;\n    typedef typename allocator_type::value_type\n                                         value_type;\n\n    typedef Alloc::pointer | value_type* pointer;\n    typedef Alloc::const_pointer\n          | pointer_traits<pointer>::rebind<const value_type>\n                                         const_pointer;\n    typedef Alloc::void_pointer\n          | pointer_traits<pointer>::rebind<void>\n                                         void_pointer;\n    typedef Alloc::const_void_pointer\n          | pointer_traits<pointer>::rebind<const void>\n                                         const_void_pointer;\n    typedef Alloc::difference_type\n          | pointer_traits<pointer>::difference_type\n                                         difference_type;\n    typedef Alloc::size_type\n          | make_unsigned<difference_type>::type\n                                         size_type;\n    typedef Alloc::propagate_on_container_copy_assignment\n          | false_type                   propagate_on_container_copy_assignment;\n    typedef Alloc::propagate_on_container_move_assignment\n          | false_type                   propagate_on_container_move_assignment;\n    typedef Alloc::propagate_on_container_swap\n          | false_type                   propagate_on_container_swap;\n    typedef Alloc::is_always_equal\n          | is_empty                     is_always_equal;\n\n    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;\n    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;\n\n    static pointer allocate(allocator_type& a, size_type n);\n    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint);\n\n    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;\n\n    template <class T, class... Args>\n        static void construct(allocator_type& a, T* p, Args&&... args);\n\n    template <class T>\n        static void destroy(allocator_type& a, T* p);\n\n    static size_type max_size(const allocator_type& a); // noexcept in C++14\n\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& a);\n};\n\ntemplate <>\nclass allocator<void>\n{\npublic:\n    typedef void*                                 pointer;\n    typedef const void*                           const_pointer;\n    typedef void                                  value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <class T>\nclass allocator\n{\npublic:\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef T*                                    pointer;\n    typedef const T*                              const_pointer;\n    typedef typename add_lvalue_reference<T>::type       reference;\n    typedef typename add_lvalue_reference<const T>::type const_reference;\n    typedef T                                     value_type;\n\n    template <class U> struct rebind {typedef allocator<U> other;};\n\n    allocator() noexcept;\n    allocator(const allocator&) noexcept;\n    template <class U> allocator(const allocator<U>&) noexcept;\n    ~allocator();\n    pointer address(reference x) const noexcept;\n    const_pointer address(const_reference x) const noexcept;\n    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);\n    void deallocate(pointer p, size_type n) noexcept;\n    size_type max_size() const noexcept;\n    template<class U, class... Args>\n        void construct(U* p, Args&&... args);\n    template <class U>\n        void destroy(U* p);\n};\n\ntemplate <class T, class U>\nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class T, class U>\nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class OutputIterator, class T>\nclass raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      T,                               // purposefully not C++03\n                      ptrdiff_t,                       // purposefully not C++03\n                      T*,                              // purposefully not C++03\n                      raw_storage_iterator&>           // purposefully not C++03\n{\npublic:\n    explicit raw_storage_iterator(OutputIterator x);\n    raw_storage_iterator& operator*();\n    raw_storage_iterator& operator=(const T& element);\n    raw_storage_iterator& operator++();\n    raw_storage_iterator  operator++(int);\n};\n\ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;\ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;\n\ntemplate <class T> T* addressof(T& r) noexcept;\ntemplate <class T> T* addressof(const T&& r) noexcept = delete;\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\nForwardIterator\nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator, class T>\nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);\n\ntemplate <class T>\nvoid destroy_at(T* location);\n\ntemplate <class ForwardIterator>\n void destroy(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator destroy_n(ForwardIterator first, Size n);\n\ntemplate <class InputIterator, class ForwardIterator>\n ForwardIterator uninitialized_move(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\n pair<InputIterator,ForwardIterator> uninitialized_move_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator>\n void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);\n\ntemplate <class ForwardIterator>\n void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);\n\ntemplate <class Y> struct auto_ptr_ref {};\n\ntemplate<class X>\nclass auto_ptr\n{\npublic:\n    typedef X element_type;\n\n    explicit auto_ptr(X* p =0) throw();\n    auto_ptr(auto_ptr&) throw();\n    template<class Y> auto_ptr(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr&) throw();\n    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr_ref<X> r) throw();\n    ~auto_ptr() throw();\n\n    typename add_lvalue_reference<X>::type operator*() const throw();\n    X* operator->() const throw();\n    X* get() const throw();\n    X* release() throw();\n    void reset(X* p =0) throw();\n\n    auto_ptr(auto_ptr_ref<X>) throw();\n    template<class Y> operator auto_ptr_ref<Y>() throw();\n    template<class Y> operator auto_ptr<Y>() throw();\n};\n\ntemplate <class T>\nstruct default_delete\n{\n    constexpr default_delete() noexcept = default;\n    template <class U> default_delete(const default_delete<U>&) noexcept;\n\n    void operator()(T*) const noexcept;\n};\n\ntemplate <class T>\nstruct default_delete<T[]>\n{\n    constexpr default_delete() noexcept = default;\n    void operator()(T*) const noexcept;\n    template <class U> void operator()(U*) const = delete;\n};\n\ntemplate <class T, class D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    typedef see below pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d1) noexcept;\n    unique_ptr(pointer p, see below d2) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n    template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    template <class U>\n        unique_ptr(auto_ptr<U>&& u) noexcept;\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    typename add_lvalue_reference<T>::type operator*() const;\n    pointer operator->() const noexcept;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\nclass unique_ptr<T[], D>\n{\npublic:\n    typedef implementation-defined pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    T& operator[](size_t i) const;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t) noexcept;\n    template <class U> void reset(U) = delete;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\n    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\n\ntemplate <class T, class D>\n    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;\ntemplate <class T, class D>\n    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T, class D>\n    bool operator<(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);\n\nclass bad_weak_ptr\n    : public std::exception\n{\n    bad_weak_ptr() noexcept;\n};\n\ntemplate<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14\ntemplate<class T>                unique_ptr<T> make_unique(size_t n);           // C++14\ntemplate<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    typedef T element_type;\n    typedef weak_ptr<T> weak_type; // C++17\n\n    // constructors:\n    constexpr shared_ptr() noexcept;\n    template<class Y> explicit shared_ptr(Y* p);\n    template<class Y, class D> shared_ptr(Y* p, D d);\n    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);\n    template <class D> shared_ptr(nullptr_t p, D d);\n    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);\n    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;\n    shared_ptr(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;\n    shared_ptr(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;\n    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);\n    template<class Y> shared_ptr(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);\n    shared_ptr(nullptr_t) : shared_ptr() { }\n\n    // destructor:\n    ~shared_ptr();\n\n    // assignment:\n    shared_ptr& operator=(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;\n    shared_ptr& operator=(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);\n    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);\n\n    // modifiers:\n    void swap(shared_ptr& r) noexcept;\n    void reset() noexcept;\n    template<class Y> void reset(Y* p);\n    template<class Y, class D> void reset(Y* p, D d);\n    template<class Y, class D, class A> void reset(Y* p, D d, A a);\n\n    // observers:\n    T* get() const noexcept;\n    T& operator*() const noexcept;\n    T* operator->() const noexcept;\n    long use_count() const noexcept;\n    bool unique() const noexcept;\n    explicit operator bool() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// shared_ptr comparisons:\ntemplate<class T, class U>\n    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\n\ntemplate <class T>\n    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;\n\n// shared_ptr specialized algorithms:\ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;\n\n// shared_ptr casts:\ntemplate<class T, class U>\n    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;\n\n// shared_ptr I/O:\ntemplate<class E, class T, class Y>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);\n\n// shared_ptr get_deleter:\ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;\n\ntemplate<class T, class... Args>\n    shared_ptr<T> make_shared(Args&&... args);\ntemplate<class T, class A, class... Args>\n    shared_ptr<T> allocate_shared(const A& a, Args&&... args);\n\ntemplate<class T>\nclass weak_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors\n    constexpr weak_ptr() noexcept;\n    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // destructor\n    ~weak_ptr();\n\n    // assignment\n    weak_ptr& operator=(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;\n    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;\n    weak_ptr& operator=(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // modifiers\n    void swap(weak_ptr& r) noexcept;\n    void reset() noexcept;\n\n    // observers\n    long use_count() const noexcept;\n    bool expired() const noexcept;\n    shared_ptr<T> lock() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// weak_ptr specialized algorithms:\ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;\n\n// class owner_less:\ntemplate<class T> struct owner_less;\n\ntemplate<class T>\nstruct owner_less<shared_ptr<T>>\n    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nstruct owner_less<weak_ptr<T>>\n    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nclass enable_shared_from_this\n{\nprotected:\n    constexpr enable_shared_from_this() noexcept;\n    enable_shared_from_this(enable_shared_from_this const&) noexcept;\n    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;\n    ~enable_shared_from_this();\npublic:\n    shared_ptr<T> shared_from_this();\n    shared_ptr<T const> shared_from_this() const;\n};\n\ntemplate<class T>\n    bool atomic_is_lock_free(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);\ntemplate<class T>\n    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    shared_ptr<T>\n    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                          shared_ptr<T> w, memory_order success,\n                                          memory_order failure);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                            shared_ptr<T> w, memory_order success,\n                                            memory_order failure);\n// Hash support\ntemplate <class T> struct hash;\ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;\ntemplate <class T> struct hash<shared_ptr<T> >;\n\n// Pointer safety\nenum class pointer_safety { relaxed, preferred, strict };\nvoid declare_reachable(void *p);\ntemplate <class T> T *undeclare_reachable(T *p);\nvoid declare_no_pointers(char *p, size_t n);\nvoid undeclare_no_pointers(char *p, size_t n);\npointer_safety get_pointer_safety() noexcept;\n\nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <cstddef>\n#include <cstdint>\n#include <new>\n#include <utility>\n#include <limits>\n#include <iterator>\n#include <__functional_base>\n#include <iosfwd>\n#include <tuple>\n#include <stdexcept>\n#include <cstring>\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n#  include <atomic>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _ValueType>\ninline _LIBCPP_ALWAYS_INLINE\n_ValueType __libcpp_relaxed_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_RELAXED) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_RELAXED);\n#else\n    return *__value;\n#endif\n}\n\ntemplate <class _ValueType>\ninline _LIBCPP_ALWAYS_INLINE\n_ValueType __libcpp_acquire_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_ACQUIRE) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_ACQUIRE);\n#else\n    return *__value;\n#endif\n}\n\n// addressof moved to <type_traits>\n\ntemplate <class _Tp> class allocator;\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<void>\n{\npublic:\n    typedef void*             pointer;\n    typedef const void*       const_pointer;\n    typedef void              value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<const void>\n{\npublic:\n    typedef const void*       pointer;\n    typedef const void*       const_pointer;\n    typedef const void        value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\n// pointer_traits\n\ntemplate <class _Tp>\nstruct __has_element_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::element_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>\nstruct __pointer_traits_element_type;\n\ntemplate <class _Ptr>\nstruct __pointer_traits_element_type<_Ptr, true>\n{\n    typedef typename _Ptr::element_type type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>\n{\n    typedef typename _Sp<_Tp, _Args...>::element_type type;\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>\n{\n    typedef _Tp type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, true>\n{\n    typedef typename _Sp<_Tp>::element_type type;\n};\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>\n{\n    typedef typename _Sp<_Tp, _A0>::element_type type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>\n{\n    typedef _Tp type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __has_difference_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::difference_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>\nstruct __pointer_traits_difference_type\n{\n    typedef ptrdiff_t type;\n};\n\ntemplate <class _Ptr>\nstruct __pointer_traits_difference_type<_Ptr, true>\n{\n    typedef typename _Ptr::difference_type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __pointer_traits_rebind\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Tp::template rebind<_Up> type;\n#else\n    typedef typename _Tp::template rebind<_Up>::other type;\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>\n{\n    typedef _Sp<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>\n{\n    typedef _Sp<_Up> type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>\n{\n    typedef _Sp<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Ptr>\nstruct _LIBCPP_TEMPLATE_VIS pointer_traits\n{\n    typedef _Ptr                                                     pointer;\n    typedef typename __pointer_traits_element_type<pointer>::type    element_type;\n    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;\n#else\n    template <class _Up> struct rebind\n        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};\n#endif  // _LIBCPP_CXX03_LANG\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                           __nat, element_type>::type& __r)\n        {return pointer::pointer_to(__r);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS pointer_traits<_Tp*>\n{\n    typedef _Tp*      pointer;\n    typedef _Tp       element_type;\n    typedef ptrdiff_t difference_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Up> using rebind = _Up*;\n#else\n    template <class _Up> struct rebind {typedef _Up* other;};\n#endif\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                      __nat, element_type>::type& __r) _NOEXCEPT\n        {return _VSTD::addressof(__r);}\n};\n\ntemplate <class _From, class _To>\nstruct __rebind_pointer {\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_From>::template rebind<_To>        type;\n#else\n    typedef typename pointer_traits<_From>::template rebind<_To>::other type;\n#endif\n};\n\n// allocator_traits\n\nnamespace __has_pointer_type_imp\n{\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::pointer* = 0);\n}\n\ntemplate <class _Tp>\nstruct __has_pointer_type\n    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(0)) == 1>\n{\n};\n\nnamespace __pointer_type_imp\n{\n\ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>\nstruct __pointer_type\n{\n    typedef typename _Dp::pointer type;\n};\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type<_Tp, _Dp, false>\n{\n    typedef _Tp* type;\n};\n\n}  // __pointer_type_imp\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type\n{\n    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __has_const_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>\nstruct __const_pointer\n{\n    typedef typename _Alloc::const_pointer type;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc>\nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>\nstruct __void_pointer\n{\n    typedef typename _Alloc::void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_const_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>\nstruct __const_void_pointer\n{\n    typedef typename _Alloc::const_void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __const_void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits<_Pointer>::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n\ntemplate <class _Tp>\nstruct __has_size_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::size_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>\nstruct __size_type\n{\n    typedef typename make_unsigned<_DiffType>::type type;\n};\n\ntemplate <class _Alloc, class _DiffType>\nstruct __size_type<_Alloc, _DiffType, true>\n{\n    typedef typename _Alloc::size_type type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_copy_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>\nstruct __propagate_on_container_copy_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_copy_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_copy_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_move_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>\nstruct __propagate_on_container_move_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_move_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_move_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_swap\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>\nstruct __propagate_on_container_swap\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_swap<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_swap type;\n};\n\ntemplate <class _Tp>\nstruct __has_is_always_equal\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::is_always_equal* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>\nstruct __is_always_equal\n{\n    typedef typename _VSTD::is_empty<_Alloc>::type type;\n};\n\ntemplate <class _Alloc>\nstruct __is_always_equal<_Alloc, true>\n{\n    typedef typename _Alloc::is_always_equal type;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __has_rebind_other\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind_other<_Tp, _Up, false>\n{\n    static const bool value = false;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>\nstruct __allocator_traits_rebind\n{\n    typedef typename _Tp::template rebind<_Up>::other type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>\n{\n    typedef _Alloc<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>\n{\n    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>\n{\n    typedef _Alloc<_Up> type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> decltype(__a.allocate(__sz, __p), true_type());\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_allocate_hint_test(declval<_Alloc>(),\n                                          declval<_SizeType>(),\n                                          declval<_ConstVoidPtr>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : true_type\n{\n};\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Alloc, class _Tp, class ..._Args>\ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),\n                                           _VSTD::declval<_Args>()...),\n                                           true_type())\n__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nfalse_type\n__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_construct_test(declval<_Alloc>(),\n                                          declval<_Pointer>(),\n                                          declval<_Args>()...)),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(_Alloc&& __a, _Pointer&& __p)\n    -> decltype(__a.destroy(__p), true_type());\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(const _Alloc& __a, _Pointer&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_destroy_test(declval<_Alloc>(),\n                                        declval<_Pointer>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(_Alloc&& __a)\n    -> decltype(__a.max_size(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_max_size_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(_Alloc&& __a)\n    -> decltype(__a.select_on_container_copy_construction(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_select_on_container_copy_construction_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_CXX03_LANG\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class _Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : false_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : true_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>\nstruct __alloc_traits_difference_type\n{\n    typedef typename pointer_traits<_Ptr>::difference_type type;\n};\n\ntemplate <class _Alloc, class _Ptr>\nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>\n{\n    typedef typename _Alloc::difference_type type;\n};\n\ntemplate <class _Alloc>\nstruct _LIBCPP_TEMPLATE_VIS allocator_traits\n{\n    typedef _Alloc                              allocator_type;\n    typedef typename allocator_type::value_type value_type;\n\n    typedef typename __pointer_type<value_type, allocator_type>::type pointer;\n    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;\n    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;\n    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;\n\n    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;\n    typedef typename __size_type<allocator_type, difference_type>::type size_type;\n\n    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type\n                     propagate_on_container_copy_assignment;\n    typedef typename __propagate_on_container_move_assignment<allocator_type>::type\n                     propagate_on_container_move_assignment;\n    typedef typename __propagate_on_container_swap<allocator_type>::type\n                     propagate_on_container_swap;\n    typedef typename __is_always_equal<allocator_type>::type\n                     is_always_equal;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Tp> using rebind_alloc =\n                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;\n    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n#else  // _LIBCPP_CXX03_LANG\n    template <class _Tp> struct rebind_alloc\n        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};\n    template <class _Tp> struct rebind_traits\n        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n)\n        {return __a.allocate(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n        {return allocate(__a, __n, __hint,\n            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT\n        {__a.deallocate(__p, __n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__construct(__has_construct<allocator_type, _Tp*, _Args...>(),\n                         __a, __p, _VSTD::forward<_Args>(__args)...);}\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p)\n            {\n                ::new ((void*)__p) _Tp();\n            }\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)\n            {\n                ::new ((void*)__p) _Tp(__a0);\n            }\n    template <class _Tp, class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1);\n            }\n    template <class _Tp, class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1, const _A2& __a2)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1, __a2);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void destroy(allocator_type& __a, _Tp* __p)\n            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type max_size(const allocator_type& __a) _NOEXCEPT\n        {return __max_size(__has_max_size<const allocator_type>(), __a);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& __a)\n            {return select_on_container_copy_construction(\n                __has_select_on_container_copy_construction<const allocator_type>(),\n                __a);}\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Iter, class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_range_forward(allocator_type& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, (void) ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), *__begin1);\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_range_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            typedef typename remove_const<_Tp>::type _Vp;\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(const_cast<_Vp*>(__begin2), __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)\n        {\n            while (__end1 != __begin1)\n            {\n                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));\n                --__end2;\n            }\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_backward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            __end2 -= _Np;\n            if (_Np > 0)\n                _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));\n        }\n\nprivate:\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer __hint, true_type)\n        {return __a.allocate(__n, __hint);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer, false_type)\n        {return __a.allocate(__n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)\n            {\n                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(true_type, allocator_type& __a, _Tp* __p)\n            {__a.destroy(__p);}\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(false_type, allocator_type&, _Tp* __p)\n            {\n                __p->~_Tp();\n            }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(true_type, const allocator_type& __a)\n            {return __a.max_size();}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(false_type, const allocator_type&)\n            {return numeric_limits<size_type>::max() / sizeof(value_type);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(true_type, const allocator_type& __a)\n            {return __a.select_on_container_copy_construction();}\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(false_type, const allocator_type& __a)\n            {return __a;}\n};\n\ntemplate <class _Traits, class _Tp>\nstruct __rebind_alloc_helper\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Traits::template rebind_alloc<_Tp>        type;\n#else\n    typedef typename _Traits::template rebind_alloc<_Tp>::other type;\n#endif\n};\n\n// allocator\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS allocator\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef _Tp*              pointer;\n    typedef const _Tp*        const_pointer;\n    typedef _Tp&              reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {\n        if (__n > max_size())\n            __throw_length_error(\"allocator<T>::allocate(size_t n)\"\n                                 \" 'n' exceeds maximum supported size\");\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n        }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__libcpp_deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS allocator<const _Tp>\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef const _Tp*        pointer;\n    typedef const _Tp*        const_pointer;\n    typedef const _Tp&        reference;\n    typedef const _Tp&        const_reference;\n    typedef const _Tp         value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n    {\n        if (__n > max_size())\n            __throw_length_error(\"allocator<const T>::allocate(size_t n)\"\n                                 \" 'n' exceeds maximum supported size\");\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n    }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__libcpp_deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}\n\ntemplate <class _OutputIterator, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      _Tp,                                         // purposefully not C++03\n                      ptrdiff_t,                                   // purposefully not C++03\n                      _Tp*,                                        // purposefully not C++03\n                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03\n{\nprivate:\n    _OutputIterator __x_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)\n        {::new(&*__x_) _Tp(__element); return *this;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(_Tp&& __element)\n        {::new(&*__x_) _Tp(_VSTD::move(__element)); return *this;}\n#endif\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)\n        {raw_storage_iterator __t(*this); ++__x_; return __t;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY _OutputIterator base() const { return __x_; } \n#endif\n};\n\ntemplate <class _Tp>\npair<_Tp*, ptrdiff_t>\nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT\n{\n    pair<_Tp*, ptrdiff_t> __r(0, 0);\n    const ptrdiff_t __m = (~ptrdiff_t(0) ^\n                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))\n                           / sizeof(_Tp);\n    if (__n > __m)\n        __n = __m;\n    while (__n > 0)\n    {\n        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));\n        if (__r.first)\n        {\n            __r.second = __n;\n            break;\n        }\n        __n /= 2;\n    }\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}\n\ntemplate <class _Tp>\nstruct auto_ptr_ref\n{\n    _Tp* __ptr_;\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS auto_ptr\n{\nprivate:\n    _Tp* __ptr_;\npublic:\n    typedef _Tp element_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()\n        : __ptr_(__p.release()) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()\n        {reset(__p.release()); return *this;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()\n        {reset(__p.release()); return *this;}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()\n        {reset(__p.__ptr_); return *this;}\n    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()\n    {\n        _Tp* __t = __ptr_;\n        __ptr_ = 0;\n        return __t;\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()\n    {\n        if (__ptr_ != __p)\n            delete __ptr_;\n        __ptr_ = __p;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()\n        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()\n        {return auto_ptr<_Up>(release());}\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS auto_ptr<void>\n{\npublic:\n    typedef void element_type;\n};\n\ntemplate <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,\n                                                     typename remove_cv<_T2>::type>::value,\n                                bool = is_empty<_T1>::value\n                                       && !__libcpp_is_final<_T1>::value,\n                                bool = is_empty<_T2>::value\n                                       && !__libcpp_is_final<_T2>::value\n         >\nstruct __libcpp_compressed_pair_switch;\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false>  {enum {value = 1};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true>  {enum {value = 2};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true>    {enum {value = 3};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true>     {enum {value = 1};};\n\ntemplate <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>\nclass __libcpp_compressed_pair_imp;\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 0>\n{\nprivate:\n    _T1 __first_;\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __first_(), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __first_(), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 1>\n    : private _T1\n{\nprivate:\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1&                                        _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const _T1&                                        _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 2>\n    : private _T2\n{\nprivate:\n    _T1 __first_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef _T2&                                        _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const _T2&                                        _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __first_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_() {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_(_VSTD::forward<_T1_param>(__t1)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...),\n              __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...)\n              \n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 3>\n    : private _T1,\n      private _T2\n{\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1& _T1_reference;\n    typedef _T2& _T2_reference;\n\n    typedef const _T1& _T1_const_reference;\n    typedef const _T2& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), _T2(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp&)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __compressed_pair\n    : private __libcpp_compressed_pair_imp<_T1, _T2>\n{\n    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;\npublic:\n    typedef typename base::_T1_param _T1_param;\n    typedef typename base::_T2_param _T2_param;\n\n    typedef typename base::_T1_reference _T1_reference;\n    typedef typename base::_T2_reference _T2_reference;\n\n    typedef typename base::_T1_const_reference _T1_const_reference;\n    typedef typename base::_T2_const_reference _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T1_param __t1)\n        : base(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T2_param __t2)\n        : base(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair(_T1_param __t1, _T2_param __t2)\n        : base(_VSTD::forward<_T1_param>(__t1), _VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                                      tuple<_Args2...> __second_args)\n            : base(__pc, _VSTD::move(__first_args), _VSTD::move(__second_args),\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return base::first();}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return base::first();}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return base::second();}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return base::second();}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__compressed_pair& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n        {base::swap(__x);}\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {__x.swap(__y);}\n\n// __same_or_less_cv_qualified\n\ntemplate <class _Ptr1, class _Ptr2,\n          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,\n                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type\n                        >::value\n         >\nstruct __same_or_less_cv_qualified_imp\n    : is_convertible<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>\n    : false_type {};\n\ntemplate <class _Ptr1, class _Ptr2, bool = is_pointer<_Ptr1>::value ||\n                                           is_same<_Ptr1, _Ptr2>::value ||\n                                           __has_element_type<_Ptr1>::value>\nstruct __same_or_less_cv_qualified\n    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified<_Ptr1, _Ptr2, false>\n    : false_type {};\n\n// default_delete\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS default_delete\n{\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up>&,\n             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY void operator() (_Tp* __ptr) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete __ptr;\n        }\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS default_delete<_Tp[]>\n{\npublic:\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up[]>&,\n             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        void operator() (_Up* __ptr,\n                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete void type\");\n            delete [] __ptr;\n        }\n};\n\ntemplate <class _Tp, class _Dp = default_delete<_Tp> >\nclass _LIBCPP_TEMPLATE_VIS unique_ptr\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr(unique_ptr<_Up, _Ep>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p) _NOEXCEPT\n        : __ptr_(_VSTD::move(__p))\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename conditional<\n                                        is_reference<deleter_type>::value,\n                                        deleter_type,\n                                        typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                      <\n                        !is_array<_Up>::value &&\n                         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                         is_convertible<_Ep, deleter_type>::value &&\n                         (\n                            !is_reference<deleter_type>::value ||\n                            is_same<deleter_type, _Ep>::value\n                         ),\n                         __nat\n                      >::type = __nat()) _NOEXCEPT\n            : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>&& __p,\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      __nat\n                                  >::type = __nat()) _NOEXCEPT\n            : __ptr_(__p.release())\n            {\n            }\n\n        _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n                return *this;\n            }\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                !is_array<_Up>::value &&\n                is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    template <class _Up, class _Ep>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        !is_array<_Up>::value &&\n        is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n        is_assignable<deleter_type&, _Ep&>::value,\n        unique_ptr&\n    >::type\n    operator=(unique_ptr<_Up, _Ep> __u)\n    {\n        reset(__u.release());\n        __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      unique_ptr&\n                                  >::type\n        operator=(auto_ptr<_Up> __p)\n            {reset(__p.release()); return *this;}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator*() const\n        {return *__ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer()) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) _NOEXCEPT\n        {__ptr_.swap(__u.__ptr_);}\n};\n\ntemplate <class _Tp, class _Dp>\nclass _LIBCPP_TEMPLATE_VIS unique_ptr<_Tp[], _Dp>\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up>\n        unique_ptr(unique_ptr<_Up>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up>\n        unique_ptr& operator=(unique_ptr<_Up>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(_Pp __p,\n            typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat()) _NOEXCEPT\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d,\n                                       typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), __d) {}\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p,\n                                         typename remove_reference<deleter_type>::type&& __d,\n                                         typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n        {\n            reset(__u.release());\n            __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n            return *this;\n        }\n\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                            <\n                                is_array<_Up>::value &&\n                                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value\n                                && is_convertible<_Ep, deleter_type>::value &&\n                                (\n                                    !is_reference<deleter_type>::value ||\n                                    is_same<deleter_type, _Ep>::value\n                                ),\n                                __nat\n                            >::type = __nat()\n                  ) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                is_array<_Up>::value &&\n                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, deleter_type __d)\n        : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(__rv<unique_ptr> __u)\n    {\n        reset(__u->release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const\n        {return __ptr_.first()[__i];}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, void>::type\n    reset(_Pp __p) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(nullptr_t = nullptr) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}\nprivate:\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Up>\n        explicit unique_ptr(_Up);\n    template <class _Up>\n        unique_ptr(_Up __u,\n                   typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type,\n                   typename enable_if\n                      <\n                         is_convertible<_Up, pointer>::value,\n                         __nat\n                      >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Dp>::value,\n    void\n>::type\nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    typedef typename unique_ptr<_T2, _D2>::pointer _P2;\n    typedef typename common_type<_P1, _P2>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(__x.get(), nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(nullptr, __x.get());\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return nullptr < __x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return __x < nullptr;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(nullptr < __x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(nullptr < __x);\n}\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nunique_ptr<_Tp, _Dp>\nmove(unique_ptr<_Tp, _Dp>& __t)\n{\n    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp>\nstruct __unique_if\n{\n    typedef unique_ptr<_Tp> __unique_single;\n};\n\ntemplate<class _Tp>\nstruct __unique_if<_Tp[]>\n{\n    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;\n};\n\ntemplate<class _Tp, size_t _Np>\nstruct __unique_if<_Tp[_Np]>\n{\n    typedef void __unique_array_known_bound;\n};\n\ntemplate<class _Tp, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_single\nmake_unique(_Args&&... __args)\n{\n    return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_array_unknown_bound\nmake_unique(size_t __n)\n{\n    typedef typename remove_extent<_Tp>::type _Up;\n    return unique_ptr<_Tp>(new _Up[__n]());\n}\n\ntemplate<class _Tp, class... _Args>\n    typename __unique_if<_Tp>::__unique_array_known_bound\n    make_unique(_Args&&...) = delete;\n\n#endif  // _LIBCPP_STD_VER > 11\n\ntemplate <class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_Size\n__loadword(const void* __p)\n{\n    _Size __r;\n    std::memcpy(&__r, __p, sizeof(__r));\n    return __r;\n}\n\n// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t\n// is 64 bits.  This is because cityhash64 uses 64bit x 64bit\n// multiplication, which can be very slow on 32-bit systems.\ntemplate <class _Size, size_t = sizeof(_Size)*__CHAR_BIT__>\nstruct __murmur2_or_cityhash;\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 32>\n{\n    _Size operator()(const void* __key, _Size __len);\n};\n\n// murmur2\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len) _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK \n{\n    const _Size __m = 0x5bd1e995;\n    const _Size __r = 24;\n    _Size __h = __len;\n    const unsigned char* __data = static_cast<const unsigned char*>(__key);\n    for (; __len >= 4; __data += 4, __len -= 4)\n    {\n        _Size __k = __loadword<_Size>(__data);\n        __k *= __m;\n        __k ^= __k >> __r;\n        __k *= __m;\n        __h *= __m;\n        __h ^= __k;\n    }\n    switch (__len)\n    {\n    case 3:\n        __h ^= __data[2] << 16;\n    case 2:\n        __h ^= __data[1] << 8;\n    case 1:\n        __h ^= __data[0];\n        __h *= __m;\n    }\n    __h ^= __h >> 13;\n    __h *= __m;\n    __h ^= __h >> 15;\n    return __h;\n}\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 64>\n{\n    _Size operator()(const void* __key, _Size __len);\n\n private:\n  // Some primes between 2^63 and 2^64.\n  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;\n  static const _Size __k1 = 0xb492b66fbe98f273ULL;\n  static const _Size __k2 = 0x9ae16a3b2f90404fULL;\n  static const _Size __k3 = 0xc949d7c7509e6557ULL;\n\n  static _Size __rotate(_Size __val, int __shift) {\n    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));\n  }\n\n  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {\n    return (__val >> __shift) | (__val << (64 - __shift));\n  }\n\n  static _Size __shift_mix(_Size __val) {\n    return __val ^ (__val >> 47);\n  }\n\n  static _Size __hash_len_16(_Size __u, _Size __v) {\n    const _Size __mul = 0x9ddfea08eb382d69ULL;\n    _Size __a = (__u ^ __v) * __mul;\n    __a ^= (__a >> 47);\n    _Size __b = (__v ^ __a) * __mul;\n    __b ^= (__b >> 47);\n    __b *= __mul;\n    return __b;\n  }\n\n  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {\n    if (__len > 8) {\n      const _Size __a = __loadword<_Size>(__s);\n      const _Size __b = __loadword<_Size>(__s + __len - 8);\n      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;\n    }\n    if (__len >= 4) {\n      const uint32_t __a = __loadword<uint32_t>(__s);\n      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);\n      return __hash_len_16(__len + (__a << 3), __b);\n    }\n    if (__len > 0) {\n      const unsigned char __a = __s[0];\n      const unsigned char __b = __s[__len >> 1];\n      const unsigned char __c = __s[__len - 1];\n      const uint32_t __y = static_cast<uint32_t>(__a) +\n                           (static_cast<uint32_t>(__b) << 8);\n      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);\n      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;\n    }\n    return __k2;\n  }\n\n  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {\n    const _Size __a = __loadword<_Size>(__s) * __k1;\n    const _Size __b = __loadword<_Size>(__s + 8);\n    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;\n    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;\n    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,\n                         __a + __rotate(__b ^ __k3, 20) - __c + __len);\n  }\n\n  // Return a 16-byte hash for 48 bytes.  Quick and dirty.\n  // Callers do best to use \"random-looking\" values for a and b.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {\n    __a += __w;\n    __b = __rotate(__b + __a + __z, 21);\n    const _Size __c = __a;\n    __a += __x;\n    __a += __y;\n    __b += __rotate(__a, 44);\n    return pair<_Size, _Size>(__a + __z, __b + __c);\n  }\n\n  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      const char* __s, _Size __a, _Size __b) {\n    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),\n                                         __loadword<_Size>(__s + 8),\n                                         __loadword<_Size>(__s + 16),\n                                         __loadword<_Size>(__s + 24),\n                                         __a,\n                                         __b);\n  }\n\n  // Return an 8-byte hash for 33 to 64 bytes.\n  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {\n    _Size __z = __loadword<_Size>(__s + 24);\n    _Size __a = __loadword<_Size>(__s) +\n                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;\n    _Size __b = __rotate(__a + __z, 52);\n    _Size __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + 8);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + 16);\n    _Size __vf = __a + __z;\n    _Size __vs = __b + __rotate(__a, 31) + __c;\n    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);\n    __z += __loadword<_Size>(__s + __len - 8);\n    __b = __rotate(__a + __z, 52);\n    __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + __len - 24);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + __len - 16);\n    _Size __wf = __a + __z;\n    _Size __ws = __b + __rotate(__a, 31) + __c;\n    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);\n    return __shift_mix(__r * __k0 + __vs) * __k2;\n  }\n};\n\n// cityhash64\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len) _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK \n{\n  const char* __s = static_cast<const char*>(__key);\n  if (__len <= 32) {\n    if (__len <= 16) {\n      return __hash_len_0_to_16(__s, __len);\n    } else {\n      return __hash_len_17_to_32(__s, __len);\n    }\n  } else if (__len <= 64) {\n    return __hash_len_33_to_64(__s, __len);\n  }\n\n  // For strings over 64 bytes we hash the end first, and then as we\n  // loop we keep 56 bytes of state: v, w, x, y, and z.\n  _Size __x = __loadword<_Size>(__s + __len - 40);\n  _Size __y = __loadword<_Size>(__s + __len - 16) +\n              __loadword<_Size>(__s + __len - 56);\n  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,\n                          __loadword<_Size>(__s + __len - 24));\n  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);\n  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);\n  __x = __x * __k1 + __loadword<_Size>(__s);\n\n  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.\n  __len = (__len - 1) & ~static_cast<_Size>(63);\n  do {\n    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;\n    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;\n    __x ^= __w.second;\n    __y += __v.first + __loadword<_Size>(__s + 40);\n    __z = __rotate(__z + __w.first, 33) * __k1;\n    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);\n    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,\n                                        __y + __loadword<_Size>(__s + 16));\n    std::swap(__z, __x);\n    __s += 64;\n    __len -= 64;\n  } while (__len != 0);\n  return __hash_len_16(\n      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,\n      __hash_len_16(__v.second, __w.second) + __x);\n}\n\ntemplate <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>\nstruct __scalar_hash;\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 0>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__a = 0;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 1>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 2>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 3>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 4>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\nstruct _PairT {\n  size_t first;\n  size_t second;\n};\n\n_LIBCPP_INLINE_VISIBILITY\ninline size_t __hash_combine(size_t __lhs, size_t __rhs) _NOEXCEPT {\n    typedef __scalar_hash<_PairT> _HashT;\n    const _PairT __p = {__lhs, __rhs};\n    return _HashT()(__p);\n}\n\ntemplate<class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash<_Tp*>\n    : public unary_function<_Tp*, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp* __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp* __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS hash<unique_ptr<_Tp, _Dp> >\n{\n    typedef unique_ptr<_Tp, _Dp> argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        typedef typename argument_type::pointer pointer;\n        return hash<pointer>()(__ptr.get());\n    }\n};\n\nstruct __destruct_n\n{\nprivate:\n    size_t size;\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT\n        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT\n        {++size;}\n    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT\n        {size = __s;}\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT\n        {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT\n        : size(__s) {}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT\n        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT\n        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT\n        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n};\n\ntemplate <class _Alloc>\nclass __allocator_destructor\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n    typedef typename __alloc_traits::size_type size_type;\nprivate:\n    _Alloc& __alloc_;\n    size_type __s_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)\n             _NOEXCEPT\n        : __alloc_(__a), __s_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n        {__alloc_traits::deallocate(__alloc_, __p, __s_);}\n};\n\ntemplate <class _InputIterator, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f, (void) ++__r)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _InputIterator, class _Size, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) ++__r, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\nvoid\nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __f;\n}\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid destroy_at(_Tp* __loc) {\n    _LIBCPP_ASSERT(__loc, \"null pointer given to destroy_at\");\n    __loc->~_Tp();\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid destroy(_ForwardIterator __first, _ForwardIterator __last) {\n    for (; __first != __last; ++__first)\n        _VSTD::destroy_at(_VSTD::addressof(*__first));\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator destroy_n(_ForwardIterator __first, _Size __n) {\n    for (; __n > 0; (void)++__first, --__n)\n        _VSTD::destroy_at(_VSTD::addressof(*__first));\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid uninitialized_default_construct(_ForwardIterator __first, _ForwardIterator __last) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __idx != __last; ++__idx)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator uninitialized_default_construct_n(_ForwardIterator __first, _Size __n) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; (void)++__idx, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt;\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid uninitialized_value_construct(_ForwardIterator __first, _ForwardIterator __last) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __idx != __last; ++__idx)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator uninitialized_value_construct_n(_ForwardIterator __first, _Size __n) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; (void)++__idx, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt();\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\n\ntemplate <class _InputIt, class _ForwardIt>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIt uninitialized_move(_InputIt __first, _InputIt __last, _ForwardIt __first_res) {\n    using _Vt = typename iterator_traits<_ForwardIt>::value_type;\n    auto __idx = __first_res;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __first != __last; (void)++__idx, ++__first)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first_res, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _InputIt, class _Size, class _ForwardIt>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIt, _ForwardIt>\nuninitialized_move_n(_InputIt __first, _Size __n, _ForwardIt __first_res) {\n    using _Vt = typename iterator_traits<_ForwardIt>::value_type;\n    auto __idx = __first_res;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; ++__idx, (void)++__first, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));\n    return {__first, __idx};\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first_res, __idx);\n        throw;\n    }\n#endif\n}\n\n\n#endif // _LIBCPP_STD_VER > 14\n\nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr\n    : public std::exception\n{\npublic:\n    virtual ~bad_weak_ptr() _NOEXCEPT;\n    virtual const char* what() const  _NOEXCEPT;\n};\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_weak_ptr()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_weak_ptr();\n#else\n    _VSTD::abort();\n#endif\n}\n\ntemplate<class _Tp> class _LIBCPP_TEMPLATE_VIS weak_ptr;\n\nclass _LIBCPP_TYPE_VIS __shared_count\n{\n    __shared_count(const __shared_count&);\n    __shared_count& operator=(const __shared_count&);\n\nprotected:\n    long __shared_owners_;\n    virtual ~__shared_count();\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT = 0;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_count(long __refs = 0) _NOEXCEPT\n        : __shared_owners_(__refs) {}\n\n    void __add_shared() _NOEXCEPT;\n    bool __release_shared() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {\n        return __libcpp_relaxed_load(&__shared_owners_) + 1;\n    }\n};\n\nclass _LIBCPP_TYPE_VIS __shared_weak_count\n    : private __shared_count\n{\n    long __shared_weak_owners_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT\n        : __shared_count(__refs),\n          __shared_weak_owners_(__refs) {}\nprotected:\n    virtual ~__shared_weak_count();\n\npublic:\n    void __add_shared() _NOEXCEPT;\n    void __add_weak() _NOEXCEPT;\n    void __release_shared() _NOEXCEPT;\n    void __release_weak() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_count::use_count();}\n    __shared_weak_count* lock() _NOEXCEPT;\n\n    // Define the function out only if we build static libc++ without RTTI.\n    // Otherwise we may break clients who need to compile their projects with\n    // -fno-rtti and yet link against a libc++.dylib compiled\n    // without -fno-rtti.\n#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\nprivate:\n    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;\n};\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nclass __shared_ptr_pointer\n    : public __shared_weak_count\n{\n    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)\n        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}\n\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nconst void*\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT\n{\n    return __t == typeid(_Dp) ? _VSTD::addressof(__data_.first().second()) : 0;\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.first().second()(__data_.first().first());\n    __data_.first().second().~_Dp();\n}\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n\n    _Al __a(__data_.second());\n    __data_.second().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nclass __shared_ptr_emplace\n    : public __shared_weak_count\n{\n    __compressed_pair<_Alloc, _Tp> __data_;\npublic:\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(_VSTD::move(__a)) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)\n            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),\n                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(__a) {}\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0)\n            :  __data_(__a, _Tp(__a0)) {}\n\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)\n            :  __data_(__a, _Tp(__a0, __a1)) {}\n\n    template <class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)\n            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* get() _NOEXCEPT {return &__data_.second();}\n};\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.second().~_Tp();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n    _Al __a(__data_.first());\n    __data_.first().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate<class _Tp> class _LIBCPP_TEMPLATE_VIS enable_shared_from_this;\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS shared_ptr\n{\npublic:\n    typedef _Tp element_type;\n\n#if _LIBCPP_STD_VER > 14\n    typedef weak_ptr<_Tp> weak_type;\n#endif\nprivate:\n    element_type*      __ptr_;\n    __shared_weak_count* __cntrl_;\n\n    struct __nat {int __for_bool_;};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\n    template<class _Yp>\n        explicit shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp>\n        shared_ptr(_Yp* __p, _Dp __d,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp, class _Alloc>\n        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);\n    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        shared_ptr(const shared_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY  shared_ptr(shared_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type= __nat());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#else\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp> __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~shared_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr<_Tp>&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp>&& __r);\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr\n        >::type&\n        operator=(auto_ptr<_Yp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp> __r);\n#endif\n    template <class _Yp, class _Dp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n            shared_ptr&\n        >::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp> __r);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(shared_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p);\n    template<class _Yp, class _Dp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d, _Alloc __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* get() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* operator->() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool unique() const _NOEXCEPT {return use_count() == 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(shared_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(weak_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    __owner_equivalent(const shared_ptr& __p) const\n        {return __cntrl_ == __p.__cntrl_;}\n\n#ifndef _LIBCPP_NO_RTTI\n    template <class _Dp>\n        _LIBCPP_INLINE_VISIBILITY\n        _Dp* __get_deleter() const _NOEXCEPT\n            {return (_Dp*)(__cntrl_ ? __cntrl_->__get_deleter(typeid(_Dp)) : 0);}\n#endif  // _LIBCPP_NO_RTTI\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class ..._Args>\n        static\n        shared_ptr<_Tp>\n        make_shared(_Args&& ...__args);\n\n    template<class _Alloc, class ..._Args>\n        static\n        shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _Args&& ...__args);\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    static shared_ptr<_Tp> make_shared();\n\n    template<class _A0>\n        static shared_ptr<_Tp> make_shared(_A0&);\n\n    template<class _A0, class _A1>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&);\n\n    template<class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);\n\n    template<class _Alloc>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a);\n\n    template<class _Alloc, class _A0>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0);\n\n    template<class _Alloc, class _A0, class _A1>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);\n\n    template<class _Alloc, class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n\n    template <class _Yp, class _OrigPtr>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        __enable_weak_this(const enable_shared_from_this<_Yp>* __e,\n                           _OrigPtr* __ptr) _NOEXCEPT\n        {\n            typedef typename remove_cv<_Yp>::type _RawYp;\n            if (__e && __e->__weak_this_.expired())\n            {\n                __e->__weak_this_ = shared_ptr<_RawYp>(*this,\n                    const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));\n            }\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __enable_weak_this(const volatile void*, const volatile void*) _NOEXCEPT {}\n\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n    unique_ptr<_Yp> __hold(__p);\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());\n    __hold.release();\n    __enable_weak_this(__p, __p);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());\n        __enable_weak_this(__p, __p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n        __enable_weak_this(__p, __p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT\n    : __ptr_(__p),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r,\n#endif\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());\n    __enable_weak_this(__r.get(), __r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                !is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());\n        __enable_weak_this(__r.get(), __r.get());\n    }\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef __shared_ptr_pointer<_Yp*,\n                                     reference_wrapper<typename remove_reference<_Dp>::type>,\n                                     allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());\n        __enable_weak_this(__r.get(), __r.get());\n    }\n    __r.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ntemplate<class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared()\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>::~shared_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>\n>::type&\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, \n                   typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, \n                   typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::reset() _NOEXCEPT\n{\n    shared_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p)\n{\n    shared_ptr(__p).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)\n{\n    shared_ptr(__p, __d).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)\n{\n    shared_ptr(__p, __d, __a).swap(*this);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nmake_shared(_Args&& ...__args)\n{\n    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate<class _Tp, class _Alloc, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nallocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared()\n{\n    return shared_ptr<_Tp>::make_shared();\n}\n\ntemplate<class _Tp, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0)\n{\n    return shared_ptr<_Tp>::make_shared(__a0);\n}\n\ntemplate<class _Tp, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1);\n}\n\ntemplate<class _Tp, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);\n}\n\ntemplate<class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __x.get() == __y.get();\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    typedef typename common_type<_Tp*, _Up*>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return less<_Tp*>()(__x.get(), nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return less<_Tp*>()(nullptr, __x.get());\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return nullptr < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return __x < nullptr;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    _Tp* __p = dynamic_cast<_Tp*>(__r.get());\n    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();\n}\n\ntemplate<class _Tp, class _Up>\ntypename enable_if\n<\n    is_array<_Tp>::value == is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    typedef typename remove_extent<_Tp>::type _RTp;\n    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Dp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Dp*\nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT\n{\n    return __p.template __get_deleter<_Dp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS weak_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*        __ptr_;\n    __shared_weak_count* __cntrl_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(shared_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                        _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~weak_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(weak_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT\n        {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool expired() const _NOEXCEPT\n        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}\n    shared_ptr<_Tp> lock() const _NOEXCEPT;\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const shared_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const weak_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n                         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\nweak_ptr<_Tp>::~weak_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_weak();\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::reset() _NOEXCEPT\n{\n    weak_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)\n{\n    if (__cntrl_ == 0)\n        __throw_bad_weak_ptr();\n}\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nweak_ptr<_Tp>::lock() const _NOEXCEPT\n{\n    shared_ptr<_Tp> __r;\n    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;\n    if (__r.__cntrl_)\n        __r.__ptr_ = __ptr_;\n    return __r;\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp = void> struct owner_less;\n#else\ntemplate <class _Tp> struct owner_less;\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<shared_ptr<_Tp> >\n    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<weak_ptr<_Tp> >\n    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<void>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x,  weak_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    typedef void is_transparent;\n};\n#endif\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS enable_shared_from_this\n{\n    mutable weak_ptr<_Tp> __weak_this_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    enable_shared_from_this() _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT\n        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    ~enable_shared_from_this() {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp> shared_from_this()\n        {return shared_ptr<_Tp>(__weak_this_);}\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp const> shared_from_this() const\n        {return shared_ptr<const _Tp>(__weak_this_);}\n\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr<_Tp> weak_from_this() _NOEXCEPT\n       { return __weak_this_; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr<const _Tp> weak_from_this() const _NOEXCEPT\n        { return __weak_this_; }\n#endif // _LIBCPP_STD_VER > 14\n\n    template <class _Up> friend class shared_ptr;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash<shared_ptr<_Tp> >\n{\n    typedef shared_ptr<_Tp>      argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        return hash<_Tp*>()(__ptr.get());\n    }\n};\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);\n\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n\nclass _LIBCPP_TYPE_VIS __sp_mut\n{\n    void* __lx;\npublic:\n    void lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\nprivate:\n    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;\n    __sp_mut(const __sp_mut&);\n    __sp_mut& operator=(const __sp_mut&);\n\n    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n};\n\n_LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const shared_ptr<_Tp>*)\n{\n    return false;\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_load(const shared_ptr<_Tp>* __p)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    shared_ptr<_Tp> __q = *__p;\n    __m.unlock();\n    return __q;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n{\n    return atomic_load(__p);\n}\n\ntemplate <class _Tp>\nvoid\natomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    atomic_store(__p, __r);\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n    return __r;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    return atomic_exchange(__p, __r);\n}\n\ntemplate <class _Tp>\nbool\natomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    shared_ptr<_Tp> __temp;\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    if (__p->__owner_equivalent(*__v))\n    {\n        _VSTD::swap(__temp, *__p);\n        *__p = __w;\n        __m.unlock();\n        return true;\n    }\n    _VSTD::swap(__temp, *__v);\n    *__v = *__p;\n    __m.unlock();\n    return false;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                        shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                      shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_weak(__p, __v, __w);\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n\n//enum class\n#if defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE)\n# ifndef _LIBCPP_CXX03_LANG\nenum class pointer_safety : unsigned char {\n  relaxed,\n  preferred,\n  strict\n};\n# endif\n#else\nstruct _LIBCPP_TYPE_VIS pointer_safety\n{\n    enum __lx\n    {\n        relaxed,\n        preferred,\n        strict\n    };\n\n    __lx __v_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety() : __v_() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety(__lx __v) : __v_(__v) {}\n    _LIBCPP_INLINE_VISIBILITY\n    operator int() const {return __v_;}\n};\n#endif\n\n#if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) && \\\n    defined(_LIBCPP_BUILDING_MEMORY)\n_LIBCPP_FUNC_VIS pointer_safety get_pointer_safety() _NOEXCEPT;\n#else\n// This function is only offered in C++03 under ABI v1.\n# if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) || !defined(_LIBCPP_CXX03_LANG)\ninline _LIBCPP_INLINE_VISIBILITY\npointer_safety get_pointer_safety() _NOEXCEPT {\n  return pointer_safety::relaxed;\n}\n# endif\n#endif\n\n\n_LIBCPP_FUNC_VIS void declare_reachable(void* __p);\n_LIBCPP_FUNC_VIS void declare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void undeclare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void* __undeclare_reachable(void* __p);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nundeclare_reachable(_Tp* __p)\n{\n    return static_cast<_Tp*>(__undeclare_reachable(__p));\n}\n\n_LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);\n\n// --- Helper for container swap --\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    __swap_allocator(__a1, __a2, \n      integral_constant<bool, _VSTD::allocator_traits<_Alloc>::propagate_on_container_swap::value>());\n}\n\ntemplate <typename _Alloc>\n_LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2, true_type)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    using _VSTD::swap;\n    swap(__a1, __a2);\n}\n\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc &, _Alloc &, false_type) _NOEXCEPT {}\n\ntemplate <typename _Alloc, typename _Traits=allocator_traits<_Alloc> >\nstruct __noexcept_move_assign_container : public integral_constant<bool, \n    _Traits::propagate_on_container_move_assignment::value\n#if _LIBCPP_STD_VER > 14\n        || _Traits::is_always_equal::value\n#else\n        && is_nothrow_move_assignable<_Alloc>::value\n#endif\n    > {};\n\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\ntemplate <class _Tp, class _Alloc>\nstruct __temp_value {\n    typedef allocator_traits<_Alloc> _Traits;\n    \n    typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __v;\n    _Alloc &__a;\n\n    _Tp *__addr() { return reinterpret_cast<_Tp *>(addressof(__v)); }\n    _Tp &   get() { return *__addr(); }\n        \n    template<class... _Args>\n    __temp_value(_Alloc &__alloc, _Args&& ... __args) : __a(__alloc)\n    { _Traits::construct(__a, __addr(), _VSTD::forward<_Args>(__args)...); }\n    \n    ~__temp_value() { _Traits::destroy(__a, __addr()); }\n    };\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MEMORY\n","// -*- C++ -*-\n//===--------------------------- string -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING\n#define _LIBCPP_STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class stateT>\nclass fpos\n{\nprivate:\n    stateT st;\npublic:\n    fpos(streamoff = streamoff());\n\n    operator streamoff() const;\n\n    stateT state() const;\n    void state(stateT);\n\n    fpos& operator+=(streamoff);\n    fpos  operator+ (streamoff) const;\n    fpos& operator-=(streamoff);\n    fpos  operator- (streamoff) const;\n};\n\ntemplate <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);\ntemplate <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static int              compare(const char_type* s1, const char_type* s2, size_t n);\n    static size_t           length(const char_type* s);\n    static const char_type* find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\ntemplate<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_string\n{\npublic:\n// types:\n    typedef traits traits_type;\n    typedef typename traits_type::char_type value_type;\n    typedef Allocator allocator_type;\n    typedef typename allocator_type::size_type size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    static const size_type npos = -1;\n\n    basic_string()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit basic_string(const allocator_type& a);\n    basic_string(const basic_string& str);\n    basic_string(basic_string&& str)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    basic_string(const basic_string& str, size_type pos,\n                 const allocator_type& a = allocator_type());\n    basic_string(const basic_string& str, size_type pos, size_type n,\n                 const Allocator& a = Allocator());\n    template<class T>\n        basic_string(const T& t, size_type pos, size_type n, const Allocator& a = Allocator()); // C++17\n    explicit basic_string(const basic_string_view<charT, traits> sv, const Allocator& a = Allocator());\n    basic_string(const value_type* s, const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());\n    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());\n    template<class InputIterator>\n        basic_string(InputIterator begin, InputIterator end,\n                     const allocator_type& a = allocator_type());\n    basic_string(initializer_list<value_type>, const Allocator& = Allocator());\n    basic_string(const basic_string&, const Allocator&);\n    basic_string(basic_string&&, const Allocator&);\n\n    ~basic_string();\n\n    operator basic_string_view<charT, traits>() const noexcept;\n\n    basic_string& operator=(const basic_string& str);\n    basic_string& operator=(basic_string_view<charT, traits> sv);\n    basic_string& operator=(basic_string&& str)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value ); // C++17\n    basic_string& operator=(const value_type* s);\n    basic_string& operator=(value_type c);\n    basic_string& operator=(initializer_list<value_type>);\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    size_type size() const noexcept;\n    size_type length() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n\n    void resize(size_type n, value_type c);\n    void resize(size_type n);\n\n    void reserve(size_type res_arg = 0);\n    void shrink_to_fit();\n    void clear() noexcept;\n    bool empty() const noexcept;\n\n    const_reference operator[](size_type pos) const;\n    reference       operator[](size_type pos);\n\n    const_reference at(size_type n) const;\n    reference       at(size_type n);\n\n    basic_string& operator+=(const basic_string& str);\n    basic_string& operator+=(basic_string_view<charT, traits> sv);\n    basic_string& operator+=(const value_type* s);\n    basic_string& operator+=(value_type c);\n    basic_string& operator+=(initializer_list<value_type>);\n\n    basic_string& append(const basic_string& str);\n    basic_string& append(basic_string_view<charT, traits> sv);\n    basic_string& append(const basic_string& str, size_type pos, size_type n=npos); //C++14\n    template <class T>\n        basic_string& append(const T& t, size_type pos, size_type n=npos); // C++17\n    basic_string& append(const value_type* s, size_type n);\n    basic_string& append(const value_type* s);\n    basic_string& append(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& append(InputIterator first, InputIterator last);\n    basic_string& append(initializer_list<value_type>);\n\n    void push_back(value_type c);\n    void pop_back();\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    basic_string& assign(const basic_string& str);\n    basic_string& assign(basic_string_view<charT, traits> sv);\n    basic_string& assign(basic_string&& str);\n    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos); // C++14\n    template <class T>\n        basic_string& assign(const T& t, size_type pos, size_type n=npos); // C++17\n    basic_string& assign(const value_type* s, size_type n);\n    basic_string& assign(const value_type* s);\n    basic_string& assign(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& assign(InputIterator first, InputIterator last);\n    basic_string& assign(initializer_list<value_type>);\n\n    basic_string& insert(size_type pos1, const basic_string& str);\n    basic_string& insert(size_type pos1, basic_string_view<charT, traits> sv);\n    basic_string& insert(size_type pos1, const basic_string& str,\n                         size_type pos2, size_type n);\n    template <class T>\n        basic_string& insert(size_type pos1, const T& t, size_type pos2, size_type n); // C++17\n    basic_string& insert(size_type pos, const value_type* s, size_type n=npos); //C++14\n    basic_string& insert(size_type pos, const value_type* s);\n    basic_string& insert(size_type pos, size_type n, value_type c);\n    iterator      insert(const_iterator p, value_type c);\n    iterator      insert(const_iterator p, size_type n, value_type c);\n    template<class InputIterator>\n        iterator insert(const_iterator p, InputIterator first, InputIterator last);\n    iterator      insert(const_iterator p, initializer_list<value_type>);\n\n    basic_string& erase(size_type pos = 0, size_type n = npos);\n    iterator      erase(const_iterator position);\n    iterator      erase(const_iterator first, const_iterator last);\n\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);\n    basic_string& replace(size_type pos1, size_type n1, basic_string_view<charT, traits> sv);\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,\n                          size_type pos2, size_type n2=npos); // C++14\n    template <class T>\n        basic_string& replace(size_type pos1, size_type n1, const T& t,\n                              size_type pos2, size_type n); // C++17\n    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s);\n    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);\n    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);\n    basic_string& replace(const_iterator i1, const_iterator i2, basic_string_view<charT, traits> sv);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);\n    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);\n    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);\n\n    size_type copy(value_type* s, size_type n, size_type pos = 0) const;\n    basic_string substr(size_type pos = 0, size_type n = npos) const;\n\n    void swap(basic_string& str)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n\n    const value_type* c_str() const noexcept;\n    const value_type* data() const noexcept;\n          value_type* data()       noexcept;   // C++17\n\n    allocator_type get_allocator() const noexcept;\n\n    size_type find(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find(value_type c, size_type pos = 0) const noexcept;\n\n    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type ffind(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;\n    size_type rfind(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;\n\n    int compare(const basic_string& str) const noexcept;\n    int compare(basic_string_view<charT, traits> sv) const noexcept;\n    int compare(size_type pos1, size_type n1, const basic_string& str) const;\n    int compare(size_type pos1, size_type n1, basic_string_view<charT, traits> sv) const;\n    int compare(size_type pos1, size_type n1, const basic_string& str,\n                size_type pos2, size_type n2=npos) const; // C++14\n    template <class T>\n        int compare(size_type pos1, size_type n1, const T& t,\n                    size_type pos2, size_type n2=npos) const; // C++17\n    int compare(const value_type* s) const noexcept;\n    int compare(size_type pos1, size_type n1, const value_type* s) const;\n    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;\n\n    bool __invariants() const;\n};\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs,\n          const basic_string<charT, traits, Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT,traits,Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nvoid swap(basic_string<charT, traits, Allocator>& lhs,\n          basic_string<charT, traits, Allocator>& rhs)\n            noexcept(noexcept(lhs.swap(rhs)));\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\noperator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_ostream<charT, traits>&\noperator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,\n        charT delim);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntypedef basic_string<char>    string;\ntypedef basic_string<wchar_t> wstring;\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\nint                stoi  (const string& str, size_t* idx = 0, int base = 10);\nlong               stol  (const string& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const string& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const string& str, size_t* idx = 0);\ndouble      stod (const string& str, size_t* idx = 0);\nlong double stold(const string& str, size_t* idx = 0);\n\nstring to_string(int val);\nstring to_string(unsigned val);\nstring to_string(long val);\nstring to_string(unsigned long val);\nstring to_string(long long val);\nstring to_string(unsigned long long val);\nstring to_string(float val);\nstring to_string(double val);\nstring to_string(long double val);\n\nint                stoi  (const wstring& str, size_t* idx = 0, int base = 10);\nlong               stol  (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const wstring& str, size_t* idx = 0);\ndouble      stod (const wstring& str, size_t* idx = 0);\nlong double stold(const wstring& str, size_t* idx = 0);\n\nwstring to_wstring(int val);\nwstring to_wstring(unsigned val);\nwstring to_wstring(long val);\nwstring to_wstring(unsigned long val);\nwstring to_wstring(long long val);\nwstring to_wstring(unsigned long long val);\nwstring to_wstring(float val);\nwstring to_wstring(double val);\nwstring to_wstring(long double val);\n\ntemplate <> struct hash<string>;\ntemplate <> struct hash<u16string>;\ntemplate <> struct hash<u32string>;\ntemplate <> struct hash<wstring>;\n\nbasic_string<char>     operator \"\" s( const char *str,     size_t len ); // C++14\nbasic_string<wchar_t>  operator \"\" s( const wchar_t *str,  size_t len ); // C++14\nbasic_string<char16_t> operator \"\" s( const char16_t *str, size_t len ); // C++14\nbasic_string<char32_t> operator \"\" s( const char32_t *str, size_t len ); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <string_view>\n#include <iosfwd>\n#include <cstring>\n#include <cstdio>  // For EOF.\n#include <cwchar>\n#include <algorithm>\n#include <iterator>\n#include <utility>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <initializer_list>\n#include <__functional_base>\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n#include <cstdint>\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// fpos\n\ntemplate <class _StateT>\nclass _LIBCPP_TEMPLATE_VIS fpos\n{\nprivate:\n    _StateT __st_;\n    streamoff __off_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}\n\n    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}\n    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}\n\n    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}\n    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}\n};\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) - streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) == streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) != streamoff(__y);}\n\n// basic_string\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x,\n          const basic_string<_CharT, _Traits, _Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);\n\ntemplate <bool>\nclass _LIBCPP_TEMPLATE_VIS __basic_string_common\n{\nprotected:\n    _LIBCPP_NORETURN void __throw_length_error() const;\n    _LIBCPP_NORETURN void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_length_error() const\n{\n    _VSTD::__throw_length_error(\"basic_string\");\n}\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_out_of_range() const\n{\n    _VSTD::__throw_out_of_range(\"basic_string\");\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __basic_string_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\n#ifdef _LIBCPP_NO_EXCEPTIONS\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public true_type {};\n#elif defined(_LIBCPP_HAS_NO_NOEXCEPT)\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public false_type {};\n#else\ntemplate <class _Iter, bool = __is_forward_iterator<_Iter>::value>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public _LIBCPP_BOOL_CONSTANT((\n    noexcept(++(declval<_Iter&>())) && \n    is_nothrow_assignable<_Iter&, _Iter>::value && \n    noexcept(declval<_Iter>() == declval<_Iter>()) && \n    noexcept(*declval<_Iter>())\n)) {};\n\ntemplate <class _Iter> \nstruct __libcpp_string_gets_noexcept_iterator_impl<_Iter, false> : public false_type {};\n#endif\n\n\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value) {};\n\ntemplate <class _CharT, class _Traits, class _Tp>\nstruct __can_be_converted_to_string_view : public _LIBCPP_BOOL_CONSTANT(\n\t( is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value &&\n     !is_convertible<const _Tp&, const _CharT*>::value)) {};\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate <class _CharT, size_t = sizeof(_CharT)>\nstruct __padding\n{\n    unsigned char __xx[sizeof(_CharT)-1];\n};\n\ntemplate <class _CharT>\nstruct __padding<_CharT, 1>\n{\n};\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS basic_string\n    : private __basic_string_common<true>\n{\npublic:\n    typedef basic_string                                 __self;\n    typedef basic_string_view<_CharT, _Traits>           __self_view;\n    typedef _Traits                                      traits_type;\n    typedef typename traits_type::char_type              value_type;\n    typedef _Allocator                                   allocator_type;\n    typedef allocator_traits<allocator_type>             __alloc_traits;\n    typedef typename __alloc_traits::size_type           size_type;\n    typedef typename __alloc_traits::difference_type     difference_type;\n    typedef value_type&                                  reference;\n    typedef const value_type&                            const_reference;\n    typedef typename __alloc_traits::pointer             pointer;\n    typedef typename __alloc_traits::const_pointer       const_pointer;\n\n    static_assert(is_pod<value_type>::value, \"Character type of basic_string must be a POD\");\n    static_assert((is_same<_CharT, value_type>::value),\n                  \"traits_type::char_type must be the same type as CharT\");\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n#if defined(_LIBCPP_RAW_ITERATORS)\n    typedef pointer                                      iterator;\n    typedef const_pointer                                const_iterator;\n#else  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef __wrap_iter<pointer>                         iterator;\n    typedef __wrap_iter<const_pointer>                   const_iterator;\n#endif  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;\n\nprivate:\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    struct __long\n    {\n        pointer   __data_;\n        size_type __size_;\n        size_type __cap_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        value_type __data_[__min_cap];\n        struct\n            : __padding<value_type>\n        {\n            unsigned char __size_;\n        };\n    };\n\n#else\n\n    struct __long\n    {\n        size_type __cap_;\n        size_type __size_;\n        pointer   __data_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        union\n        {\n            unsigned char __size_;\n            value_type __lx;\n        };\n        value_type __data_[__min_cap];\n    };\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    union __ulx{__long __lx; __short __lxx;};\n\n    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};\n\n    struct __raw\n    {\n        size_type __words[__n_words];\n    };\n\n    struct __rep\n    {\n        union\n        {\n            __long  __l;\n            __short __s;\n            __raw   __r;\n        };\n    };\n\n    __compressed_pair<__rep, allocator_type> __r_;\n\npublic:\n    static const size_type npos = -1;\n\n    _LIBCPP_INLINE_VISIBILITY basic_string()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    basic_string(const basic_string& __str);\n    basic_string(const basic_string& __str, const allocator_type& __a);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY basic_string(const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c, const allocator_type& __a);\n    basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                 const allocator_type& __a = allocator_type());\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const basic_string& __str, size_type __pos,\n                 const allocator_type& __a = allocator_type());\n    template<class _Tp>\n        basic_string(const _Tp& __t, size_type __pos, size_type __n, \n                     const allocator_type& __a = allocator_type(),\n                     typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type* = 0);\n    _LIBCPP_INLINE_VISIBILITY explicit\n    basic_string(__self_view __sv);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(__self_view __sv, const allocator_type& __a);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    inline ~basic_string();\n\n    _LIBCPP_INLINE_VISIBILITY\n    operator __self_view() const _NOEXCEPT { return __self_view(data(), size()); }\n\n    basic_string& operator=(const basic_string& __str);\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class = void>\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(__self_view __sv)  {return assign(__sv);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(basic_string&& __str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {return assign(__s);}\n    basic_string& operator=(value_type __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(this, __get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer() + size());}\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(__get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(__get_pointer() + size());}\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT\n        {return __is_long() ? __get_long_size() : __get_short_size();}\n    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT\n        {return (__is_long() ? __get_long_cap()\n                             : static_cast<size_type>(__min_cap)) - 1;}\n\n    void resize(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}\n\n    void reserve(size_type res_arg = 0);\n    _LIBCPP_INLINE_VISIBILITY\n    void shrink_to_fit() _NOEXCEPT {reserve();}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY bool empty() const _NOEXCEPT {return size() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos)       _NOEXCEPT;\n\n    const_reference at(size_type __n) const;\n    reference       at(size_type __n);\n\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(__self_view __sv)          {return append(__sv);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)     {return append(__s);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(__self_view __sv) { return append(__sv.data(), __sv.size()); }\n    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  append(const _Tp& __t, size_type __pos, size_type __n=npos);\n    basic_string& append(const value_type* __s, size_type __n);\n    basic_string& append(const value_type* __s);\n    basic_string& append(size_type __n, value_type __c);\n    template <class _ForwardIterator>\n    inline basic_string& __append_forward_unsafe(_ForwardIterator, _ForwardIterator);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n    _LIBCPP_INLINE_VISIBILITY\n    append(_InputIterator __first, _InputIterator __last) {\n      const basic_string __temp (__first, __last, __alloc());\n      append(__temp.data(), __temp.size());\n      return *this;\n    }\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n    _LIBCPP_INLINE_VISIBILITY\n    append(_ForwardIterator __first, _ForwardIterator __last) {\n      return __append_forward_unsafe(__first, __last);\n    }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    void push_back(value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n    _LIBCPP_INLINE_VISIBILITY reference       front();\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const;\n    _LIBCPP_INLINE_VISIBILITY reference       back();\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(__self_view __sv) { return assign(__sv.data(), __sv.size()); }\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(const basic_string& __str) { return *this = __str; }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(basic_string&& str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n        {*this = _VSTD::move(str); return *this;}\n#endif\n    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  assign(const _Tp & __t, size_type pos, size_type n=npos);\n    basic_string& assign(const value_type* __s, size_type __n);\n    basic_string& assign(const value_type* __s);\n    basic_string& assign(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, __self_view __sv) { return insert(__pos1, __sv.data(), __sv.size()); }\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s);\n    basic_string& insert(size_type __pos, size_type __n, value_type __c);\n    iterator      insert(const_iterator __pos, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      insert(const_iterator __pos, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __pos, initializer_list<value_type> __il)\n                    {return insert(__pos, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    basic_string& erase(size_type __pos = 0, size_type __n = npos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __pos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, __self_view __sv) { return replace(__pos1, __n1, __sv.data(), __sv.size()); }\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  replace(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);\n    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, __self_view __sv) { return replace(__i1 - begin(), __i2 - __i1, __sv); }\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)\n        {return replace(__i1, __i2, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string substr(size_type __pos = 0, size_type __n = npos) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG;\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* c_str() const _NOEXCEPT {return data();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    value_type* data()             _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const basic_string& __str) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(__self_view __sv) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, __self_view __sv) const;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;\n    template <class _Tp>\n    inline _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            int\n        >::type\n        compare(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos) const;\n    int compare(const value_type* __s) const _NOEXCEPT;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;\n\n    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __is_long() const _NOEXCEPT\n        {return bool(__r_.first().__s.__size_ & __short_mask);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __r_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __r_.second();}\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_ >> 1;}\n#   else\n        {return __r_.first().__s.__size_;}\n#   endif\n\n#else  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_;}\n#   else\n        {return __r_.first().__s.__size_ >> 1;}\n#   endif\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_size(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_size() const _NOEXCEPT\n        {return __r_.first().__l.__size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_size(size_type __s) _NOEXCEPT\n        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_cap(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__cap_  = __long_mask | __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_cap() const _NOEXCEPT\n        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_pointer(pointer __p) _NOEXCEPT\n        {__r_.first().__l.__data_ = __p;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_long_pointer() _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_long_pointer() const _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_short_pointer() _NOEXCEPT\n        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_short_pointer() const _NOEXCEPT\n        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_pointer() _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_pointer() const _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __zero() _NOEXCEPT\n        {\n            size_type (&__a)[__n_words] = __r_.first().__r.__words;\n            for (unsigned __i = 0; __i < __n_words; ++__i)\n                __a[__i] = 0;\n        }\n\n    template <size_type __a> static\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __align_it(size_type __s) _NOEXCEPT\n            {return (__s + (__a-1)) & ~(__a-1);}\n    enum {__alignment = 16};\n    static _LIBCPP_INLINE_VISIBILITY\n    size_type __recommend(size_type __s) _NOEXCEPT\n        {return (__s < __min_cap ? static_cast<size_type>(__min_cap) :\n                 __align_it<sizeof(value_type) < __alignment ?\n                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void __init(const value_type* __s, size_type __sz, size_type __reserve);\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void __init(const value_type* __s, size_type __sz);\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void __init(size_type __n, value_type __c);\n\n    template <class _InputIterator>\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    typename enable_if\n    <\n        __is_exactly_input_iterator<_InputIterator>::value,\n        void\n    >::type\n    __init(_InputIterator __first, _InputIterator __last);\n\n    template <class _ForwardIterator>\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    typename enable_if\n    <\n        __is_forward_iterator<_ForwardIterator>::value,\n        void\n    >::type\n    __init(_ForwardIterator __first, _ForwardIterator __last);\n\n    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);\n    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                               size_type __n_copy,  size_type __n_del,\n                               size_type __n_add, const value_type* __p_new_stuff);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __erase_to_end(size_type __pos);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str)\n        {__copy_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str, true_type)\n        {\n            if (__alloc() != __str.__alloc())\n            {\n                clear();\n                shrink_to_fit();\n            }\n            __alloc() = __str.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, false_type)\n        _NOEXCEPT_(__alloc_traits::is_always_equal::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n#endif\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    __move_assign_alloc(basic_string& __str)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n    {__move_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);\n\n    friend basic_string operator+<>(const basic_string&, const basic_string&);\n    friend basic_string operator+<>(const value_type*, const basic_string&);\n    friend basic_string operator+<>(value_type, const basic_string&);\n    friend basic_string operator+<>(const basic_string&, const value_type*);\n    friend basic_string operator+<>(const basic_string&, value_type);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                                                                        __pos\n#endif\n                                                                      )\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    if (__c)\n    {\n        const_pointer __new_last = __get_pointer() + __pos;\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n: __r_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s,\n                                                       size_type __sz,\n                                                       size_type __reserve)\n{\n    if (__reserve > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__reserve < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__reserve);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)\n{\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*, allocator) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n, allocator) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)\n    : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n    : __r_(_VSTD::move(__str.__r_))\n{\n    __str.__zero();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (__str.__is_long() && __a != __str.__alloc()) // copy, not move\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n    else\n    {\n        __r_.first().__r = __str.__r_.first().__r;\n        __str.__zero();\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__n < __min_cap)\n    {\n        __set_short_size(__n);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__n);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__n);\n    }\n    traits_type::assign(_VSTD::__to_raw_pointer(__p), __n, __c);\n    traits_type::assign(__p[__n], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, __str_sz - __pos);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(\n             const _Tp& __t, size_type __pos, size_type __n, const allocator_type& __a,\n\t\t\t typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type *)\n    : __r_(__a)\n{\n\t__self_view __sv = __self_view(__t).substr(__pos, __n);\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\t\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv)\n{\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_exactly_input_iterator<_InputIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)\n{\n    __zero();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__is_long())\n            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    for (; __first != __last; ++__first, (void) ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::~basic_string()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n    if (__is_long())\n        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace\n    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n     size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    if (__n_add != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n    __old_sz = __n_copy + __n_add + __sec_cp_sz;\n    __set_long_size(__old_sz);\n    traits_type::assign(__p[__old_sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del,\n                          __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n}\n\n// assign\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::assign received nullptr\");\n    size_type __cap = capacity();\n    if (__cap >= __n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        traits_type::move(__p, __s, __n);\n        traits_type::assign(__p[__n], value_type());\n        __set_size(__n);\n        __invalidate_iterators_past(__n);\n    }\n    else\n    {\n        size_type __sz = size();\n        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)\n{\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n    traits_type::assign(__p, __n, __c);\n    traits_type::assign(__p[__n], value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)\n{\n    pointer __p;\n    if (__is_long())\n    {\n        __p = __get_long_pointer();\n        __set_long_size(1);\n    }\n    else\n    {\n        __p = __get_short_pointer();\n        __set_short_size(1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n    __invalidate_iterators_past(1);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)\n{\n    if (this != &__str)\n    {\n        __copy_assign_alloc(__str);\n        assign(__str.data(), __str.size());\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)\n    _NOEXCEPT_(__alloc_traits::is_always_equal::value)\n{\n    if (__alloc() != __str.__alloc())\n        assign(__str);\n    else\n        __move_assign(__str, true_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n#endif\n{\n    clear();\n    shrink_to_fit();\n    __r_.first() = __str.__r_.first();\n    __move_assign_alloc(__str);\n    __str.__zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__str, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_exactly_input_iterator <_InputIterator>::value\n          || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    const basic_string __temp(__first, __last, __alloc());\n    assign(__temp.data(), __temp.size());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n         && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    pointer __p = __get_pointer();\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tbasic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(const _Tp & __t, size_type __pos, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __sz = __sv.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::assign received nullptr\");\n    return assign(__s, traits_type::length(__s));\n}\n\n// append\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::append received nullptr\");\n    size_type __cap = capacity();\n    size_type __sz = size();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            traits_type::copy(__p + __sz, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)\n{\n    if (__n)\n    {\n        size_type __cap = capacity();\n        size_type __sz = size();\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer();\n        traits_type::assign(_VSTD::__to_raw_pointer(__p) + __sz, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)\n{\n    bool __is_short = !__is_long();\n    size_type __cap;\n    size_type __sz;\n    if (__is_short)\n    {\n        __cap = __min_cap - 1;\n        __sz = __get_short_size();\n    }\n    else\n    {\n        __cap = __get_long_cap() - 1;\n        __sz = __get_long_size();\n    }\n    if (__sz == __cap)\n    {\n        __grow_by(__cap, 1, __sz, __sz, 0);\n        __is_short = !__is_long();\n    }\n    pointer __p;\n    if (__is_short)\n    {\n        __p = __get_short_pointer() + __sz;\n        __set_short_size(__sz+1);\n    }\n    else\n    {\n        __p = __get_long_pointer() + __sz;\n        __set_long_size(__sz+1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n}\n\ntemplate <class _Tp>\nbool __ptr_in_range (const _Tp* __p, const _Tp* __first, const _Tp* __last)\n{\n    return __first <= __p && __p < __last;\n}\n\ntemplate <class _Tp1, class _Tp2>\nbool __ptr_in_range (const _Tp1*, const _Tp2*, const _Tp2*)\n{\n    return false;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::__append_forward_unsafe(\n    _ForwardIterator __first, _ForwardIterator __last)\n{\n    static_assert(__is_forward_iterator<_ForwardIterator>::value,\n                  \"function requires a ForwardIterator\");\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;\n        _CharRef __tmp_ref = *__first;\n        if (__ptr_in_range(_VSTD::addressof(__tmp_ref), data(), data() + size()))\n        {\n            const basic_string __temp (__first, __last, __alloc());\n            append(__temp.data(), __temp.size());\n        }\n        else \n        {\n            if (__cap - __sz < __n)\n                __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n            pointer __p = __get_pointer() + __sz;\n            for (; __first != __last; ++__p, ++__first)\n                traits_type::assign(*__p, *__first);\n            traits_type::assign(*__p, value_type());\n            __set_size(__sz + __n);\n        }\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)\n{\n    return append(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\n    typename enable_if\n    <\n        __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n        basic_string<_CharT, _Traits, _Allocator>&\n    >::type\nbasic_string<_CharT, _Traits, _Allocator>::append(const _Tp & __t, size_type __pos, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __sz = __sv.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::append received nullptr\");\n    return append(__s, traits_type::length(__s));\n}\n\n// insert\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::insert received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __cap = capacity();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n            {\n                if (__p + __pos <= __s && __s < __p + __sz)\n                    __s += __n;\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n            }\n            traits_type::move(__p + __pos, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        traits_type::assign(__p + __pos, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n   __is_exactly_input_iterator<_InputIterator>::value\n        || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n   typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    const basic_string __temp(__first, __last, __alloc());\n    return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n        && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;\n        _CharRef __tmp_char = *__first;\n        if (__ptr_in_range(_VSTD::addressof(__tmp_char), data(), data() + size()))\n        {\n            const basic_string __temp(__first, __last, __alloc());\n            return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n        }\n\n        size_type __sz = size();\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __ip;\n            if (__n_move != 0)\n                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n        for (__p += __ip; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n    }\n    return begin() + __ip;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)\n{\n    return insert(__pos1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,\n                                                  size_type __pos2, size_type __n)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tbasic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const _Tp& __t,\n                                                  size_type __pos2, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __str_sz = __sv.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __sv.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::insert received nullptr\");\n    return insert(__pos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap == __sz)\n    {\n        __grow_by(__cap, 1, __sz, __ip, 0, 1);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    else\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        size_type __n_move = __sz - __ip;\n        if (__n_move != 0)\n            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);\n    }\n    traits_type::assign(__p[__ip], __c);\n    traits_type::assign(__p[++__sz], value_type());\n    __set_size(__sz);\n    return begin() + static_cast<difference_type>(__ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, n, value) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    difference_type __p = __pos - begin();\n    insert(static_cast<size_type>(__p), __n, __c);\n    return begin() + __p;\n}\n\n// replace\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::replace received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n            {\n                if (__n1 > __n2)\n                {\n                    traits_type::move(__p + __pos, __s, __n2);\n                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n                    goto __finish;\n                }\n                if (__p + __pos < __s && __s < __p + __sz)\n                {\n                    if (__p + __pos + __n1 <= __s)\n                        __s += __n2 - __n1;\n                    else // __p + __pos < __s < __p + __pos + __n1\n                    {\n                        traits_type::move(__p + __pos, __s, __n1);\n                        __pos += __n1;\n                        __s += __n2;\n                        __n2 -= __n1;\n                        __n1 = 0;\n                    }\n                }\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n            }\n        }\n        traits_type::move(__p + __pos, __s, __n2);\n__finish:\n        __sz += __n2 - __n1;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    else\n        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n        }\n    }\n    else\n    {\n        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    traits_type::assign(__p + __pos, __n2, __c);\n    __sz += __n2 - __n1;\n    __set_size(__sz);\n    __invalidate_iterators_past(__sz);\n    traits_type::assign(__p[__sz], value_type());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,\n                                                   _InputIterator __j1, _InputIterator __j2)\n{\n    const basic_string __temp(__j1, __j2, __alloc());\n    return this->replace(__i1, __i2, __temp);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)\n{\n    return replace(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,\n                                                   size_type __pos2, size_type __n2)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n\t__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tbasic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const _Tp& __t,\n                                                   size_type __pos2, size_type __n2)\n{\n    __self_view __sv = __t;\n    size_type __str_sz = __sv.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __sv.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::replace received nullptr\");\n    return replace(__pos, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),\n                   __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);\n}\n\n// erase\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        __n = _VSTD::min(__n, __sz - __pos);\n        size_type __n_move = __sz - __pos - __n;\n        if (__n_move != 0)\n            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);\n        __sz -= __n;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::erase(iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__pos != end(),\n        \"string::erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__pos - __b);\n    erase(__r, 1);\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"string::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"string::erase(first, last) called with invalid range\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__first - __b);\n    erase(__r, static_cast<size_type>(__last - __first));\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::pop_back(): string is already empty\");\n    size_type __sz;\n    if (__is_long())\n    {\n        __sz = __get_long_size() - 1;\n        __set_long_size(__sz);\n        traits_type::assign(*(__get_long_pointer() + __sz), value_type());\n    }\n    else\n    {\n        __sz = __get_short_size() - 1;\n        __set_short_size(__sz);\n        traits_type::assign(*(__get_short_pointer() + __sz), value_type());\n    }\n    __invalidate_iterators_past(__sz);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n    {\n        traits_type::assign(*__get_long_pointer(), value_type());\n        __set_long_size(0);\n    }\n    else\n    {\n        traits_type::assign(*__get_short_pointer(), value_type());\n        __set_short_size(0);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)\n{\n    if (__is_long())\n    {\n        traits_type::assign(*(__get_long_pointer() + __pos), value_type());\n        __set_long_size(__pos);\n    }\n    else\n    {\n        traits_type::assign(*(__get_short_pointer() + __pos), value_type());\n        __set_short_size(__pos);\n    }\n    __invalidate_iterators_past(__pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__n > __sz)\n        append(__n - __sz, __c);\n    else\n        __erase_to_end(__n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __m = __alloc_traits::max_size(__alloc());\n#if _LIBCPP_BIG_ENDIAN\n    return (__m <= ~__long_mask ? __m : __m/2) - __alignment;\n#else\n    return __m - __alignment;\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)\n{\n    if (__res_arg > max_size())\n        this->__throw_length_error();\n    size_type __cap = capacity();\n    size_type __sz = size();\n    __res_arg = _VSTD::max(__res_arg, __sz);\n    __res_arg = __recommend(__res_arg);\n    if (__res_arg != __cap)\n    {\n        pointer __new_data, __p;\n        bool __was_long, __now_long;\n        if (__res_arg == __min_cap - 1)\n        {\n            __was_long = true;\n            __now_long = false;\n            __new_data = __get_short_pointer();\n            __p = __get_long_pointer();\n        }\n        else\n        {\n            if (__res_arg > __cap)\n                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            else\n            {\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    return;\n                }\n            #else  // _LIBCPP_NO_EXCEPTIONS\n                if (__new_data == nullptr)\n                    return;\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            __now_long = true;\n            __was_long = __is_long();\n            __p = __get_pointer();\n        }\n        traits_type::copy(_VSTD::__to_raw_pointer(__new_data),\n                          _VSTD::__to_raw_pointer(__p), size()+1);\n        if (__was_long)\n            __alloc_traits::deallocate(__alloc(), __p, __cap+1);\n        if (__now_long)\n        {\n            __set_long_cap(__res_arg+1);\n            __set_long_size(__sz);\n            __set_long_pointer(__new_data);\n        }\n        else\n            __set_short_size(__sz);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(data() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(__get_pointer() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::front()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *__get_pointer();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::front() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *data();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(__get_pointer() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::back() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(data() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n, __sz - __pos);\n    traits_type::copy(__s, data() + __pos, __rlen);\n    return __rlen;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const\n{\n    return basic_string(*this, __pos, __n, __alloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    if (!__is_long())\n        __get_db()->__invalidate_all(this);\n    if (!__str.__is_long())\n        __get_db()->__invalidate_all(&__str);\n    __get_db()->swap(this, &__str);\n#endif\n    _LIBCPP_ASSERT(\n        __alloc_traits::propagate_on_container_swap::value ||\n        __alloc_traits::is_always_equal::value ||\n        __alloc() == __str.__alloc(), \"swapping non-equal allocators\");\n    _VSTD::swap(__r_.first(), __str.__r_.first());\n    __swap_allocator(__alloc(), __str.__alloc());\n}\n\n// find\n\ntemplate <class _Traits>\nstruct _LIBCPP_HIDDEN __traits_eq\n{\n    typedef typename _Traits::char_type char_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT\n        {return _Traits::eq(__x, __y);}\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos,\n                                                size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find(): received nullptr\");\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find(): received nullptr\");\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(value_type __c,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// rfind\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos,\n                                                 size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::rfind(): received nullptr\");\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::rfind(): received nullptr\");\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_first_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos,\n                                                         size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_of(): received nullptr\");\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_of(): received nullptr\");\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find(__c, __pos);\n}\n\n// find_last_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos,\n                                                        size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_of(): received nullptr\");\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_of(): received nullptr\");\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return rfind(__c, __pos);\n}\n\n// find_first_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos,\n                                                             size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_last_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos,\n                                                            size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// compare\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(__self_view __sv) const _NOEXCEPT\n{\n    size_t __lhs_sz = size();\n    size_t __rhs_sz = __sv.size();\n    int __result = traits_type::compare(data(), __sv.data(),\n                                        _VSTD::min(__lhs_sz, __rhs_sz));\n    if (__result != 0)\n        return __result;\n    if (__lhs_sz < __rhs_sz)\n        return -1;\n    if (__lhs_sz > __rhs_sz)\n        return 1;\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT\n{\n    return compare(__self_view(__str));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s,\n                                                   size_type __n2) const\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::compare(): received nullptr\");\n    size_type __sz = size();\n    if (__pos1 > __sz || __n2 == npos)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);\n    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));\n    if (__r == 0)\n    {\n        if (__rlen < __n2)\n            __r = -1;\n        else if (__rlen > __n2)\n            __r = 1;\n    }\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   __self_view __sv) const\n{\n    return compare(__pos1, __n1, __sv.data(), __sv.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str) const\n{\n    return compare(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n\t__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tint\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const _Tp& __t,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n    __self_view __sv = __t;\n    return __self_view(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n        return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(0, npos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s) const\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(__pos1, __n1, __s, traits_type::length(__s));\n}\n\n// __invariants\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__invariants() const\n{\n    if (size() > capacity())\n        return false;\n    if (capacity() < __min_cap - 1)\n        return false;\n    if (data() == 0)\n        return false;\n    if (data()[size()] != value_type(0))\n        return false;\n    return true;\n}\n\n// operator==\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),\n                                                        __rhs.data(),\n                                                        __lhs_sz) == 0;\n}\n\ntemplate<class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,\n           const basic_string<char, char_traits<char>, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    if (__lhs_sz != __rhs.size())\n        return false;\n    const char* __lp = __lhs.data();\n    const char* __rp = __rhs.data();\n    if (__lhs.__is_long())\n        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;\n    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)\n        if (*__lp != *__rp)\n            return false;\n    return true;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__lhs != nullptr, \"operator==(char*, basic_string): received nullptr\");\n    size_t __lhs_len = _Traits::length(__lhs);\n    if (__lhs_len != __rhs.size()) return false;\n    return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__rhs != nullptr, \"operator==(basic_string, char*): received nullptr\");\n    size_t __rhs_len = _Traits::length(__rhs);\n    if (__rhs_len != __lhs.size()) return false;\n    return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\n// operator<\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) > 0;\n}\n\n// operator>\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\n// operator<=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\n// operator>=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\n// operator +\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n          const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(&__lhs, 1, 1 + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs, __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);\n    __r.push_back(__rhs);\n    return __r;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    __rhs.insert(__rhs.begin(), __lhs);\n    return _VSTD::move(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)\n{\n    __lhs.push_back(__rhs);\n    return _VSTD::move(__lhs);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// swap\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_string<_CharT, _Traits, _Allocator>& __lhs,\n     basic_string<_CharT, _Traits, _Allocator>& __rhs)\n     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))\n{\n    __lhs.swap(__rhs);\n}\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n_LIBCPP_FUNC_VIS int                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const string& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS string to_string(int __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned __val);\n_LIBCPP_FUNC_VIS string to_string(long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long __val);\n_LIBCPP_FUNC_VIS string to_string(long long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long long __val);\n_LIBCPP_FUNC_VIS string to_string(float __val);\n_LIBCPP_FUNC_VIS string to_string(double __val);\n_LIBCPP_FUNC_VIS string to_string(long double __val);\n\n_LIBCPP_FUNC_VIS int                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const wstring& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS wstring to_wstring(int __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(float __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(double __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long double __val);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n    const typename basic_string<_CharT, _Traits, _Allocator>::size_type\n                   basic_string<_CharT, _Traits, _Allocator>::npos;\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nstruct _LIBCPP_TEMPLATE_VIS hash<basic_string<_CharT, _Traits, _Allocator> >\n    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>\n{\n    size_t\n        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nsize_t\nhash<basic_string<_CharT, _Traits, _Allocator> >::operator()(\n        const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT\n{\n    return __do_string_hash(__val.data(), __val.data() + __val.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->data() <= _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) < this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->data() < _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p < this->data() + this->size();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n#if _LIBCPP_STD_VER > 11 \n// Literal suffixes for basic_string [basic.string.literals]\ninline namespace literals\n{\n  inline namespace string_literals\n  {\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char> operator \"\" s( const char *__str, size_t __len )\n    {\n        return basic_string<char> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<wchar_t> operator \"\" s( const wchar_t *__str, size_t __len )\n    {\n        return basic_string<wchar_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char16_t> operator \"\" s( const char16_t *__str, size_t __len )\n    {\n        return basic_string<char16_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char32_t> operator \"\" s( const char32_t *__str, size_t __len )\n    {\n        return basic_string<char32_t> (__str, __len);\n    }\n  }\n}\n#endif\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_string<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_string<wchar_t>)\n_LIBCPP_EXTERN_TEMPLATE(string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&))\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STRING\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___LOCALE\n#define _LIBCPP___LOCALE\n\n#include <__config>\n#include <string>\n#include <memory>\n#include <utility>\n#include <mutex>\n#include <cstdint>\n#include <cctype>\n#include <locale.h>\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n# include <support/win32/locale_win32.h>\n#elif defined(_AIX)\n# include <support/ibm/xlocale.h>\n#elif defined(__ANDROID__)\n// Android gained the locale aware functions in L (API level 21)\n# include <android/api-level.h>\n# if __ANDROID_API__ <= 20\n#  include <support/android/locale_bionic.h>\n# endif\n#elif defined(__sun__)\n# include <xlocale.h>\n# include <support/solaris/xlocale.h>\n#elif defined(_NEWLIB_VERSION)\n# include <support/newlib/xlocale.h>\n#elif (defined(__GLIBC__) || defined(__APPLE__)      || defined(__FreeBSD__) \\\n    || defined(__EMSCRIPTEN__) || defined(__IBMCPP__))\n# include <xlocale.h>\n#elif defined(_LIBCPP_HAS_MUSL_LIBC)\n# include <support/musl/xlocale.h>\n#endif // __GLIBC__ || __APPLE__ || __FreeBSD__ || __sun__ || __EMSCRIPTEN__ || __IBMCPP__\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_TYPE_VIS locale;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale&) _NOEXCEPT;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale&);\n\nclass _LIBCPP_TYPE_VIS locale\n{\npublic:\n    // types:\n    class _LIBCPP_TYPE_VIS facet;\n    class _LIBCPP_TYPE_VIS id;\n\n    typedef int category;\n    static const category // values assigned here are for exposition only\n        none     = 0,\n        collate  = LC_COLLATE_MASK,\n        ctype    = LC_CTYPE_MASK,\n        monetary = LC_MONETARY_MASK,\n        numeric  = LC_NUMERIC_MASK,\n        time     = LC_TIME_MASK,\n        messages = LC_MESSAGES_MASK,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale()  _NOEXCEPT;\n    locale(const locale&)  _NOEXCEPT;\n    explicit locale(const char*);\n    explicit locale(const string&);\n    locale(const locale&, const char*, category);\n    locale(const locale&, const string&, category);\n    template <class _Facet>\n        _LIBCPP_INLINE_VISIBILITY locale(const locale&, _Facet*);\n    locale(const locale&, const locale&, category);\n\n    ~locale();\n\n    const locale& operator=(const locale&)  _NOEXCEPT;\n\n    template <class _Facet> locale combine(const locale&) const;\n\n    // locale operations:\n    string name() const;\n    bool operator==(const locale&) const;\n    bool operator!=(const locale& __y) const {return !(*this == __y);}\n    template <class _CharT, class _Traits, class _Allocator>\n      bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,\n                      const basic_string<_CharT, _Traits, _Allocator>&) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n\nprivate:\n    class __imp;\n    __imp* __locale_;\n\n    void __install_ctor(const locale&, facet*, long);\n    static locale& __global();\n    bool has_facet(id&) const;\n    const facet* use_facet(id&) const;\n\n    template <class _Facet> friend bool has_facet(const locale&)  _NOEXCEPT;\n    template <class _Facet> friend const _Facet& use_facet(const locale&);\n};\n\nclass _LIBCPP_TYPE_VIS locale::facet\n    : public __shared_count\n{\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit facet(size_t __refs = 0)\n        : __shared_count(static_cast<long>(__refs)-1) {}\n\n    virtual ~facet();\n\n//    facet(const facet&) = delete;     // effectively done in __shared_count\n//    void operator=(const facet&) = delete;\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n};\n\nclass _LIBCPP_TYPE_VIS locale::id\n{\n    once_flag      __flag_;\n    int32_t        __id_;\n\n    static int32_t __next_id;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR id() :__id_(0) {}\nprivate:\n    void __init();\n    void operator=(const id&); // = delete;\n    id(const id&); // = delete;\npublic:  // only needed for tests\n    long __get();\n\n    friend class locale;\n    friend class locale::__imp;\n};\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale::locale(const locale& __other, _Facet* __f)\n{\n    __install_ctor(__other, __f, __f ? __f->id.__get() : 0);\n}\n\ntemplate <class _Facet>\nlocale\nlocale::combine(const locale& __other) const\n{\n    if (!_VSTD::has_facet<_Facet>(__other))\n        __throw_runtime_error(\"locale::combine: locale missing facet\");\n\n    return locale(*this, &const_cast<_Facet&>(_VSTD::use_facet<_Facet>(__other)));\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale& __l)  _NOEXCEPT\n{\n    return __l.has_facet(_Facet::id);\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale& __l)\n{\n    return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));\n}\n\n// template <class _CharT> class collate;\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS collate\n    : public locale::facet\n{\npublic:\n    typedef _CharT char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit collate(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const char_type* __lo1, const char_type* __hi1,\n                const char_type* __lo2, const char_type* __hi2) const\n    {\n        return do_compare(__lo1, __hi1, __lo2, __hi2);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    string_type transform(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_transform(__lo, __hi);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    long hash(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_hash(__lo, __hi);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~collate();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const\n        {return string_type(__lo, __hi);}\n    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT> locale::id collate<_CharT>::id;\n\ntemplate <class _CharT>\ncollate<_CharT>::~collate()\n{\n}\n\ntemplate <class _CharT>\nint\ncollate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,\n                            const char_type* __lo2, const char_type* __hi2) const\n{\n    for (; __lo2 != __hi2; ++__lo1, ++__lo2)\n    {\n        if (__lo1 == __hi1 || *__lo1 < *__lo2)\n            return -1;\n        if (*__lo2 < *__lo1)\n            return 1;\n    }\n    return __lo1 != __hi1;\n}\n\ntemplate <class _CharT>\nlong\ncollate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const\n{\n    size_t __h = 0;\n    const size_t __sr = __CHAR_BIT__ * sizeof(size_t) - 8;\n    const size_t __mask = size_t(0xF) << (__sr + 4);\n    for(const char_type* __p = __lo; __p != __hi; ++__p)\n    {\n        __h = (__h << 4) + static_cast<size_t>(*__p);\n        size_t __g = __h & __mask;\n        __h ^= __g | (__g >> __sr);\n    }\n    return static_cast<long>(__h);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS collate<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS collate<wchar_t>)\n\n// template <class CharT> class collate_byname;\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS collate_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<char>\n    : public collate<char>\n{\n    locale_t __l;\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<wchar_t>\n    : public collate<wchar_t>\n{\n    locale_t __l;\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbool\nlocale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,\n                   const basic_string<_CharT, _Traits, _Allocator>& __y) const\n{\n    return _VSTD::use_facet<_VSTD::collate<_CharT> >(*this).compare(\n                                       __x.data(), __x.data() + __x.size(),\n                                       __y.data(), __y.data() + __y.size()) < 0;\n}\n\n// template <class charT> class ctype\n\nclass _LIBCPP_TYPE_VIS ctype_base\n{\npublic:\n#if defined(__GLIBC__)\n    typedef unsigned short mask;\n    static const mask space  = _ISspace;\n    static const mask print  = _ISprint;\n    static const mask cntrl  = _IScntrl;\n    static const mask upper  = _ISupper;\n    static const mask lower  = _ISlower;\n    static const mask alpha  = _ISalpha;\n    static const mask digit  = _ISdigit;\n    static const mask punct  = _ISpunct;\n    static const mask xdigit = _ISxdigit;\n    static const mask blank  = _ISblank;\n#elif defined(_LIBCPP_MSVCRT)\n    typedef unsigned short mask;\n    static const mask space  = _SPACE;\n    static const mask print  = _BLANK|_PUNCT|_ALPHA|_DIGIT;\n    static const mask cntrl  = _CONTROL;\n    static const mask upper  = _UPPER;\n    static const mask lower  = _LOWER;\n    static const mask alpha  = _ALPHA;\n    static const mask digit  = _DIGIT;\n    static const mask punct  = _PUNCT;\n    static const mask xdigit = _HEX;\n    static const mask blank  = _BLANK;\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_PRINT\n#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__EMSCRIPTEN__) || defined(__NetBSD__)\n# ifdef __APPLE__\n    typedef __uint32_t mask;\n# elif defined(__FreeBSD__)\n    typedef unsigned long mask;\n# elif defined(__EMSCRIPTEN__) || defined(__NetBSD__)\n    typedef unsigned short mask;\n# endif\n    static const mask space  = _CTYPE_S;\n    static const mask print  = _CTYPE_R;\n    static const mask cntrl  = _CTYPE_C;\n    static const mask upper  = _CTYPE_U;\n    static const mask lower  = _CTYPE_L;\n    static const mask alpha  = _CTYPE_A;\n    static const mask digit  = _CTYPE_D;\n    static const mask punct  = _CTYPE_P;\n    static const mask xdigit = _CTYPE_X;\n\n# if defined(__NetBSD__)\n    static const mask blank  = _CTYPE_BL;\n# else\n    static const mask blank  = _CTYPE_B;\n# endif\n#elif defined(__sun__) || defined(_AIX)\n    typedef unsigned int mask;\n    static const mask space  = _ISSPACE;\n    static const mask print  = _ISPRINT;\n    static const mask cntrl  = _ISCNTRL;\n    static const mask upper  = _ISUPPER;\n    static const mask lower  = _ISLOWER;\n    static const mask alpha  = _ISALPHA;\n    static const mask digit  = _ISDIGIT;\n    static const mask punct  = _ISPUNCT;\n    static const mask xdigit = _ISXDIGIT;\n    static const mask blank  = _ISBLANK;\n#elif defined(_NEWLIB_VERSION)\n    // Same type as Newlib's _ctype_ array in newlib/libc/include/ctype.h.\n    typedef char mask;\n    static const mask space  = _S;\n    static const mask print  = _P | _U | _L | _N | _B;\n    static const mask cntrl  = _C;\n    static const mask upper  = _U;\n    static const mask lower  = _L;\n    static const mask alpha  = _U | _L;\n    static const mask digit  = _N;\n    static const mask punct  = _P;\n    static const mask xdigit = _X | _N;\n    static const mask blank  = _B;\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_PRINT\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_ALPHA\n# define _LIBCPP_CTYPE_MASK_IS_COMPOSITE_XDIGIT\n#else\n    typedef unsigned long mask;\n    static const mask space  = 1<<0;\n    static const mask print  = 1<<1;\n    static const mask cntrl  = 1<<2;\n    static const mask upper  = 1<<3;\n    static const mask lower  = 1<<4;\n    static const mask alpha  = 1<<5;\n    static const mask digit  = 1<<6;\n    static const mask punct  = 1<<7;\n    static const mask xdigit = 1<<8;\n    static const mask blank  = 1<<9;\n#endif\n    static const mask alnum  = alpha | digit;\n    static const mask graph  = alnum | punct;\n\n    _LIBCPP_ALWAYS_INLINE ctype_base() {}\n};\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS ctype;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<wchar_t>\n    : public locale::facet,\n      public ctype_base\n{\npublic:\n    typedef wchar_t char_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit ctype(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    bool is(mask __m, char_type __c) const\n    {\n        return do_is(__m, __c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        return do_is(__low, __high, __vec);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_is(__m, __low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_not(__m, __low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~ctype();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<char>\n    : public locale::facet, public ctype_base\n{\n    const mask* __tab_;\n    bool        __del_;\npublic:\n    typedef char char_type;\n\n    explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE\n    bool is(mask __m, char_type __c) const\n    {\n        return isascii(__c) ? (__tab_[static_cast<int>(__c)] & __m) !=0 : false;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        for (; __low != __high; ++__low, ++__vec)\n            *__vec = isascii(*__low) ? __tab_[static_cast<int>(*__low)] : 0;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (!(isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m)))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\n#ifdef _CACHED_RUNES\n    static const size_t table_size = _CACHED_RUNES;\n#else\n    static const size_t table_size = 256;  // FIXME: Don't hardcode this.\n#endif\n    _LIBCPP_ALWAYS_INLINE const mask* table() const  _NOEXCEPT {return __tab_;}\n    static const mask* classic_table()  _NOEXCEPT;\n#if defined(__GLIBC__) || defined(__EMSCRIPTEN__)\n    static const int* __classic_upper_table() _NOEXCEPT;\n    static const int* __classic_lower_table() _NOEXCEPT;\n#endif\n#if defined(__NetBSD__)\n    static const short* __classic_upper_table() _NOEXCEPT;\n    static const short* __classic_lower_table() _NOEXCEPT;\n#endif\n\nprotected:\n    ~ctype();\n    virtual char_type do_toupper(char_type __c) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type __c) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char __c) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;\n    virtual char do_narrow(char_type __c, char __dfault) const;\n    virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;\n};\n\n// template <class CharT> class ctype_byname;\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS ctype_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<char>\n    : public ctype<char>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<wchar_t>\n    : public ctype<wchar_t>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisspace(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisprint(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\niscntrl(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nislower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalpha(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nispunct(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisxdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalnum(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisgraph(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntoupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).toupper(__c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntolower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).tolower(__c);\n}\n\n// codecvt_base\n\nclass _LIBCPP_TYPE_VIS codecvt_base\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE codecvt_base() {}\n    enum result {ok, partial, error, noconv};\n};\n\n// template <class internT, class externT, class stateT> class codecvt;\n\ntemplate <class _InternT, class _ExternT, class _StateT> class _LIBCPP_TEMPLATE_VIS codecvt;\n\n// template <> class codecvt<char, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char      intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<wchar_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<wchar_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\n    locale_t __l;\npublic:\n    typedef wchar_t   intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    explicit codecvt(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    explicit codecvt(const char*, size_t __refs = 0);\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char16_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char16_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char16_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char32_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char32_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char32_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <class _InternT, class _ExternT, class _StateT> class codecvt_byname\n\ntemplate <class _InternT, class _ExternT, class _StateT>\nclass _LIBCPP_TEMPLATE_VIS codecvt_byname\n    : public codecvt<_InternT, _ExternT, _StateT>\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt_byname(const char* __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt_byname(const string& __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}\nprotected:\n    ~codecvt_byname();\n};\n\ntemplate <class _InternT, class _ExternT, class _StateT>\ncodecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()\n{\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<wchar_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char16_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char32_t, char, mbstate_t>)\n\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);\n\ntemplate <size_t _Np>\nstruct __narrow_to_utf8\n{\n    template <class _OutputIterator, class _CharT>\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;\n};\n\ntemplate <>\nstruct __narrow_to_utf8<8>\n{\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        for (; __wb < __we; ++__wb, ++__s)\n            *__s = *__wb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __narrow_to_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char16_t* __wn = (const char16_t*)__wb;\n            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __narrow_to_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char32_t* __wn = (const char32_t*)__wb;\n            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <size_t _Np>\nstruct __widen_from_utf8\n{\n    template <class _OutputIterator>\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;\n};\n\ntemplate <>\nstruct __widen_from_utf8<8>\n{\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        for (; __nb < __ne; ++__nb, ++__s)\n            *__s = *__nb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __widen_from_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char16_t __buf[__sz];\n            char16_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __widen_from_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char32_t __buf[__sz];\n            char32_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\n// template <class charT> class numpunct\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS numpunct;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<char>\n    : public locale::facet\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}\n    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<wchar_t>\n    : public locale::facet\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}\n    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\n// template <class charT> class numpunct_byname\n\ntemplate <class _CharT> class _LIBCPP_TEMPLATE_VIS numpunct_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<char>\n: public numpunct<char>\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<wchar_t>\n: public numpunct<wchar_t>\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___LOCALE\n","// -*- C++ -*-\n//===------------------------ type_traits ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TYPE_TRAITS\n#define _LIBCPP_TYPE_TRAITS\n\n/*\n    type_traits synopsis\n\nnamespace std\n{\n\n    // helper class:\n    template <class T, T v> struct integral_constant;\n    typedef integral_constant<bool, true>  true_type;   // C++11\n    typedef integral_constant<bool, false> false_type;  // C++11\n    \n    template <bool B>                                   // C++14\n    using bool_constant = integral_constant<bool, B>;   // C++14\n    typedef bool_constant<true> true_type;              // C++14\n    typedef bool_constant<false> false_type;            // C++14\n\n    // helper traits\n    template <bool, class T = void> struct enable_if;\n    template <bool, class T, class F> struct conditional;\n\n    // Primary classification traits:\n    template <class T> struct is_void;\n    template <class T> struct is_null_pointer;  // C++14\n    template <class T> struct is_integral;\n    template <class T> struct is_floating_point;\n    template <class T> struct is_array;\n    template <class T> struct is_pointer;\n    template <class T> struct is_lvalue_reference;\n    template <class T> struct is_rvalue_reference;\n    template <class T> struct is_member_object_pointer;\n    template <class T> struct is_member_function_pointer;\n    template <class T> struct is_enum;\n    template <class T> struct is_union;\n    template <class T> struct is_class;\n    template <class T> struct is_function;\n\n    // Secondary classification traits:\n    template <class T> struct is_reference;\n    template <class T> struct is_arithmetic;\n    template <class T> struct is_fundamental;\n    template <class T> struct is_member_pointer;\n    template <class T> struct is_scalar;\n    template <class T> struct is_object;\n    template <class T> struct is_compound;\n\n    // Const-volatile properties and transformations:\n    template <class T> struct is_const;\n    template <class T> struct is_volatile;\n    template <class T> struct remove_const;\n    template <class T> struct remove_volatile;\n    template <class T> struct remove_cv;\n    template <class T> struct add_const;\n    template <class T> struct add_volatile;\n    template <class T> struct add_cv;\n\n    // Reference transformations:\n    template <class T> struct remove_reference;\n    template <class T> struct add_lvalue_reference;\n    template <class T> struct add_rvalue_reference;\n\n    // Pointer transformations:\n    template <class T> struct remove_pointer;\n    template <class T> struct add_pointer;\n\n    // Integral properties:\n    template <class T> struct is_signed;\n    template <class T> struct is_unsigned;\n    template <class T> struct make_signed;\n    template <class T> struct make_unsigned;\n\n    // Array properties and transformations:\n    template <class T> struct rank;\n    template <class T, unsigned I = 0> struct extent;\n    template <class T> struct remove_extent;\n    template <class T> struct remove_all_extents;\n\n    // Member introspection:\n    template <class T> struct is_pod;\n    template <class T> struct is_trivial;\n    template <class T> struct is_trivially_copyable;\n    template <class T> struct is_standard_layout;\n    template <class T> struct is_literal_type;\n    template <class T> struct is_empty;\n    template <class T> struct is_polymorphic;\n    template <class T> struct is_abstract;\n    template <class T> struct is_final; // C++14\n\n    template <class T, class... Args> struct is_constructible;\n    template <class T>                struct is_default_constructible;\n    template <class T>                struct is_copy_constructible;\n    template <class T>                struct is_move_constructible;\n    template <class T, class U>       struct is_assignable;\n    template <class T>                struct is_copy_assignable;\n    template <class T>                struct is_move_assignable;\n    template <class T, class U>       struct is_swappable_with;       // C++17\n    template <class T>                struct is_swappable;            // C++17\n    template <class T>                struct is_destructible;\n\n    template <class T, class... Args> struct is_trivially_constructible;\n    template <class T>                struct is_trivially_default_constructible;\n    template <class T>                struct is_trivially_copy_constructible;\n    template <class T>                struct is_trivially_move_constructible;\n    template <class T, class U>       struct is_trivially_assignable;\n    template <class T>                struct is_trivially_copy_assignable;\n    template <class T>                struct is_trivially_move_assignable;\n    template <class T>                struct is_trivially_destructible;\n\n    template <class T, class... Args> struct is_nothrow_constructible;\n    template <class T>                struct is_nothrow_default_constructible;\n    template <class T>                struct is_nothrow_copy_constructible;\n    template <class T>                struct is_nothrow_move_constructible;\n    template <class T, class U>       struct is_nothrow_assignable;\n    template <class T>                struct is_nothrow_copy_assignable;\n    template <class T>                struct is_nothrow_move_assignable;\n    template <class T, class U>       struct is_nothrow_swappable_with; // C++17\n    template <class T>                struct is_nothrow_swappable;      // C++17\n    template <class T>                struct is_nothrow_destructible;\n\n    template <class T> struct has_virtual_destructor;\n\n    // Relationships between types:\n    template <class T, class U> struct is_same;\n    template <class Base, class Derived> struct is_base_of;\n    template <class From, class To> struct is_convertible;\n\n    template <class, class R = void> struct is_callable; // not defined\n    template <class Fn, class... ArgTypes, class R>\n      struct is_callable<Fn(ArgTypes...), R>;\n\n    template <class, class R = void> struct is_nothrow_callable; // not defined\n    template <class Fn, class... ArgTypes, class R>\n      struct is_nothrow_callable<Fn(ArgTypes...), R>;\n\n    // Alignment properties and transformations:\n    template <class T> struct alignment_of;\n    template <size_t Len, size_t Align = most_stringent_alignment_requirement>\n        struct aligned_storage;\n    template <size_t Len, class... Types> struct aligned_union;\n\n    template <class T> struct decay;\n    template <class... T> struct common_type;\n    template <class T> struct underlying_type;\n    template <class> class result_of; // undefined\n    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;\n\n    // const-volatile modifications:\n    template <class T>\n      using remove_const_t    = typename remove_const<T>::type;  // C++14\n    template <class T>\n      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14\n    template <class T>\n      using remove_cv_t       = typename remove_cv<T>::type;  // C++14\n    template <class T>\n      using add_const_t       = typename add_const<T>::type;  // C++14\n    template <class T>\n      using add_volatile_t    = typename add_volatile<T>::type;  // C++14\n    template <class T>\n      using add_cv_t          = typename add_cv<T>::type;  // C++14\n  \n    // reference modifications:\n    template <class T>\n      using remove_reference_t     = typename remove_reference<T>::type;  // C++14\n    template <class T>\n      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14\n    template <class T>\n      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14\n  \n    // sign modifications:\n    template <class T>\n      using make_signed_t   = typename make_signed<T>::type;  // C++14\n    template <class T>\n      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14\n  \n    // array modifications:\n    template <class T>\n      using remove_extent_t      = typename remove_extent<T>::type;  // C++14\n    template <class T>\n      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14\n\n    // pointer modifications:\n    template <class T>\n      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14\n    template <class T>\n      using add_pointer_t    = typename add_pointer<T>::type;  // C++14\n\n    // other transformations:\n    template <size_t Len, std::size_t Align=default-alignment>\n      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14\n    template <std::size_t Len, class... Types>\n      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14\n    template <class T>\n      using decay_t           = typename decay<T>::type;  // C++14\n    template <bool b, class T=void>\n      using enable_if_t       = typename enable_if<b,T>::type;  // C++14\n    template <bool b, class T, class F>\n      using conditional_t     = typename conditional<b,T,F>::type;  // C++14\n    template <class... T>\n      using common_type_t     = typename common_type<T...>::type;  // C++14\n    template <class T>\n      using underlying_type_t = typename underlying_type<T>::type;  // C++14\n    template <class F, class... ArgTypes>\n      using result_of_t       = typename result_of<F(ArgTypes...)>::type;  // C++14\n\n    template <class...>\n      using void_t = void;   // C++17\n      \n      // See C++14 20.10.4.1, primary type categories\n      template <class T> constexpr bool is_void_v\n        = is_void<T>::value;                                             // C++17\n      template <class T> constexpr bool is_null_pointer_v\n        = is_null_pointer<T>::value;                                     // C++17\n      template <class T> constexpr bool is_integral_v\n        = is_integral<T>::value;                                         // C++17\n      template <class T> constexpr bool is_floating_point_v\n        = is_floating_point<T>::value;                                   // C++17\n      template <class T> constexpr bool is_array_v\n        = is_array<T>::value;                                            // C++17\n      template <class T> constexpr bool is_pointer_v\n        = is_pointer<T>::value;                                          // C++17\n      template <class T> constexpr bool is_lvalue_reference_v\n        = is_lvalue_reference<T>::value;                                 // C++17\n      template <class T> constexpr bool is_rvalue_reference_v\n        = is_rvalue_reference<T>::value;                                 // C++17\n      template <class T> constexpr bool is_member_object_pointer_v\n        = is_member_object_pointer<T>::value;                            // C++17\n      template <class T> constexpr bool is_member_function_pointer_v\n        = is_member_function_pointer<T>::value;                          // C++17\n      template <class T> constexpr bool is_enum_v\n        = is_enum<T>::value;                                             // C++17\n      template <class T> constexpr bool is_union_v\n        = is_union<T>::value;                                            // C++17\n      template <class T> constexpr bool is_class_v\n        = is_class<T>::value;                                            // C++17\n      template <class T> constexpr bool is_function_v\n        = is_function<T>::value;                                         // C++17\n\n      // See C++14 20.10.4.2, composite type categories\n      template <class T> constexpr bool is_reference_v\n        = is_reference<T>::value;                                        // C++17\n      template <class T> constexpr bool is_arithmetic_v\n        = is_arithmetic<T>::value;                                       // C++17\n      template <class T> constexpr bool is_fundamental_v\n        = is_fundamental<T>::value;                                      // C++17\n      template <class T> constexpr bool is_object_v\n        = is_object<T>::value;                                           // C++17\n      template <class T> constexpr bool is_scalar_v\n        = is_scalar<T>::value;                                           // C++17\n      template <class T> constexpr bool is_compound_v\n        = is_compound<T>::value;                                         // C++17\n      template <class T> constexpr bool is_member_pointer_v\n        = is_member_pointer<T>::value;                                   // C++17\n\n      // See C++14 20.10.4.3, type properties\n      template <class T> constexpr bool is_const_v\n        = is_const<T>::value;                                            // C++17\n      template <class T> constexpr bool is_volatile_v\n        = is_volatile<T>::value;                                         // C++17\n      template <class T> constexpr bool is_trivial_v\n        = is_trivial<T>::value;                                          // C++17\n      template <class T> constexpr bool is_trivially_copyable_v\n        = is_trivially_copyable<T>::value;                               // C++17\n      template <class T> constexpr bool is_standard_layout_v\n        = is_standard_layout<T>::value;                                  // C++17\n      template <class T> constexpr bool is_pod_v\n        = is_pod<T>::value;                                              // C++17\n      template <class T> constexpr bool is_literal_type_v\n        = is_literal_type<T>::value;                                     // C++17\n      template <class T> constexpr bool is_empty_v\n        = is_empty<T>::value;                                            // C++17\n      template <class T> constexpr bool is_polymorphic_v\n        = is_polymorphic<T>::value;                                      // C++17\n      template <class T> constexpr bool is_abstract_v\n        = is_abstract<T>::value;                                         // C++17\n      template <class T> constexpr bool is_final_v\n        = is_final<T>::value;                                            // C++17\n      template <class T> constexpr bool is_signed_v\n        = is_signed<T>::value;                                           // C++17\n      template <class T> constexpr bool is_unsigned_v\n        = is_unsigned<T>::value;                                         // C++17\n      template <class T, class... Args> constexpr bool is_constructible_v\n        = is_constructible<T, Args...>::value;                           // C++17\n      template <class T> constexpr bool is_default_constructible_v\n        = is_default_constructible<T>::value;                            // C++17\n      template <class T> constexpr bool is_copy_constructible_v\n        = is_copy_constructible<T>::value;                               // C++17\n      template <class T> constexpr bool is_move_constructible_v\n        = is_move_constructible<T>::value;                               // C++17\n      template <class T, class U> constexpr bool is_assignable_v\n        = is_assignable<T, U>::value;                                    // C++17\n      template <class T> constexpr bool is_copy_assignable_v\n        = is_copy_assignable<T>::value;                                  // C++17\n      template <class T> constexpr bool is_move_assignable_v\n        = is_move_assignable<T>::value;                                  // C++17\n      template <class T, class U> constexpr bool is_swappable_with_v\n        = is_swappable_with<T, U>::value;                                // C++17\n      template <class T> constexpr bool is_swappable_v\n        = is_swappable<T>::value;                                        // C++17\n      template <class T> constexpr bool is_destructible_v\n        = is_destructible<T>::value;                                     // C++17\n      template <class T, class... Args> constexpr bool is_trivially_constructible_v\n        = is_trivially_constructible<T, Args...>::value;                 // C++17\n      template <class T> constexpr bool is_trivially_default_constructible_v\n        = is_trivially_default_constructible<T>::value;                  // C++17\n      template <class T> constexpr bool is_trivially_copy_constructible_v\n        = is_trivially_copy_constructible<T>::value;                     // C++17\n      template <class T> constexpr bool is_trivially_move_constructible_v\n        = is_trivially_move_constructible<T>::value;                     // C++17\n      template <class T, class U> constexpr bool is_trivially_assignable_v\n        = is_trivially_assignable<T, U>::value;                          // C++17\n      template <class T> constexpr bool is_trivially_copy_assignable_v\n        = is_trivially_copy_assignable<T>::value;                        // C++17\n      template <class T> constexpr bool is_trivially_move_assignable_v\n        = is_trivially_move_assignable<T>::value;                        // C++17\n      template <class T> constexpr bool is_trivially_destructible_v\n        = is_trivially_destructible<T>::value;                           // C++17\n      template <class T, class... Args> constexpr bool is_nothrow_constructible_v\n        = is_nothrow_constructible<T, Args...>::value;                   // C++17\n      template <class T> constexpr bool is_nothrow_default_constructible_v\n        = is_nothrow_default_constructible<T>::value;                    // C++17\n      template <class T> constexpr bool is_nothrow_copy_constructible_v\n        = is_nothrow_copy_constructible<T>::value;                       // C++17\n      template <class T> constexpr bool is_nothrow_move_constructible_v\n        = is_nothrow_move_constructible<T>::value;                       // C++17\n      template <class T, class U> constexpr bool is_nothrow_assignable_v\n        = is_nothrow_assignable<T, U>::value;                            // C++17\n      template <class T> constexpr bool is_nothrow_copy_assignable_v\n        = is_nothrow_copy_assignable<T>::value;                          // C++17\n      template <class T> constexpr bool is_nothrow_move_assignable_v\n        = is_nothrow_move_assignable<T>::value;                          // C++17\n      template <class T, class U> constexpr bool is_nothrow_swappable_with_v\n        = is_nothrow_swappable_with<T, U>::value;                       // C++17\n      template <class T> constexpr bool is_nothrow_swappable_v\n        = is_nothrow_swappable<T>::value;                               // C++17\n      template <class T> constexpr bool is_nothrow_destructible_v\n        = is_nothrow_destructible<T>::value;                             // C++17\n      template <class T> constexpr bool has_virtual_destructor_v\n        = has_virtual_destructor<T>::value;                              // C++17\n\n      // See C++14 20.10.5, type property queries\n      template <class T> constexpr size_t alignment_of_v\n        = alignment_of<T>::value;                                        // C++17\n      template <class T> constexpr size_t rank_v\n        = rank<T>::value;                                                // C++17\n      template <class T, unsigned I = 0> constexpr size_t extent_v\n        = extent<T, I>::value;                                           // C++17\n\n      // See C++14 20.10.6, type relations\n      template <class T, class U> constexpr bool is_same_v\n        = is_same<T, U>::value;                                          // C++17\n      template <class Base, class Derived> constexpr bool is_base_of_v\n        = is_base_of<Base, Derived>::value;                              // C++17\n      template <class From, class To> constexpr bool is_convertible_v\n        = is_convertible<From, To>::value;                               // C++17\n      template <class T, class R = void> constexpr bool is_callable_v\n        = is_callable<T, R>::value;                                      // C++17\n      template <class T, class R = void> constexpr bool is_nothrow_callable_v\n        = is_nothrow_callable<T, R>::value;                              // C++17\n\n      // [meta.logical], logical operator traits:\n      template<class... B> struct conjunction;                           // C++17\n      template<class... B> \n        constexpr bool conjunction_v = conjunction<B...>::value;         // C++17\n      template<class... B> struct disjunction;                           // C++17\n      template<class... B>\n        constexpr bool disjunction_v = disjunction<B...>::value;         // C++17\n      template<class B> struct negation;                                 // C++17\n      template<class B> \n        constexpr bool negation_v = negation<B>::value;                  // C++17\n\n}\n\n*/\n#include <__config>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS pair;\ntemplate <class _Tp> class _LIBCPP_TEMPLATE_VIS reference_wrapper;\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS hash;\n\ntemplate <class>\nstruct __void_t { typedef void type; };\n\ntemplate <class _Tp>\nstruct __identity { typedef _Tp type; };\n\ntemplate <class _Tp, bool>\nstruct _LIBCPP_TEMPLATE_VIS __dependent_type : public _Tp {};\n\ntemplate <bool _Bp, class _If, class _Then>\n    struct _LIBCPP_TEMPLATE_VIS conditional {typedef _If type;};\ntemplate <class _If, class _Then>\n    struct _LIBCPP_TEMPLATE_VIS conditional<false, _If, _Then> {typedef _Then type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;\n#endif\n\ntemplate <bool, class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};\n\ntemplate <bool, class _Tp = void> struct _LIBCPP_TEMPLATE_VIS enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS enable_if<true, _Tp> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;\n#endif\n\n// addressof\n#ifndef _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF\n\ntemplate <class _Tp>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\n_LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return __builtin_addressof(__x);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n  return reinterpret_cast<_Tp *>(\n      const_cast<char *>(&reinterpret_cast<const volatile char &>(__x)));\n}\n\n#endif // _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF\n\n#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)\n// Objective-C++ Automatic Reference Counting uses qualified pointers\n// that require special addressof() signatures. When\n// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler\n// itself is providing these definitions. Otherwise, we provide them.\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__strong _Tp*\naddressof(__strong _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\n#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__weak _Tp*\naddressof(__weak _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__autoreleasing _Tp*\naddressof(__autoreleasing _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__unsafe_unretained _Tp*\naddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\n#if !defined(_LIBCPP_CXX03_LANG)\ntemplate <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;\n#endif\n\nstruct __two {char __lx[2];};\n\n// helper class:\n\ntemplate <class _Tp, _Tp __v>\nstruct _LIBCPP_TEMPLATE_VIS integral_constant\n{\n    static _LIBCPP_CONSTEXPR const _Tp      value = __v;\n    typedef _Tp               value_type;\n    typedef integral_constant type;\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n         constexpr value_type operator ()() const _NOEXCEPT {return value;}\n#endif\n};\n\ntemplate <class _Tp, _Tp __v>\n_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;\n\n#if _LIBCPP_STD_VER > 14\ntemplate <bool __b>\nusing bool_constant = integral_constant<bool, __b>;\n#define _LIBCPP_BOOL_CONSTANT(__b) bool_constant<(__b)>\n#else\n#define _LIBCPP_BOOL_CONSTANT(__b) integral_constant<bool,(__b)>\n#endif\n\ntypedef _LIBCPP_BOOL_CONSTANT(true)  true_type;\ntypedef _LIBCPP_BOOL_CONSTANT(false) false_type;\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\n// __lazy_and\n\ntemplate <bool _Last, class ..._Preds>\nstruct __lazy_and_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_and_impl<false, _Preds...> : false_type {};\n\ntemplate <>\nstruct __lazy_and_impl<true> : true_type {};\n\ntemplate <class _Pred>\nstruct __lazy_and_impl<true, _Pred> : integral_constant<bool, _Pred::type::value> {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_and_impl<true, _Hp, _Tp...> : __lazy_and_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_or\n\ntemplate <bool _List, class ..._Preds>\nstruct __lazy_or_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_or_impl<true, _Preds...> : true_type {};\n\ntemplate <>\nstruct __lazy_or_impl<false> : false_type {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_or_impl<false, _Hp, _Tp...>\n        : __lazy_or_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_or : __lazy_or_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_not\n\ntemplate <class _Pred>\nstruct __lazy_not : integral_constant<bool, !_Pred::type::value> {};\n\n// __and_\ntemplate<class...> struct __and_;\ntemplate<> struct __and_<> : true_type {};\n\ntemplate<class _B0> struct __and_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __and_<_B0, _B1> : conditional<_B0::value, _B1, _B0>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __and_<_B0, _B1, _B2, _Bn...> \n        : conditional<_B0::value, __and_<_B1, _B2, _Bn...>, _B0>::type {};\n\n// __or_\ntemplate<class...> struct __or_;\ntemplate<> struct __or_<> : false_type {};\n\ntemplate<class _B0> struct __or_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __or_<_B0, _B1> : conditional<_B0::value, _B0, _B1>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __or_<_B0, _B1, _B2, _Bn...> \n        : conditional<_B0::value, _B0, __or_<_B1, _B2, _Bn...> >::type {};\n\n// __not_\ntemplate<class _Tp> \nstruct __not_ : conditional<_Tp::value, false_type, true_type>::type {};\n\n#endif // !defined(_LIBCPP_CXX03_LANG)\n\n// is_const\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const            : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const<_Tp const> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_const_v\n    = is_const<_Tp>::value;\n#endif\n\n// is_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile               : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile<_Tp volatile> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_volatile_v\n    = is_volatile<_Tp>::value;\n#endif\n\n// remove_const\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const            {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const<const _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;\n#endif\n\n// remove_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile               {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile<volatile _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;\n#endif\n\n// remove_cv\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_cv\n{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;\n#endif\n\n// is_void\n\ntemplate <class _Tp> struct __libcpp_is_void       : public false_type {};\ntemplate <>          struct __libcpp_is_void<void> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_void\n    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_void_v\n    = is_void<_Tp>::value;\n#endif\n\n// __is_nullptr_t\n\ntemplate <class _Tp> struct __is_nullptr_t_impl       : public false_type {};\ntemplate <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS __is_nullptr_t\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_null_pointer\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_null_pointer_v\n    = is_null_pointer<_Tp>::value;\n#endif\n#endif\n\n// is_integral\n\ntemplate <class _Tp> struct __libcpp_is_integral                     : public false_type {};\ntemplate <>          struct __libcpp_is_integral<bool>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<signed char>        : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<char16_t>           : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char32_t>           : public true_type {};\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<short>              : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};\ntemplate <>          struct __libcpp_is_integral<int>                : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long long>          : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <>          struct __libcpp_is_integral<__int128_t>         : public true_type {};\ntemplate <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_integral\n    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_integral_v\n    = is_integral<_Tp>::value;\n#endif\n\n// is_floating_point\n\ntemplate <class _Tp> struct __libcpp_is_floating_point              : public false_type {};\ntemplate <>          struct __libcpp_is_floating_point<float>       : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<double>      : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<long double> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_floating_point\n    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_floating_point_v\n    = is_floating_point<_Tp>::value;\n#endif\n\n// is_array\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array\n    : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[]>\n    : public true_type {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[_Np]>\n    : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_array_v\n    = is_array<_Tp>::value;\n#endif\n\n// is_pointer\n\ntemplate <class _Tp> struct __libcpp_is_pointer       : public false_type {};\ntemplate <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pointer\n    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_pointer_v\n    = is_pointer<_Tp>::value;\n#endif\n\n// is_reference\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference       : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference<_Tp&> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference        : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference<_Tp&&> : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference        : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&>  : public true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&&> : public true_type {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_reference_v\n    = is_reference<_Tp>::value;\n\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_lvalue_reference_v\n    = is_lvalue_reference<_Tp>::value;\n\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_rvalue_reference_v\n    = is_rvalue_reference<_Tp>::value;\n#endif\n// is_union\n\n#if __has_feature(is_union) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union\n    : public integral_constant<bool, __is_union(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_union : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union\n    : public __libcpp_union<typename remove_cv<_Tp>::type> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_union_v\n    = is_union<_Tp>::value;\n#endif\n\n// is_class\n\n#if __has_feature(is_class) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class\n    : public integral_constant<bool, __is_class(_Tp)> {};\n\n#else\n\nnamespace __is_class_imp\n{\ntemplate <class _Tp> char  __test(int _Tp::*);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class\n    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_class_v\n    = is_class<_Tp>::value;\n#endif\n\n// is_same\n\ntemplate <class _Tp, class _Up> struct _LIBCPP_TEMPLATE_VIS is_same           : public false_type {};\ntemplate <class _Tp>            struct _LIBCPP_TEMPLATE_VIS is_same<_Tp, _Tp> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Up> _LIBCPP_CONSTEXPR bool is_same_v\n    = is_same<_Tp, _Up>::value;\n#endif\n\n// is_function\n\nnamespace __libcpp_is_function_imp\n{\nstruct __dummy_type {};\ntemplate <class _Tp> char  __test(_Tp*);\ntemplate <class _Tp> char __test(__dummy_type);\ntemplate <class _Tp> __two __test(...);\ntemplate <class _Tp> _Tp&  __source(int);\ntemplate <class _Tp> __dummy_type __source(...);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value ||\n                            is_union<_Tp>::value ||\n                            is_void<_Tp>::value  ||\n                            is_reference<_Tp>::value ||\n                            __is_nullptr_t<_Tp>::value >\nstruct __libcpp_is_function\n    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>\n    {};\ntemplate <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_function\n    : public __libcpp_is_function<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_function_v\n    = is_function<_Tp>::value;\n#endif\n\n// is_member_function_pointer\n\n// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};\n// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};\n// \n\ntemplate <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>\nstruct __member_pointer_traits_imp\n{  // forward declaration; specializations later\n};\n\n\ntemplate <class _Tp> struct __libcpp_is_member_function_pointer\n    : public false_type {};\n\ntemplate <class _Ret, class _Class>\nstruct __libcpp_is_member_function_pointer<_Ret _Class::*>\n    : public is_function<_Ret> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_function_pointer\n    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_function_pointer_v\n    = is_member_function_pointer<_Tp>::value;\n#endif\n\n// is_member_pointer\n\ntemplate <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};\ntemplate <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_pointer\n    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_pointer_v\n    = is_member_pointer<_Tp>::value;\n#endif\n\n// is_member_object_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_object_pointer\n    : public integral_constant<bool, is_member_pointer<_Tp>::value &&\n                                    !is_member_function_pointer<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_object_pointer_v\n    = is_member_object_pointer<_Tp>::value;\n#endif\n\n// is_enum\n\n#if __has_feature(is_enum) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum\n    : public integral_constant<bool, __is_enum(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum\n    : public integral_constant<bool, !is_void<_Tp>::value             &&\n                                     !is_integral<_Tp>::value         &&\n                                     !is_floating_point<_Tp>::value   &&\n                                     !is_array<_Tp>::value            &&\n                                     !is_pointer<_Tp>::value          &&\n                                     !is_reference<_Tp>::value        &&\n                                     !is_member_pointer<_Tp>::value   &&\n                                     !is_union<_Tp>::value            &&\n                                     !is_class<_Tp>::value            &&\n                                     !is_function<_Tp>::value         > {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_enum_v\n    = is_enum<_Tp>::value;\n#endif\n\n// is_arithmetic\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_arithmetic\n    : public integral_constant<bool, is_integral<_Tp>::value      ||\n                                     is_floating_point<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_arithmetic_v\n    = is_arithmetic<_Tp>::value;\n#endif\n\n// is_fundamental\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_fundamental\n    : public integral_constant<bool, is_void<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value ||\n                                     is_arithmetic<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_fundamental_v\n    = is_fundamental<_Tp>::value;\n#endif\n\n// is_scalar\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_scalar\n    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||\n                                     is_member_pointer<_Tp>::value ||\n                                     is_pointer<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value    ||\n                                     is_enum<_Tp>::value           > {};\n\ntemplate <> struct _LIBCPP_TEMPLATE_VIS is_scalar<nullptr_t> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_scalar_v\n    = is_scalar<_Tp>::value;\n#endif\n\n// is_object\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_object\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_array<_Tp>::value  ||\n                                     is_union<_Tp>::value  ||\n                                     is_class<_Tp>::value  > {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_object_v\n    = is_object<_Tp>::value;\n#endif\n\n// is_compound\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_compound\n    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_compound_v\n    = is_compound<_Tp>::value;\n#endif\n\n\n// __is_referenceable  [defns.referenceable]\n\nstruct __is_referenceable_impl {\n    template <class _Tp> static _Tp& __test(int);\n    template <class _Tp> static __two __test(...);\n};\n\ntemplate <class _Tp>\nstruct __is_referenceable : integral_constant<bool,\n    !is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};\n\n\n// add_const\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_const<_Tp>::value     >\nstruct __add_const             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_const<_Tp, false> {typedef const _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_const\n    {typedef typename __add_const<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_const_t = typename add_const<_Tp>::type;\n#endif\n\n// add_volatile\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_volatile<_Tp>::value  >\nstruct __add_volatile             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_volatile<_Tp, false> {typedef volatile _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_volatile\n    {typedef typename __add_volatile<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;\n#endif\n\n// add_cv\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_cv\n    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;\n#endif\n\n// remove_reference\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference        {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&>  {typedef _Tp type;};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&&> {typedef _Tp type;};\n#endif\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;\n#endif\n\n// add_lvalue_reference\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl            { typedef _Tp  type; };\ntemplate <class _Tp                                       > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_lvalue_reference\n{typedef typename __add_lvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl            { typedef _Tp   type; };\ntemplate <class _Tp                                       > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_rvalue_reference\n{typedef typename __add_rvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> _Tp&& __declval(int);\ntemplate <class _Tp> _Tp   __declval(long);\n\ntemplate <class _Tp>\ndecltype(_VSTD::__declval<_Tp>(0))\ndeclval() _NOEXCEPT;\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_lvalue_reference<_Tp>::type\ndeclval();\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// __uncvref\n\ntemplate <class _Tp>\nstruct __uncvref  {\n    typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __unconstref {\n    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;\n};\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp>\nusing __uncvref_t = typename __uncvref<_Tp>::type;\n#endif\n\n// __is_same_uncvref\n\ntemplate <class _Tp, class _Up>\nstruct __is_same_uncvref : is_same<typename __uncvref<_Tp>::type,\n                                   typename __uncvref<_Up>::type> {};\n\nstruct __any\n{\n    __any(...);\n};\n\n// remove_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer                      {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp*>                {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const>          {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* volatile>       {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const volatile> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;\n#endif\n\n// add_pointer\n\ntemplate <class _Tp, \n        bool = __is_referenceable<_Tp>::value || \n                is_same<typename remove_cv<_Tp>::type, void>::value>\nstruct __add_pointer_impl\n    {typedef typename remove_reference<_Tp>::type* type;};\ntemplate <class _Tp> struct __add_pointer_impl<_Tp, false> \n    {typedef _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_pointer\n    {typedef typename __add_pointer_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;\n#endif\n\n// is_signed\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_signed_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(-1) < _Tp(0)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_signed : public __libcpp_is_signed<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_signed_v\n    = is_signed<_Tp>::value;\n#endif\n\n// is_unsigned\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_unsigned_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(0) < _Tp(-1)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_unsigned : public __libcpp_is_unsigned<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_unsigned_v\n    = is_unsigned<_Tp>::value;\n#endif\n\n// rank\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[_Np]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR size_t rank_v\n    = rank<_Tp>::value;\n#endif\n\n// extent\n\ntemplate <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TEMPLATE_VIS extent\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], 0>\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], 0>\n    : public integral_constant<size_t, _Np> {};\ntemplate <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, unsigned _Ip = 0> _LIBCPP_CONSTEXPR size_t extent_v\n    = extent<_Tp, _Ip>::value;\n#endif\n\n// remove_extent\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[]>\n    {typedef _Tp type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[_Np]>\n    {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;\n#endif\n\n// remove_all_extents\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[_Np]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;\n#endif\n\n// decay\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS decay\n{\nprivate:\n    typedef typename remove_reference<_Tp>::type _Up;\npublic:\n    typedef typename conditional\n                     <\n                         is_array<_Up>::value,\n                         typename remove_extent<_Up>::type*,\n                         typename conditional\n                         <\n                              is_function<_Up>::value,\n                              typename add_pointer<_Up>::type,\n                              typename remove_cv<_Up>::type\n                         >::type\n                     >::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using decay_t = typename decay<_Tp>::type;\n#endif\n\n// is_abstract\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_abstract\n    : public integral_constant<bool, __is_abstract(_Tp)> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_abstract_v\n    = is_abstract<_Tp>::value;\n#endif\n\n// is_final\n\n#if defined(_LIBCPP_HAS_IS_FINAL)\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\n__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};\n#else\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\n__libcpp_is_final : public false_type {};\n#endif\n\n#if defined(_LIBCPP_HAS_IS_FINAL) && _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\nis_final : public integral_constant<bool, __is_final(_Tp)> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_final_v\n    = is_final<_Tp>::value;\n#endif\n\n// is_base_of\n\n#ifdef _LIBCPP_HAS_IS_BASE_OF\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS is_base_of\n    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};\n\n#else  // _LIBCPP_HAS_IS_BASE_OF\n\nnamespace __is_base_of_imp\n{\ntemplate <class _Tp>\nstruct _Dst\n{\n    _Dst(const volatile _Tp &);\n};\ntemplate <class _Tp>\nstruct _Src\n{\n    operator const volatile _Tp &();\n    template <class _Up> operator const _Dst<_Up> &();\n};\ntemplate <size_t> struct __one { typedef char type; };\ntemplate <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);\ntemplate <class _Bp, class _Dp> __two __test(...);\n}\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS is_base_of\n    : public integral_constant<bool, is_class<_Bp>::value &&\n                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};\n\n#endif  // _LIBCPP_HAS_IS_BASE_OF\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Bp, class _Dp> _LIBCPP_CONSTEXPR bool is_base_of_v\n    = is_base_of<_Bp, _Dp>::value;\n#endif\n\n// is_convertible\n\n#if __has_feature(is_convertible_to) && !defined(_LIBCPP_USE_IS_CONVERTIBLE_FALLBACK)\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&\n                                     !is_abstract<_T2>::value> {};\n\n#else  // __has_feature(is_convertible_to)\n\nnamespace __is_convertible_imp\n{\ntemplate <class _Tp> void  __test_convert(_Tp);\n\ntemplate <class _From, class _To, class = void>\nstruct __is_convertible_test : public false_type {};\n\ntemplate <class _From, class _To>\nstruct __is_convertible_test<_From, _To,\n    decltype(_VSTD::__is_convertible_imp::__test_convert<_To>(_VSTD::declval<_From>()))> : public true_type\n{};\n\ntemplate <class _Tp, bool _IsArray =    is_array<_Tp>::value,\n                     bool _IsFunction = is_function<_Tp>::value,\n                     bool _IsVoid =     is_void<_Tp>::value>\n                     struct __is_array_function_or_void                          {enum {value = 0};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};\n}\n\ntemplate <class _Tp,\n    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>\nstruct __is_convertible_check\n{\n    static const size_t __v = 0;\n};\n\ntemplate <class _Tp>\nstruct __is_convertible_check<_Tp, 0>\n{\n    static const size_t __v = sizeof(_Tp);\n};\n\ntemplate <class _T1, class _T2,\n    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,\n    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>\nstruct __is_convertible\n    : public integral_constant<bool,\n        __is_convertible_imp::__is_convertible_test<_T1, _T2>::value\n#if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value\n              && (!is_const<typename remove_reference<_T2>::type>::value\n                  || is_volatile<typename remove_reference<_T2>::type>::value)\n                  && (is_same<typename remove_cv<_T1>::type,\n                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value\n                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))\n#endif\n    >\n{};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible\n    : public __is_convertible<_T1, _T2>\n{\n    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;\n    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;\n};\n\n#endif  // __has_feature(is_convertible_to)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _From, class _To> _LIBCPP_CONSTEXPR bool is_convertible_v\n    = is_convertible<_From, _To>::value;\n#endif\n\n// is_empty\n\n#if __has_feature(is_empty) || (_GNUC_VER >= 407)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_empty\n    : public integral_constant<bool, __is_empty(_Tp)> {};\n\n#else  // __has_feature(is_empty)\n\ntemplate <class _Tp>\nstruct __is_empty1\n    : public _Tp\n{\n    double __lx;\n};\n\nstruct __is_empty2\n{\n    double __lx;\n};\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};\n\ntemplate <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_empty : public __libcpp_empty<_Tp> {};\n\n#endif  // __has_feature(is_empty)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_empty_v\n    = is_empty<_Tp>::value;\n#endif\n\n// is_polymorphic\n\n#if __has_feature(is_polymorphic) || defined(_LIBCPP_COMPILER_MSVC)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_polymorphic\n    : public integral_constant<bool, __is_polymorphic(_Tp)> {};\n\n#else\n\ntemplate<typename _Tp> char &__is_polymorphic_impl(\n    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,\n                       int>::type);\ntemplate<typename _Tp> __two &__is_polymorphic_impl(...);\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_polymorphic\n    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};\n\n#endif // __has_feature(is_polymorphic)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_polymorphic_v\n    = is_polymorphic<_Tp>::value;\n#endif\n\n// has_virtual_destructor\n\n#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor\n    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool has_virtual_destructor_v\n    = has_virtual_destructor<_Tp>::value;\n#endif\n\n// alignment_of\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS alignment_of\n    : public integral_constant<size_t, __alignof__(_Tp)> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR size_t alignment_of_v\n    = alignment_of<_Tp>::value;\n#endif\n\n// aligned_storage\n\ntemplate <class _Hp, class _Tp>\nstruct __type_list\n{\n    typedef _Hp _Head;\n    typedef _Tp _Tail;\n};\n\nstruct __nat\n{\n#ifndef _LIBCPP_CXX03_LANG\n    __nat() = delete;\n    __nat(const __nat&) = delete;\n    __nat& operator=(const __nat&) = delete;\n    ~__nat() = delete;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __align_type\n{\n    static const size_t value = alignment_of<_Tp>::value;\n    typedef _Tp type;\n};\n\nstruct __struct_double {long double __lx;};\nstruct __struct_double4 {double __lx[4];};\n\ntypedef\n    __type_list<__align_type<unsigned char>,\n    __type_list<__align_type<unsigned short>,\n    __type_list<__align_type<unsigned int>,\n    __type_list<__align_type<unsigned long>,\n    __type_list<__align_type<unsigned long long>,\n    __type_list<__align_type<double>,\n    __type_list<__align_type<long double>,\n    __type_list<__align_type<__struct_double>,\n    __type_list<__align_type<__struct_double4>,\n    __type_list<__align_type<int*>,\n    __nat\n    > > > > > > > > > > __all_types;\n\ntemplate <class _TL, size_t _Align> struct __find_pod;\n\ntemplate <class _Hp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, __nat>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             void\n                         >::type type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, _Tp>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             typename __find_pod<_Tp, _Align>::type\n                         >::type type;\n};\n\ntemplate <class _TL, size_t _Len> struct __find_max_align;\n\ntemplate <class _Hp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};\n\ntemplate <size_t _Len, size_t _A1, size_t _A2>\nstruct __select_align\n{\nprivate:\n    static const size_t __min = _A2 < _A1 ? _A2 : _A1;\n    static const size_t __max = _A1 < _A2 ? _A2 : _A1;\npublic:\n    static const size_t value = _Len < __max ? __min : __max;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, _Tp>, _Len>\n    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};\n\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\nstruct _LIBCPP_TEMPLATE_VIS aligned_storage\n{\n    typedef typename __find_pod<__all_types, _Align>::type _Aligner;\n    static_assert(!is_void<_Aligner>::value, \"\");\n    union type\n    {\n        _Aligner __align;\n        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];\n    };\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\n    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;\n#endif\n\n#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \\\ntemplate <size_t _Len>\\\nstruct _LIBCPP_TEMPLATE_VIS aligned_storage<_Len, n>\\\n{\\\n    struct _ALIGNAS(n) type\\\n    {\\\n        unsigned char __lx[(_Len + n - 1)/n * n];\\\n    };\\\n}\n\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);\n// PE/COFF does not support alignment beyond 8192 (=0x2000)\n#if !defined(_LIBCPP_OBJECT_FORMAT_COFF)\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);\n#endif // !defined(_LIBCPP_OBJECT_FORMAT_COFF)\n\n#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// aligned_union\n\ntemplate <size_t _I0, size_t ..._In>\nstruct __static_max;\n\ntemplate <size_t _I0>\nstruct __static_max<_I0>\n{\n    static const size_t value = _I0;\n};\n\ntemplate <size_t _I0, size_t _I1, size_t ..._In>\nstruct __static_max<_I0, _I1, _In...>\n{\n    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :\n                                             __static_max<_I1, _In...>::value;\n};\n\ntemplate <size_t _Len, class _Type0, class ..._Types>\nstruct aligned_union\n{\n    static const size_t alignment_value = __static_max<__alignof__(_Type0),\n                                                       __alignof__(_Types)...>::value;\n    static const size_t __len = __static_max<_Len, sizeof(_Type0),\n                                             sizeof(_Types)...>::value;\n    typedef typename aligned_storage<__len, alignment_value>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __numeric_type\n{\n   static void __test(...);\n   static float __test(float);\n   static double __test(char);\n   static double __test(int);\n   static double __test(unsigned);\n   static double __test(long);\n   static double __test(unsigned long);\n   static double __test(long long);\n   static double __test(unsigned long long);\n   static double __test(double);\n   static long double __test(long double);\n\n   typedef decltype(__test(declval<_Tp>())) type;\n   static const bool value = !is_same<type, void>::value;\n};\n\ntemplate <>\nstruct __numeric_type<void>\n{\n   static const bool value = true;\n};\n\n// __promote\n\ntemplate <class _A1, class _A2 = void, class _A3 = void,\n          bool = __numeric_type<_A1>::value &&\n                 __numeric_type<_A2>::value &&\n                 __numeric_type<_A3>::value>\nclass __promote_imp\n{\npublic:\n    static const bool value = false;\n};\n\ntemplate <class _A1, class _A2, class _A3>\nclass __promote_imp<_A1, _A2, _A3, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\n    typedef typename __promote_imp<_A3>::type __type3;\npublic:\n    typedef decltype(__type1() + __type2() + __type3()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2>\nclass __promote_imp<_A1, _A2, void, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\npublic:\n    typedef decltype(__type1() + __type2()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1>\nclass __promote_imp<_A1, void, void, true>\n{\npublic:\n    typedef typename __numeric_type<_A1>::type type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2 = void, class _A3 = void>\nclass __promote : public __promote_imp<_A1, _A2, _A3> {};\n\n// make_signed / make_unsigned\n\ntypedef\n    __type_list<signed char,\n    __type_list<signed short,\n    __type_list<signed int,\n    __type_list<signed long,\n    __type_list<signed long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__int128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __signed_types;\n\ntypedef\n    __type_list<unsigned char,\n    __type_list<unsigned short,\n    __type_list<unsigned int,\n    __type_list<unsigned long,\n    __type_list<unsigned long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__uint128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __unsigned_types;\n\ntemplate <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, true>\n{\n    typedef _Hp type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, false>\n{\n    typedef typename __find_first<_Tp, _Size>::type type;\n};\n\ntemplate <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,\n                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>\nstruct __apply_cv\n{\n    typedef _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, false>\n{\n    typedef const _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, false, true>\n{\n    typedef volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, true>\n{\n    typedef const volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, false>\n{\n    typedef _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, false>\n{\n    typedef const _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, true>\n{\n    typedef volatile _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, true>\n{\n    typedef const volatile _Up& type;\n};\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_signed {};\n\ntemplate <class _Tp>\nstruct __make_signed<_Tp, true>\n{\n    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_signed<bool,               true> {};\ntemplate <> struct __make_signed<  signed short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<unsigned short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<  signed int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<unsigned int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<  signed long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<unsigned long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<  signed long long, true> {typedef long long type;};\ntemplate <> struct __make_signed<unsigned long long, true> {typedef long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};\ntemplate <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS make_signed\n{\n    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;\n#endif\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_unsigned {};\n\ntemplate <class _Tp>\nstruct __make_unsigned<_Tp, true>\n{\n    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_unsigned<bool,               true> {};\ntemplate <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};\ntemplate <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};\ntemplate <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS make_unsigned\n{\n    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Up = void, class _Vp = void>\nstruct _LIBCPP_TEMPLATE_VIS common_type\n{\npublic:\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp>::type type;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, void, void>\n{\npublic:\n    typedef typename decay<_Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, void>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n      )>::type type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// bullet 1 - sizeof...(Tp) == 0\n\ntemplate <class ..._Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type {};\n\n// bullet 2 - sizeof...(Tp) == 1\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp>\n{\n    typedef typename decay<_Tp>::type type;\n};\n\n// bullet 3 - sizeof...(Tp) == 2\n\ntemplate <class _Tp, class _Up, class = void>\nstruct __common_type2_imp {};\n\ntemplate <class _Tp, class _Up>\nstruct __common_type2_imp<_Tp, _Up,\n    typename __void_t<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type type;\n};\n\ntemplate <class _Tp, class _Up,\n          class _DTp = typename decay<_Tp>::type,\n          class _DUp = typename decay<_Up>::type>\nusing __common_type2 =\n  typename conditional<\n    is_same<_Tp, _DTp>::value && is_same<_Up, _DUp>::value,\n    __common_type2_imp<_Tp, _Up>,\n    common_type<_DTp, _DUp>\n  >::type;\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up>\n    : __common_type2<_Tp, _Up> {};\n\n// bullet 4 - sizeof...(Tp) > 2\n\ntemplate <class ...Tp> struct __common_types;\n\ntemplate <class, class = void>\nstruct __common_type_impl {};\n\ntemplate <class _Tp, class _Up>\nstruct __common_type_impl<\n    __common_types<_Tp, _Up>,\n    typename __void_t<typename common_type<_Tp, _Up>::type>::type>\n{\n  typedef typename common_type<_Tp, _Up>::type type;\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct __common_type_impl<__common_types<_Tp, _Up, _Vp...>,\n    typename __void_t<typename common_type<_Tp, _Up>::type>::type>\n  : __common_type_impl<\n      __common_types<typename common_type<_Tp, _Up>::type, _Vp...> >\n{\n\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, _Vp...>\n    : __common_type_impl<__common_types<_Tp, _Up, _Vp...> > {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_assignable\n\ntemplate<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };\n\ntemplate <class _Tp, class _Arg>\ntypename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type\n__is_assignable_test(int);\n\ntemplate <class, class>\nfalse_type __is_assignable_test(...);\n\n\ntemplate <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>\nstruct __is_assignable_imp\n    : public decltype((_VSTD::__is_assignable_test<_Tp, _Arg>(0))) {};\n\ntemplate <class _Tp, class _Arg>\nstruct __is_assignable_imp<_Tp, _Arg, true>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct is_assignable\n    : public __is_assignable_imp<_Tp, _Arg> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_assignable_v\n    = is_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_copy_assignable\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_assignable_v\n    = is_copy_assignable<_Tp>::value;\n#endif\n\n// is_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_move_assignable\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                           typename add_rvalue_reference<_Tp>::type> {};\n#else\n    : public is_copy_assignable<_Tp> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_move_assignable_v\n    = is_move_assignable<_Tp>::value;\n#endif\n\n// is_destructible\n\n//  if it's a reference, return true\n//  if it's a function, return false\n//  if it's   void,     return false\n//  if it's an array of unknown bound, return false\n//  Otherwise, return \"std::declval<_Up&>().~_Up()\" is well-formed\n//    where _Up is remove_all_extents<_Tp>::type\n\ntemplate <class>\nstruct __is_destructible_apply { typedef int type; };\n\ntemplate <typename _Tp>\nstruct __is_destructor_wellformed {\n    template <typename _Tp1>\n    static char  __test (\n        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type\n    );\n\n    template <typename _Tp1>\n    static __two __test (...);\n    \n    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);\n};\n\ntemplate <class _Tp, bool>\nstruct __destructible_imp;\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, false> \n   : public _VSTD::integral_constant<bool, \n        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, true>\n    : public _VSTD::true_type {};\n\ntemplate <class _Tp, bool>\nstruct __destructible_false;\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, true> : public _VSTD::false_type {};\n\ntemplate <class _Tp>\nstruct is_destructible\n    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_destructible<_Tp[]>\n    : public _VSTD::false_type {};\n\ntemplate <>\nstruct is_destructible<void>\n    : public _VSTD::false_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_destructible_v\n    = is_destructible<_Tp>::value;\n#endif\n\n// move\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename remove_reference<_Tp>::type&&\nmove(_Tp&& __t) _NOEXCEPT\n{\n    typedef typename remove_reference<_Tp>::type _Up;\n    return static_cast<_Up&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n_Tp&&\nforward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return static_cast<_Tp&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n_Tp&&\nforward(typename remove_reference<_Tp>::type&& __t) _NOEXCEPT\n{\n    static_assert(!is_lvalue_reference<_Tp>::value,\n                  \"can not forward an rvalue as an lvalue\");\n    return static_cast<_Tp&&>(__t);\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nmove(_Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmove(const _Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nforward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return __t;\n}\n\n\ntemplate <class _Tp>\nclass __rv\n{\n    typedef typename remove_reference<_Tp>::type _Trr;\n    _Trr& t_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Trr* operator->() {return &t_;}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __rv(_Trr& __t) : t_(__t) {}\n};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(_Tp&& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(const _Tp& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#endif\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#if __has_feature(cxx_reference_qualified_functions) || \\\n    (defined(_GNUC_VER) && _GNUC_VER >= 409)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#endif  // __has_feature(cxx_reference_qualified_functions) || _GNUC_VER >= 409\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp _Class::*, false, true>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _MP>\nstruct __member_pointer_traits\n    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,\n                    is_member_function_pointer<_MP>::value,\n                    is_member_object_pointer<_MP>::value>\n{\n//     typedef ... _ClassType;\n//     typedef ... _ReturnType;\n//     typedef ... _FnType;\n};\n\n\ntemplate <class _DecayedFp>\nstruct __member_pointer_class_type {};\n\ntemplate <class _Ret, class _ClassType>\nstruct __member_pointer_class_type<_Ret _ClassType::*> {\n  typedef _ClassType type;\n};\n\n// result_of\n\ntemplate <class _Callable> class result_of;\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Fn, bool, bool>\nclass __result_of\n{\n};\n\ntemplate <class _Fn>\nclass __result_of<_Fn(), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()()) type;\n};\n\ntemplate <class _Fn, class _A0>\nclass __result_of<_Fn(_A0), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass __result_of<_Fn(_A0, _A1), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_A0, _A1, _A2), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;\n};\n\ntemplate <class _MP, class _Tp, bool _IsMemberFunctionPtr>\nstruct __result_of_mp;\n\n// member function pointer\n\ntemplate <class _MP, class _Tp>\nstruct __result_of_mp<_MP, _Tp, true>\n    : public __identity<typename __member_pointer_traits<_MP>::_ReturnType>\n{\n};\n\n// member data pointer\n\ntemplate <class _MP, class _Tp, bool>\nstruct __result_of_mdp;\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, false>\n{\n    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, true>\n{\n    typedef typename __apply_cv<_Tp, _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mp<_Rp _Class::*, _Tp, false>\n    : public __result_of_mdp<_Rp _Class::*, _Tp,\n            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>\n{\n};\n\n\n\ntemplate <class _Fn, class _Tp>\nclass __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0>\nclass __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1>\nclass __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\n// result_of\n\ntemplate <class _Fn>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn()>\n    : public __result_of<_Fn(),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0)>\n    : public __result_of<_Fn(_A0),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1)>\n    : public __result_of<_Fn(_A0, _A1),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1, _A2)>\n    : public __result_of<_Fn(_A0, _A1, _A2),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T, class... Args> struct is_constructible;\n\nnamespace __is_construct\n{\nstruct __nat {};\n}\n\n#if !defined(_LIBCPP_CXX03_LANG) && (!__has_feature(is_constructible) || \\\n    defined(_LIBCPP_TESTING_FALLBACK_IS_CONSTRUCTIBLE))\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_constructible;\n\ntemplate <class _To, class _From>\nstruct __is_invalid_base_to_derived_cast {\n  static_assert(is_reference<_To>::value, \"Wrong specialization\");\n  using _RawFrom = __uncvref_t<_From>;\n  using _RawTo = __uncvref_t<_To>;\n  static const bool value = __lazy_and<\n        __lazy_not<is_same<_RawFrom, _RawTo>>,\n        is_base_of<_RawFrom, _RawTo>,\n        __lazy_not<__libcpp_is_constructible<_RawTo, _From>>\n  >::value;\n};\n\ntemplate <class _To, class _From>\nstruct __is_invalid_lvalue_to_rvalue_cast : false_type {\n  static_assert(is_reference<_To>::value, \"Wrong specialization\");\n};\n\ntemplate <class _ToRef, class _FromRef>\nstruct __is_invalid_lvalue_to_rvalue_cast<_ToRef&&, _FromRef&> {\n  using _RawFrom = __uncvref_t<_FromRef>;\n  using _RawTo = __uncvref_t<_ToRef>;\n  static const bool value = __lazy_and<\n      __lazy_not<is_function<_RawTo>>,\n      __lazy_or<\n        is_same<_RawFrom, _RawTo>,\n        is_base_of<_RawTo, _RawFrom>>\n    >::value;\n};\n\nstruct __is_constructible_helper\n{\n    template <class _To>\n    static void __eat(_To);\n\n    // This overload is needed to work around a Clang bug that disallows\n    // static_cast<T&&>(e) for non-reference-compatible types.\n    // Example: static_cast<int&&>(declval<double>());\n    // NOTE: The static_cast implementation below is required to support\n    //  classes with explicit conversion operators.\n    template <class _To, class _From,\n              class = decltype(__eat<_To>(_VSTD::declval<_From>()))>\n    static true_type __test_cast(int);\n\n    template <class _To, class _From,\n              class = decltype(static_cast<_To>(_VSTD::declval<_From>()))>\n    static integral_constant<bool,\n        !__is_invalid_base_to_derived_cast<_To, _From>::value &&\n        !__is_invalid_lvalue_to_rvalue_cast<_To, _From>::value\n    > __test_cast(long);\n\n    template <class, class>\n    static false_type __test_cast(...);\n\n    template <class _Tp, class ..._Args,\n        class = decltype(_Tp(_VSTD::declval<_Args>()...))>\n    static true_type __test_nary(int);\n    template <class _Tp, class...>\n    static false_type __test_nary(...);\n\n    template <class _Tp, class _A0, class = decltype(::new _Tp(_VSTD::declval<_A0>()))>\n    static is_destructible<_Tp> __test_unary(int);\n    template <class, class>\n    static false_type __test_unary(...);\n};\n\ntemplate <class _Tp, bool = is_void<_Tp>::value>\nstruct __is_default_constructible\n    : decltype(__is_constructible_helper::__test_nary<_Tp>(0))\n{};\n\ntemplate <class _Tp>\nstruct __is_default_constructible<_Tp, true> : false_type {};\n\ntemplate <class _Tp>\nstruct __is_default_constructible<_Tp[], false> : false_type {};\n\ntemplate <class _Tp, size_t _Nx>\nstruct __is_default_constructible<_Tp[_Nx], false>\n    : __is_default_constructible<typename remove_all_extents<_Tp>::type>  {};\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_constructible\n{\n  static_assert(sizeof...(_Args) > 1, \"Wrong specialization\");\n  typedef decltype(__is_constructible_helper::__test_nary<_Tp, _Args...>(0))\n      type;\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_constructible<_Tp> : __is_default_constructible<_Tp> {};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp, _A0>\n    : public decltype(__is_constructible_helper::__test_unary<_Tp, _A0>(0))\n{};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp&, _A0>\n    : public decltype(__is_constructible_helper::\n    __test_cast<_Tp&, _A0>(0))\n{};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp&&, _A0>\n    : public decltype(__is_constructible_helper::\n    __test_cast<_Tp&&, _A0>(0))\n{};\n\n#endif\n\n#if __has_feature(is_constructible)\ntemplate <class _Tp, class ..._Args>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>\n    {};\n#elif !defined(_LIBCPP_CXX03_LANG)\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public __libcpp_is_constructible<_Tp, _Args...>::type {};\n#else\n// template <class T> struct is_constructible0;\n\n//      main is_constructible0 test\n\ntemplate <class _Tp>\ndecltype((_Tp(), true_type()))\n__is_constructible0_test(_Tp&);\n\nfalse_type\n__is_constructible0_test(__any);\n\ntemplate <class _Tp, class _A0>\ndecltype((_Tp(_VSTD::declval<_A0>()), true_type()))\n__is_constructible1_test(_Tp&, _A0&);\n\ntemplate <class _A0>\nfalse_type\n__is_constructible1_test(__any, _A0&);\n\ntemplate <class _Tp, class _A0, class _A1>\ndecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))\n__is_constructible2_test(_Tp&, _A0&, _A1&);\n\ntemplate <class _A0, class _A1>\nfalse_type\n__is_constructible2_test(__any, _A0&, _A1&);\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible0_test(declval<_Tp&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))\n             >::type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __is_constructible0_imp<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_imp<true, _Tp, _A0>\n    : public is_convertible<_A0, _Tp>\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_void_check\n    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp>\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_void_check\n    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0>\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check\n    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0, _A1>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp>\nstruct __is_constructible0_void_check<true, _Tp>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_void_check<true, _Tp, _A0>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public __is_constructible2_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value\n                                        || is_void<_A1>::value,\n                                           _Tp, _A0, _A1>\n    {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>\n    : public __is_constructible0_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value,\n                                           _Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, _A0, __is_construct::__nat>\n    : public __is_constructible1_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value,\n                                           _Tp, _A0>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __is_constructible0_imp<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0>\nstruct __is_constructible1_imp<false, _Ap[_Np], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap>\nstruct __is_constructible0_imp<false, _Ap[]>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0>\nstruct __is_constructible1_imp<false, _Ap[], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[], _A0, _A1>\n    : public false_type\n    {};\n\n#endif // __has_feature(is_constructible)\n\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_constructible_v\n    = is_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_default_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_default_constructible\n    : public is_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_default_constructible_v\n    = is_default_constructible<_Tp>::value;\n#endif\n\n// is_copy_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_copy_constructible\n    : public is_constructible<_Tp, \n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_constructible_v\n    = is_copy_constructible<_Tp>::value;\n#endif\n\n// is_move_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_move_constructible_v\n    = is_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_constructible\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp>\n#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_trivial_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp>\n#endif\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : false_type\n{\n};\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class... _Args> _LIBCPP_CONSTEXPR bool is_trivially_constructible_v\n    = is_trivially_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_trivially_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_default_constructible\n    : public is_trivially_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_default_constructible_v\n    = is_trivially_default_constructible<_Tp>::value;\n#endif\n\n// is_trivially_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_constructible\n    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_constructible_v\n    = is_trivially_copy_constructible<_Tp>::value;\n#endif\n\n// is_trivially_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_trivially_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_constructible_v\n    = is_trivially_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_assignable\n\n#if __has_feature(is_trivially_assignable) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>\n{\n};\n\n#else  // !__has_feature(is_trivially_assignable)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // !__has_feature(is_trivially_assignable)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_trivially_assignable_v\n    = is_trivially_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_trivially_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_assignable_v\n    = is_trivially_copy_assignable<_Tp>::value;\n#endif\n\n// is_trivially_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_assignable_v\n    = is_trivially_move_assignable<_Tp>::value;\n#endif\n\n// is_trivially_destructible\n\n#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible\n    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_trivial_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible\n    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_destructible_v\n    = is_trivially_destructible<_Tp>::value;\n#endif\n\n// is_nothrow_constructible\n\n#if 0\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))>\n{\n};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/false, _Tp, _Args...>\n    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>\n{\n};\n\ntemplate <class _Tp>\nvoid __implicit_conversion_to(_Tp) noexcept { }\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(declval<_Arg>()))>\n{\n};\n\ntemplate <class _Tp, bool _IsReference, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/false, _IsReference, _Tp, _Args...>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp[_Ns]>\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp>\n#endif\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_nothrow_constructible)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_nothrow_constructible_v\n    = is_nothrow_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_nothrow_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_default_constructible\n    : public is_nothrow_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_default_constructible_v\n    = is_nothrow_default_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_constructible\n    : public is_nothrow_constructible<_Tp,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_constructible_v\n    = is_nothrow_copy_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_nothrow_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_constructible_v\n    = is_nothrow_move_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_assignable\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable\n    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, const _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_nothrow_assignable<_Tp&, _Tp&&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // __has_feature(cxx_noexcept)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_nothrow_assignable_v\n    = is_nothrow_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_nothrow_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_assignable_v\n    = is_nothrow_copy_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_assignable_v\n    = is_nothrow_move_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_destructible\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp> struct __libcpp_is_nothrow_destructible;\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<true, _Tp>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible\n    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[_Ns]>\n    : public is_nothrow_destructible<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&>\n    : public true_type\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&&>\n    : public true_type\n{\n};\n\n#endif\n\n#else\n\ntemplate <class _Tp> struct __libcpp_nothrow_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible\n    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_destructible_v\n    = is_nothrow_destructible<_Tp>::value;\n#endif\n\n// is_pod\n\n#if __has_feature(is_pod) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod\n    : public integral_constant<bool, __is_pod(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod\n    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&\n                                     is_trivially_copy_constructible<_Tp>::value      &&\n                                     is_trivially_copy_assignable<_Tp>::value    &&\n                                     is_trivially_destructible<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_pod_v\n    = is_pod<_Tp>::value;\n#endif\n\n// is_literal_type;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_literal_type\n#ifdef _LIBCPP_IS_LITERAL\n    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||\n                              is_reference<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_literal_type_v\n    = is_literal_type<_Tp>::value;\n#endif\n\n// is_standard_layout;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_standard_layout\n#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)\n    : public integral_constant<bool, __is_standard_layout(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_standard_layout_v\n    = is_standard_layout<_Tp>::value;\n#endif\n\n// is_trivially_copyable;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copyable\n#if __has_feature(is_trivially_copyable)\n    : public integral_constant<bool, __is_trivially_copyable(_Tp)>\n#elif _GNUC_VER >= 501\n    : public integral_constant<bool, !is_volatile<_Tp>::value && __is_trivially_copyable(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copyable_v\n    = is_trivially_copyable<_Tp>::value;\n#endif\n\n// is_trivial;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivial\n#if __has_feature(is_trivial) || _GNUC_VER >= 407\n    : public integral_constant<bool, __is_trivial(_Tp)>\n#else\n    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&\n                                 is_trivially_default_constructible<_Tp>::value>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivial_v\n    = is_trivial<_Tp>::value;\n#endif\n\ntemplate <class _Tp> struct __is_reference_wrapper_impl : public false_type {};\ntemplate <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};\ntemplate <class _Tp> struct __is_reference_wrapper\n    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};\n\n#ifndef _LIBCPP_CXX03_LANG\n\n// Check for complete types\n\ntemplate <class ..._Tp> struct __check_complete;\n\ntemplate <>\nstruct __check_complete<>\n{\n};\n\ntemplate <class _Hp, class _T0, class ..._Tp>\nstruct __check_complete<_Hp, _T0, _Tp...>\n    : private __check_complete<_Hp>,\n      private __check_complete<_T0, _Tp...>\n{\n};\n\ntemplate <class _Hp>\nstruct __check_complete<_Hp, _Hp>\n    : private __check_complete<_Hp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp>\n{\n    static_assert(sizeof(_Tp) > 0, \"Type must be complete.\");\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (*)(_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (*)(_Param...)>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (_Param...)>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...)>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class>\nstruct __check_complete<_Rp _Class::*>\n    : private __check_complete<_Class>\n{\n};\n\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet1 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet2 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet3 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet4 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet5 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet6 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\n// __invoke forward declarations\n\n// fall back - none of the bullets\n\n#define _LIBCPP_INVOKE_RETURN(...) \\\n    noexcept(noexcept(__VA_ARGS__)) -> decltype(__VA_ARGS__) \\\n    { return __VA_ARGS__; }\n\ntemplate <class ..._Args>\nauto __invoke(__any, _Args&& ...__args) -> __nat;\n\ntemplate <class ..._Args>\nauto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;\n\n// bullets 1, 2 and 3\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\n// bullets 4, 5 and 6\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\n// bullet 7\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\n#undef _LIBCPP_INVOKE_RETURN\n\n// __invokable\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __invokable_r\n    : private __check_complete<_Fp>\n{\n    using _Result = decltype(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n\n    static const bool value =\n        conditional<\n            !is_same<_Result, __nat>::value,\n            typename conditional<\n                is_void<_Ret>::value,\n                true_type,\n                is_convertible<_Result, _Ret>\n            >::type,\n            false_type\n        >::type::value;\n};\n\ntemplate <class _Fp, class ..._Args>\nusing __invokable = __invokable_r<void, _Fp, _Args...>;\n\ntemplate <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp {\n  static const bool value = false;\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>\n{\n    typedef __nothrow_invokable_r_imp _ThisT;\n\n    template <class _Tp>\n    static void __test_noexcept(_Tp) noexcept;\n\n    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>\n{\n    static const bool value = noexcept(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nusing __nothrow_invokable_r =\n    __nothrow_invokable_r_imp<\n            __invokable_r<_Ret, _Fp, _Args...>::value,\n            is_void<_Ret>::value,\n            _Ret, _Fp, _Args...\n    >;\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of\n    : public enable_if<\n        __invokable<_Fp, _Args...>::value,\n        typename __invokable_r<void, _Fp, _Args...>::_Result>\n{\n};\n\n// result_of\n\ntemplate <class _Fp, class ..._Args>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fp(_Args...)>\n    : public __invoke_of<_Fp, _Args...>\n{\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using result_of_t = typename result_of<_Tp>::type;\n#endif\n\n#if _LIBCPP_STD_VER > 14\n\n// is_callable\n\ntemplate <class _Fn, class _Ret = void>\nstruct _LIBCPP_TEMPLATE_VIS is_callable;\n\ntemplate <class _Fn, class ..._Args, class _Ret>\nstruct _LIBCPP_TEMPLATE_VIS is_callable<_Fn(_Args...), _Ret>\n    : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};\n\ntemplate <class _Fn, class _Ret = void>\nconstexpr bool is_callable_v = is_callable<_Fn, _Ret>::value;\n\n// is_nothrow_callable\n\ntemplate <class _Fn, class _Ret = void>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_callable;\n\ntemplate <class _Fn, class ..._Args, class _Ret>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_callable<_Fn(_Args...), _Ret>\n    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value>\n{};\n\ntemplate <class _Fn, class _Ret = void>\nconstexpr bool is_nothrow_callable_v = is_nothrow_callable<_Fn, _Ret>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Tp> struct __is_swappable;\ntemplate <class _Tp> struct __is_nothrow_swappable;\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_CXX03_LANG\ntypename enable_if\n<\n    is_move_constructible<_Tp>::value &&\n    is_move_assignable<_Tp>::value\n>::type\n#else\nvoid\n#endif\nswap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&\n                                    is_nothrow_move_assignable<_Tp>::value)\n{\n    _Tp __t(_VSTD::move(__x));\n    __x = _VSTD::move(__y);\n    __y = _VSTD::move(__t);\n}\n\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Tp>::value\n>::type\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value);\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\niter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))\n               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),\n                                          *_VSTD::declval<_ForwardIterator2>())))\n{\n    swap(*__a, *__b);\n}\n\n// __swappable\n\nnamespace __detail\n{\n// ALL generic swap overloads MUST already have a declaration available at this point.\n\ntemplate <class _Tp, class _Up = _Tp,\n          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>\nstruct __swappable_with\n{\n    template <class _LHS, class _RHS>\n    static decltype(swap(_VSTD::declval<_LHS>(), _VSTD::declval<_RHS>()))\n    __test_swap(int);\n    template <class, class>\n    static __nat __test_swap(long);\n\n    // Extra parens are needed for the C++03 definition of decltype.\n    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;\n    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;\n\n    static const bool value = !is_same<__swap1, __nat>::value\n                           && !is_same<__swap2, __nat>::value;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __swappable_with<_Tp, _Up,  false> : false_type {};\n\ntemplate <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>\nstruct __nothrow_swappable_with {\n  static const bool value =\n#ifndef _LIBCPP_HAS_NO_NOEXCEPT\n      noexcept(swap(_VSTD::declval<_Tp>(), _VSTD::declval<_Up>()))\n  &&  noexcept(swap(_VSTD::declval<_Up>(), _VSTD::declval<_Tp>()));\n#else\n      false;\n#endif\n};\n\ntemplate <class _Tp, class _Up>\nstruct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};\n\n}  // __detail\n\ntemplate <class _Tp>\nstruct __is_swappable\n    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>\n{\n};\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS is_swappable_with\n    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable_with\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_nothrow_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\nconstexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\nconstexpr bool is_swappable_v = is_swappable<_Tp>::value;\n\ntemplate <class _Tp, class _Up>\nconstexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\nconstexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#ifdef _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp>\nstruct underlying_type\n{\n    typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;\n#endif\n\n#else  // _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp, bool _Support = false>\nstruct underlying_type\n{\n    static_assert(_Support, \"The underyling_type trait requires compiler \"\n                            \"support. Either no such support exists or \"\n                            \"libc++ does not know how to use it.\");\n};\n\n#endif // _LIBCPP_UNDERLYING_TYPE\n\n\ntemplate <class _Tp, bool = is_enum<_Tp>::value>\nstruct __sfinae_underlying_type\n{\n    typedef typename underlying_type<_Tp>::type type;\n    typedef decltype(((type)1) + 0) __promoted_type;\n};\n\ntemplate <class _Tp>\nstruct __sfinae_underlying_type<_Tp, false> {};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __convert_to_integral(int __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned __convert_to_integral(unsigned __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong __convert_to_integral(long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long __convert_to_integral(unsigned long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong long __convert_to_integral(long long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long __convert_to_integral(unsigned long long __val) {return __val; }\n\n#ifndef _LIBCPP_HAS_NO_INT128\ninline _LIBCPP_INLINE_VISIBILITY\n__int128_t __convert_to_integral(__int128_t __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\n__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __sfinae_underlying_type<_Tp>::__promoted_type\n__convert_to_integral(_Tp __val) { return __val; }\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_member_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(_VSTD::declval<_Up>().operator&()), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_free_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(operator&(_VSTD::declval<_Up>())), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof\n    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value\n                                  || __has_operator_addressof_free_imp<_Tp>::value>\n{};\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER > 14\n\n#define __cpp_lib_void_t 201411\ntemplate <class...> using void_t = void;\n\n# ifndef _LIBCPP_HAS_NO_VARIADICS\ntemplate <class... _Args>\nstruct conjunction : __and_<_Args...> {};\ntemplate<class... _Args> constexpr bool conjunction_v = conjunction<_Args...>::value;\n\ntemplate <class... _Args>\nstruct disjunction : __or_<_Args...> {};\ntemplate<class... _Args> constexpr bool disjunction_v = disjunction<_Args...>::value;\n\ntemplate <class _Tp>\nstruct negation : __not_<_Tp> {};\ntemplate<class _Tp> constexpr bool negation_v = negation<_Tp>::value;\n# endif // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_STD_VER > 14\n\n// These traits are used in __tree and __hash_table\n#ifndef _LIBCPP_CXX03_LANG\nstruct __extract_key_fail_tag {};\nstruct __extract_key_self_tag {};\nstruct __extract_key_first_tag {};\n\ntemplate <class _ValTy, class _Key,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_key\n    : conditional<is_same<_RawValTy, _Key>::value, __extract_key_self_tag,\n                  __extract_key_fail_tag>::type {};\n\ntemplate <class _Pair, class _Key, class _First, class _Second>\nstruct __can_extract_key<_Pair, _Key, pair<_First, _Second>>\n    : conditional<is_same<typename remove_const<_First>::type, _Key>::value,\n                  __extract_key_first_tag, __extract_key_fail_tag>::type {};\n\n// __can_extract_map_key uses true_type/false_type instead of the tags.\n// It returns true if _Key != _ContainerValueTy (the container is a map not a set)\n// and _ValTy == _Key.\ntemplate <class _ValTy, class _Key, class _ContainerValueTy,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_map_key\n    : integral_constant<bool, is_same<_RawValTy, _Key>::value> {};\n\n// This specialization returns __extract_key_fail_tag for non-map containers\n// because _Key == _ContainerValueTy\ntemplate <class _ValTy, class _Key, class _RawValTy>\nstruct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>\n    : false_type {};\n\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TYPE_TRAITS\n","// -*- C++ -*-\n//===----------------------------- new ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_NEW\n#define _LIBCPP_NEW\n\n/*\n    new synopsis\n\nnamespace std\n{\n\nclass bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() noexcept;\n    bad_alloc(const bad_alloc&) noexcept;\n    bad_alloc& operator=(const bad_alloc&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_array_length : public bad_alloc // FIXME: Not part of C++\n{\npublic:\n    bad_array_length() noexcept;\n};\n\nclass bad_array_new_length : public bad_alloc // C++14\n{\npublic:\n    bad_array_new_length() noexcept;\n};\n\nenum class align_val_t : size_t {}; // C++17\nstruct nothrow_t {};\nextern const nothrow_t nothrow;\ntypedef void (*new_handler)();\nnew_handler set_new_handler(new_handler new_p) noexcept;\nnew_handler get_new_handler() noexcept;\n\n}  // std\n\nvoid* operator new(std::size_t size);                                   // replaceable\nvoid* operator new(std::size_t size, std::align_val_t alignment);       // replaceable, C++17\nvoid* operator new(std::size_t size, const std::nothrow_t&) noexcept;   // replaceable\nvoid* operator new(std::size_t size, std::align_val_t alignment,\n                   const std::nothrow_t&) noexcept;                     // replaceable, C++17\nvoid  operator delete(void* ptr) noexcept;                              // replaceable\nvoid  operator delete(void* ptr, std::size_t size) noexcept;            // replaceable, C++14\nvoid  operator delete(void* ptr, std::align_val_t alignment) noexcept;  // replaceable, C++17\nvoid  operator delete(void* ptr, std::size_t size,\n                      std::align_val_t alignment) noexcept;             // replaceable, C++17\nvoid  operator delete(void* ptr, const std::nothrow_t&) noexcept;       // replaceable\nvoid  operator delete(void* ptr, std:align_val_t alignment,\n                      const std::nothrow_t&) noexcept;                  // replaceable, C++17\n\nvoid* operator new[](std::size_t size);                                 // replaceable\nvoid* operator new[](std::size_t size,\n                     std::align_val_t alignment) noexcept;              // replaceable, C++17\nvoid* operator new[](std::size_t size, const std::nothrow_t&) noexcept; // replaceable\nvoid* operator new[](std::size_t size, std::align_val_t alignment,\n                     const std::nothrow_t&) noexcept;                   // replaceable, C++17\nvoid  operator delete[](void* ptr) noexcept;                            // replaceable\nvoid  operator delete[](void* ptr, std::size_t size) noexcept;          // replaceable, C++14\nvoid  operator delete[](void* ptr,\n                        std::align_val_t alignment) noexcept;           // replaceable, C++17\nvoid  operator delete[](void* ptr, std::size_t size,\n                        std::align_val_t alignment) noexcept;           // replaceable, C++17\nvoid  operator delete[](void* ptr, const std::nothrow_t&) noexcept;     // replaceable\nvoid  operator delete[](void* ptr, std::align_val_t alignment,\n                        const std::nothrow_t&) noexcept;                // replaceable, C++17\n\nvoid* operator new  (std::size_t size, void* ptr) noexcept;\nvoid* operator new[](std::size_t size, void* ptr) noexcept;\nvoid  operator delete  (void* ptr, void*) noexcept;\nvoid  operator delete[](void* ptr, void*) noexcept;\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#if !(defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER >= 14 || \\\n    (defined(__cpp_sized_deallocation) && __cpp_sized_deallocation >= 201309))\n# define _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION) && \\\n    (!(defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER > 14 || \\\n    (defined(__cpp_aligned_new) && __cpp_aligned_new >= 201606)))\n# define _LIBCPP_HAS_NO_ALIGNED_ALLOCATION\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() _NOEXCEPT;\n    virtual ~bad_alloc() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_new_length\n    : public bad_alloc\n{\npublic:\n    bad_array_new_length() _NOEXCEPT;\n    virtual ~bad_array_new_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_bad_alloc();  // not in C++ spec\n\n#if defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_length\n    : public bad_alloc\n{\npublic:\n    bad_array_length() _NOEXCEPT;\n    virtual ~bad_array_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#define _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n\n#endif  // defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\n#if !defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION) || _LIBCPP_STD_VER > 14\n#ifndef _LIBCPP_CXX03_LANG\nenum class _LIBCPP_ENUM_VIS align_val_t : size_t { };\n#else\nenum align_val_t { __zero = 0, __max = (size_t)-1 };\n#endif\n#endif\n\nstruct _LIBCPP_TYPE_VIS nothrow_t {};\nextern _LIBCPP_FUNC_VIS const nothrow_t nothrow;\ntypedef void (*new_handler)();\n_LIBCPP_FUNC_VIS new_handler set_new_handler(new_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS new_handler get_new_handler() _NOEXCEPT;\n\n}  // std\n\n#if defined(_LIBCPP_CXX03_LANG)\n#define _THROW_BAD_ALLOC throw(std::bad_alloc)\n#else\n#define _THROW_BAD_ALLOC\n#endif\n\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_ALIGNED_ALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, std::align_val_t) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::align_val_t) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::align_val_t, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::size_t __sz, std::align_val_t) _NOEXCEPT;\n#endif\n\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, std::align_val_t) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::align_val_t) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::align_val_t, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::size_t __sz, std::align_val_t) _NOEXCEPT;\n#endif\n#endif\n\ninline _LIBCPP_INLINE_VISIBILITY void* operator new  (std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void* operator new[](std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete  (void*, void*) _NOEXCEPT {}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete[](void*, void*) _NOEXCEPT {}\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ninline _LIBCPP_INLINE_VISIBILITY void *__allocate(size_t __size) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  return ::operator new(__size);\n#else\n  return __builtin_operator_new(__size);\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void __libcpp_deallocate(void *__ptr) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  ::operator delete(__ptr);\n#else\n  __builtin_operator_delete(__ptr);\n#endif\n}\n\n#ifdef _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_array_length()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_array_length();\n#else\n\t_VSTD::abort();\n#endif\n}\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_NEW\n","// -*- C++ -*-\n//===--------------------------- iosfwd -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOSFWD\n#define _LIBCPP_IOSFWD\n\n/*\n    iosfwd synopsis\n\nnamespace std\n{\n\ntemplate<class charT> struct char_traits;\ntemplate<class T>     class allocator;\n\nclass ios_base;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ios;\n\ntemplate <class charT, class traits = char_traits<charT> > class basic_streambuf;\ntemplate <class charT, class traits = char_traits<charT> > class basic_istream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ostream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_iostream;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_stringbuf;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_istringstream;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_ostringstream;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_stringstream;\n\ntemplate <class charT, class traits = char_traits<charT> > class basic_filebuf;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ifstream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ofstream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_fstream;\n\ntemplate <class charT, class traits = char_traits<charT> > class istreambuf_iterator;\ntemplate <class charT, class traits = char_traits<charT> > class ostreambuf_iterator;\n\ntypedef basic_ios<char>              ios;\ntypedef basic_ios<wchar_t>           wios;\n\ntypedef basic_streambuf<char>        streambuf;\ntypedef basic_istream<char>          istream;\ntypedef basic_ostream<char>          ostream;\ntypedef basic_iostream<char>         iostream;\n\ntypedef basic_stringbuf<char>        stringbuf;\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_stringstream<char>     stringstream;\n\ntypedef basic_filebuf<char>          filebuf;\ntypedef basic_ifstream<char>         ifstream;\ntypedef basic_ofstream<char>         ofstream;\ntypedef basic_fstream<char>          fstream;\n\ntypedef basic_streambuf<wchar_t>     wstreambuf;\ntypedef basic_istream<wchar_t>       wistream;\ntypedef basic_ostream<wchar_t>       wostream;\ntypedef basic_iostream<wchar_t>      wiostream;\n\ntypedef basic_stringbuf<wchar_t>     wstringbuf;\ntypedef basic_istringstream<wchar_t> wistringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\ntypedef basic_stringstream<wchar_t>  wstringstream;\n\ntypedef basic_filebuf<wchar_t>       wfilebuf;\ntypedef basic_ifstream<wchar_t>      wifstream;\ntypedef basic_ofstream<wchar_t>      wofstream;\ntypedef basic_fstream<wchar_t>       wfstream;\n\ntemplate <class state> class fpos;\ntypedef fpos<char_traits<char>::state_type>    streampos;\ntypedef fpos<char_traits<wchar_t>::state_type> wstreampos;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <wchar.h>  // for mbstate_t\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_TYPE_VIS ios_base;\n\ntemplate<class _CharT>  struct _LIBCPP_TEMPLATE_VIS char_traits;\ntemplate<class _Tp>     class _LIBCPP_TEMPLATE_VIS allocator;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_ios;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_streambuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_istream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_ostream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_iostream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_stringbuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_istringstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_ostringstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_stringstream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_filebuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_ifstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_ofstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_fstream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS istreambuf_iterator;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS ostreambuf_iterator;\n\ntypedef basic_ios<char>              ios;\ntypedef basic_ios<wchar_t>           wios;\n\ntypedef basic_streambuf<char>        streambuf;\ntypedef basic_istream<char>          istream;\ntypedef basic_ostream<char>          ostream;\ntypedef basic_iostream<char>         iostream;\n\ntypedef basic_stringbuf<char>        stringbuf;\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_stringstream<char>     stringstream;\n\ntypedef basic_filebuf<char>          filebuf;\ntypedef basic_ifstream<char>         ifstream;\ntypedef basic_ofstream<char>         ofstream;\ntypedef basic_fstream<char>          fstream;\n\ntypedef basic_streambuf<wchar_t>     wstreambuf;\ntypedef basic_istream<wchar_t>       wistream;\ntypedef basic_ostream<wchar_t>       wostream;\ntypedef basic_iostream<wchar_t>      wiostream;\n\ntypedef basic_stringbuf<wchar_t>     wstringbuf;\ntypedef basic_istringstream<wchar_t> wistringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\ntypedef basic_stringstream<wchar_t>  wstringstream;\n\ntypedef basic_filebuf<wchar_t>       wfilebuf;\ntypedef basic_ifstream<wchar_t>      wifstream;\ntypedef basic_ofstream<wchar_t>      wofstream;\ntypedef basic_fstream<wchar_t>       wfstream;\n\ntemplate <class _State>             class _LIBCPP_TEMPLATE_VIS fpos;\ntypedef fpos<mbstate_t>    streampos;\ntypedef fpos<mbstate_t>    wstreampos;\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntypedef fpos<mbstate_t>    u16streampos;\ntypedef fpos<mbstate_t>    u32streampos;\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n#if defined(_NEWLIB_VERSION)\n// On newlib, off_t is 'long int'\ntypedef long int streamoff;         // for char_traits in <string>\n#else\ntypedef long long streamoff;        // for char_traits in <string>\n#endif\n\ntemplate <class _CharT,             // for <stdexcept>\n          class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TEMPLATE_VIS basic_string;\ntypedef basic_string<char, char_traits<char>, allocator<char> > string;\ntypedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;\n\n\n// Include other forward declarations here\ntemplate <class _Tp, class _Alloc = allocator<_Tp> >\nclass _LIBCPP_TEMPLATE_VIS vector;\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOSFWD\n","#pragma once\r\n\r\n\r\n\r\n\r\ntypedef Vec2 vec2f; // TODO: math lib\r\n\r\nnamespace engine\r\n{\r\n\tclass  SpriteRenderer;\r\n\tstruct Resources;\r\n\tstruct InputData;\r\n}\r\n\r\nstruct game_memory;\r\nstruct RenderData;\r\nstruct Layer;\r\nstruct LogBuffer;\r\n\r\nenum CurrentGame\r\n{\r\n\tGame_unknown,\r\n\tGame_tetris,\r\n\tGame_aoe160k,\r\n\tGame_jam_game,\r\n\tGame_max,\r\n};\r\n\r\n\r\ntypedef size_t memory_index;\r\nintrospect() struct memory_arena\r\n{\r\n\tmemory_index    size;\r\n\tuint8_t        *base;\r\n\tmemory_index    used;\r\n\r\n\r\n\tignore void InitalizeArena(memory_index size, uint8_t *base);\r\n\tignore void Reset();\r\n};\r\n\r\n// loop niin kauan kuin koko ^^\r\nvoid memory_arena::InitalizeArena(memory_index size, uint8_t *base)\r\n{\r\n\tthis->size = size;\r\n\tthis->base = base;\r\n\tthis->used = 0;\r\n}\r\n\r\nvoid memory_arena::Reset()\r\n{\r\n\tthis->used = 0;\r\n}\r\n\r\nnamespace maths\r\n{\r\n\tstatic inline bool isInsideRect(vec4* rect, vec4* position)\r\n\t{\r\n\t\treturn\r\n\t\t\t(rect->x < position->x && (rect->x + rect->w) > position->x &&\r\n\t\t\t\trect->y < position->y && (rect->y + rect->h) > position->y);\r\n\t}\r\n\r\n\tstatic inline bool isInsideRect(vec4* rect, vec2f* position)\r\n\t{\r\n\t\treturn\r\n\t\t\t(rect->x < position->x && (rect->x + rect->w) > position->x &&\r\n\t\t\t\trect->y < position->y && (rect->y + rect->h) > position->y);\r\n\t}\r\n}\r\n\r\nnamespace graphics\r\n{\r\n\tvoid drawPoint(Vertex** points, Vec2& pos)\r\n\t{\r\n\t\tda_push(*points, pos);\r\n\t}\r\n\r\n\tvoid drawLine(Vertex** lines, Vec2* pos0, Vec2* pos1)\r\n\t{\r\n\t\tda_push(*lines, *pos0);\r\n\t\tda_push(*lines, *pos1);\r\n\t}\r\n\r\n\tvoid drawBox(Vertex** lines, Vec2* pos, Vec2* size)\r\n\t{\r\n\t\tVec2 xw{ pos->x + size->x, pos->y };\r\n\t\tVec2 yh{ pos->x, pos->y + pos->y };\r\n\t\tVec2 xwyh{ pos->x + size->x, pos->y + size->y };\r\n\r\n\t\tdrawLine(lines, pos, &xw);\r\n\t\tdrawLine(lines, pos, &yh);\r\n\t\tdrawLine(lines, &xw, &xwyh);\r\n\t\tdrawLine(lines, &yh, &xwyh);\r\n\t}\r\n\r\n\tvoid drawBox(Vertex** lines, vec4* ps)\r\n\t{\r\n\t\tVec2 xw{ ps->x + ps->w, ps->y };\r\n\t\tVec2 yh{ ps->x, ps->y + ps->h };\r\n\t\tVec2 xwyh{ ps->x + ps->w, ps->y + ps->h };\r\n\t\tVec2 xy{ ps->x, ps->y };\r\n\r\n\t\tdrawLine(lines, &xy, &xw);\r\n\t\tdrawLine(lines, &xy, &yh);\r\n\t\tdrawLine(lines, &xw, &xwyh);\r\n\t\tdrawLine(lines, &yh, &xwyh);\r\n\t}\r\n\r\n\tvoid drawBox(Vertex** lines, vec4& ps)\r\n\t{\r\n\t\tdrawBox(lines, &ps);\r\n\t}\r\n\r\n\r\n\r\n\t// TODO: implement insertin large array to da_array or own implementatino\r\n\t// TODO: RESERVE\r\n\r\n\tstatic Vec2* circlePrefab = 0;\r\n\tvoid setCircle(Vertex** lines, const Vec2& center, float radius)\r\n\t{\r\n\t\tstatic const int NUM_VERTS = 100;\r\n\r\n\t\t//set up verticles\r\n\t\t// int start = m_verts.size();\r\n\r\n\t\t// m_verts.resize(m_verts.size() + NUM_VERTS);\r\n\r\n\t\t// LOLOLOLOLOL\r\n#define PI 3.141592f\r\n\t\tfloat x = cosf(0) * radius + center.x;\r\n\t\tfloat y = sinf(0) * radius + center.y;\r\n\t\tVec2 last{ x, y };\r\n\r\n\t\t// da_push(*lines, last);\r\n\r\n\t\tfor (int i = 0; i < NUM_VERTS; i++)\r\n\t\t{\r\n\t\t\tfloat angle = ((float)i / NUM_VERTS) * PI * 2.0f;\r\n#if 0\r\n\t\t\tm_verts[start + i].position.x = cos(angle) * radius + center.x;\r\n\t\t\tm_verts[start + i].position.y = sin(angle) * radius + center.y;\r\n#else\r\n\t\t\tfloat x = cos(angle) * radius + center.x;\r\n\t\t\tfloat y = sin(angle) * radius + center.y;\r\n\t\t\tVec2 pos{ x, y };\r\n\t\t\tda_push(*lines, pos);\r\n\t\t\tda_push(*lines, last);\r\n\t\t\tlast.x = x;\r\n\t\t\tlast.y = y;\r\n#endif\r\n\t\t\t// m_verts[start + i].color = color;\r\n\t\t}\r\n\t\tVec2 pos = { x, y };\r\n\t\tda_push(*lines, pos);\r\n\t\tda_push(*lines, last);\r\n\r\n\t\t// float x = cos(0) * radius + center.x;\r\n\t\t// float y = sin(0) * radius + center.y;\r\n\r\n\r\n\r\n\t\t// Set up indices for indexed drawing\r\n//\t\tm_indices.reserve(m_indices.size() + NUM_VERTS * 2);\r\n//\t\tfor (int i = 0; i < NUM_VERTS - 1; i++)\r\n//\t\t{\r\n//\t\t\tm_indices.push_back(start + i);\r\n//\t\t\tm_indices.push_back(start + i + 1);\r\n//\t\t}\r\n\r\n//\t\tm_indices.push_back(start + NUM_VERTS - 1);\r\n//\t\tm_indices.push_back(start);\r\n\t}\r\n\r\n\t//void drawCircle(const Vec2& center, float radius)\r\n\t//{\r\n\t//\tstatic const int NUM_VERTS = 100;\r\n\t//\t//set up verticles\r\n\t//\tint start = m_verts.size();\r\n\r\n\t//\tm_verts.resize(m_verts.size() + NUM_VERTS);\r\n\r\n\t//\tfor (int i = 0; i < NUM_VERTS; i++)\r\n\t//\t{\r\n\t//\t\tfloat angle = ((float)i / NUM_VERTS) * PI * 2.0f;\r\n\t//\t\tm_verts[start + i].position.x = cos(angle) * radius + center.x;\r\n\t//\t\tm_verts[start + i].position.y = sin(angle) * radius + center.y;\r\n\t//\t\tm_verts[start + i].color = color;\r\n\t//\t}\r\n\r\n\t//\t// Set up indices for indexed drawing\r\n\t//\tm_indices.reserve(m_indices.size() + NUM_VERTS * 2);\r\n\t//\tfor (int i = 0; i < NUM_VERTS - 1; i++)\r\n\t//\t{\r\n\t//\t\tm_indices.push_back(start + i);\r\n\t//\t\tm_indices.push_back(start + i + 1);\r\n\t//\t}\r\n\t//\tm_indices.push_back(start + NUM_VERTS - 1);\r\n\t//\tm_indices.push_back(start);\r\n\t//}\r\n}\r\n\r\n// #include \"../src/ResourceManager.cpp\"\r\nconstexpr CurrentGame defaultGame = Game_jam_game;\r\n\r\n\r\n\r\n\r\n\r\nstruct EngineCore\r\n{\r\n\tLayer* layers;\r\n\tint layerCount = 0;\r\n\r\n\tRenderData* renderData;\r\n\tengine::Resources*      resources;\r\n\tengine::InputData*      inputData;\r\n\tgame_memory* memory;\r\n\tmemory_arena* arena;\r\n\r\n\t///\r\n\tVertex** lines;\r\n\tVertex** points;\r\n\t///\r\n\r\n\tfloat currentTime = 0.f;\r\n\tint   currentFrame = 0;\r\n\tint   runToFrame = 0;\r\n\r\n\tbool paused = false;\r\n\tbool setUpContexts = false;\r\n\r\n\tbool needReset = false;\r\n\r\n\tLogBuffer* log;\r\n\r\n\tvoid* imguiContext;\r\n\r\n\tCurrentGame currentGame;\r\n\r\n\t// camera/win stuff\r\n\tvec2f screenDimensions;\r\n\r\n\r\n\tvec2f* cameraPosition;\r\n\tfloat* cameraScale;\r\n\tfloat* cameraAngle;\r\n\tbool dirtyCamera;\r\n};\r\n\r\n\r\nnamespace camera\r\n{\r\n\t// lerp zoom\r\n\tstatic inline void setDirtyCamera(EngineCore* core)\r\n\t{\r\n\t\tcore->dirtyCamera = true;\r\n\t}\r\n\r\n\tstatic inline void zoom(EngineCore* core, float zoom)\r\n\t{\r\n\t\t*core->cameraScale += zoom;\r\n\t\tsetDirtyCamera(core);\r\n\t}\r\n\r\n\tstatic inline void moveCamera(EngineCore* core, vec2f& movement)\r\n\t{\r\n\t\t*core->cameraPosition += movement;\r\n\t\tsetDirtyCamera(core);\r\n\t}\r\n\r\n\tstatic inline void setCameraPosition(EngineCore* core, vec2f& position)\r\n\t{\r\n\t\t*core->cameraPosition = position;\r\n\t\tsetDirtyCamera(core);\r\n\t}\r\n\r\n\tstatic inline void setCameraRotaion(EngineCore* core, float angle)\r\n\t{\r\n\t\t*core->cameraAngle = angle;\r\n\t\tsetDirtyCamera(core);\r\n\t}\r\n\t// invery y \r\n\t// make 0, 0 center\r\n\t// scale world\r\n\t// translate camera pos\r\n\tstatic inline vec2f convertScreenToWorld(EngineCore* core, vec2f screenCoords)\r\n\t{\r\n\t\tscreenCoords.y = core->screenDimensions.y - screenCoords.y;\r\n\t\tscreenCoords -= vec2f{ core->screenDimensions.x / 2, core->screenDimensions.y / 2 };\r\n\t\tscreenCoords /= *core->cameraScale;\r\n\t\tscreenCoords += *core->cameraPosition;\r\n\t\treturn screenCoords;\r\n\t}\r\n\r\n\tstatic inline vec4 cameraRect(EngineCore* core)\r\n\t{\r\n\t\tvec2f zero{ 0.f, 0.f };\r\n\t\tvec2f max{ core->screenDimensions.x, core->screenDimensions.y };\r\n\t\tzero = convertScreenToWorld(core, zero);\r\n\t\tmax  = convertScreenToWorld(core, max);\r\n\t\treturn { zero.x, max.y, max.x, zero.y };\r\n\t}\r\n\r\n\r\n\tstatic inline bool cull(vec4* camRect, vec2f& position)\r\n\t{\r\n\t\treturn maths::isInsideRect(camRect, &position);\r\n\t}\r\n}\r\n\r\n// Entiteetit\r\n// fysiikat (collision)\r\n\r\n// Peli, jossa on oikeaasti biljoonia\r\n\r\n// Art: Age of empires \r\n//     * isometric\r\n\r\n// Tavoite:\r\n//\t   * 160 K\r\n\r\n// Fysiikka:\r\n//\tympyr kaikille\r\n// \r\n\r\n// Collisionit: \r\n// Spatial partision:\r\n//\t  * ympyr ympyr vs 1/9 tiilet joissa collision \r\n","/*\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n       SINGLE-HEADER C/++ DYNAMIC ARRAY LIBRARY\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n    DESCRIPTION\r\n\r\n        This library provides functionality that\r\n        allows easy creation/usage of dynamically\r\n        sizing arrays. It follows a similar pattern\r\n        to Sean Barrett's stretchy buffer library.\r\n        It stretches and reallocates memory as needed\r\n        depending on how many objects it needs to\r\n        store.\r\n\r\n        Its only dependency is the CRT.\r\n\r\n    USAGE\r\n\r\n        There are a few notable functions for usual\r\n        usage:\r\n\r\n        * da_size     returns number of elements\r\n\r\n        * da_cap      returns number of elements\r\n                      allowed without reallocation.\r\n                      if this is surpassed, the array\r\n                      will require reallocation of\r\n                      memory.\r\n\r\n        * da_push     pushes an element to the back of\r\n                      the array\r\n\r\n        * da_insert   inserts an element to a position\r\n                      in the array\r\n\r\n        * da_pop      removes the last element of the\r\n                      array\r\n\r\n        * da_erase    removes an element at a specified\r\n                      position in the array\r\n\r\n        * da_clear    resets size to 0. does not free any\r\n                      memory.\r\n\r\n        * da_free     frees all memory associated with\r\n                      an array\r\n\r\n        To declare an array ready to use with these\r\n        functions, simply create a pointer to a type of\r\n        your choice and point it to NULL. Remember to\r\n        call da_free before the pointer goes out of\r\n        scope if you don't want the memory to be\r\n        allocated for the lifetime of the program.\r\n\r\n    EXAMPLE\r\n\r\n        int *int_array = NULL;\r\n        for(int i = 0; i < 100; i++) {\r\n            da_push(int_array, i);\r\n            printf(\"%i\\n\", int_array[i]);\r\n        }\r\n        da_free(int_array);\r\n\r\n    WARNING\r\n\r\n        Memory might be reallocated. Therefore, don't\r\n        expect a pointer to an element to remain\r\n        constant. If you need pointers to elements\r\n        to remain consistent, consider creating an\r\n        array of pointers instead. Consider:\r\n\r\n            int *int_array = NULL,\r\n                *first_element = NULL;\r\n\r\n            for(int i = 0; i < 100; i++) {\r\n                da_push(int_array, i);\r\n                if(!i) first_element = int_array;\r\n            }\r\n\r\n            //first_element probably dangling\r\n\r\n        vs.\r\n\r\n            int **int_array = NULL,\r\n                *first_element = NULL;\r\n\r\n            for(int i = 0; i < 100; i++) {\r\n                int *int_ptr = (int *)malloc(sizeof(int));\r\n                *int_ptr = i;\r\n                da_push(int_array, int_ptr);\r\n                if(!i) first_element = int_ptr;\r\n            }\r\n\r\n            //first_element is not dangling\r\n\r\n        Also, do not try to insert something at a\r\n        position greater than the length of the\r\n        array.\r\n\r\n    LICENSE INFORMATION IS AT THE END OF THE FILE\r\n*/\r\n\r\n#ifndef _DARRAY_H\r\n#define _DARRAY_H\r\n\r\n#include <stdlib.h>\r\n#include <stdint.h>\r\n#include <memory.h>\r\n#include <string.h>\r\n\r\n#define _DARRAY_START_CAP 32\r\n\r\n#define da_raw(a)                       (a ? ((uint32_t *)a) - 2 : NULL)\r\n#define da_size(a)                      (a ? da_raw(a)[0] : 0)\r\n#define da_cap(a)                       (a ? da_raw(a)[1] : 0)\r\n\r\n#define da_push(a, e)                   _da_insert((void **)&a, &e, sizeof(e), da_size(a))\r\n#define da_insert(a, e, i)              _da_insert((void **)&a, &e, sizeof(e), i)\r\n#define da_pop(a)                       if(da_size(a)) { _da_erase((void **)&a, sizeof(a[0]), da_size(a) - 1); }\r\n#define da_erase(a, i)                  if(da_size(a)) { _da_erase((void **)&a, sizeof(a[0]), i); }\r\n\r\n#define da_clear(a)                     { if(da_size(a)) { da_raw(a)[0] = 0; } }\r\n#define da_free(a)                      { if(a) { free(da_raw(a)); a = NULL; } }\r\n\r\ninline void _da_grow(void **array, size_t element_size, uint32_t required_elements) {\r\n    if(da_cap(*array) < required_elements) {\r\n        uint32_t new_cap = da_cap(*array) > _DARRAY_START_CAP ? da_cap(*array) : _DARRAY_START_CAP;\r\n        while(required_elements >= new_cap) {\r\n            new_cap = 3 * (new_cap / 2);\r\n        }\r\n        *array = (void *)((uint32_t *)realloc(da_raw(*array), new_cap*element_size + 2*sizeof(uint32_t)) + 2);\r\n\r\n        *(da_raw(*array) + 1) = new_cap;\r\n    }\r\n}\r\n\r\ninline void _da_insert(void **array, void *element, size_t element_size, uint32_t pos) {\r\n    int8_t array_null = !*array;\r\n\r\n    _da_grow(array, element_size, da_size(*array) + 1);\r\n\r\n    if(array_null) {\r\n        da_raw(*array)[0] = 0;\r\n    }\r\n\r\n    memmove(((uint8_t *)(*array)) + (element_size * (pos + 1)),\r\n            ((uint8_t *)(*array)) + (element_size * pos),\r\n            element_size * (da_size(*array) - pos));\r\n\r\n    memcpy(((uint8_t *)(*array)) + (element_size * pos),\r\n           element, element_size);\r\n\r\n    da_raw(*array)[0]++;\r\n}\r\n\r\ninline void _da_erase(void **array, size_t element_size, uint32_t pos) {\r\n    if(*array) {\r\n        memmove(((uint8_t *)(*array)) + (element_size * pos),\r\n                ((uint8_t *)(*array)) + (element_size * (pos + 1)),\r\n                element_size * (da_size(*array) - pos - 1));\r\n\r\n        da_raw(*array)[0]--;\r\n\r\n        if(da_size(*array) < 1) {\r\n            da_free(*array);\r\n            *array = NULL;\r\n        }\r\n    }\r\n}\r\n\r\n#endif\r\n\r\n/*\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\nMIT License\r\nCopyright (c) 2017 Ryan Fleury\r\n\r\nPermission is hereby granted, free of charge, to any\r\nperson obtaining a copy of this software and associated\r\ndocumentation files (the \"Software\"), to deal in the\r\nSoftware without restriction, including without\r\nlimitation the rights to use, copy, modify, merge,\r\npublish, distribute, sublicense, and/or sell copies of\r\nthe Software, and to permit persons to whom the Software\r\nis furnished to do so, subject to the following\r\nconditions: The above copyright notice and this permission\r\nnotice shall be included in all copies or substantial\r\nportions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\r\nANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\r\nTO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\nPARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\r\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n*/\r\n","#include <core/sdl_window.h>\r\n\r\n#ifdef __EMSCRIPTEN__\r\n#include <SDL.h>\r\n#include <SDL_opengles2.h>\r\n\r\n#include <emscripten.h>\r\n#include <emscripten/html5.h>\r\n\r\n#include <EGL/egl.h>\r\n#else\r\n#include <SDL2/SDL.h>\r\n#include <glad/glad.h>\r\n#endif\r\n\r\n#include <stdio.h>\r\n\r\n\r\n\r\n\r\n\r\n\r\nnamespace engine\r\n{\r\n\tbool Sdl_Window::initWindow(int width, int height, const char* windowName)\r\n\t{\r\n\t\t_width = width;\r\n\t\t_height = height;\r\n\r\n\t\tSDL_Init(SDL_INIT_EVERYTHING);\r\n\r\n#if 0\r\n\t\t//SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG);\r\n\t\tSDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_ES);\r\n\t\t// SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);\r\n\t\tSDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);\r\n        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);\r\n\t\tSDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);\r\n\t\tSDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);\r\n\t\tSDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\r\n#else\r\n#ifndef __EMSCRIPTEN__\r\n\t\t// SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG);\r\n\t\tSDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_PROFILE_CORE);\r\n\t\tSDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);\r\n\t\tSDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);\r\n        SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);\r\n\t\tSDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);\r\n\t\tSDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);\r\n\t\tSDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\r\n#else\r\n\t\tSDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);\r\n\t\tSDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);\r\n\t\tSDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 16);\r\n\r\n\t\tSDL_GL_SetAttribute(SDL_GL_RED_SIZE, 2);\r\n\t\tSDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 3);\r\n\t\tSDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 2);\r\n\t\tSDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 2);\r\n#endif\r\n#endif\r\n\r\n\t\t//SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\r\n\r\n\r\n\t\tUint32 flags = SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE;\r\n\r\n#ifdef __EMSCRIPTEN__\r\n\t\t_window = SDL_CreateWindow(windowName, 0, 0, width, height, flags);\r\n#else\r\n\t\t_window = SDL_CreateWindow(windowName, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, width, height, flags);\r\n#endif\r\n\r\n\t\tif (!_window)\r\n\t\t{\r\n\t\t\t// debugBreak();\r\n\t\t\tprintf(\"failed to window \\n\");\r\n\t\t\tstd::terminate();\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tSDL_GLContext glContex = SDL_GL_CreateContext(_window);\r\n\r\n\t\t// auto rdr = SDL_CreateRenderer(wnd, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_TARGETTEXTURE);\r\n\r\n\t\tif (!glContex)\r\n\t\t{\r\n\t\t\t// debugBreak();\r\n\t\t\tprintf(\"failed to context \\n\");\r\n\t\t\tstd::terminate();\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\r\n\t\tSDL_GL_MakeCurrent(_window, glContex);\r\n\t\tSDL_GL_SetSwapInterval(0);\r\n\r\n#ifndef __EMSCRIPTEN__\r\n\t\tif (!gladLoadGL())\r\n\t\t{\r\n\t\t\tprintf(\"failed to initaliaze GLAD\\n\");\r\n\t\t\t// debugBreak();\r\n\t\t\tstd::terminate();\r\n\t\t\treturn false;\r\n\t\t}\r\n#endif\r\n\r\n\r\n\r\n\r\n#if 0\r\n\t\tEMSCRIPTEN_WEBGL_CONTEXT_HANDLE context;\r\n\r\n\t\tEmscriptenWebGLContextAttributes attrs;\r\n\t\temscripten_webgl_init_context_attributes(&attrs);\r\n\t\tattrs.majorVersion = 2;\r\n\t\tattrs.minorVersion = 0;\r\n\t\tEMSCRIPTEN_WEBGL_CONTEXT_HANDLE context = emscripten_webgl_create_context(0, &attrs);\r\n\t\tEMSCRIPTEN_RESULT res = emscripten_webgl_make_context_current(context);\r\n#endif\r\n\r\n\r\n\r\n\r\n\t\tprintf(\"*** OpenGL Version: %s  ***\\n\", glGetString(GL_VERSION));\r\n\r\n\t\tglViewport(0, 0, width, height);\r\n\t\tglEnable(GL_BLEND);\r\n\t\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\r\n\t\tglClearColor(114.f / 255.0f, 144.f / 255.0f, 154.f / 255.0f, 1.0f);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tbool Sdl_Window::updateMessages()\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\r\n\tvoid Sdl_Window::swap()\r\n\t{\r\n\t\tSDL_GL_SwapWindow(_window);\r\n\t\t\r\n\t\t// eglSwapBuffers(0, 0);\r\n\t}\r\n}\r\n","#define _CRT_SECURE_NO_WARNINGS 1\r\n#define  _HAS_EXCEPTIONS 0\r\n\r\n\r\n\r\n#include <stdio.h>\r\n#include <iostream>\r\n\r\n#include <mutex>\r\n#include <thread>\r\n#include <atomic>\r\n\r\n#include <chrono> \t// timer\r\n#include <string>\r\n#include <iostream>\r\n#include <functional>\r\n\r\n#include <math.h>\r\n#include \"platform.cpp\"\r\n\r\n\r\n// static engine::Audio* g_Audio = 0;\r\n\r\n#ifdef __EMSCRIPTEN__\r\n\r\n#include <SDL.h>\r\n#include <SDL_image.h>\r\n// #include <SDL_mixer.h>\r\n// #include <SDL_ttf.h>\r\n\r\n#include <emscripten.h>\r\n#define GL_GLEXT_PROTOTYPES 1\r\n#include <SDL_opengles2.h>\r\n\r\n\r\n#else\r\n#include <glad/glad.h>\r\n#include \"glad.c\"\r\n#endif\r\n\r\n#include \"Imgui/imgui.h\"\r\n#include \"Imgui/imgui.cpp\"\r\n#include \"Imgui/imgui_draw.cpp\"\r\n#include \"Imgui/imgui_demo.cpp\"\r\n#include \"Imgui/imgui_impl_sdl_gl3.cpp\"\r\n\r\n#include \"IO.cpp\"\r\n#include <EngineCore.h>\r\n\r\n#include <freetype/ft2build.h>\r\n#include FT_FREETYPE_H\r\n#include <../freetype-gl/freetype-gl.h>\r\nclass Font\r\n{\r\nprivate:\r\n\tftgl::texture_atlas_t* m_FTAtlas;\r\n\tftgl::texture_font_t* m_FTFont;\r\n\tunsigned int m_Size;\r\n\tVec2 m_Scale;\r\n\tstd::string m_Name;\r\n\tstd::string m_Filename;\r\npublic:\r\n\tFont(std::string name, std::string filename, int size)\r\n\t\t: m_Name(name), m_Filename(filename), m_Size(size)\r\n\t{\r\n\t\tm_FTAtlas = ftgl::texture_atlas_new(512, 512, 2);\r\n\t\tm_FTFont = ftgl::texture_font_new_from_file(m_FTAtlas, (float)size, filename.c_str());\r\n\t}\r\n\r\n\tvoid setScale(float x, float y) {\r\n\t\tm_Scale = { x, y };\r\n\t}\r\n\r\n\tinline ftgl::texture_font_t* getFTFont() const { return m_FTFont; }\r\n\r\n\tinline const unsigned int getID() const { return m_FTAtlas->id; }\r\n\tinline const Vec2& getScale() const { return m_Scale; }\r\n\tinline const std::string& getName() const { return m_Name; }\r\n\tinline const std::string& getFileName() const { return m_Filename; }\r\n\tinline const int getSize() const { return m_Size; }\r\n};\r\n\r\n#include \"sdl_window.cpp\"\r\n\r\nGLenum glCheckError__(const char *file, int line)\r\n{\r\n\tGLenum errorCode;\r\n\twhile ((errorCode = glGetError()) != GL_NO_ERROR)\r\n\t{\r\n\t\tstd::string error;\r\n\t\tswitch (errorCode)\r\n\t\t{\r\n\t\tcase GL_INVALID_ENUM:                  error = \"INVALID_ENUM\"; break;\r\n\t\tcase GL_INVALID_VALUE:                 error = \"INVALID_VALUE\"; break;\r\n\t\tcase GL_INVALID_OPERATION:             error = \"INVALID_OPERATION\"; break;\r\n\t\t\t// case GL_STACK_OVERFLOW:                error = \"STACK_OVERFLOW\"; break;\r\n\t\t\t// case GL_STACK_UNDERFLOW:               error = \"STACK_UNDERFLOW\"; break;\r\n\t\tcase GL_OUT_OF_MEMORY:                 error = \"OUT_OF_MEMORY\"; break;\r\n\t\tcase GL_INVALID_FRAMEBUFFER_OPERATION: error = \"INVALID_FRAMEBUFFER_OPERATION\"; break;\r\n\t\t}\r\n\t\tstd::cout << error << \" | \" << file << \" (\" << line << \")\" << std::endl;\r\n\t}\r\n\treturn errorCode;\r\n}\r\n\r\n// #define glCheckError()  \r\n#define glCheckError()  glCheckError__(__FILE__, __LINE__) \r\n\r\n#include \"Graphics/Shader.cpp\"\r\n#include \"Graphics/Texture2D.cpp\"\r\n#include \"Graphics/SpriteRenderer.cpp\"\r\n#include \"Camera2D.cpp\"\r\n\r\n#include \"Graphics/LineRenderer.cpp\"\r\n\r\nstatic const char frag2[] = R\"(\r\nprecision mediump float; \r\nuniform sampler2D textures[8];\r\nvarying vec2 texCoord;\r\nvarying float textureId;\r\n\r\nvoid main()\r\n{\r\n\tvec4 texColor;\r\n\tint tid = int(textureId - 0.5);\r\n\ttexColor = texture2D(textures[tid], texCoord);\r\n    gl_FragColor = texColor;\r\n})\";\r\n\r\n\r\n\r\n\r\n// #include <da_array.h>\r\n#include \"ResourceManager.cpp\"\r\n#include \"Input.cpp\"\r\n\r\nconstexpr int MAX_ENTITYS = 4000003;\r\n\r\nconstexpr int BENCHMARK_ENTITYS = 100000;\r\nconstexpr int BENCHMARK_ENTITYS_ATTRIBUTE_COUNT = BENCHMARK_ENTITYS * 2;\r\n\r\nconstexpr float BENCMARK_ENTITY_SIZE = 16.f;\r\n\r\n\r\nstatic void initBenchmark(Benchmark* b)\r\n{\r\n\tb->positions = new float[BENCHMARK_ENTITYS_ATTRIBUTE_COUNT];\r\n\tb->velocities = new float[BENCHMARK_ENTITYS_ATTRIBUTE_COUNT];\r\n\r\n\tfor (int i = 0; i < 16; i++)\r\n\t{\r\n\t\tstate[i] = rand() % 1324234;\r\n\t}\r\n\r\n\tfor (int i = 0; i < BENCHMARK_ENTITYS_ATTRIBUTE_COUNT; ++i)\r\n\t{\r\n\t\tb->positions[i] = RandomFloat(0.f, 600.f);\r\n\t\tb->velocities[i] = RandomFloat(-2.f, 2.f);\r\n\t}\r\n}\r\n\r\nstatic void update(Benchmark* b, vec4* cameraRect)\r\n{\r\n\tfor (int i = 0; i < BENCHMARK_ENTITYS_ATTRIBUTE_COUNT; ++i)\r\n\t{\r\n\t\tb->positions[i] += b->velocities[i];\r\n\r\n\t\tif (b->positions[i] < cameraRect->x)\r\n\t\t{\r\n\t\t\tb->velocities[i] *= -1;\r\n\t\t\tb->positions[i] = cameraRect->x + 1;\r\n\t\t}\r\n\t\telse if (b->positions[i] > cameraRect->w)\r\n\t\t{\r\n\t\t\tb->velocities[i] *= -1;\r\n\t\t\tb->positions[i] = cameraRect->w - 1;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic void render(Benchmark* b, RenderData* sr, int tex)\r\n{\r\n\tsr->setTexture(tex);\r\n\tvec4 position{ 0.f, 0.f, BENCMARK_ENTITY_SIZE, BENCMARK_ENTITY_SIZE };\r\n\tvec4 uv{ 0.f, 0.f, 1.f, 1.f };\r\n\tfor (int i = 0; i < BENCHMARK_ENTITYS_ATTRIBUTE_COUNT; i += 2)\r\n\t{\r\n\t\tposition.x = b->positions[i];\r\n\t\tposition.y = b->positions[i + 1];\r\n\t\t// sr->DrawSprite(&position, &uv);\r\n\t}\r\n}\r\n\r\n\r\n// #include \"game/game.h\"\r\n\r\nupdate_Game* gameUpdatePtr = 0;\r\ndraw_Game*   gameDrawPtr = 0;\r\ninit_game*   gameInitPtr = 0;\r\nplayback_start* gamePlaybackStartPtr = 0;\r\nvoid* gameHandle = 0;\r\ntime_t lastWriteTime = 0;\r\n\r\n#if _WIN32\r\nstatic const char* gameDllName = \"game.dll\";\r\n#else\r\nstatic const char* gameDllName = \"libgame.so\";\r\n#endif\r\n\r\n#include <stdlib.h>\r\n\r\nstatic bool copyFile(const char* filename, const char* newName)\r\n{\r\n\tFILE* file = fopen(filename, \"rb\");\r\n\r\n\tif (file)\r\n\t{\r\n\t\tfseek(file, 0L, SEEK_END);\r\n\t\tlong size = ftell(file);\r\n\t\tfseek(file, 0L, SEEK_SET);\r\n\r\n\t\tvoid* mem = malloc(sizeof(char) * size);\r\n\t\tfread(mem, sizeof(char), size, file);\r\n\r\n\t\tfclose(file);\r\n\r\n\t\tfile = fopen(newName, \"wb\");\r\n\t\tfwrite(mem, sizeof(char), size, file);\r\n\t\tfclose(file);\r\n\r\n\r\n\t\tfree(mem);\r\n\t\tLOGI(\"success\\n\");\r\n\t\treturn true;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tLOGI(\"failure\\n\");\r\n\t\tperror(\"Error\");\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n// fast copy\r\n//FILE *in = fopen(infile, \"rb\");\r\n//FILE *out = fopen(outfile, \"wb\");\r\n//\r\n//char buf[1024];\r\n//int read = 0;\r\n//\r\n////  Read data in 1kb chunks and write to output file\r\n//while ((read = fread(buf, 1, 1024, in)) == 1024)\r\n//{\r\n//  fwrite(buf, 1, 1024, out);\r\n//}\r\n//\r\n////  If there is any data left over write it out\r\n//fwrite(buf, 1, read, out);\r\n//\r\n//fclose(out);\r\n//fclose(in);\r\n\r\n// #include <sys/stat.h>\r\n#include <sys/stat.h>\r\n\r\nvoid copyFileOs(std::string infile, std::string outfile)\r\n{\r\n#ifdef _WIN32 //|| _WIN64\r\n\t//  Windows\r\n\tCopyFileA(infile.c_str(), outfile.c_str(), false);\r\n#elif __APPLE__\r\n\t//  OSX\r\n\tcopyfile(infile.c_str(), outfile.c_str(), NULL, COPYFILE_DATA);\r\n#elif __linux\r\n\t//  Linux\r\n#if 0 \r\n\tstruct stat stat_buf;\r\n\tint in_fd, out_fd;\r\n\toffset_t offset = 0;\r\n\r\n\tin_fd = open(infile.c_str(), O_RDONLY);\r\n\tfstat(in_fd, &stat_buf);\r\n\tout_fd = open(outfile.c_str(), O_WRONLY | O_CREAT, stat_buf.st_mode);\r\n\r\n\tsendfile(out_fd, in_fd, &offset, stat_buf.st_size);\r\n\r\n\tclose(out_fd);\r\n\tclose(in_fd);\r\n#endif\r\n#endif\r\n}\r\n\r\n\r\n#ifndef __EMSCRIPTEN__\r\nstatic void unloadGameDll(void* handle)\r\n{\r\n\tSDL_UnloadObject(handle);\r\n\tgameInitPtr = gameUpdatePtr = gameDrawPtr = 0;\r\n}\r\n#endif\r\n\r\n// time_t    st_atime;   /* time of last access */\r\n// time_t    st_mtime;   /* time of last modification */\r\n// time_t    st_ctime;   /* time of last status change */\r\n\r\nstatic time_t getWriteTime(const char* filename)\r\n{\r\n\tstruct stat stats;\r\n\tstat(filename, &stats);\r\n\r\n\ttime_t mtime = stats.st_mtime; /* seconds since the epoch */\r\n\treturn mtime;\r\n}\r\n\r\nnamespace engine {\r\n\tvoid checkWriteTimes(engine::Resources* resources, engine::resource_type type)\r\n\t{\r\n\t\tswitch (type)\r\n\t\t{\r\n\t\tcase engine::ResourceType_texture:\r\n\t\t\tfor (int i = 0; i < textures::Texture_Count; i++)\r\n\t\t\t{\r\n\t\t\t\tuint64_t writeTime = getWriteTime(engine::ResourcePaths[i]);\r\n\t\t\t\tif (resources->textures[i].writeTime == 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tresources->textures[i].writeTime = writeTime;\r\n\t\t\t\t}\r\n\t\t\t\telse if (resources->textures[i].writeTime != writeTime)\r\n\t\t\t\t{\r\n\t\t\t\t\t// reload the texture\r\n\t\t\t\t\tresources->textures[i].writeTime = writeTime;\r\n\t\t\t\t\tglDeleteTextures(1, &resources->textures[i].ID);\r\n\t\t\t\t\tresources->loaded[i] = false;\r\n\t\t\t\t\tgetTexture(resources, i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase engine::ResourceType_shader:\r\n\t\t\tbreak;\r\n\t\tcase engine::ResourceType_sound:\r\n\t\t\tbreak;\r\n\t\tcase engine::ResourceType_file:\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n#if _WIN32 || __linux\r\nstatic bool loadGameDll(const char* dllName)\r\n{\r\n#if _WIN32\r\n\tWIN32_FILE_ATTRIBUTE_DATA unused;\r\n\tif (!GetFileAttributesEx(\"lock.tmp\", GetFileExInfoStandard, &unused))\r\n\t{\r\n#else\r\n\t\t{\r\n#endif\r\n\r\n\t\t\tunloadGameDll(gameHandle);\r\n\r\n\t\t\tstatic char buffer[256];\r\n\t\t\tsprintf(buffer, \"%s\", dllName);\r\n#if _WIN32\r\n\t\t\tbuffer[strlen(dllName) - 4] = '\\0';\r\n\t\t\tstrcat(buffer, \"_temp.dll\");\r\n#else\r\n\t\t\tbuffer[strlen(dllName) - 3] = '\\0';\r\n\t\t\tstrcat(buffer, \"_temp.so\");\r\n#endif\r\n\r\n#if _WIN32\r\n\t\t\tSTART_TIMING();\r\n\t\t\tbool success = CopyFileEx(dllName, buffer, NULL, NULL, false, COPY_FILE_NO_BUFFERING);\r\n\r\n\t\t\tprintf(\"%i\", (int)success);\r\n\t\t\t// CopyFileA(dllName, buffer, false);\r\n\t\t\tEND_TIMING();\r\n#endif\r\n\r\n\t\t\t// void* handle = SDL_LoadObject(buffer); // temp\r\n\t\t\t// void* handle = SDL_LoadObject(buffer); // temp\r\n\r\n\r\n\t\t\t// handle = dlopen(buffer, RTLD_LAZY);\r\n#if _LINUX\r\n\t\t\twhile (!copyFile(dllName, buffer)) {}\r\n\r\n\t\t\tvoid* handle = dlopen(\"./libgame_temp.so\", RTLD_LAZY);\r\n\t\t\tLOGI(\"handle: %p %i name: %s\\n\", handle, handle, buffer);\r\n\t\t\tLOGI(\"error %s\\n\", dlerror());\r\n\t\t\tSTART_TIMING2()\r\n#else\r\n\t\t\tvoid* handle = SDL_LoadObject(buffer); // temp\r\n#endif\r\n\r\n\r\n\t\t\tif (handle)\r\n\t\t\t{\r\n\t\t\t\tLOGI(\"dynamic library load success! \\n\");\r\n\r\n\t\t\t\tgameHandle = handle;\r\n\t\t\t\tupdate_Game* gameUpdate = (update_Game*)SDL_LoadFunction(handle, \"updateGame\");\r\n\r\n\t\t\t\tif (gameUpdate)\r\n\t\t\t\t{\r\n\t\t\t\t\tgameUpdatePtr = gameUpdate;\r\n\t\t\t\t\tprintf(\"success \\n\");\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tLOGI(\"counld not load game update!\\n\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdraw_Game*   gameDraw = (draw_Game*)SDL_LoadFunction(handle, \"drawGame\");\r\n\t\t\t\tif (gameDraw)\r\n\t\t\t\t{\r\n\t\t\t\t\tgameDrawPtr = gameDraw;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tLOGI(\"counld not load game draw!\\n\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tinit_game*   gameInit = (init_game*)SDL_LoadFunction(handle, \"initGame\");\r\n\t\t\t\tif (gameInit)\r\n\t\t\t\t{\r\n\t\t\t\t\tgameInitPtr = gameInit;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tLOGI(\"could't load game init! \\n\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tplayback_start*  play = (playback_start*)SDL_LoadFunction(handle, \"startPlayback\");\r\n\t\t\t\tif (play)\r\n\t\t\t\t{\r\n\t\t\t\t\tgamePlaybackStartPtr = play;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tLOGI(\"could't load game playback! \\n\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlastWriteTime = getWriteTime(buffer);\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t}\r\n\t\treturn false;\r\n}\r\n#endif\r\n\r\nstd::function<void()> loop;\r\nstatic void main_loop() { loop(); }\r\n\r\n#define MOUSE_BUTTON_COUNT 5\r\nstatic void updateInput(engine::InputData* inputData)\r\n{\r\n\tfor (int i = 0; i < 512; i++)\r\n\t{\r\n\t\tinputData->lastFrame[i] = inputData->thisFrame[i];\r\n\t}\r\n\r\n\tfor (int i = 0; i < MOUSE_BUTTON_COUNT; i++)\r\n\t{\r\n\t\tinputData->mouseLastFrame[i] = inputData->mouse[i];\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n#if _LINUX\r\n// #include \"game/game.h\"\r\n#include <platform.h>\r\n\r\n// #define DRAW_GAME(name) void name(game_memory *memory, EngineCore* core)\r\n// typedef DRAW_GAME(draw_Game);\r\n// #include \"game/game.h\"\r\n// #include \"game/game.cpp\"\r\n\r\n#endif\r\n\r\n#define STB_IMAGE_WRITE_IMPLEMENTATION\r\n#define STBIW_ASSERT(x)\r\n#include <3rdparty/stb_image_write.h>\r\n\r\n#if _WIN32\r\n#include <InputPlayback.h>\r\n#endif\r\n\r\nvoid screenshot(int width, int height)\r\n{\r\n\tunsigned char* pixels = new unsigned char[3 * width * height];\r\n\tunsigned char* p = new unsigned char[3 * width * height];\r\n\r\n\tglReadPixels(0, 0, width, height, GL_RGB, GL_UNSIGNED_BYTE, pixels);\r\n\r\n#if 0\r\n\tfor (int i = 0; i < height; i++)\r\n\t{\r\n\t\tint copyH = height - 1;\r\n\t\tmemmove(p + (copyH * width * 3), pixels + (i * width * 3), sizeof(unsigned char) * 3 * width);\r\n\t}\r\n#endif\r\n\tfor (int i = 0; i < height; i++)\r\n\t{\r\n\t\tint lastRow = height - i - 1;\r\n\t\tmemmove(p + (lastRow * width * 3), pixels + (i * width * 3), sizeof(unsigned char) * 3 * width);\r\n\t}\r\n\r\n\tstbi_write_png(\"assets/uusi.png\", width, height, 3, p, 0);\r\n\r\n\t// FIBITMAP* image = FreeImage_ConvertFromRawBits(pixels, width, height, 3 * width, 24, 0x0000FF, 0xFF0000, 0x00FF00, false);\r\n\t// FreeImage_Save(FIF_BMP, image, \"C:/test.bmp\", 0);\r\n\r\n\tdelete[] pixels;\r\n\tdelete[] p;\r\n}\r\n\r\n#ifdef _WIN32\r\nstatic void load_thread(PlaybackState* data)\r\n{\r\n\tPlaybackState* inputState = data;\r\n\r\n\tfor (int i = 0; i < ArrayCount(inputState->replayBuffer); i++)\r\n\t{\r\n\t\tReplayBuffer* replayBuffer = &inputState->replayBuffer[i];\r\n\r\n\t\t// working dir?\r\n\t\tgetInputRecordName(i, replayBuffer->fileName, true);\r\n\r\n\t\t// create always ?\r\n\t\treplayBuffer->FileHandle = CreateFileA(replayBuffer->fileName, GENERIC_WRITE | GENERIC_READ, 0, 0, CREATE_ALWAYS, 0, 0);\r\n\r\n\t\tLARGE_INTEGER maxSize;\r\n\r\n\t\tmaxSize.QuadPart = inputState->totalMemorySize;\r\n\t\treplayBuffer->MemoryMap = CreateFileMapping(replayBuffer->FileHandle,\r\n\t\t\t0, PAGE_READWRITE, maxSize.HighPart, maxSize.LowPart, 0);\r\n\r\n\t\treplayBuffer->memoryBlock = MapViewOfFile(replayBuffer->MemoryMap, FILE_MAP_ALL_ACCESS,\r\n\t\t\t0, 0, inputState->totalMemorySize);\r\n\r\n\t\tif (!replayBuffer->memoryBlock)\r\n\t\t{\r\n\t\t\tassert(false);\r\n\t\t}\r\n\t}\r\n}\r\n#endif\r\n\r\n#if __EMSCRIPTEN__\r\n#include \"game/game.cpp\"\r\n#endif\r\n\r\n\r\n#if __linux\r\n// #include \"game/game.h\"\r\n#endif\r\n\r\n#ifndef __EMSCRIPTEN__\r\nint main(int argc, char* argv[])\r\n#else\r\nextern \"C\" void mainf()\r\n#endif\r\n{\r\n\t// handle command line args \r\n\tLOGI(\"akjsdlfjasdlf \\n\");\r\n\r\n#if __EMSCRIPTEN__\r\n\tgameInitPtr = initGame;\r\n\tgameUpdatePtr = updateGame;\r\n\tgameDrawPtr = drawGame;\r\n\tgamePlaybackStartPtr = startPlayback;\r\n#endif\r\n\r\n\tint windowWidth = 640;\r\n\tint windowHeight = 480;\r\n\r\n\tengine::Sdl_Window* window = new engine::Sdl_Window();\r\n\twindow->initWindow(windowWidth, windowHeight, \"Refactorings\");\r\n\tengine::Input::windowDimension = { (float)windowWidth, (float)windowHeight };\r\n\r\n\r\n\tImGui_ImplSdlGL3_Init(window->_window);                        // IMGUI\r\n\tbool show_demo_window = true;\r\n\tbool show_another_window = false;\r\n\r\n\r\n\t// Setup style\r\n\tImGui::StyleColorsClassic();\r\n\tImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);\r\n\t//\tImGui::StyleColorsDark();\r\n\t\t//ImGuiIO& io = ImGui::GetIO();\r\n\t   //io.Fonts->AddFontDefault();\r\n\t   //io.Fonts->AddFontFromFileTTF(\"../../extra_fonts/Roboto-Medium.ttf\", 16.0f);\r\n\t   //io.Fonts->AddFontFromFileTTF(\"../../extra_fonts/Cousine-Regular.ttf\", 15.0f);\r\n\t   //io.Fonts->AddFontFromFileTTF(\"../../extra_fonts/DroidSans.ttf\", 16.0f);\r\n\t   //io.Fonts->AddFontFromFileTTF(\"../../extra_fonts/ProggyTiny.ttf\", 10.0f);\r\n\t   //ImFont* font = io.Fonts->AddFontFromFileTTF(\"c:\\\\Windows\\\\Fonts\\\\ArialUni.ttf\", 18.0f, NULL, io.Fonts->GetGlyphRangesJapanese());\r\n\t   //IM_ASSERT(font != NULL);\r\n\r\n\tglCheckError();\r\n\tengine::InputData* inputData = new engine::InputData;\r\n\tengine::Input::init(inputData, 512, 0);\r\n\r\n\tengine::Camera2D camera;\r\n\tglm::vec2 move{ windowWidth / 2, windowHeight / 2 };\r\n\tcamera.init(windowWidth, windowHeight);\r\n\tcamera.mvoe(move);\r\n\r\n\tengine::Camera2D hudCamera;\r\n\thudCamera.mvoe(move);\r\n\t//hudCamera.mvoe(move);\r\n\r\n\tengine::Shader shader(\"hei\", \"hei\");\r\n\r\n#ifndef __linux\r\n\tshader.compileShaderFromFile(\"assets/shaders/mainVert.txt\", \"assets/shaders/mainFrag.txt\");\r\n\tLOGI(\"ONKO SHADER KUNNOSSA!!\\n\");\r\n#else\r\n\tshader.compileShaderFromFile(\"assets/shaders/mainVert2.txt\", \"assets/shaders/mainFrag2.txt\");\r\n#endif\r\n\t// shader.compileShadersFromSource(vert, frag, \"main vertex\", \"main frag\");\r\n\r\n\tengine::SpriteRenderer sr;\r\n\tRenderData renderData{};\r\n\tsr.Init(&renderData, MAX_ENTITYS, &shader);\r\n\r\n\tstd::chrono::nanoseconds simulationTime(0);\r\n\tstd::chrono::nanoseconds timestep(16);\r\n\tauto currentTime = std::chrono::high_resolution_clock::now();\r\n\r\n\tfloat dt = 1 / 60.0;\r\n\tfloat lastFT = 0.f;\r\n\tbool quit = false;\r\n\r\n\tfloat alltime = 0.f;\r\n\tint frameCount = 0;\r\n\r\n\tFont font(\"test font\", \"assets/rs.ttf\", 60);\r\n\tfont.setScale(1.f, 1.f);\r\n\tglCheckError();\r\n\r\n\tengine::Resources resources{};\r\n\tresources.loadTexturePtr = &engine::loadTexture;\r\n\t{\r\n\t\tgetTexture(&resources, textures::Texture_infantry);\r\n\t\tgetTexture(&resources, textures::Texture_Alien);\r\n\t\tgetTexture(&resources, textures::Texture_Block);\r\n\t}\r\n\tauto tex = engine::getTexture(&resources, textures::Texture_infantry);\r\n\r\n\tengine::checkWriteTimes(&resources, engine::ResourceType_texture);\r\n\r\n\t// allocate game memory\r\n\tgame_memory gameMemory = {};\r\n\tgameMemory.permanentStorageSize = Megabytes(128 * 2);\r\n\tgameMemory.transientStorageSize = Gigabytes((uint64_t)0.1);\r\n\tuint64_t totalSize = gameMemory.permanentStorageSize + gameMemory.transientStorageSize;\r\n\r\n#if _WIN32\r\n\tLPVOID baseAddress = (LPVOID)Terabytes(2);\r\n\r\n\tgameMemory.permanentStorage = // malloc(totalSize);\r\n\t\tVirtualAlloc(baseAddress, (size_t)totalSize, // KIITOS virtualAlloc\r\n\t\t\tMEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\r\n#else\r\n\tgameMemory.permanentStorage = malloc(totalSize);\r\n#endif\r\n\tgameMemory.transientStorage = ((uint8_t*)gameMemory.permanentStorage + gameMemory.permanentStorageSize);\r\n\r\n\r\n\t// DEV INILIZATION\r\n#if _WIN32\r\n\tPlaybackState inputState{};\r\n\r\n\tinputState.memory = gameMemory.permanentStorage;\r\n\tinputState.totalMemorySize = Megabytes(128 * 2); // + gigaBytes(1);\r\n\r\n\tstd::atomic<bool> fileLoadingThreadDone(false);\r\n\tstd::thread thread([&fileLoadingThreadDone, &inputState] {\r\n\t\tprintf(\"thread started\\n\");\r\n\t\tload_thread(&inputState);\r\n\t\tprintf(\"thread done\\n\");\r\n\t\tfileLoadingThreadDone = true;\r\n\t});\r\n#endif\r\n\r\n\tengine::LineRenderer lineRenderer;\r\n\tlineRenderer.Init();\r\n\r\n\tEngineCore engineCore{};\r\n\tengineCore.renderData = &renderData;\r\n\tengineCore.resources = &resources;\r\n\tengineCore.inputData = inputData;\r\n\tengineCore.memory = &gameMemory;\r\n\tengineCore.paused = false;\r\n\tengineCore.setUpContexts = true;\r\n\r\n\tengineCore.lines = &lineRenderer._lineVertices;\r\n\tengineCore.points = &lineRenderer._pointVertices;\r\n\r\n\tengineCore.screenDimensions = { (float)windowWidth, (float)windowHeight };\r\n\r\n\tengineCore.imguiContext = (void*)ImGui::GetCurrentContext();\r\n\r\n\tengineCore.cameraPosition = (vec2f*)(&camera._position);\r\n\tengineCore.cameraScale = (float*)(&camera._scale);\r\n\tengineCore.cameraAngle = &camera.angle;\r\n\r\n\r\n\tauto realTime(std::chrono::high_resolution_clock::now());\r\n\tauto simulationTIMER(std::chrono::high_resolution_clock::now());\r\n\r\n\t// playback LOG //\r\n\tconst char* playbackFile = \"playbackLog.txt\";\r\n\tchar currentFile[64] = \"Log_0.txt\";\r\n\tint  currentFileNumber = 0;\r\n\t// const char*  = \"playbackLog.txt\";\r\n\tLogBuffer log{};\r\n\tengineCore.log = &log;\r\n\trestartLog(playbackFile);\r\n\trestartLog(currentFile);\r\n\tg_log = &log;\r\n\r\n\tint recordStartedFrame = 0;\r\n\r\n\t// Benchmark b;\r\n\t// initBenchmark(&b);\r\n\r\n#if !_WIN32 \r\n\t//\tinitGame(&gameMemory);\r\n\t// loadGameDll(gameDllName);\r\n\tgameInitPtr(&gameMemory, &engineCore);\r\n#else\r\n\tloadGameDll(gameDllName);\r\n\tlastWriteTime = getWriteTime(gameDllName);\r\n\tgameInitPtr(&gameMemory, &engineCore);\r\n#endif\r\n\r\n\tauto startTime(std::chrono::high_resolution_clock::now());\r\n\tglCheckError();\r\n\r\n\t// engine::Audio a;\r\n\t// a.init();\r\n\t// a.loadSound(\"assets/test.wav\", \"audio\");\r\n\t// a.playSound(\"audio\", 0.4f, 1);\r\n\t// a.update();\r\n\t// g_Audio = &a;\r\n\t// LOGI(\"audio working ???\\n\");\r\n\r\n\r\n#if __EMSCRIPTEN__\r\n\r\n\r\n\tloop = [&] {\r\n#else\r\n\twhile (!quit) {\r\n#endif\r\n\r\n\t\tauto timePoint1(std::chrono::high_resolution_clock::now());\r\n\r\n\t\tauto delta_time = std::chrono::high_resolution_clock::now() - currentTime;\r\n\t\tcurrentTime = std::chrono::high_resolution_clock::now();\r\n\t\tsimulationTime += std::chrono::duration_cast<std::chrono::nanoseconds>(delta_time);\r\n\r\n\t\tcamera.update();\r\n\r\n#if _WIN32 // DEV PLATFORM\r\n\t\tif (fileLoadingThreadDone) // dev feature // needed web\r\n\t\t{\r\n\t\t\tthread.join();\r\n\t\t\tprintf(\"thread joined\\n\");\r\n\t\t\tfileLoadingThreadDone = false;\r\n\t\t}\r\n\r\n#endif\r\n\t\t{\r\n\t\t\t// file write time performance horrible on linux\r\n#if _WIN32\r\n\t\t\ttime_t newWriteTime = getWriteTime(gameDllName);\r\n\t\t\tif (newWriteTime != lastWriteTime)\r\n\t\t\t{\r\n\t\t\t\tif (loadGameDll(gameDllName))\r\n\t\t\t\t{\r\n\t\t\t\t\tengineCore.needReset = true;\r\n\t\t\t\t\tengineCore.setUpContexts = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n#endif\r\n\t\t}\r\n\r\n\t\tSDL_Event e;\r\n\t\twhile (SDL_PollEvent(&e))\r\n\t\t{\r\n\t\t\tImGui_ImplSdlGL3_ProcessEvent(&e);\r\n\r\n\t\t\tswitch (e.type)\r\n\t\t\t{\r\n\t\t\tcase SDL_QUIT:\r\n#if __EMSCRIPTEN__\r\n\t\t\t\tstd::terminate();\r\n#else\r\n\t\t\t\tquit = true;\r\n#endif\r\n\t\t\t\tbreak;\r\n\t\t\tcase SDL_WINDOWEVENT:\r\n\t\t\t{\r\n\t\t\t\tswitch (e.window.event)\r\n\t\t\t\t{\r\n\t\t\t\tcase SDL_WINDOWEVENT_SIZE_CHANGED:\r\n\t\t\t\t\tSDL_Log(\"Window %d changed to %dx%d\",\r\n\t\t\t\t\t\te.window.windowID, e.window.data1,\r\n\t\t\t\t\t\te.window.data2);\r\n\r\n\t\t\t\t\twindowWidth = e.window.data1;\r\n\t\t\t\t\twindowHeight = e.window.data2;\r\n\r\n\t\t\t\t\twindow->setSize(windowWidth, windowHeight);\r\n\t\t\t\t\tengineCore.screenDimensions = { (float)windowWidth, (float)windowHeight };\r\n\t\t\t\t\tglViewport(0, 0, windowWidth, windowHeight);\r\n\r\n\t\t\t\t\t// camera.init(e.window.data1, e.window.data2);\r\n\t\t\t\t}\r\n\t\t\t} break;\r\n\t\t\tcase SDL_MOUSEMOTION:\r\n\t\t\t{\r\n\t\t\t\tinputData->mousePos.x = (float)e.motion.x;\r\n\t\t\t\tinputData->mousePos.y = (float)e.motion.y;\r\n\t\t\t} break;\r\n\t\t\tcase SDL_MOUSEBUTTONDOWN:\r\n\t\t\t{\r\n\t\t\t\tSDL_MouseButtonEvent *m = (SDL_MouseButtonEvent*)&e;\r\n\t\t\t\t//\tassert(m->state == 0);\r\n\t\t\t\t// printf(\"button down : %d,%d  %d,%d\\n\", m->button, m->state, m->x, m->y);\r\n\r\n\t\t\t\tif (m->button >= 1 && m->button < MOUSE_BUTTON_COUNT)\r\n\t\t\t\t\tinputData->mouse[m->button - 1] = true;\r\n\t\t\t\t// inputDamouseButtons[m->button + 1] = true;\r\n\t\t\t} break;\r\n\t\t\tcase SDL_MOUSEBUTTONUP:\r\n\t\t\t{\r\n\t\t\t\tSDL_MouseButtonEvent *m = (SDL_MouseButtonEvent*)&e;\r\n\r\n\t\t\t\tif (m->button >= 1 && m->button < MOUSE_BUTTON_COUNT)\r\n\t\t\t\t\tinputData->mouse[m->button - 1] = false;\r\n\r\n\t\t\t\t//mouseButtons[m->button + 1] = false;\r\n\t\t\t} break;\r\n\t\t\tcase SDL_KEYDOWN:\r\n\t\t\t{\r\n\t\t\t\tinputData->thisFrame[e.key.keysym.scancode] = true;\r\n#if _WIN32\r\n\t\t\t\tif (e.key.keysym.scancode == SDL_SCANCODE_F1)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!inputState.recording && !inputState.playing) // eka\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tprintf(\"record\");\r\n\t\t\t\t\t\tstartRecordInput(inputData, &inputState, 0);\r\n\t\t\t\t\t\tinputState.recording = true;\r\n\r\n\t\t\t\t\t\tgamePlaybackStartPtr(&gameMemory, &engineCore);\r\n\r\n\t\t\t\t\t\tcurrentFileNumber++;\r\n\t\t\t\t\t\tif (currentFileNumber < 10)\r\n\t\t\t\t\t\t\tcurrentFile[4] = currentFileNumber + '0';\r\n\r\n\t\t\t\t\t\trestartLog(currentFile);\r\n\t\t\t\t\t\trecordStartedFrame = engineCore.currentFrame;\r\n\t\t\t\t\t\t// LOGI(\"RECORD STARTED at frame %i \\n\", engineCore.currentFrame);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (inputState.recording) // toka\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tprintf(\"playback start\");\r\n\t\t\t\t\t\tendRecording(&inputState);\r\n\t\t\t\t\t\tstartInputPlayback(inputData, &inputState, 0); // restart\r\n\r\n\t\t\t\t\t\tgamePlaybackStartPtr(&gameMemory, &engineCore);\r\n\r\n\t\t\t\t\t\tcurrentFileNumber++;\r\n\t\t\t\t\t\tif (currentFileNumber < 10)\r\n\t\t\t\t\t\t\tcurrentFile[4] = currentFileNumber + '0';\r\n\t\t\t\t\t\trestartLog(currentFile);\r\n\t\t\t\t\t\t// recordStartedFrame = engineCore.currentFrame;\r\n\t\t\t\t\t\tengineCore.currentFrame = recordStartedFrame;\r\n\r\n\t\t\t\t\t\tinputState.recording = false;\r\n\t\t\t\t\t\tinputState.playing = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// start recording second slot?\r\n\t\t\t\t\t\t// or change recording with shift + 1\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (e.key.keysym.scancode == SDL_SCANCODE_F2)\r\n\t\t\t\t{\r\n\t\t\t\t\tinputState.playing = !inputState.playing;\r\n\t\t\t\t\t*inputData = InputData{}; // reset input state\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif (e.key.keysym.scancode == (int)Keycode::B)\r\n\t\t\t\t{\r\n\t\t\t\t\tengineCore.paused = !engineCore.paused;\r\n\t\t\t\t\tif (!engineCore.paused)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsimulationTIMER = realTime;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n#endif\r\n\t\t\t} break;\r\n\t\t\tcase SDL_KEYUP:\r\n\t\t\t{\r\n\t\t\t\tinputData->thisFrame[e.key.keysym.scancode] = false;\r\n\t\t\t\t// inputManager.releaseKey(ev.key.keysym.scancode);\r\n\t\t\t\t// if (ev.key.keysym.scancode > 0 && ev.key.keysym.scancode < SDL_SCANCODE_3)\r\n\t\t\t\t// {\r\n\t\t\t\t\t// nesInput.buttons &= ~(1 << ev.key.keysym.scancode);\r\n\t\t\t\t// }\r\n\t\t\t} break;\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n#if 1\r\n#ifndef __EMSCRIPTEN__\r\n\t\tImGui_ImplSdlGL3_NewFrame(window->_window);\r\n\r\n\t\t{\r\n\t\t\tstatic float f = 0.0f;\r\n\t\t\tImGui::Text(\"Hello, world!\");                           // Some text (you can use a format string too)\r\n\t\t\tImGui::SliderFloat(\"float\", &f, 0.0f, 1.0f);            // Edit 1 float as a slider from 0.0f to 1.0f\r\n\t\t\tImGui::ColorEdit3(\"clear color\", (float*)&clear_color); // Edit 3 floats as a color\r\n\r\n\t\t\tif (ImGui::Button(\"Demo Window\"))                       // Use buttons to toggle our bools. We could use Checkbox() as well.\r\n\t\t\t\tshow_demo_window ^= 1;\r\n\t\t\tif (ImGui::Button(\"Another Window\"))\r\n\t\t\t\tshow_another_window ^= 1;\r\n\r\n\t\t\tImGui::Text(\"Application average %.3f ms/frame (%.1f FPS)\", 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);\r\n\t\t}\r\n\t\tif (show_demo_window)\r\n\t\t{\r\n\t\t\tImGui::SetNextWindowPos(ImVec2(650, 20), ImGuiCond_FirstUseEver); // Normally user code doesn't need/want to call this because positions are saved in .ini file anyway. Here we just want to make the demo initial state a bit more friendly!\r\n\t\t\tImGui::ShowDemoWindow(&show_demo_window);\r\n\t\t}\r\n\r\n\t\t{\r\n\t\t\tImGui::DragFloat(\"roll\", &camera.angle, 0.1f);\r\n\t\t\tImGui::DragFloat(\"yaw\", &camera.yaw, 0.1f);\r\n\t\t\tImGui::DragFloat(\"pitch\", &camera.pitch, 0.1f);\r\n\t\t}\r\n\r\n\r\n\r\n\t\tif (ImGui::Checkbox(\"Pause\", &engineCore.paused))\r\n\t\t{\r\n\t\t\tif (!engineCore.paused)\r\n\t\t\t{\r\n\t\t\t\t// need to update simulation timer\r\n\t\t\t\tsimulationTIMER = realTime;\r\n\t\t\t}\r\n\t\t}\r\n#endif\r\n#endif\r\n\r\n\t\t// glClearColor(0.45f, 0.55f, 0.60f, 1.00f); imgui blue\r\n\t\tglClearColor(255.f / 255.f, 98.f / 255.f, 98.f / 255.f, 1.00f);\r\n\t\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\r\n\r\n\t\tlineRenderer.Clear();\r\n\t\tint id = tex->ID;\r\n\t\tfor (int i = 0; i < engineCore.layerCount; i++)\r\n\t\t{\r\n\t\t\tsr.Clear(engineCore.layers[i].data);\r\n\t\t\tengineCore.layers[i].currentLen = 0; // buffer len\r\n\t\t\tda_clear(engineCore.layers[i].fontCommands);\r\n\t\t}\r\n\r\n\r\n\t\tauto rect = camera.getCameraRect();\r\n\t\trealTime = std::chrono::high_resolution_clock::now();\r\n\t\tint update = 0;\r\n\t\tint framesThisLoop = 0;\r\n\t\twhile ((simulationTIMER < realTime && update <= 0) && !engineCore.paused) //|| ) // || core->nextFrame)\r\n\t\t{\r\n\t\t\t//if (core->frame == core->runToFrame)\r\n\t\t\t//{\r\n\t\t\t//\tcore->pause = true;\r\n\t\t\t//\tcore->runToFrame = -1;\r\n\t\t\t//}\r\n\r\n\t\t\t//if (core->pause)\r\n\t\t\t//\tbreak;\r\n\r\n\t\t\t//if (core->updateToRenderRatio != 0)\r\n\t\t\t//{\r\n\t\t\t//\t// core->nextFrame = (core->updateToRenderRatio == framesThisLoop) ? true : false;\r\n\t\t\t//}\r\n\t\t\t//else \r\n\t\t\t//{\r\n\t\t\t//\tcore->nextFrame = false;\r\n\t\t\t//}\r\n#if _WIN32\r\n\t\t\tif (inputState.recording)\r\n\t\t\t{\r\n\t\t\t\trecordInput(inputData, &inputState);\r\n\t\t\t}\r\n\t\t\telse if (inputState.playing)\r\n\t\t\t{\r\n\t\t\t\tif (playBackInput(inputData, &inputState))\r\n\t\t\t\t{\r\n\t\t\t\t\tgamePlaybackStartPtr(&gameMemory, &engineCore);\r\n\t\t\t\t\tcurrentFileNumber++;\r\n\t\t\t\t\tif (currentFileNumber < 10)\r\n\t\t\t\t\t\tcurrentFile[4] = currentFileNumber + '0';\r\n\r\n\t\t\t\t\trestartLog(currentFile);\r\n\r\n\t\t\t\t\tengineCore.currentFrame = recordStartedFrame;\r\n\r\n\t\t\t\t\tLOGI(\"RECORD restarted at frame %i \\n\", engineCore.currentFrame);\r\n\t\t\t\t}\r\n\t\t\t}\r\n#endif\r\n\r\n\t\t\tsimulationTIMER += std::chrono::milliseconds(16);\r\n\r\n\t\t\t// engineCore.currentTime = totalDiff.count();\r\n\r\n\t\t\t// application->update(deltaTime, core);\r\n\t\t\tupdate++;\r\n\r\n\t\t\tgameUpdatePtr(&gameMemory, &engineCore);\r\n\r\n\t\t\tif (engineCore.dirtyCamera)\r\n\t\t\t{\r\n\t\t\t\tcamera.setDirty();\r\n\t\t\t}\r\n\r\n\t\t\tupdateInput(inputData);\r\n\t\t\tframesThisLoop++;\r\n\r\n\t\t\tengineCore.currentFrame += 1;\r\n\r\n\t\t\t// feels sadmaaan feeeellss baadmaan :( \r\n\t\t\t// WRITE_LOG(engineCore.log, engineCore.currentFrame - 1, currentFile);\r\n\t\t}\r\n\t\tif (update > 1)\r\n\t\t\tprintf(\"Applikaatio on kuolemassa!!!\\n\");\r\n\r\n\t\t{ // camera movement\r\n#ifdef DEBUG  \r\n\t\t\tif (engine::Input::isKeyDown(Keycode::Q))\r\n\t\t\t{\r\n\t\t\t\tcamera.zoom(-0.002f * dt);\r\n\t\t\t}\r\n\t\t\telse if (engine::Input::isKeyDown(Keycode::E))\r\n\t\t\t{\r\n\t\t\t\tcamera.zoom(0.002f * dt);\r\n\t\t\t}\r\n\r\n\t\t\tif (engine::Input::isKeyDown(Keycode::K))\r\n\t\t\t\tcamera.mvoe({ 0.f, -0.08f * dt });\r\n\t\t\tif (engine::Input::isKeyDown(Keycode::I))\r\n\t\t\t\tcamera.mvoe({ 0.f, 0.08f * dt });\r\n\t\t\tif (engine::Input::isKeyDown(Keycode::J))\r\n\t\t\t\tcamera.mvoe({ -0.08f * dt, 0.f });\r\n\t\t\tif (engine::Input::isKeyDown(Keycode::L))\r\n\t\t\t\tcamera.mvoe({ 0.08f * dt , 0.f });\r\n#endif\r\n\t\t}\r\n\r\n\t\tcamera.update();\r\n\t\thudCamera.update();\r\n\t\tgameDrawPtr(&gameMemory, &engineCore);\t\t\t\t\t\t\t\t       // RENDER\r\n\r\n\t\t// update(&b, &rect);\r\n\t\t// render(&b, &renderData, id);\r\n\r\n\t\tif (engine::Input::isKeyPressed(Keycode::NUM_5))\r\n\t\t{\r\n\t\t\tgameInitPtr(&gameMemory, &engineCore);\r\n\t\t}\r\n\r\n\t\tif (engine::Input::isKeyPressed(Keycode::NUM_7))\r\n\t\t{\r\n\t\t\tengine::checkWriteTimes(engineCore.resources, engine::ResourceType_texture);\r\n\t\t}\r\n\r\n\t\tauto mat = camera.getCameraMatrix();\r\n\r\n\t\t//{ FPS\r\n\t\t//\tchar buffer[64];\r\n\t\t//\tsprintf(buffer, \"ft: %f\", lastFT);\r\n\t\t//\tVec2 pos{ 400, 200 };\r\n\t\t//\tengineCore.layers[0].drawString(buffer, &pos, 0xFFFFFFFF, 0);\r\n\t\t//}\r\n\r\n\t\t// SDL_Delay(10); ///////////////////////////////////////// LOLOLO SKIPPINGS????\r\n\r\n\t\tchar frameTime[64];\r\n\t\tVec2 position{ 300, 6 };\r\n\t\tsprintf(frameTime, \"frametime: %f\", alltime / frameCount);\r\n\t\t// engineCore.layers[0].drawString(frameTime, &position, 0xFFFFFFFF, 0);\r\n\r\n\t\tfor (int i = 0; i < engineCore.layerCount; i++)\r\n\t\t{\r\n\t\t\tint stringCount = da_size(engineCore.layers[i].fontCommands);\r\n\r\n\r\n\t\t\tLayer* layer = &engineCore.layers[i];\r\n\t\t\tint totalCount = 0;\r\n\t\t\tfor (int j = 0; j < stringCount; j++)\r\n\t\t\t{\r\n\t\t\t\tFontData* command = &layer->fontCommands[j];\r\n\t\t\t\tsr.drawString(layer->strBuffer + totalCount, command->size,\r\n\t\t\t\t\t&command->position, font, command->color, engineCore.layers[i].data);\r\n\t\t\t\ttotalCount += command->size;\r\n\t\t\t}\r\n\r\n\t\t\t// if (i != 2) \r\n\r\n\t\t\tsr.RenderLayer(&shader, mat, &engineCore.layers[i]);\r\n\r\n\t\t\t//else\t\t\t\t\t\t\t\t\t\t\t\t\t\t// hacky hud layer\r\n\r\n\t\t\t//\tsr.RenderLayer(&shader, hudCamera.getCameraMatrix(), &engineCore.layers[i]);\r\n\t\t}\r\n\r\n\t\tif (engine::Input::isKeyPressed(Keycode::Y))\r\n\t\t{\r\n\t\t\tscreenshot(windowWidth, windowHeight);\r\n\t\t}\r\n\r\n\r\n\t\t//lineRenderer.DrawBox(10.f, 10.f, 30.f, 30.f);\r\n\t\t//lineRenderer.DrawPoint(20.f, 20.f);\r\n\t\t// LOGI(\"fps: %f  avg: %f  ft: %f \\n\", 1.f / ftSeconds, alltime / (float)frameCount, ft);\r\n\t\tstatic float ftSeconds2 = 1.f;\r\n\t\tstatic float ft2 = 1.f;\r\n\t\t{\r\n#ifndef __EMSCRIPTEN__\r\n\t\t\tImGui::Text(\"fps: %f \\navg: %f \\nft: %f\\n\", 1.f / ftSeconds2, alltime / (float)frameCount, ft2);\r\n#endif\r\n\r\n\t\t\tstatic float avgg[100]{};\r\n\t\t\tstatic int avgCount = 0;\r\n\r\n\t\t\tif (avgCount == 100)\r\n\t\t\t{\r\n\t\t\t\tavgCount = 0;\r\n\t\t\t}\r\n\t\t\tavgg[avgCount] = ft2;\r\n\t\t\tavgCount++;\r\n\r\n\r\n\t\t\tfloat maxx{};\r\n\t\t\tfor (int i = 0; i < 100; ++i)\r\n\t\t\t{\r\n\t\t\t\tmaxx += avgg[i];\r\n\t\t\t}\r\n#ifndef __EMSCRIPTEN__\r\n\t\t\tImGui::Text(\"avg: %f\", maxx / 100.f);\r\n\r\n\t\t\tif (ImGui::Button(\"reset avg\"))\r\n\t\t\t{\r\n\t\t\t\talltime = 0.f;\r\n\t\t\t\tframeCount = 0;\r\n\t\t\t}\r\n#endif\r\n\t\t}\r\n\t\tlineRenderer.Render(&mat);\r\n#ifndef __EMSCRIPTEN__\r\n\t\tImGui::Render();\r\n#endif\r\n\t\twindow->swap();\r\n\r\n\t\tauto timePoint2(std::chrono::high_resolution_clock::now());\r\n\t\tauto elapsedTime(timePoint2 - timePoint1);\r\n\t\tfloat ft = { std::chrono::duration_cast<std::chrono::duration<float, std::milli>>(elapsedTime).count() };\r\n\t\tlastFT = ft;\r\n\t\tfloat ftSeconds = (ft / 1000.f);\r\n\r\n\t\tftSeconds2 = ftSeconds;\r\n\t\tft2 = ft;\r\n\r\n\t\tdt = ft;\r\n\r\n\t\talltime += 1.f / ftSeconds;\r\n\t\tframeCount++;\r\n\r\n\t\tstd::chrono::duration<float, std::milli> totalDiff = timePoint2 - startTime;\r\n\t\tengineCore.currentTime = totalDiff.count();\r\n\r\n\t\t// LOGI(\"time: %f \\n\", engineCore.currentTime);\r\n\r\n#if LOG_FRAMES\r\n#endif\r\n\t};\r\n\r\n#if __EMSCRIPTEN__\r\n\temscripten_set_main_loop(main_loop, 0, true);\r\n#else\r\n\treturn 0;\r\n#endif\r\n\t//\tSDL_Quit();\r\n\t//\treturn 0;\r\n}\r\n","// -*- C++ -*-\n//===-------------------------- ostream -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_OSTREAM\n#define _LIBCPP_OSTREAM\n\n/*\n    ostream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ostream\n    : virtual public basic_ios<charT,traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    explicit basic_ostream(basic_streambuf<char_type,traits>* sb);\n    basic_ostream(basic_ostream&& rhs);\n    virtual ~basic_ostream();\n\n    // 27.7.2.3 Assign/swap\n    basic_ostream& operator=(const basic_ostream& rhs) = delete; // C++14\n    basic_ostream& operator=(basic_ostream&& rhs);\n    void swap(basic_ostream& rhs);\n\n    // 27.7.2.4 Prefix/suffix:\n    class sentry;\n\n    // 27.7.2.6 Formatted output:\n    basic_ostream& operator<<(basic_ostream& (*pf)(basic_ostream&));\n    basic_ostream& operator<<(basic_ios<charT, traits>& (*pf)(basic_ios<charT,traits>&));\n    basic_ostream& operator<<(ios_base& (*pf)(ios_base&));\n    basic_ostream& operator<<(bool n);\n    basic_ostream& operator<<(short n);\n    basic_ostream& operator<<(unsigned short n);\n    basic_ostream& operator<<(int n);\n    basic_ostream& operator<<(unsigned int n);\n    basic_ostream& operator<<(long n);\n    basic_ostream& operator<<(unsigned long n);\n    basic_ostream& operator<<(long long n);\n    basic_ostream& operator<<(unsigned long long n);\n    basic_ostream& operator<<(float f);\n    basic_ostream& operator<<(double f);\n    basic_ostream& operator<<(long double f);\n    basic_ostream& operator<<(const void* p);\n    basic_ostream& operator<<(basic_streambuf<char_type,traits>* sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type c);\n    basic_ostream& write(const char_type* s, streamsize n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    pos_type tellp();\n    basic_ostream& seekp(pos_type);\n    basic_ostream& seekp(off_type, ios_base::seekdir);\nprotected:\n    basic_ostream(const basic_ostream& rhs) = delete;\n    basic_ostream(basic_ostream&& rhs);\n    // 27.7.3.3 Assign/swap\n    basic_ostream& operator=(basic_ostream& rhs) = delete;\n    basic_ostream& operator=(const basic_ostream&& rhs);\n    void swap(basic_ostream& rhs);\n};\n\n// 27.7.2.6.4 character inserters\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, charT);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, char);\n\n// signed and unsigned\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, signed char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, unsigned char);\n\n// NTBS\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const charT*);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const char*);\n\n// signed and unsigned\ntemplate<class traits>\nbasic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const signed char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const unsigned char*);\n\n// swap:\ntemplate <class charT, class traits>\n  void swap(basic_ostream<charT, traits>& x, basic_ostream<charT, traits>& y);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& endl(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& ends(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& flush(basic_ostream<charT,traits>& os);\n\n// rvalue stream insertion\ntemplate <class charT, class traits, class T>\n  basic_ostream<charT, traits>&\n  operator<<(basic_ostream<charT, traits>&& os, const T& x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ios>\n#include <streambuf>\n#include <locale>\n#include <iterator>\n#include <bitset>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_ostream\n    : virtual public basic_ios<_CharT, _Traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb)\n    { this->init(__sb); }\n    virtual ~basic_ostream();\nprotected:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_ostream(basic_ostream&& __rhs);\n#endif\n\n    // 27.7.2.3 Assign/swap\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_ostream& operator=(basic_ostream&& __rhs);\n#endif\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void swap(basic_ostream& __rhs)\n    { basic_ios<char_type, traits_type>::swap(__rhs); }\n\n#ifndef _LIBCPP_CXX03_LANG\n    basic_ostream           (const basic_ostream& __rhs) = delete;\n    basic_ostream& operator=(const basic_ostream& __rhs) = delete;\n#else\n    basic_ostream           (const basic_ostream& __rhs); // not defined\n    basic_ostream& operator=(const basic_ostream& __rhs); // not defined\n#endif\npublic:\n\n    // 27.7.2.4 Prefix/suffix:\n    class _LIBCPP_TEMPLATE_VIS sentry;\n\n    // 27.7.2.6 Formatted output:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&))\n    { return __pf(*this); }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_ostream& operator<<(basic_ios<char_type, traits_type>&\n                              (*__pf)(basic_ios<char_type,traits_type>&))\n    { __pf(*this); return *this; }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_ostream& operator<<(ios_base& (*__pf)(ios_base&))\n    { __pf(*this); return *this; }\n\n    basic_ostream& operator<<(bool __n);\n    basic_ostream& operator<<(short __n);\n    basic_ostream& operator<<(unsigned short __n);\n    basic_ostream& operator<<(int __n);\n    basic_ostream& operator<<(unsigned int __n);\n    basic_ostream& operator<<(long __n);\n    basic_ostream& operator<<(unsigned long __n);\n    basic_ostream& operator<<(long long __n);\n    basic_ostream& operator<<(unsigned long long __n);\n    basic_ostream& operator<<(float __f);\n    basic_ostream& operator<<(double __f);\n    basic_ostream& operator<<(long double __f);\n    basic_ostream& operator<<(const void* __p);\n    basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type __c);\n    basic_ostream& write(const char_type* __s, streamsize __n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    pos_type tellp();\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_ostream& seekp(pos_type __pos);\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ostream() {}  // extension, intentially does not initialize\n};\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_ostream<_CharT, _Traits>::sentry\n{\n    bool __ok_;\n    basic_ostream<_CharT, _Traits>& __os_;\n\n    sentry(const sentry&); // = delete;\n    sentry& operator=(const sentry&); // = delete;\n\npublic:\n    explicit sentry(basic_ostream<_CharT, _Traits>& __os);\n    ~sentry();\n\n    _LIBCPP_ALWAYS_INLINE\n        _LIBCPP_EXPLICIT\n        operator bool() const {return __ok_;}\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os)\n    : __ok_(false),\n      __os_(__os)\n{\n    if (__os.good())\n    {\n        if (__os.tie())\n            __os.tie()->flush();\n        __ok_ = true;\n    }\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::~sentry()\n{\n    if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf)\n                      && !uncaught_exception())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__os_.rdbuf()->pubsync() == -1)\n                __os_.setstate(ios_base::badbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::basic_ostream(basic_ostream&& __rhs)\n{\n    this->move(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator=(basic_ostream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::~basic_ostream()\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            if (__sb)\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n                    _Ip __i(__sb);\n                    _Ip __eof;\n                    _Op __o(*this);\n                    size_t __c = 0;\n                    for (; __i != __eof; ++__i, ++__o, ++__c)\n                    {\n                        *__o = *__i;\n                        if (__o.failed())\n                            break;\n                    }\n                    if (__c == 0)\n                        this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    this->__set_failbit_and_consider_rethrow();\n                }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            else\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(bool __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned short>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned int>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(float __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(const void* __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\n__put_character_sequence(basic_ostream<_CharT, _Traits>& __os,\n                          const _CharT* __str, size_t __len)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 __str,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __str + __len :\n                                     __str,\n                                 __str + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c)\n{\n    return _VSTD::__put_character_sequence(__os, &__c, 1);\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, char __cn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            _CharT __c = __os.widen(__cn);\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 &__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     &__c + 1 :\n                                     &__c,\n                                 &__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, char __c)\n{\n    return _VSTD::__put_character_sequence(__os, &__c, 1);\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, signed char __c)\n{\n    return _VSTD::__put_character_sequence(__os, (char *) &__c, 1);\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, unsigned char __c)\n{\n    return _VSTD::__put_character_sequence(__os, (char *) &__c, 1);\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str, _Traits::length(__str));\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            size_t __len = char_traits<char>::length(__strn);\n            const int __bs = 100;\n            _CharT __wbb[__bs];\n            _CharT* __wb = __wbb;\n            unique_ptr<_CharT, void(*)(void*)> __h(0, free);\n            if (__len > __bs)\n            {\n                __wb = (_CharT*)malloc(__len*sizeof(_CharT));\n                if (__wb == 0)\n                    __throw_bad_alloc();\n                __h.reset(__wb);\n            }\n            for (_CharT* __p = __wb; *__strn != '\\0'; ++__strn, ++__p)\n                *__p = __os.widen(*__strn);\n            if (__pad_and_output(_Ip(__os),\n                                 __wb,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __wb + __len :\n                                     __wb,\n                                 __wb + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const char* __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str, _Traits::length(__str));\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const signed char* __str)\n{\n    const char *__s = (const char *) __str;\n    return _VSTD::__put_character_sequence(__os, __s, _Traits::length(__s));\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str)\n{\n    const char *__s = (const char *) __str;\n    return _VSTD::__put_character_sequence(__os, __s, _Traits::length(__s));\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::put(char_type __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n            _Op __o(*this);\n            *__o = __c;\n            if (__o.failed())\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this);\n        if (__sen && __n)\n        {\n            if (this->rdbuf()->sputn(__s, __n) != __n)\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::flush()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (this->rdbuf())\n        {\n            sentry __s(*this);\n            if (__s)\n            {\n                if (this->rdbuf()->pubsync() == -1)\n                    this->setstate(ios_base::badbit);\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_ostream<_CharT, _Traits>::pos_type\nbasic_ostream<_CharT, _Traits>::tellp()\n{\n    if (this->fail())\n        return pos_type(-1);\n    return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(pos_type __pos)\n{\n    sentry __s(*this);\n    if (!this->fail())\n    {\n        if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir)\n{\n    sentry __s(*this);\n    if (!this->fail())\n    {\n        if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nendl(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(__os.widen('\\n'));\n    __os.flush();\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nends(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(_CharT());\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nflush(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.flush();\n    return __os;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Stream, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_lvalue_reference<_Stream>::value &&\n    is_base_of<ios_base, _Stream>::value,\n    _Stream&&\n>::type\noperator<<(_Stream&& __os, const _Tp& __x)\n{\n    __os << __x;\n    return _VSTD::move(__os);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str.data(), __str.size());\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string_view<_CharT, _Traits> __sv)\n{\n    return _VSTD::__put_character_sequence(__os, __sv.data(), __sv.size());\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec)\n{\n    return __os << __ec.category().name() << ':' << __ec.value();\n}\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p)\n{\n    return __os << __p.get();\n}\n\ntemplate <class _CharT, class _Traits, size_t _Size>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)\n{\n    return __os << __x.template to_string<_CharT, _Traits>\n                        (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),\n                         use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ostream<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ostream<wchar_t>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_OSTREAM\n","#include <Graphics/Shader.h>\r\n#include <fstream>\r\n#include <vector>\r\n\r\nnamespace engine {\r\n}\r\n\r\nvoid checkCompileErrors(unsigned shader, std::string type, const char* shaderName)\r\n{\r\n\tint success;\r\n\tchar infoLog[1024];\r\n\tif (type != \"PROGRAM\")\r\n\t{\r\n\t\tglGetShaderiv(shader, GL_COMPILE_STATUS, &success);\r\n\t\tif (!success)\r\n\t\t{\r\n\t\t\tglGetShaderInfoLog(shader, 1024, NULL, infoLog);\r\n\t\t\tLOGI(\"ERROR::SHADER_COMPILATION_ERROR of type: %s \\n %s \\n\", type.c_str(), infoLog);\r\n            LOGI(\"In shader %s\\n\", shaderName);\r\n\t\t\tASSERT(false);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tglGetProgramiv(shader, GL_LINK_STATUS, &success);\r\n\t\tif (!success)\r\n\t\t{\r\n\t\t\tglGetProgramInfoLog(shader, 1024, NULL, infoLog);\r\n\t\t\tLOGI(\"ERROR::PROGRAM_LINKING_ERROR of type: %s \\n %s \\n\", type.c_str(), infoLog);\r\n            LOGI(\"In shader %s\\n\", shaderName);\r\n\t\t\tASSERT(false);\r\n\t\t}\r\n\t}\r\n}\r\n","#include <Graphics/SpriteRenderer.h>\r\n\r\n#include <iostream>\r\n#include <cstddef>\r\n\r\n// #define __EMSCRIPTEN__ 0\r\n\r\n\r\n#define MAP_BUFFER 1\r\n#define SOA 1\r\n\r\n//#include <graphics/error.h>\r\n\r\n// #undef _WIN32\r\n// #define _ANDROID 1\r\n\r\n// batchaus metodi oli aika hyv desktopilla ja selaimessa\r\n// mutta ei sitten mitenkn lhtenyt toimimaan androidilla\r\n\r\nnamespace engine\r\n{\r\n\tunsigned int textureBuffer, positionBuffer, indexBuffer;\r\n\tunsigned int textureSlots[32];\r\n\tunsigned int currentSlots = 0;\r\n\tunsigned int textureIndexBuffer;\r\n\tconstexpr int MAX_TEXTURES = 8;\r\n\tunsigned int VAO;\r\n\r\n\tstruct VertexDat\r\n\t{\r\n\t\tglm::vec3 position; // 4 + 4 + 4\r\n\t\tglm::vec2 uv;       // 4 + 4\r\n\t\tfloat id;           // 4\r\n\t};\r\n\r\n\tVertexDat* vertexData;\r\n\tVertexDat* start;\r\n\r\n\tfloat* positions;\r\n\tfloat* uvs;\r\n\tfloat* ids;\r\n\tunsigned int* colors;\r\n\r\n\tunsigned int POS, UVS, ID, COLOR;\r\n\r\n\tfloat* buffer[3];\r\n\tfloat* base[3];\r\n\r\n\t// unsigned int *baseColor, *bufferColor;\r\n\r\n\tvoid SpriteRenderer::Init(RenderData* renderData, int maxSize, Shader* shader)\r\n\t{\r\n\t\t// nelja vertexsia * float * att\r\n\t\tint quadBufferSize = maxSize * 4 * 3 * sizeof(float);\r\n\t\tint uvsSize = maxSize * 4 * 2 * sizeof(float);\r\n\t\tint indexBufferSize = maxSize * 6 * sizeof(float);\r\n\r\n\r\n\t\tindices = (GLuint*)malloc(indexBufferSize);\r\n\t\tthis->maxSize = maxSize;\r\n\t\tthis->maxIndicesSize = maxSize * 6;\r\n\r\n\t\tpositions = new float[maxSize * 3 * 4]; // 3 per 4\r\n\t\tuvs = new float[maxSize * 2 * 4];\r\n\t\tids = new float[maxSize * 1 * 4];\r\n\t\tcolors = new unsigned int[maxSize * 1 * 4];\r\n\r\n\r\n\t\t// buffer[ipos] = base[ipos] = positions;\r\n\t\t// buffer[iuv] = base[iuv] = uvs;\r\n\t\t// buffer[iid] = base[iid] = ids;\r\n\r\n\t\trenderData->base[ipos] = renderData->buffer[ipos] = positions;\r\n\t\trenderData->base[iuv] = renderData->buffer[iuv] = uvs;\r\n\t\trenderData->base[iid] = renderData->buffer[iid] = ids;\r\n\r\n\t\trenderData->baseColor = renderData->bufferColor = colors;\r\n\r\n\r\n#if __EMSCRIPTEN__\r\n\t\tglGenVertexArraysOES(1, &VAO);\r\n\t\tglBindVertexArrayOES(VAO);            // TODO: laita kaikki samaan niin varmaan toimii selaimessa\r\n#else\r\n\t\tglGenVertexArrays(1, &VAO);\r\n\t\tglBindVertexArray(VAO);\r\n#endif\r\n\r\n\t\tglGenBuffers(1, &positionBuffer);\r\n\r\n#if !SOA\r\n\t\tglBindBuffer(GL_ARRAY_BUFFER, positionBuffer);\r\n\t\tglBufferData(GL_ARRAY_BUFFER, maxSize * sizeof(VertexDat) * 4, NULL, GL_DYNAMIC_DRAW);\r\n#else\r\n\t\tglEnableVertexAttribArray(0);\r\n\t\tglEnableVertexAttribArray(1);\r\n\t\tglEnableVertexAttribArray(2);\r\n\t\tglEnableVertexAttribArray(3);\r\n\r\n\t\tglGenBuffers(1, &POS);\r\n\t\tglBindBuffer(GL_ARRAY_BUFFER, POS);\r\n\t\tglVertexAttribPointer(0, 3, GL_FLOAT, false, 0, 0);\r\n\t\tglBufferData(GL_ARRAY_BUFFER, maxSize * sizeof(float) * 4 * 3, NULL, GL_DYNAMIC_DRAW); // 3 nelit    4    pistett            3     positionia      floatteina\r\n\r\n\t\tglGenBuffers(1, &UVS);\r\n\t\tglBindBuffer(GL_ARRAY_BUFFER, UVS);\r\n\t\tglVertexAttribPointer(1, 2, GL_FLOAT, false, 0, 0);\r\n\t\tglBufferData(GL_ARRAY_BUFFER, maxSize * sizeof(float) * 4 * 2, NULL, GL_DYNAMIC_DRAW);\r\n\r\n\t\tglGenBuffers(1, &ID);\r\n\t\tglBindBuffer(GL_ARRAY_BUFFER, ID);\r\n\t\tglVertexAttribPointer(2, 1, GL_FLOAT, false, 0, 0);\r\n\t\tglBufferData(GL_ARRAY_BUFFER, maxSize * sizeof(float) * 4 * 1, NULL, GL_DYNAMIC_DRAW);\r\n\r\n\t\tglGenBuffers(1, &COLOR);\r\n\t\tglBindBuffer(GL_ARRAY_BUFFER, COLOR);\r\n\t\tglVertexAttribPointer(3, 4, GL_UNSIGNED_BYTE, GL_TRUE, 0, 0);\r\n\t\tglBufferData(GL_ARRAY_BUFFER, maxSize * sizeof(unsigned int) * 4 * 1, NULL, GL_DYNAMIC_DRAW);\r\n#endif\r\n\r\n\r\n#if !SOA\r\n\t\tglVertexAttribPointer(0, 3, GL_FLOAT, false, sizeof(VertexDat), 0);\r\n\t\tglVertexAttribPointer(1, 2, GL_FLOAT, false, sizeof(VertexDat), (const GLvoid*)(offsetof(VertexDat, uv)));\r\n\t\tglVertexAttribPointer(2, 1, GL_FLOAT, false, sizeof(VertexDat), (const GLvoid*)(offsetof(VertexDat, id)));\r\n#else\r\n#endif\r\n\r\n\r\n\t\tint index = 0;\r\n\t\tfor (int i = 0; i < maxSize * 6; i += 6)\r\n\t\t{\r\n\t\t\tindices[i] = index + 0;\r\n\t\t\tindices[i + 1] = index + 1;\r\n\t\t\tindices[i + 2] = index + 2;\r\n\t\t\tindices[i + 3] = index + 2;\r\n\t\t\tindices[i + 4] = index + 3;\r\n\t\t\tindices[i + 5] = index + 0;\r\n\t\t\tindex += 4;\r\n\t\t}\r\n\t\tglGenBuffers(1, &indexBuffer);\r\n\t\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n\t\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, maxSize * sizeof(GLuint) * 6, indices, GL_STATIC_DRAW);\r\n\r\n\r\n#if __EMSCRIPTEN__\r\n\t\tglBindVertexArrayOES(0);\r\n\r\n\t\t// vertexData = new VertexDat[maxSize * 4];\r\n\t\t// start = vertexData;\r\n#else\r\n\t\tglBindVertexArray(0);\r\n\r\n#if MAP_BUFFER\r\n\t\t// vertexData = new VertexDat[maxSize * 4];\r\n\t\t// start = vertexData;\r\n#else\r\n#endif\r\n\r\n#endif\r\n        glCheckError();\r\n\t\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\r\n        glCheckError();\r\n\t\tglBindBuffer(GL_ARRAY_BUFFER, 0);\r\n        glCheckError();\r\n\r\n        LOGI(\"inti pah\\n\");\r\n\t\tglCheckError();\r\n\t\tshader->use();\r\n\t\tglCheckError();\r\n#if 1\r\n\t\tint values[8]{ 0, 1, 2, 3, 4, 5, 6, 7 };\r\n\t\tshader->setInts(\"textures\", 8, values);\r\n\t\tglCheckError();\r\n#else\r\n\t\tshader->setInts(\"textures\", 8, values);\r\n\t\tshader->setInts(\"textures\", 8, values);\r\n\t\tshader->setInts(\"textures\", 8, values);\r\n\t\tshader->setInts(\"textures\", 8, values);\r\n\r\n\t\tshader->setInts(\"textures\", 8, values);\r\n\t\tshader->setInts(\"textures\", 8, values);\r\n\t\tshader->setInts(\"textures\", 8, values);\r\n\t\tshader->setInts(\"textures\", 8, values);\r\n#endif\r\n\r\n\t\tglCheckError();\r\n\t\tglCheckError();\r\n\t}\r\n\r\n\tvoid SpriteRenderer::Clear(RenderData* renderData)\r\n\t{\r\n\t\tsize = 0;\r\n\t\tindSize = 0;\r\n\t\t_currentSize = 0;\r\n\t\tcurrentSlots = 0;\r\n\r\n\r\n\t\tfor (int i = 0; i < 3; i++)\r\n\t\t{\r\n\t\t\trenderData->buffer[i] = renderData->base[i];\r\n\t\t}\r\n\t\trenderData->bufferColor = renderData->baseColor;\r\n\t\trenderData->indCount = 0;\r\n\t\trenderData->currentSlots = 0;\r\n\r\n\t\tfor (int i = 0; i < 32; i++)\r\n\t\t{\r\n\t\t\trenderData->textureSlots[i] = -1;\r\n\t\t}\r\n\r\n\t\tbuffer[0] = base[0];\r\n\t\tbuffer[1] = base[1];\r\n\t\tbuffer[2] = base[2];\r\n\r\n#if __EMSCRIPTEN__\r\n\t\tvertexData = start;\r\n#else\r\n#if MAP_BUFFER\r\n\t\tvertexData = start;\r\n#else\r\n\t\tglBindBuffer(GL_ARRAY_BUFFER, positionBuffer);\r\n\t\tvertexData = (VertexDat*)glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);\r\n#endif\r\n#endif\r\n\t}\r\n\r\n\r\n\tvoid DrawSprite()\r\n\t{\r\n\t}\r\n\r\n\tinline void SpriteRenderer::DrawSprite(float x, float y, float w, float h, float uv0, float uv1, float uv2, float uv3,\r\n\t\tint texId)\r\n\t{\r\n\t\t// if (_currentSize == maxSize)\r\n\t\t\t// ASSERT(false);\r\n\t\tbool found = false;\r\n\t\tint i = 0;\r\n\t\tfloat ts = 0.0f;\r\n\t\tfor (; i < MAX_TEXTURES; i++)\r\n\t\t{\r\n\t\t\tif (texId == textureSlots[i])\r\n\t\t\t{\r\n\t\t\t\tts = (float)(i + 1);\r\n\t\t\t\tfound = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!found)  // huom loop ^^\r\n\t\t{\r\n\t\t\ttextureSlots[currentSlots] = texId;\r\n\t\t\t++currentSlots;\r\n\t\t\tts = (float)(currentSlots);\r\n\t\t}\r\n\r\n\t\tvertexData->position = { x, y + h, 0.0f };\r\n\t\tvertexData->uv = { uv0, uv1 };\r\n\t\tvertexData->id = ts;\r\n\t\tvertexData++;\r\n\r\n\t\tvertexData->position = { x, y, 0.0f };\r\n\t\tvertexData->uv = { uv0, uv1 + uv3 };\r\n\t\tvertexData->id = ts;\r\n\t\tvertexData++;\r\n\r\n\t\tvertexData->position = { x + w, y, 0.0f };\r\n\t\tvertexData->uv = { uv0 + uv2, uv1 + uv3 };\r\n\t\tvertexData->id = ts;\r\n\t\tvertexData++;\r\n\r\n\t\tvertexData->position = { x + w, y + h, 0.0f };\r\n\t\tvertexData->uv = { uv0 + uv2, uv1 };\r\n\t\tvertexData->id = ts;\r\n\t\tvertexData++;\r\n\r\n\t\t// texIds\r\n\t\tsize += 4;\r\n\t\tindSize += 6;\r\n\t\t_currentSize += 1;\r\n\r\n\t}\r\n\r\n\tstatic float ts = 0.0f;\r\n\tvoid SpriteRenderer::setTexture(int texId)\r\n\t{\r\n\t\tbool found = false;\r\n\t\tint i = 0;\r\n\t\tfloat ts = 0.0f;\r\n\t\tfor (; i < MAX_TEXTURES; i++)\r\n\t\t{\r\n\t\t\tif (texId == textureSlots[i])\r\n\t\t\t{\r\n\t\t\t\tts = (float)(i + 1);\r\n\t\t\t\tfound = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!found)  // huom loop ^^\r\n\t\t{\r\n\t\t\ttextureSlots[currentSlots] = texId;\r\n\t\t\t++currentSlots;\r\n\t\t\tts = (float)(currentSlots);\r\n\t\t}\r\n\t}\r\n\r\n\tvoid SpriteRenderer::DrawSprite2(vec4* __restrict posSize, vec4* __restrict uv, vec4* color)\r\n\t{\r\n\t\t// if (indSize == maxIndicesSize)\r\n\t\t\t// *((int*)0) = 12;\r\n\t\t\t//ASSERT(false);\r\n\t\tassert(false);\r\n\t\tassert(false);\r\n\t\tassert(false);\r\n\t\tassert(false);\r\n\t\tassert(false);\r\n\r\n\t\tint r = (int)(color->x * 255.0f);\r\n\t\tint g = (int)(color->y * 255.0f);\r\n\t\tint b = (int)(color->w * 255.0f);\r\n\t\tint a = (int)(color->h * 255.0f);\r\n\r\n\t\tunsigned int c = (a << 24 | b << 16 | g << 8 | r);\r\n\r\n\t\t//*(buffer[icolor] + 0) = c;\r\n\t\t//*(buffer[icolor] + 1) = c;\r\n\t\t//*(buffer[icolor] + 2) = c;\r\n\t\t//*(buffer[icolor] + 3) = c;\r\n\r\n#if !SOA\r\n\t\tvertexData->position = { posSize->x, posSize->y + posSize->h, 0.0f };\r\n\t\tvertexData->uv = { uv->x, uv->y };\r\n\t\tvertexData->id = ts;\r\n\t\tvertexData++;\r\n\r\n\t\tvertexData->position = { posSize->x, posSize->y, 0.0f };\r\n\t\tvertexData->uv = { uv->x, uv->y + uv->h };\r\n\t\tvertexData->id = ts;\r\n\t\tvertexData++;\r\n\r\n\t\tvertexData->position = { posSize->x + posSize->w, posSize->y, 0.0f };\r\n\t\tvertexData->uv = { uv->x + uv->w, uv->y + uv->h };\r\n\t\tvertexData->id = ts;\r\n\t\tvertexData++;\r\n\r\n\t\tvertexData->position = { posSize->x + posSize->w, posSize->y + posSize->h, 0.0f };\r\n\t\tvertexData->uv = { uv->x + uv->w, uv->y };\r\n\t\tvertexData->id = ts;\r\n\t\tvertexData++;\r\n#else\r\n\t\t*(buffer[ipos] + 0) = posSize->x;\r\n\t\t*(buffer[ipos] + 1) = posSize->y + posSize->h;\r\n\t\t*(buffer[ipos] + 2) = 0.0f;\r\n\r\n\t\t*(buffer[ipos] + 3) = posSize->x;\r\n\t\t*(buffer[ipos] + 4) = posSize->y;\r\n\t\t*(buffer[ipos] + 5) = 0.0f;\r\n\r\n\t\t*(buffer[ipos] + 6) = posSize->x + posSize->w;\r\n\t\t*(buffer[ipos] + 7) = posSize->y;\r\n\t\t*(buffer[ipos] + 8) = 0.0f;\r\n\r\n\t\t*(buffer[ipos] + 9) = posSize->x + posSize->w;\r\n\t\t*(buffer[ipos] + 10) = posSize->y + posSize->h;\r\n\t\t*(buffer[ipos] + 11) = 0.0f;\r\n\r\n\t\tbuffer[ipos] += 12;\r\n\r\n\t\t*(buffer[iuv] + 0) = uv->x;\r\n\t\t*(buffer[iuv] + 1) = uv->y;\r\n\r\n\t\t*(buffer[iuv] + 2) = uv->x;\r\n\t\t*(buffer[iuv] + 3) = uv->y + uv->h;\r\n\r\n\t\t*(buffer[iuv] + 4) = uv->x + uv->w;\r\n\t\t*(buffer[iuv] + 5) = uv->y + uv->h;\r\n\r\n\t\t*(buffer[iuv] + 6) = uv->x + uv->w;\r\n\t\t*(buffer[iuv] + 7) = uv->y;\r\n\r\n\t\tbuffer[iuv] += 8;\r\n\r\n#if 1\r\n//\t\tmemset(buffer[iid], ts, 4 * sizeof(float));\r\n#else\r\n\t\t*(buffer[iid] + 0) = ts;\r\n\t\t*(buffer[iid] + 1) = ts;\r\n\t\t*(buffer[iid] + 2) = ts;\r\n\t\t*(buffer[iid] + 3) = ts;\r\n#endif\r\n\t\tbuffer[iid] += 4;\r\n#endif\r\n\t\tindSize += 6;\r\n\t\tglCheckError();\r\n\t}\r\n\r\n\tvoid SpriteRenderer::DrawSpriteF(float x, float y, float w, float h, float uv0, float uv1, float uv2, float uv3, int texId, bool flippedX, bool flippedY)\r\n\t{\r\n\t\tif (flippedX)\r\n\t\t{\r\n\t\t\tx += w;\r\n\t\t\tw = -w;\r\n\t\t}\r\n\r\n\t\tif (flippedY)\r\n\t\t{\r\n\t\t\ty += h;\r\n\t\t\th = -h;\r\n\t\t}\r\n\r\n\t\tDrawSprite(x, y, w, h, uv0, uv1, uv2, uv3, texId);\r\n\t}\r\n\r\n\r\n\r\n\tvoid SpriteRenderer::drawString(const char* text, int count, Vec2* position, const Font& font,\r\n\t\tunsigned int color, RenderData* data)\r\n\t{\r\n\t\tusing namespace ftgl;\r\n\r\n\t\tfloat ts = 0.0f;\r\n\t\tbool found = false;\r\n\t\tfor (int i = 0; i < MAX_TEXTURES; i++)\r\n\t\t{\r\n\t\t\tif (data->textureSlots[i] == font.getID())\r\n\t\t\t{\r\n\t\t\t\tts = (float)(i + 1);\r\n\t\t\t\tfound = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!found)\r\n\t\t{\r\n\t\t\t// if ( >= 32)\r\n\t\t\t// {\r\n\t\t\t\t// end();\r\n\t\t\t\t// flush();\r\n\t\t\t\t// begin();\r\n\t\t\t// }\r\n\t\t\tdata->textureSlots[data->currentSlots] = font.getID();\r\n\t\t\t(data->currentSlots) = data->currentSlots + 1;\r\n\t\t\tts = (float)(data->currentSlots);\r\n\t\t\t// m_TextureSlots.push_back(font.getID());\r\n\t\t\t// ts = (float)(m_TextureSlots.size());\r\n\t\t}\r\n\r\n\t\tconst Vec2 scale = font.getScale();\r\n\r\n\t\tfloat x = position->x;\r\n\r\n\t\ttexture_font_t* ftFont = font.getFTFont();\r\n\r\n\t\tfor (int i = 0; i < count; i++)\r\n\t\t{\r\n\t\t\tchar c = text[i];\r\n\t\t\ttexture_glyph_t* glyph = texture_font_get_glyph(ftFont, c);\r\n\t\t\tif (glyph != NULL)\r\n\t\t\t{\r\n\r\n\t\t\t\tif (i > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tfloat kerning = texture_glyph_get_kerning(glyph, text[i - 1]);\r\n\t\t\t\t\tx += kerning / scale.x;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfloat x0 = x + glyph->offset_x / scale.x;\r\n\t\t\t\tfloat y0 = position->y + glyph->offset_y / scale.y;\r\n\t\t\t\tfloat x1 = x0 + glyph->width / scale.x;\r\n\t\t\t\tfloat y1 = y0 - glyph->height / scale.y;\r\n\r\n\t\t\t\tfloat u0 = glyph->s0;\r\n\t\t\t\tfloat v0 = glyph->t0;\r\n\t\t\t\tfloat u1 = glyph->s1;\r\n\t\t\t\tfloat v1 = glyph->t1;\r\n\r\n\r\n\t\t\t\t*(data->bufferColor + 0) = color;\r\n\t\t\t\t*(data->bufferColor + 1) = color;\r\n\t\t\t\t*(data->bufferColor + 2) = color;\r\n\t\t\t\t*(data->bufferColor + 3) = color;\r\n\t\t\t\tdata->bufferColor += 4;\r\n\r\n\r\n\t\t\t\t*(data->buffer[ipos] + 0) = x0;\r\n\t\t\t\t*(data->buffer[ipos] + 1) = y0;\r\n\t\t\t\t*(data->buffer[ipos] + 2) = 0.0f;\r\n\r\n\t\t\t\t*(data->buffer[ipos] + 3) = x0;\r\n\t\t\t\t*(data->buffer[ipos] + 4) = y1;\r\n\t\t\t\t*(data->buffer[ipos] + 5) = 0.0f;\r\n\r\n\t\t\t\t*(data->buffer[ipos] + 6) = x1;\r\n\t\t\t\t*(data->buffer[ipos] + 7) = y1;\r\n\t\t\t\t*(data->buffer[ipos] + 8) = 0.0f;\r\n\r\n\t\t\t\t*(data->buffer[ipos] + 9) = x1;\r\n\t\t\t\t*(data->buffer[ipos] + 10) = y0;\r\n\t\t\t\t*(data->buffer[ipos] + 11) = 0.0f;\r\n\r\n\t\t\t\tdata->buffer[ipos] += 12;\r\n\r\n\t\t\t\t*(data->buffer[iuv] + 0) = u0;\r\n\t\t\t\t*(data->buffer[iuv] + 1) = v0;\r\n\r\n\t\t\t\t*(data->buffer[iuv] + 2) = u0;\r\n\t\t\t\t*(data->buffer[iuv] + 3) = v1;\r\n\r\n\t\t\t\t*(data->buffer[iuv] + 4) = u1;\r\n\t\t\t\t*(data->buffer[iuv] + 5) = v1;\r\n\r\n\t\t\t\t*(data->buffer[iuv] + 6) = u1;\r\n\t\t\t\t*(data->buffer[iuv] + 7) = v0;\r\n\r\n\t\t\t\tdata->buffer[iuv] += 8;\r\n\r\n\t\t\t\t// memset(data->buffer[iid], (int)ts, 4 * sizeof(float));\r\n\t\t\t\t*(data->buffer[iid] + 0) = ts;\r\n\t\t\t\t*(data->buffer[iid] + 1) = ts;\r\n\t\t\t\t*(data->buffer[iid] + 2) = ts;\r\n\t\t\t\t*(data->buffer[iid] + 3) = ts;\r\n\r\n\t\t\t\tdata->buffer[iid] += 4;\r\n\t\t\t\tdata->indCount += 6;\r\n\r\n\t\t\t\tx += glyph->advance_x / scale.x;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// LOGI(\"%s :\\n\", string.c_str());;\r\n\t}\r\n\r\n\r\n\r\n\r\n\tvoid SpriteRenderer::RenderLayer(Shader* shader, glm::mat4 cam, Layer* layer)\r\n\t{\r\n\t\tRender(shader, &cam, layer->data);\r\n\t}\r\n\r\n\r\n\r\n\tvoid SpriteRenderer::Render(Shader* shader, glm::mat4* cam, RenderData* renderData) {\r\n\r\n\r\n\t\t// #if __EMSCRIPTEN__ || MAP_BUFFER\r\n\t\tbuffer[ipos] = renderData->buffer[ipos];\r\n\t\tbuffer[iuv] = renderData->buffer[iuv];\r\n\t\tbuffer[iid] = renderData->buffer[iid];\r\n\r\n\t\tbase[ipos] = renderData->base[ipos];\r\n\t\tbase[iuv] = renderData->base[iuv];\r\n\t\tbase[iid] = renderData->base[iid];\r\n\r\n\r\n#if !SOA\r\n\t\tglBindBuffer(GL_ARRAY_BUFFER, positionBuffer);\r\n\r\n\t\tglBufferData(GL_ARRAY_BUFFER, (vertexData - start) * sizeof(VertexDat), start, GL_DYNAMIC_DRAW);\r\n#else\r\n\t\tglCheckError();\r\n\t\tglBindBuffer(GL_ARRAY_BUFFER, POS);\r\n\t\tglBufferData(GL_ARRAY_BUFFER, (buffer[ipos] - base[ipos]) * sizeof(float), base[ipos], GL_DYNAMIC_DRAW);\r\n\r\n\t\tglBindBuffer(GL_ARRAY_BUFFER, UVS);\r\n\t\tglBufferData(GL_ARRAY_BUFFER, (buffer[iuv] - base[iuv]) * sizeof(float), base[iuv], GL_DYNAMIC_DRAW);\r\n\r\n\t\tglBindBuffer(GL_ARRAY_BUFFER, ID);\r\n\t\tglBufferData(GL_ARRAY_BUFFER, (buffer[iid] - base[iid]) * sizeof(float), base[iid], GL_DYNAMIC_DRAW);\r\n\r\n\t\tglCheckError();\r\n\t\tglBindBuffer(GL_ARRAY_BUFFER, COLOR);\r\n\t\tglBufferData(GL_ARRAY_BUFFER, (renderData->bufferColor - renderData->baseColor) * sizeof(unsigned int), renderData->baseColor, GL_DYNAMIC_DRAW);\r\n\r\n\t\trenderData->buffer[ipos] = renderData->base[ipos];\r\n\t\trenderData->buffer[iuv] = renderData->base[iuv];\r\n\t\trenderData->buffer[iid] = renderData->base[iid];\r\n\t\trenderData->bufferColor = renderData->baseColor;\r\n\t\t// buffer[ipos] = base[ipos];\r\n\t\t// buffer[iuv] = base[iuv];\r\n\t\t// buffer[iid] = base[iid];\r\n#endif\r\n\t\t// glBufferData(GL_ARRAY_BUFFER, 0 (vertexData - start) * sizeof(VertexDat), start);\r\n\r\n\t\t// glBufferData(GL_ARRAY_BUFFER, (vertexData - start) * sizeof(VertexDat), NULL, GL_DYNAMIC_DRAW);\r\n\t\t// glBufferSubData(GL_ARRAY_BUFFER, 0, (vertexData - start) * sizeof(VertexDat), start);\r\n\r\n\t\t// vertexData = start; what\r\n// #else\r\n\t\t// glUnmapBuffer(GL_ARRAY_BUFFER);\r\n// #endif\r\n\t\t// glBindBuffer(GL_ARRAY_BUFFER, 0);\r\n\r\n\t\t// glActiveTexture(GL_TEXTURE0);\r\n\t\t// glBindTexture(GL_TEXTURE_2D, texture->getTextureId());\r\n\t\tshader->use();\r\n\t\tshader->setMat4(\"position\", *cam);\r\n\r\n\r\n#if __EMSCRIPTEN__\r\n\t\tglBindVertexArrayOES(VAO);\r\n#else\r\n\t\tglBindVertexArray(VAO);\r\n#endif\r\n\r\n\t\tfor (int i = 0; i < MAX_TEXTURES; i++)\r\n\t\t{\r\n\t\t\tif (renderData->textureSlots[i] == -1)\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tglActiveTexture(GL_TEXTURE0 + i);\r\n\t\t\tglBindTexture(GL_TEXTURE_2D, renderData->textureSlots[i]);\r\n\t\t}\r\n\r\n\t\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n\t\tglDrawElements(GL_TRIANGLES, renderData->indCount, GL_UNSIGNED_INT, 0);\r\n\r\n\r\n#if __EMSCRIPTEN__\r\n\t\tglBindVertexArrayOES(0);\r\n#else\r\n\t\tglBindVertexArray(0);\r\n#endif\r\n\t\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\r\n\r\n\t\tglCheckError();\r\n\t}\r\n\r\n}\r\n\r\n\r\n#undef SOA\r\n#undef MAP_BUFFER\r\n","#pragma once\r\n#include <string>\r\n\r\n// #include <GLES2/gl.h>\r\n#if defined(__EMSCRIPTEN__)\r\n// #include <SDL2/SDL_opengles2.h>\r\n#else\r\n#include <glad/glad.h>\r\n#endif\r\n\r\n// #include <GLES3/gl3.h>\r\n\r\n// #include <core/IO.h>\r\n// #include <core/Log.h>\r\n\r\n#include <glm/glm.hpp>\r\n#include <glm/gtc/type_ptr.hpp>\r\n\r\nvoid checkCompileErrors(unsigned int shader, std::string type, const char* shaderName);\r\n\r\nnamespace engine {\r\n\r\n\tclass Shader\r\n\t{\r\n\tpublic:\r\n\t\tunsigned int ID;\r\n\r\n\t\tShader(const char* vertexPath, const char* fragmentPath)\r\n\t\t{\r\n\t\t\tif (vertexPath == 0 && fragmentPath == 0)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// compileShaderFromFile(vertexPath, fragmentPath);\r\n\t\t}\r\n\r\n\t\tvoid SetVector3f(const GLchar *name, const glm::vec3 &value)\r\n\t\t{\r\n\t\t\tglUniform3f(glGetUniformLocation(this->ID, name), value.x, value.y, value.z);\r\n\t\t}\r\n\r\n#if 1\r\n\t\tvoid compileShaderFromFile(const char* vertexFilepath, const char* fragmentFilepath)\r\n\t\t{\r\n\t\t\tstd::string vertexCode;\r\n\t\t\tstd::string fragmentCode;\r\n\r\n\t\t\tvertexCode = engine::io::ReadEntireFileToString(vertexFilepath);\r\n\t\t\tfragmentCode = engine::io::ReadEntireFileToString(fragmentFilepath);\r\n\r\n\t\t\tconst char* vShaderCode = vertexCode.c_str();\r\n\t\t\tconst char* fShaderCode = fragmentCode.c_str();\r\n\r\n\t\t\tcompileShadersFromSource(vShaderCode, fShaderCode, vertexFilepath, fragmentFilepath);\r\n\t\t}\r\n#endif\r\n\r\n\t\tvoid compileShadersFromSource(const char * vertexSrc, const char * fragmentSrc,\r\n                const char* vertexName, const char* fragmentName)\r\n\t\t{\r\n\t\t\tunsigned int vertex, fragment;\r\n\r\n\t\t\tvertex = glCreateShader(GL_VERTEX_SHADER);\r\n\t\t\tglShaderSource(vertex, 1, &vertexSrc, NULL);\r\n\t\t\tglCompileShader(vertex);\r\n\t\t\tcheckCompileErrors(vertex, \"VERTEX\", vertexName);\r\n\r\n\t\t\t// fragment Shader\r\n\t\t\tfragment = glCreateShader(GL_FRAGMENT_SHADER);\r\n\t\t\tglShaderSource(fragment, 1, &fragmentSrc, NULL);\r\n\t\t\tglCompileShader(fragment);\r\n\t\t\tcheckCompileErrors(fragment, \"FRAGMENT\", fragmentName);\r\n\r\n\t\t\t// shader Program\r\n\t\t\tID = glCreateProgram();\r\n\t\t\tglAttachShader(ID, vertex);\r\n\t\t\tglAttachShader(ID, fragment);\r\n\t\t\tglLinkProgram(ID);\r\n\t\t\tcheckCompileErrors(ID, \"PROGRAM\", fragmentName);\r\n\r\n\t\t\t// delete the shaders as they're linked into our program now and no longer necessary\r\n\t\t\tglDeleteShader(vertex);\r\n\t\t\tglDeleteShader(fragment);\r\n\r\n\r\n\t\t}\r\n\r\n\t\t// activate the shader\r\n\t\t// ------------------------------------------------------------------------\r\n\t\tvoid use()\r\n\t\t{\r\n\t\t\tglUseProgram(ID);\r\n            glCheckError();\r\n\t\t}\r\n\t\t// utility uniform functions\r\n\t\t// ------------------------------------------------------------------------\r\n\t\tvoid setBool(const std::string &name, bool value) const\r\n\t\t{\r\n\t\t\tglUniform1i(glGetUniformLocation(ID, name.c_str()), (int)value);\r\n\t\t}\r\n\t\t// ------------------------------------------------------------------------\r\n\t\tvoid setInt(const std::string &name, int value) const\r\n\t\t{\r\n\t\t\tglUniform1i(glGetUniformLocation(ID, name.c_str()), value);\r\n\t\t}\r\n\r\n\t\tvoid setInts(const std::string &name, int count, int* values) const\r\n\t\t{\r\n\t\t\tglUniform1iv(glGetUniformLocation(ID, name.c_str()), count, values);\r\n\t\t}\r\n\r\n\t\t// ------------------------------------------------------------------------\r\n\t\tvoid setFloat(const std::string &name, float value) const\r\n\t\t{\r\n\t\t\tglUniform1f(glGetUniformLocation(ID, name.c_str()), value);\r\n\t\t}\r\n\r\n\t\tvoid setFloat2(const std::string &name, glm::vec2& value) const\r\n\t\t{\r\n\t\t\tglUniform2f(glGetUniformLocation(ID, name.c_str()), value.x, value.y);\r\n\t\t}\r\n\r\n\t\tvoid setMat4(const std::string &name, glm::mat4 value) const\r\n\t\t{\r\n            float* ptr = glm::value_ptr(value);\r\n            GLuint id = glGetUniformLocation(ID, name.c_str());\r\n\t\t\tglUniformMatrix4fv(id, 1, GL_FALSE, ptr);\r\n\t\t}\r\n\r\n\t\tvoid setFloat4(const char* name, const glm::vec4& vec4)\r\n\t\t{\r\n\t\t\tglUniform4f(glGetUniformLocation(ID, name), vec4.x, vec4.y, vec4.z, vec4.w);\r\n\t\t}\r\n\r\n\tprivate:\r\n\t\t// utility function for checking shader compilation/linking errors.\r\n\t\t// ------------------------------------------------------------------------\r\n\t};\r\n}\r\n","#include <Camera2D.h>\r\n#include <cmath>\r\n\r\nnamespace engine {\r\n\r\n\tCamera2D::Camera2D() :\r\n\t\t_needsMatrixUpdate(true),\r\n\t\t_position(0.0f, 0.0f),\r\n\t\t_cameraMatrix(1.0f),\r\n\t\t_orthoMatrix(1.0f),\r\n\t\t_scale(1.0f),\r\n\t\t_screenWidth(500),\r\n\t\t_screenHeight(500),\r\n\t\tangle(0), yaw(0), pitch(0)\r\n\t{\r\n\t}\r\n\r\n\r\n\tCamera2D::~Camera2D()\r\n\t{\r\n\t}\r\n\r\n\tvoid Camera2D::init(int screenWidth, int screenHeight)\r\n\t{\r\n\t\t_screenWidth = screenWidth;\r\n\t\t_screenHeight = screenHeight;\r\n\t\t_orthoMatrix = glm::ortho(0.0f, (float)_screenWidth, 0.0f, (float)_screenHeight);\r\n\t}\r\n\r\n\tvoid Camera2D::update()\r\n\t{\r\n\t\tif (_needsMatrixUpdate)\r\n\t\t{\r\n\t\t\t//glm::vec3 translate(-_position.x, -_position.y, 0.0f);\r\n\t\t\t//negatiivinen position,ett kun menemme ite vasemmalle kaikki muu menee oikealle  kolmas olisi kolmiulotteiselle\r\n\t\t\t//translate liikuttaa objecteja ruudussa \r\n\r\n\t\t\tglm::vec3 translate(-_position.x + _screenWidth / 2, -_position.y + _screenHeight / 2, 0.0f);  //centeroi cameran mys\r\n\t\t\t_cameraMatrix = glm::translate(_orthoMatrix, translate);\r\n\r\n\r\n\t\t\tglm::mat4 matRoll = glm::mat4(1.0f);\r\n\t\t\tglm::mat4 matPitch = glm::mat4(1.0f);\r\n\t\t\tglm::mat4 matYaw = glm::mat4(1.0f);\r\n\r\n\t\t\tmatRoll = glm::rotate(matRoll, angle, glm::vec3(0.f, 0.f, 1.0f));\r\n\t\t\tmatPitch = glm::rotate(matPitch, pitch, glm::vec3(1.0f, 0.0f, 0.0f));\r\n\t\t\tmatYaw = glm::rotate(matYaw, yaw, glm::vec3(0.0f, 1.0f, 0.0f));\r\n\r\n\t\t\tglm::mat4 rotate = matRoll * matPitch * matYaw;\r\n\r\n\t\t\t// kun yksi niin normaali eli kerrotaan yhdell | jos 0.5 zoomattu ulos ja 2.o niiin zoom in\r\n\t\t\tglm::vec3 scale(_scale, _scale, 0.0f);\r\n\t\t\t_cameraMatrix = rotate * glm::scale(glm::mat4(1.0f), scale) * _cameraMatrix;\r\n\t\t\t//camera scale^^\r\n\r\n\t\t\t_needsMatrixUpdate = false;\r\n\t\t}\r\n\t}\r\n\r\n\tvoid Camera2D::zoom(float factor)\r\n\t{\r\n\t\t_scale = _scale + factor;\r\n\t\t_needsMatrixUpdate = true;\r\n\t\tif (_scale < 0.01f)\r\n\t\t\t_scale = 0.f;\r\n\t}\r\n\r\n\tglm::vec2 Camera2D::convertScreenToWorld(glm::vec2 screenCoords)\r\n\t{\r\n\t\t//invert y direction\r\n\t\tscreenCoords.y = _screenHeight - screenCoords.y;\r\n\t\t// tehdn keskustasta 0,0\r\n\t\tscreenCoords -= glm::vec2(_screenWidth / 2, _screenHeight / 2);\r\n\t\t//scalettaa maailman koordinaatiti\r\n\t\tscreenCoords /= _scale;\r\n\t\t//translate with the camera position\r\n\t\tscreenCoords += _position;\r\n\t\treturn screenCoords;\r\n\t}\r\n\t//AABB TEST to see if the box is in the camera view\r\n\tbool Camera2D::isBoxinView(const glm::vec2 &position, const glm::vec2 &dimensions)\r\n\t{\r\n\t\tglm::vec2 scaledScreenDimensions = glm::vec2(_screenWidth, _screenHeight) / _scale;\r\n\r\n\t\tconst float MIN_DISTANCE_X = dimensions.x / 2.0f + scaledScreenDimensions.x / 2.0f;\r\n\t\tconst float MIN_DISTANCE_Y = dimensions.y / 2.0f + scaledScreenDimensions.y / 2.0f;\r\n\r\n\r\n\t\tglm::vec2 centerPos = position + dimensions / 2.0f;\r\n\r\n\t\tglm::vec2 centerCameraPos = _position;\t\t//center position of the camera\r\n\r\n\t\tglm::vec2 distVec = centerPos - centerCameraPos;\t\t\t//vector from the input to the camera\r\n\r\n\t\tfloat xDepth = MIN_DISTANCE_X - fabs(distVec.x);\r\n\t\tfloat yDepth = MIN_DISTANCE_Y - fabs(distVec.y);\r\n\r\n\t\tif (xDepth > 0 && yDepth > 0)\r\n\t\t{\r\n\r\n\t\t\t// there was a collision \r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvec4 Camera2D::getCameraRect()\r\n\t{\r\n\t\tauto bot = convertScreenToWorld({ _screenWidth, _screenHeight });\r\n\t\tauto top = convertScreenToWorld({ 0, 0 });\r\n\r\n\t\tfloat x0, y0, x1, y1;\r\n\t\tx0 = top.x;\r\n\t\ty0 = bot.y;\r\n\t\tx1 = bot.x;\r\n\t\ty1 = top.y;\r\n\r\n\t\treturn { x0, y0, x1, y1 };\r\n\t}\r\n}","/// @ref core\r\n/// @file glm/core/type_tvec2.inl\r\n\r\nnamespace glm\r\n{\r\n#\tifdef GLM_STATIC_CONST_MEMBERS\r\n\ttemplate <typename T, precision P>\r\n\tconst tvec2<T, P> tvec2<T, P>::ZERO(static_cast<T>(0), static_cast<T>(0));\r\n\r\n\ttemplate <typename T, precision P>\r\n\tconst tvec2<T, P> tvec2<T, P>::X(static_cast<T>(1), static_cast<T>(0));\r\n\r\n\ttemplate <typename T, precision P>\r\n\tconst tvec2<T, P> tvec2<T, P>::Y(static_cast<T>(0), static_cast<T>(1));\r\n\r\n\ttemplate <typename T, precision P>\r\n\tconst tvec2<T, P> tvec2<T, P>::XY(static_cast<T>(1), static_cast<T>(1));\r\n#\tendif\r\n\t// -- Implicit basic constructors --\r\n\r\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS || !defined(GLM_FORCE_NO_CTOR_INIT)\r\n\t\ttemplate <typename T, precision P>\r\n\t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec2<T, P>::tvec2()\r\n#\t\t\tifndef GLM_FORCE_NO_CTOR_INIT\r\n\t\t\t\t: x(0), y(0)\r\n#\t\t\tendif\r\n\t\t{}\r\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\r\n\r\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\r\n\t\ttemplate <typename T, precision P>\r\n\t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec2<T, P>::tvec2(tvec2<T, P> const & v)\r\n\t\t\t: x(v.x), y(v.y)\r\n\t\t{}\r\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec2<T, P>::tvec2(tvec2<T, Q> const & v)\r\n\t\t: x(v.x), y(v.y)\r\n\t{}\r\n\r\n\t// -- Explicit basic constructors --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec2<T, P>::tvec2(ctor)\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec2<T, P>::tvec2(T scalar)\r\n\t\t: x(scalar), y(scalar)\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec2<T, P>::tvec2(T s1, T s2)\r\n\t\t: x(s1), y(s2)\r\n\t{}\r\n\r\n\t// -- Conversion scalar constructors --\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec2<T, P>::tvec2(A a, B b)\r\n\t\t: x(static_cast<T>(a))\r\n\t\t, y(static_cast<T>(b))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec2<T, P>::tvec2(tvec1<A, P> const & a, tvec1<B, P> const & b)\r\n\t\t: x(static_cast<T>(a.x))\r\n\t\t, y(static_cast<T>(b.x))\r\n\t{}\r\n\r\n\t// -- Conversion vector constructors --\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U, precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec2<T, P>::tvec2(tvec2<U, Q> const & v)\r\n\t\t: x(static_cast<T>(v.x))\r\n\t\t, y(static_cast<T>(v.y))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U, precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec2<T, P>::tvec2(tvec3<U, Q> const & v)\r\n\t\t: x(static_cast<T>(v.x))\r\n\t\t, y(static_cast<T>(v.y))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U, precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec2<T, P>::tvec2(tvec4<U, Q> const & v)\r\n\t\t: x(static_cast<T>(v.x))\r\n\t\t, y(static_cast<T>(v.y))\r\n\t{}\r\n\r\n\t// -- Component accesses --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T & tvec2<T, P>::operator[](typename tvec2<T, P>::length_type i)\r\n\t{\r\n\t\tassert(i >= 0 && i < this->length());\r\n\t\treturn (&x)[i];\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T const & tvec2<T, P>::operator[](typename tvec2<T, P>::length_type i) const\r\n\t{\r\n\t\tassert(i >= 0 && i < this->length());\r\n\t\treturn (&x)[i];\r\n\t}\r\n\r\n\t// -- Unary arithmetic operators --\r\n\r\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\r\n\t\ttemplate <typename T, precision P>\r\n\t\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator=(tvec2<T, P> const & v)\r\n\t\t{\r\n\t\t\tthis->x = v.x;\r\n\t\t\tthis->y = v.y;\r\n\t\t\treturn *this;\r\n\t\t}\r\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator=(tvec2<U, P> const & v)\r\n\t{\r\n\t\tthis->x = static_cast<T>(v.x);\r\n\t\tthis->y = static_cast<T>(v.y);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator+=(U scalar)\r\n\t{\r\n\t\tthis->x += static_cast<T>(scalar);\r\n\t\tthis->y += static_cast<T>(scalar);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator+=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x += static_cast<T>(v.x);\r\n\t\tthis->y += static_cast<T>(v.x);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator+=(tvec2<U, P> const & v)\r\n\t{\r\n\t\tthis->x += static_cast<T>(v.x);\r\n\t\tthis->y += static_cast<T>(v.y);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator-=(U scalar)\r\n\t{\r\n\t\tthis->x -= static_cast<T>(scalar);\r\n\t\tthis->y -= static_cast<T>(scalar);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator-=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x -= static_cast<T>(v.x);\r\n\t\tthis->y -= static_cast<T>(v.x);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator-=(tvec2<U, P> const & v)\r\n\t{\r\n\t\tthis->x -= static_cast<T>(v.x);\r\n\t\tthis->y -= static_cast<T>(v.y);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator*=(U scalar)\r\n\t{\r\n\t\tthis->x *= static_cast<T>(scalar);\r\n\t\tthis->y *= static_cast<T>(scalar);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator*=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x *= static_cast<T>(v.x);\r\n\t\tthis->y *= static_cast<T>(v.x);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator*=(tvec2<U, P> const & v)\r\n\t{\r\n\t\tthis->x *= static_cast<T>(v.x);\r\n\t\tthis->y *= static_cast<T>(v.y);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator/=(U scalar)\r\n\t{\r\n\t\tthis->x /= static_cast<T>(scalar);\r\n\t\tthis->y /= static_cast<T>(scalar);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator/=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x /= static_cast<T>(v.x);\r\n\t\tthis->y /= static_cast<T>(v.x);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator/=(tvec2<U, P> const & v)\r\n\t{\r\n\t\tthis->x /= static_cast<T>(v.x);\r\n\t\tthis->y /= static_cast<T>(v.y);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\t// -- Increment and decrement operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator++()\r\n\t{\r\n\t\t++this->x;\r\n\t\t++this->y;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator--()\r\n\t{\r\n\t\t--this->x;\r\n\t\t--this->y;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P> \r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> tvec2<T, P>::operator++(int)\r\n\t{\r\n\t\ttvec2<T, P> Result(*this);\r\n\t\t++*this;\r\n\t\treturn Result;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P> \r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> tvec2<T, P>::operator--(int)\r\n\t{\r\n\t\ttvec2<T, P> Result(*this);\r\n\t\t--*this;\r\n\t\treturn Result;\r\n\t}\r\n\r\n\t// -- Unary bit operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator%=(U scalar)\r\n\t{\r\n\t\tthis->x %= static_cast<T>(scalar);\r\n\t\tthis->y %= static_cast<T>(scalar);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator%=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x %= static_cast<T>(v.x);\r\n\t\tthis->y %= static_cast<T>(v.x);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator%=(tvec2<U, P> const & v)\r\n\t{\r\n\t\tthis->x %= static_cast<T>(v.x);\r\n\t\tthis->y %= static_cast<T>(v.y);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator&=(U scalar)\r\n\t{\r\n\t\tthis->x &= static_cast<T>(scalar);\r\n\t\tthis->y &= static_cast<T>(scalar);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator&=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x &= static_cast<T>(v.x);\r\n\t\tthis->y &= static_cast<T>(v.x);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator&=(tvec2<U, P> const & v)\r\n\t{\r\n\t\tthis->x &= static_cast<T>(v.x);\r\n\t\tthis->y &= static_cast<T>(v.y);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator|=(U scalar)\r\n\t{\r\n\t\tthis->x |= static_cast<T>(scalar);\r\n\t\tthis->y |= static_cast<T>(scalar);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator|=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x |= static_cast<T>(v.x);\r\n\t\tthis->y |= static_cast<T>(v.x);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator|=(tvec2<U, P> const & v)\r\n\t{\r\n\t\tthis->x |= static_cast<T>(v.x);\r\n\t\tthis->y |= static_cast<T>(v.y);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator^=(U scalar)\r\n\t{\r\n\t\tthis->x ^= static_cast<T>(scalar);\r\n\t\tthis->y ^= static_cast<T>(scalar);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator^=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x ^= static_cast<T>(v.x);\r\n\t\tthis->y ^= static_cast<T>(v.x);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator^=(tvec2<U, P> const & v)\r\n\t{\r\n\t\tthis->x ^= static_cast<T>(v.x);\r\n\t\tthis->y ^= static_cast<T>(v.y);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator<<=(U scalar)\r\n\t{\r\n\t\tthis->x <<= static_cast<T>(scalar);\r\n\t\tthis->y <<= static_cast<T>(scalar);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator<<=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x <<= static_cast<T>(v.x);\r\n\t\tthis->y <<= static_cast<T>(v.x);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator<<=(tvec2<U, P> const & v)\r\n\t{\r\n\t\tthis->x <<= static_cast<T>(v.x);\r\n\t\tthis->y <<= static_cast<T>(v.y);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator>>=(U scalar)\r\n\t{\r\n\t\tthis->x >>= static_cast<T>(scalar);\r\n\t\tthis->y >>= static_cast<T>(scalar);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator>>=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x >>= static_cast<T>(v.x);\r\n\t\tthis->y >>= static_cast<T>(v.x);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> & tvec2<T, P>::operator>>=(tvec2<U, P> const & v)\r\n\t{\r\n\t\tthis->x >>= static_cast<T>(v.x);\r\n\t\tthis->y >>= static_cast<T>(v.y);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\t// -- Unary arithmetic operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator+(tvec2<T, P> const & v)\r\n\t{\r\n\t\treturn v;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator-(tvec2<T, P> const & v)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\t-v.x, \r\n\t\t\t-v.y);\r\n\t}\r\n\r\n\t// -- Binary arithmetic operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator+(tvec2<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv.x + scalar,\r\n\t\t\tv.y + scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec1<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x + v2.x,\r\n\t\t\tv1.y + v2.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator+(T scalar, tvec2<T, P> const & v)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tscalar + v.x,\r\n\t\t\tscalar + v.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator+(tvec1<T, P> const & v1, tvec2<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x + v2.x,\r\n\t\t\tv1.x + v2.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x + v2.x,\r\n\t\t\tv1.y + v2.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator-(tvec2<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv.x - scalar,\r\n\t\t\tv.y - scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec1<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x - v2.x,\r\n\t\t\tv1.y - v2.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator-(T scalar, tvec2<T, P> const & v)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tscalar - v.x,\r\n\t\t\tscalar - v.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator-(tvec1<T, P> const & v1, tvec2<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x - v2.x,\r\n\t\t\tv1.x - v2.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x - v2.x,\r\n\t\t\tv1.y - v2.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator*(tvec2<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv.x * scalar,\r\n\t\t\tv.y * scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec1<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x * v2.x,\r\n\t\t\tv1.y * v2.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator*(T scalar, tvec2<T, P> const & v)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tscalar * v.x,\r\n\t\t\tscalar * v.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator*(tvec1<T, P> const & v1, tvec2<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x * v2.x,\r\n\t\t\tv1.x * v2.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x * v2.x,\r\n\t\t\tv1.y * v2.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator/(tvec2<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv.x / scalar,\r\n\t\t\tv.y / scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec1<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x / v2.x,\r\n\t\t\tv1.y / v2.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator/(T scalar, tvec2<T, P> const & v)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tscalar / v.x,\r\n\t\t\tscalar / v.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator/(tvec1<T, P> const & v1, tvec2<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x / v2.x,\r\n\t\t\tv1.x / v2.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x / v2.x,\r\n\t\t\tv1.y / v2.y);\r\n\t}\r\n\r\n\t// -- Binary bit operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator%(tvec2<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv.x % scalar,\r\n\t\t\tv.y % scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec1<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x % v2.x,\r\n\t\t\tv1.y % v2.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator%(T scalar, tvec2<T, P> const & v)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tscalar % v.x,\r\n\t\t\tscalar % v.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator%(tvec1<T, P> const & v1, tvec2<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x % v2.x,\r\n\t\t\tv1.x % v2.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x % v2.x,\r\n\t\t\tv1.y % v2.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator&(tvec2<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv.x & scalar,\r\n\t\t\tv.y & scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec1<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x & v2.x,\r\n\t\t\tv1.y & v2.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator&(T scalar, tvec2<T, P> const & v)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tscalar & v.x,\r\n\t\t\tscalar & v.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator&(tvec1<T, P> const & v1, tvec2<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x & v2.x,\r\n\t\t\tv1.x & v2.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x & v2.x,\r\n\t\t\tv1.y & v2.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator|(tvec2<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv.x | scalar,\r\n\t\t\tv.y | scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec1<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x | v2.x,\r\n\t\t\tv1.y | v2.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator|(T scalar, tvec2<T, P> const & v)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tscalar | v.x,\r\n\t\t\tscalar | v.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator|(tvec1<T, P> const & v1, tvec2<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x | v2.x,\r\n\t\t\tv1.x | v2.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x | v2.x,\r\n\t\t\tv1.y | v2.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator^(tvec2<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv.x ^ scalar,\r\n\t\t\tv.y ^ scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec1<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x ^ v2.x,\r\n\t\t\tv1.y ^ v2.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator^(T scalar, tvec2<T, P> const & v)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tscalar ^ v.x,\r\n\t\t\tscalar ^ v.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator^(tvec1<T, P> const & v1, tvec2<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x ^ v2.x,\r\n\t\t\tv1.x ^ v2.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x ^ v2.x,\r\n\t\t\tv1.y ^ v2.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator<<(tvec2<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv.x << scalar,\r\n\t\t\tv.y << scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec1<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x << v2.x,\r\n\t\t\tv1.y << v2.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator<<(T scalar, tvec2<T, P> const & v)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tscalar << v.x,\r\n\t\t\tscalar << v.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator<<(tvec1<T, P> const & v1, tvec2<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x << v2.x,\r\n\t\t\tv1.x << v2.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x << v2.x,\r\n\t\t\tv1.y << v2.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator>>(tvec2<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv.x >> scalar,\r\n\t\t\tv.y >> scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec1<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x >> v2.x,\r\n\t\t\tv1.y >> v2.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator>>(T scalar, tvec2<T, P> const & v)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tscalar >> v.x,\r\n\t\t\tscalar >> v.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator>>(tvec1<T, P> const & v1, tvec2<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x >> v2.x,\r\n\t\t\tv1.x >> v2.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\tv1.x >> v2.x,\r\n\t\t\tv1.y >> v2.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, P> operator~(tvec2<T, P> const & v)\r\n\t{\r\n\t\treturn tvec2<T, P>(\r\n\t\t\t~v.x,\r\n\t\t\t~v.y);\r\n\t}\r\n\r\n\t// -- Boolean operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER bool operator==(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\r\n\t{\r\n\t\treturn (v1.x == v2.x) && (v1.y == v2.y);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER bool operator!=(tvec2<T, P> const & v1, tvec2<T, P> const & v2)\r\n\t{\r\n\t\treturn (v1.x != v2.x) || (v1.y != v2.y);\r\n\t}\r\n\r\n\ttemplate <precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<bool, P> operator&&(tvec2<bool, P> const & v1, tvec2<bool, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<bool, P>(v1.x && v2.x, v1.y && v2.y);\r\n\t}\r\n\r\n\ttemplate <precision P>\r\n\tGLM_FUNC_QUALIFIER tvec2<bool, P> operator||(tvec2<bool, P> const & v1, tvec2<bool, P> const & v2)\r\n\t{\r\n\t\treturn tvec2<bool, P>(v1.x || v2.x, v1.y || v2.y);\r\n\t}\r\n}//namespace glm\r\n","/// @ref core\r\n/// @file glm/detail/type_mat4x4.hpp\r\n\r\n#pragma once\r\n\r\n#include \"../fwd.hpp\"\r\n#include \"type_vec4.hpp\"\r\n#include \"type_mat.hpp\"\r\n#include <limits>\r\n#include <cstddef>\r\n\r\nnamespace glm\r\n{\r\n\ttemplate <typename T, precision P = defaultp>\r\n\tstruct tmat4x4\r\n\t{\r\n\t\ttypedef tvec4<T, P> col_type;\r\n\t\ttypedef tvec4<T, P> row_type;\r\n\t\ttypedef tmat4x4<T, P> type;\r\n\t\ttypedef tmat4x4<T, P> transpose_type;\r\n\t\ttypedef T value_type;\r\n\r\n\tprivate:\r\n\t\tcol_type value[4];\r\n\r\n\tpublic:\r\n\t\t// -- Constructors --\r\n\r\n\t\tGLM_FUNC_DECL tmat4x4() GLM_DEFAULT_CTOR;\r\n\t\tGLM_FUNC_DECL tmat4x4(tmat4x4<T, P> const & m) GLM_DEFAULT;\r\n\t\ttemplate <precision Q>\r\n\t\tGLM_FUNC_DECL tmat4x4(tmat4x4<T, Q> const & m);\r\n\r\n\t\tGLM_FUNC_DECL explicit tmat4x4(ctor);\r\n\t\tGLM_FUNC_DECL explicit tmat4x4(T const & x);\r\n\t\tGLM_FUNC_DECL tmat4x4(\r\n\t\t\tT const & x0, T const & y0, T const & z0, T const & w0,\r\n\t\t\tT const & x1, T const & y1, T const & z1, T const & w1,\r\n\t\t\tT const & x2, T const & y2, T const & z2, T const & w2,\r\n\t\t\tT const & x3, T const & y3, T const & z3, T const & w3);\r\n\t\tGLM_FUNC_DECL tmat4x4(\r\n\t\t\tcol_type const & v0,\r\n\t\t\tcol_type const & v1,\r\n\t\t\tcol_type const & v2,\r\n\t\t\tcol_type const & v3);\r\n\r\n\t\t// -- Conversions --\r\n\r\n\t\ttemplate <\r\n\t\t\ttypename X1, typename Y1, typename Z1, typename W1,\r\n\t\t\ttypename X2, typename Y2, typename Z2, typename W2,\r\n\t\t\ttypename X3, typename Y3, typename Z3, typename W3,\r\n\t\t\ttypename X4, typename Y4, typename Z4, typename W4>\r\n\t\tGLM_FUNC_DECL tmat4x4(\r\n\t\t\tX1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,\r\n\t\t\tX2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,\r\n\t\t\tX3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3,\r\n\t\t\tX4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4);\r\n\r\n\t\ttemplate <typename V1, typename V2, typename V3, typename V4>\r\n\t\tGLM_FUNC_DECL tmat4x4(\r\n\t\t\ttvec4<V1, P> const & v1,\r\n\t\t\ttvec4<V2, P> const & v2,\r\n\t\t\ttvec4<V3, P> const & v3,\r\n\t\t\ttvec4<V4, P> const & v4);\r\n\r\n\t\t// -- Matrix conversions --\r\n\r\n\t\ttemplate <typename U, precision Q>\r\n\t\tGLM_FUNC_DECL GLM_EXPLICIT tmat4x4(tmat4x4<U, Q> const & m);\r\n\r\n\t\tGLM_FUNC_DECL GLM_EXPLICIT tmat4x4(tmat2x2<T, P> const & x);\r\n\t\tGLM_FUNC_DECL GLM_EXPLICIT tmat4x4(tmat3x3<T, P> const & x);\r\n\t\tGLM_FUNC_DECL GLM_EXPLICIT tmat4x4(tmat2x3<T, P> const & x);\r\n\t\tGLM_FUNC_DECL GLM_EXPLICIT tmat4x4(tmat3x2<T, P> const & x);\r\n\t\tGLM_FUNC_DECL GLM_EXPLICIT tmat4x4(tmat2x4<T, P> const & x);\r\n\t\tGLM_FUNC_DECL GLM_EXPLICIT tmat4x4(tmat4x2<T, P> const & x);\r\n\t\tGLM_FUNC_DECL GLM_EXPLICIT tmat4x4(tmat3x4<T, P> const & x);\r\n\t\tGLM_FUNC_DECL GLM_EXPLICIT tmat4x4(tmat4x3<T, P> const & x);\r\n\r\n\t\t// -- Accesses --\r\n\r\n\t\ttypedef length_t length_type;\r\n\t\tGLM_FUNC_DECL static length_type length(){return 4;}\r\n\r\n\t\tGLM_FUNC_DECL col_type & operator[](length_type i);\r\n\t\tGLM_FUNC_DECL col_type const & operator[](length_type i) const;\r\n\r\n\t\t// -- Unary arithmetic operators --\r\n\r\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator=(tmat4x4<T, P> const & m) GLM_DEFAULT;\r\n\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator=(tmat4x4<U, P> const & m);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator+=(U s);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator+=(tmat4x4<U, P> const & m);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator-=(U s);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator-=(tmat4x4<U, P> const & m);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator*=(U s);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator*=(tmat4x4<U, P> const & m);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator/=(U s);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator/=(tmat4x4<U, P> const & m);\r\n\r\n\t\t// -- Increment and decrement operators --\r\n\r\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator++();\r\n\t\tGLM_FUNC_DECL tmat4x4<T, P> & operator--();\r\n\t\tGLM_FUNC_DECL tmat4x4<T, P> operator++(int);\r\n\t\tGLM_FUNC_DECL tmat4x4<T, P> operator--(int);\r\n\t};\r\n\r\n\t// -- Unary operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tmat4x4<T, P> operator+(tmat4x4<T, P> const & m);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tmat4x4<T, P> operator-(tmat4x4<T, P> const & m);\r\n\r\n\t// -- Binary operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tmat4x4<T, P> operator+(tmat4x4<T, P> const & m, T const & s);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tmat4x4<T, P> operator+(T const & s, tmat4x4<T, P> const & m);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tmat4x4<T, P> operator+(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tmat4x4<T, P> operator-(tmat4x4<T, P> const & m, T const & s);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tmat4x4<T, P> operator-(T const & s, tmat4x4<T, P> const & m);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tmat4x4<T, P> operator-(tmat4x4<T, P> const & m1,\ttmat4x4<T, P> const & m2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tmat4x4<T, P> operator*(tmat4x4<T, P> const & m, T const & s);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tmat4x4<T, P> operator*(T const & s, tmat4x4<T, P> const & m);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL typename tmat4x4<T, P>::col_type operator*(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL typename tmat4x4<T, P>::row_type operator*(typename tmat4x4<T, P>::col_type const & v, tmat4x4<T, P> const & m);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tmat2x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat2x4<T, P> const & m2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tmat3x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat3x4<T, P> const & m2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tmat4x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tmat4x4<T, P> operator/(tmat4x4<T, P> const & m, T const & s);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tmat4x4<T, P> operator/(T const & s, tmat4x4<T, P> const & m);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL typename tmat4x4<T, P>::col_type operator/(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL typename tmat4x4<T, P>::row_type operator/(typename tmat4x4<T, P>::col_type const & v, tmat4x4<T, P> const & m);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tmat4x4<T, P> operator/(tmat4x4<T, P> const & m1,\ttmat4x4<T, P> const & m2);\r\n\r\n\t// -- Boolean operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL bool operator==(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL bool operator!=(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);\r\n}//namespace glm\r\n\r\n#ifndef GLM_EXTERNAL_TEMPLATE\r\n#include \"type_mat4x4.inl\"\r\n#endif//GLM_EXTERNAL_TEMPLATE\r\n","/// @ref core\r\n/// @file glm/detail/type_mat4x4.inl\r\n\r\n#include \"func_matrix.hpp\"\r\n\r\nnamespace glm\r\n{\r\n\t// -- Constructors --\r\n\r\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS || !defined(GLM_FORCE_NO_CTOR_INIT)\r\n\t\ttemplate <typename T, precision P>\r\n\t\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4()\r\n\t\t{\r\n#\t\t\tifndef GLM_FORCE_NO_CTOR_INIT \r\n\t\t\t\tthis->value[0] = col_type(1, 0, 0, 0);\r\n\t\t\t\tthis->value[1] = col_type(0, 1, 0, 0);\r\n\t\t\t\tthis->value[2] = col_type(0, 0, 1, 0);\r\n\t\t\t\tthis->value[3] = col_type(0, 0, 0, 1);\r\n#\t\t\tendif\r\n\t\t}\r\n#\tendif\r\n\r\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\r\n\t\ttemplate <typename T, precision P>\r\n\t\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat4x4<T, P> const & m)\r\n\t\t{\r\n\t\t\tthis->value[0] = m[0];\r\n\t\t\tthis->value[1] = m[1];\r\n\t\t\tthis->value[2] = m[2];\r\n\t\t\tthis->value[3] = m[3];\r\n\t\t}\r\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <precision Q>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat4x4<T, Q> const & m)\r\n\t{\r\n\t\tthis->value[0] = m[0];\r\n\t\tthis->value[1] = m[1];\r\n\t\tthis->value[2] = m[2];\r\n\t\tthis->value[3] = m[3];\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(ctor)\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(T const & s)\r\n\t{\r\n\t\tthis->value[0] = col_type(s, 0, 0, 0);\r\n\t\tthis->value[1] = col_type(0, s, 0, 0);\r\n\t\tthis->value[2] = col_type(0, 0, s, 0);\r\n\t\tthis->value[3] = col_type(0, 0, 0, s);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4\r\n\t(\r\n\t\tT const & x0, T const & y0, T const & z0, T const & w0,\r\n\t\tT const & x1, T const & y1, T const & z1, T const & w1,\r\n\t\tT const & x2, T const & y2, T const & z2, T const & w2,\r\n\t\tT const & x3, T const & y3, T const & z3, T const & w3\r\n\t)\r\n\t{\r\n\t\tthis->value[0] = col_type(x0, y0, z0, w0);\r\n\t\tthis->value[1] = col_type(x1, y1, z1, w1);\r\n\t\tthis->value[2] = col_type(x2, y2, z2, w2);\r\n\t\tthis->value[3] = col_type(x3, y3, z3, w3);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4\r\n\t(\r\n\t\tcol_type const & v0,\r\n\t\tcol_type const & v1,\r\n\t\tcol_type const & v2,\r\n\t\tcol_type const & v3\r\n\t)\r\n\t{\r\n\t\tthis->value[0] = v0;\r\n\t\tthis->value[1] = v1;\r\n\t\tthis->value[2] = v2;\r\n\t\tthis->value[3] = v3;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U, precision Q>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4\r\n\t(\r\n\t\ttmat4x4<U, Q> const & m\r\n\t)\r\n\t{\r\n\t\tthis->value[0] = col_type(m[0]);\r\n\t\tthis->value[1] = col_type(m[1]);\r\n\t\tthis->value[2] = col_type(m[2]);\r\n\t\tthis->value[3] = col_type(m[3]);\r\n\t}\r\n\r\n\t// -- Conversions --\r\n\r\n\ttemplate <typename T, precision P> \r\n\ttemplate <\r\n\t\ttypename X1, typename Y1, typename Z1, typename W1,\r\n\t\ttypename X2, typename Y2, typename Z2, typename W2,\r\n\t\ttypename X3, typename Y3, typename Z3, typename W3,\r\n\t\ttypename X4, typename Y4, typename Z4, typename W4>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4\r\n\t(\r\n\t\tX1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,\r\n\t\tX2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,\r\n\t\tX3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3,\r\n\t\tX4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4\r\n\t)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<X1>::is_iec559 || std::numeric_limits<X1>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.\");\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Y1>::is_iec559 || std::numeric_limits<Y1>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.\");\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Z1>::is_iec559 || std::numeric_limits<Z1>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.\");\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<W1>::is_iec559 || std::numeric_limits<W1>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.\");\r\n\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<X2>::is_iec559 || std::numeric_limits<X2>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 5th parameter type invalid.\");\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Y2>::is_iec559 || std::numeric_limits<Y2>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 6th parameter type invalid.\");\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Z2>::is_iec559 || std::numeric_limits<Z2>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 7th parameter type invalid.\");\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<W2>::is_iec559 || std::numeric_limits<W2>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 8th parameter type invalid.\");\r\n\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<X3>::is_iec559 || std::numeric_limits<X3>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 9th parameter type invalid.\");\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Y3>::is_iec559 || std::numeric_limits<Y3>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 10th parameter type invalid.\");\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Z3>::is_iec559 || std::numeric_limits<Z3>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 11th parameter type invalid.\");\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<W3>::is_iec559 || std::numeric_limits<W3>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 12th parameter type invalid.\");\r\n\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<X4>::is_iec559 || std::numeric_limits<X4>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 13th parameter type invalid.\");\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Y4>::is_iec559 || std::numeric_limits<Y4>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 14th parameter type invalid.\");\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<Z4>::is_iec559 || std::numeric_limits<Z4>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 15th parameter type invalid.\");\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<W4>::is_iec559 || std::numeric_limits<W4>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 16th parameter type invalid.\");\r\n\r\n\t\tthis->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));\r\n\t\tthis->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));\r\n\t\tthis->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3), value_type(w3));\r\n\t\tthis->value[3] = col_type(static_cast<T>(x4), value_type(y4), value_type(z4), value_type(w4));\r\n\t}\r\n\t\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename V1, typename V2, typename V3, typename V4>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4\r\n\t(\r\n\t\ttvec4<V1, P> const & v1,\r\n\t\ttvec4<V2, P> const & v2,\r\n\t\ttvec4<V3, P> const & v3,\r\n\t\ttvec4<V4, P> const & v4\r\n\t)\t\t\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<V1>::is_iec559 || std::numeric_limits<V1>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.\");\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<V2>::is_iec559 || std::numeric_limits<V2>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.\");\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<V3>::is_iec559 || std::numeric_limits<V3>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.\");\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<V4>::is_iec559 || std::numeric_limits<V4>::is_integer || GLM_UNRESTRICTED_GENTYPE, \"*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.\");\r\n\r\n\t\tthis->value[0] = col_type(v1);\r\n\t\tthis->value[1] = col_type(v2);\r\n\t\tthis->value[2] = col_type(v3);\r\n\t\tthis->value[3] = col_type(v4);\r\n\t}\r\n\r\n\t// -- Matrix conversions --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat2x2<T, P> const & m)\r\n\t{\r\n\t\tthis->value[0] = col_type(m[0], 0, 0);\r\n\t\tthis->value[1] = col_type(m[1], 0, 0);\r\n\t\tthis->value[2] = col_type(0, 0, 1, 0);\r\n\t\tthis->value[3] = col_type(0, 0, 0, 1);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat3x3<T, P> const & m)\r\n\t{\r\n\t\tthis->value[0] = col_type(m[0], 0);\r\n\t\tthis->value[1] = col_type(m[1], 0);\r\n\t\tthis->value[2] = col_type(m[2], 0);\r\n\t\tthis->value[3] = col_type(0, 0, 0, 1);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat2x3<T, P> const & m)\r\n\t{\r\n\t\tthis->value[0] = col_type(m[0], 0);\r\n\t\tthis->value[1] = col_type(m[1], 0);\r\n\t\tthis->value[2] = col_type(0, 0, 1, 0);\r\n\t\tthis->value[3] = col_type(0, 0, 0, 1);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat3x2<T, P> const & m)\r\n\t{\r\n\t\tthis->value[0] = col_type(m[0], 0, 0);\r\n\t\tthis->value[1] = col_type(m[1], 0, 0);\r\n\t\tthis->value[2] = col_type(m[2], 1, 0);\r\n\t\tthis->value[3] = col_type(0, 0, 0, 1);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat2x4<T, P> const & m)\r\n\t{\r\n\t\tthis->value[0] = m[0];\r\n\t\tthis->value[1] = m[1];\r\n\t\tthis->value[2] = col_type(0, 0, 1, 0);\r\n\t\tthis->value[3] = col_type(0, 0, 0, 1);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat4x2<T, P> const & m)\r\n\t{\r\n\t\tthis->value[0] = col_type(m[0], 0, 0);\r\n\t\tthis->value[1] = col_type(m[1], 0, 0);\r\n\t\tthis->value[2] = col_type(0, 0, 1, 0);\r\n\t\tthis->value[3] = col_type(0, 0, 0, 1);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat3x4<T, P> const & m)\r\n\t{\r\n\t\tthis->value[0] = m[0];\r\n\t\tthis->value[1] = m[1];\r\n\t\tthis->value[2] = m[2];\r\n\t\tthis->value[3] = col_type(0, 0, 0, 1);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>::tmat4x4(tmat4x3<T, P> const & m)\r\n\t{\r\n\t\tthis->value[0] = col_type(m[0], 0);\r\n\t\tthis->value[1] = col_type(m[1], 0);\r\n\t\tthis->value[2] = col_type(m[2], 0);\r\n\t\tthis->value[3] = col_type(m[3], 1);\r\n\t}\r\n\r\n\t// -- Accesses --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER typename tmat4x4<T, P>::col_type & tmat4x4<T, P>::operator[](typename tmat4x4<T, P>::length_type i)\r\n\t{\r\n\t\tassert(i < this->length());\r\n\t\treturn this->value[i];\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER typename tmat4x4<T, P>::col_type const & tmat4x4<T, P>::operator[](typename tmat4x4<T, P>::length_type i) const\r\n\t{\r\n\t\tassert(i < this->length());\r\n\t\treturn this->value[i];\r\n\t}\r\n\r\n\t// -- Unary arithmetic operators --\r\n\r\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\r\n\t\ttemplate <typename T, precision P>\r\n\t\tGLM_FUNC_QUALIFIER tmat4x4<T, P>& tmat4x4<T, P>::operator=(tmat4x4<T, P> const & m)\r\n\t\t{\r\n\t\t\t//memcpy could be faster\r\n\t\t\t//memcpy(&this->value, &m.value, 16 * sizeof(valType));\r\n\t\t\tthis->value[0] = m[0];\r\n\t\t\tthis->value[1] = m[1];\r\n\t\t\tthis->value[2] = m[2];\r\n\t\t\tthis->value[3] = m[3];\r\n\t\t\treturn *this;\r\n\t\t}\r\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\r\n\r\n\ttemplate <typename T, precision P> \r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>& tmat4x4<T, P>::operator=(tmat4x4<U, P> const & m)\r\n\t{\r\n\t\t//memcpy could be faster\r\n\t\t//memcpy(&this->value, &m.value, 16 * sizeof(valType));\r\n\t\tthis->value[0] = m[0];\r\n\t\tthis->value[1] = m[1];\r\n\t\tthis->value[2] = m[2];\r\n\t\tthis->value[3] = m[3];\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>& tmat4x4<T, P>::operator+=(U s)\r\n\t{\r\n\t\tthis->value[0] += s;\r\n\t\tthis->value[1] += s;\r\n\t\tthis->value[2] += s;\r\n\t\tthis->value[3] += s;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P>& tmat4x4<T, P>::operator+=(tmat4x4<U, P> const & m)\r\n\t{\r\n\t\tthis->value[0] += m[0];\r\n\t\tthis->value[1] += m[1];\r\n\t\tthis->value[2] += m[2];\r\n\t\tthis->value[3] += m[3];\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator-=(U s)\r\n\t{\r\n\t\tthis->value[0] -= s;\r\n\t\tthis->value[1] -= s;\r\n\t\tthis->value[2] -= s;\r\n\t\tthis->value[3] -= s;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator-=(tmat4x4<U, P> const & m)\r\n\t{\r\n\t\tthis->value[0] -= m[0];\r\n\t\tthis->value[1] -= m[1];\r\n\t\tthis->value[2] -= m[2];\r\n\t\tthis->value[3] -= m[3];\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator*=(U s)\r\n\t{\r\n\t\tthis->value[0] *= s;\r\n\t\tthis->value[1] *= s;\r\n\t\tthis->value[2] *= s;\r\n\t\tthis->value[3] *= s;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator*=(tmat4x4<U, P> const & m)\r\n\t{\r\n\t\treturn (*this = *this * m);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator/=(U s)\r\n\t{\r\n\t\tthis->value[0] /= s;\r\n\t\tthis->value[1] /= s;\r\n\t\tthis->value[2] /= s;\r\n\t\tthis->value[3] /= s;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator/=(tmat4x4<U, P> const & m)\r\n\t{\r\n\t\treturn *this *= inverse(m);\r\n\t}\r\n\r\n\t// -- Increment and decrement operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator++()\r\n\t{\r\n\t\t++this->value[0];\r\n\t\t++this->value[1];\r\n\t\t++this->value[2];\r\n\t\t++this->value[3];\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> & tmat4x4<T, P>::operator--()\r\n\t{\r\n\t\t--this->value[0];\r\n\t\t--this->value[1];\r\n\t\t--this->value[2];\r\n\t\t--this->value[3];\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> tmat4x4<T, P>::operator++(int)\r\n\t{\r\n\t\ttmat4x4<T, P> Result(*this);\r\n\t\t++*this;\r\n\t\treturn Result;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> tmat4x4<T, P>::operator--(int)\r\n\t{\r\n\t\ttmat4x4<T, P> Result(*this);\r\n\t\t--*this;\r\n\t\treturn Result;\r\n\t}\r\n\r\n\t// -- Unary constant operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator+(tmat4x4<T, P> const & m)\r\n\t{\r\n\t\treturn m;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator-(tmat4x4<T, P> const & m)\r\n\t{\r\n\t\treturn tmat4x4<T, P>(\r\n\t\t\t-m[0],\r\n\t\t\t-m[1],\r\n\t\t\t-m[2],\r\n\t\t\t-m[3]);\r\n\t}\r\n\r\n\t// -- Binary arithmetic operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator+(tmat4x4<T, P> const & m, T const & s)\r\n\t{\r\n\t\treturn tmat4x4<T, P>(\r\n\t\t\tm[0] + s,\r\n\t\t\tm[1] + s,\r\n\t\t\tm[2] + s,\r\n\t\t\tm[3] + s);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator+(T const & s, tmat4x4<T, P> const & m)\r\n\t{\r\n\t\treturn tmat4x4<T, P>(\r\n\t\t\tm[0] + s,\r\n\t\t\tm[1] + s,\r\n\t\t\tm[2] + s,\r\n\t\t\tm[3] + s);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator+(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)\r\n\t{\r\n\t\treturn tmat4x4<T, P>(\r\n\t\t\tm1[0] + m2[0],\r\n\t\t\tm1[1] + m2[1],\r\n\t\t\tm1[2] + m2[2],\r\n\t\t\tm1[3] + m2[3]);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator-(tmat4x4<T, P> const & m, T const & s)\r\n\t{\r\n\t\treturn tmat4x4<T, P>(\r\n\t\t\tm[0] - s,\r\n\t\t\tm[1] - s,\r\n\t\t\tm[2] - s,\r\n\t\t\tm[3] - s);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator-(T const & s, tmat4x4<T, P> const & m)\r\n\t{\r\n\t\treturn tmat4x4<T, P>(\r\n\t\t\ts - m[0],\r\n\t\t\ts - m[1],\r\n\t\t\ts - m[2],\r\n\t\t\ts - m[3]);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator-(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)\r\n\t{\r\n\t\treturn tmat4x4<T, P>(\r\n\t\t\tm1[0] - m2[0],\r\n\t\t\tm1[1] - m2[1],\r\n\t\t\tm1[2] - m2[2],\r\n\t\t\tm1[3] - m2[3]);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator*(tmat4x4<T, P> const & m, T const  & s)\r\n\t{\r\n\t\treturn tmat4x4<T, P>(\r\n\t\t\tm[0] * s,\r\n\t\t\tm[1] * s,\r\n\t\t\tm[2] * s,\r\n\t\t\tm[3] * s);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator*(T const & s, tmat4x4<T, P> const & m)\r\n\t{\r\n\t\treturn tmat4x4<T, P>(\r\n\t\t\tm[0] * s,\r\n\t\t\tm[1] * s,\r\n\t\t\tm[2] * s,\r\n\t\t\tm[3] * s);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER typename tmat4x4<T, P>::col_type operator*\r\n\t(\r\n\t\ttmat4x4<T, P> const & m,\r\n\t\ttypename tmat4x4<T, P>::row_type const & v\r\n\t)\r\n\t{\r\n/*\r\n\t\t__m128 v0 = _mm_shuffle_ps(v.data, v.data, _MM_SHUFFLE(0, 0, 0, 0));\r\n\t\t__m128 v1 = _mm_shuffle_ps(v.data, v.data, _MM_SHUFFLE(1, 1, 1, 1));\r\n\t\t__m128 v2 = _mm_shuffle_ps(v.data, v.data, _MM_SHUFFLE(2, 2, 2, 2));\r\n\t\t__m128 v3 = _mm_shuffle_ps(v.data, v.data, _MM_SHUFFLE(3, 3, 3, 3));\r\n\r\n\t\t__m128 m0 = _mm_mul_ps(m[0].data, v0);\r\n\t\t__m128 m1 = _mm_mul_ps(m[1].data, v1);\r\n\t\t__m128 a0 = _mm_add_ps(m0, m1);\r\n\r\n\t\t__m128 m2 = _mm_mul_ps(m[2].data, v2);\r\n\t\t__m128 m3 = _mm_mul_ps(m[3].data, v3);\r\n\t\t__m128 a1 = _mm_add_ps(m2, m3);\r\n\r\n\t\t__m128 a2 = _mm_add_ps(a0, a1);\r\n\r\n\t\treturn typename tmat4x4<T, P>::col_type(a2);\r\n*/\r\n\r\n\t\ttypename tmat4x4<T, P>::col_type const Mov0(v[0]);\r\n\t\ttypename tmat4x4<T, P>::col_type const Mov1(v[1]);\r\n\t\ttypename tmat4x4<T, P>::col_type const Mul0 = m[0] * Mov0;\r\n\t\ttypename tmat4x4<T, P>::col_type const Mul1 = m[1] * Mov1;\r\n\t\ttypename tmat4x4<T, P>::col_type const Add0 = Mul0 + Mul1;\r\n\t\ttypename tmat4x4<T, P>::col_type const Mov2(v[2]);\r\n\t\ttypename tmat4x4<T, P>::col_type const Mov3(v[3]);\r\n\t\ttypename tmat4x4<T, P>::col_type const Mul2 = m[2] * Mov2;\r\n\t\ttypename tmat4x4<T, P>::col_type const Mul3 = m[3] * Mov3;\r\n\t\ttypename tmat4x4<T, P>::col_type const Add1 = Mul2 + Mul3;\r\n\t\ttypename tmat4x4<T, P>::col_type const Add2 = Add0 + Add1;\r\n\t\treturn Add2;\r\n\r\n/*\r\n\t\treturn typename tmat4x4<T, P>::col_type(\r\n\t\t\tm[0][0] * v[0] + m[1][0] * v[1] + m[2][0] * v[2] + m[3][0] * v[3],\r\n\t\t\tm[0][1] * v[0] + m[1][1] * v[1] + m[2][1] * v[2] + m[3][1] * v[3],\r\n\t\t\tm[0][2] * v[0] + m[1][2] * v[1] + m[2][2] * v[2] + m[3][2] * v[3],\r\n\t\t\tm[0][3] * v[0] + m[1][3] * v[1] + m[2][3] * v[2] + m[3][3] * v[3]);\r\n*/\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER typename tmat4x4<T, P>::row_type operator*\r\n\t(\r\n\t\ttypename tmat4x4<T, P>::col_type const & v,\r\n\t\ttmat4x4<T, P> const & m\r\n\t)\r\n\t{\r\n\t\treturn typename tmat4x4<T, P>::row_type(\r\n\t\t\tm[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2] + m[0][3] * v[3],\r\n\t\t\tm[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2] + m[1][3] * v[3],\r\n\t\t\tm[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2] + m[2][3] * v[3],\r\n\t\t\tm[3][0] * v[0] + m[3][1] * v[1] + m[3][2] * v[2] + m[3][3] * v[3]);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat2x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat2x4<T, P> const & m2)\r\n\t{\r\n\t\treturn tmat2x4<T, P>(\r\n\t\t\tm1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],\r\n\t\t\tm1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],\r\n\t\t\tm1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],\r\n\t\t\tm1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],\r\n\t\t\tm1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],\r\n\t\t\tm1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],\r\n\t\t\tm1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],\r\n\t\t\tm1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat3x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat3x4<T, P> const & m2)\r\n\t{\r\n\t\treturn tmat3x4<T, P>(\r\n\t\t\tm1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],\r\n\t\t\tm1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],\r\n\t\t\tm1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],\r\n\t\t\tm1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],\r\n\t\t\tm1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],\r\n\t\t\tm1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],\r\n\t\t\tm1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],\r\n\t\t\tm1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],\r\n\t\t\tm1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],\r\n\t\t\tm1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],\r\n\t\t\tm1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],\r\n\t\t\tm1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)\r\n\t{\r\n\t\ttypename tmat4x4<T, P>::col_type const SrcA0 = m1[0];\r\n\t\ttypename tmat4x4<T, P>::col_type const SrcA1 = m1[1];\r\n\t\ttypename tmat4x4<T, P>::col_type const SrcA2 = m1[2];\r\n\t\ttypename tmat4x4<T, P>::col_type const SrcA3 = m1[3];\r\n\r\n\t\ttypename tmat4x4<T, P>::col_type const SrcB0 = m2[0];\r\n\t\ttypename tmat4x4<T, P>::col_type const SrcB1 = m2[1];\r\n\t\ttypename tmat4x4<T, P>::col_type const SrcB2 = m2[2];\r\n\t\ttypename tmat4x4<T, P>::col_type const SrcB3 = m2[3];\r\n\r\n\t\ttmat4x4<T, P> Result(uninitialize);\r\n\t\tResult[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];\r\n\t\tResult[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];\r\n\t\tResult[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];\r\n\t\tResult[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];\r\n\t\treturn Result;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator/(tmat4x4<T, P> const & m, T const & s)\r\n\t{\r\n\t\treturn tmat4x4<T, P>(\r\n\t\t\tm[0] / s,\r\n\t\t\tm[1] / s,\r\n\t\t\tm[2] / s,\r\n\t\t\tm[3] / s);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator/(T const & s,\ttmat4x4<T, P> const & m)\r\n\t{\r\n\t\treturn tmat4x4<T, P>(\r\n\t\t\ts / m[0],\r\n\t\t\ts / m[1],\r\n\t\t\ts / m[2],\r\n\t\t\ts / m[3]);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER typename tmat4x4<T, P>::col_type operator/(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v)\r\n\t{\r\n\t\treturn inverse(m) * v;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER typename tmat4x4<T, P>::row_type operator/(typename tmat4x4<T, P>::col_type const & v, tmat4x4<T, P> const & m)\r\n\t{\r\n\t\treturn v * inverse(m);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> operator/(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)\r\n\t{\r\n\t\ttmat4x4<T, P> m1_copy(m1);\r\n\t\treturn m1_copy /= m2;\r\n\t}\r\n\r\n\t// -- Boolean operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER bool operator==(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)\r\n\t{\r\n\t\treturn (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER bool operator!=(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)\r\n\t{\r\n\t\treturn (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);\r\n\t}\r\n}//namespace glm\r\n\r\n#if GLM_ARCH != GLM_ARCH_PURE\r\n#\tinclude \"type_mat4x4_simd.inl\"\r\n#endif\r\n","/// @ref gtc_matrix_transform\r\n/// @file glm/gtc/matrix_transform.inl\r\n\r\n#include \"../geometric.hpp\"\r\n#include \"../trigonometric.hpp\"\r\n#include \"../matrix.hpp\"\r\n\r\nnamespace glm\r\n{\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> translate(tmat4x4<T, P> const & m, tvec3<T, P> const & v)\r\n\t{\r\n\t\ttmat4x4<T, P> Result(m);\r\n\t\tResult[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];\r\n\t\treturn Result;\r\n\t}\r\n\t\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> rotate(tmat4x4<T, P> const & m, T angle, tvec3<T, P> const & v)\r\n\t{\r\n\t\tT const a = angle;\r\n\t\tT const c = cos(a);\r\n\t\tT const s = sin(a);\r\n\r\n\t\ttvec3<T, P> axis(normalize(v));\r\n\t\ttvec3<T, P> temp((T(1) - c) * axis);\r\n\r\n\t\ttmat4x4<T, P> Rotate(uninitialize);\r\n\t\tRotate[0][0] = c + temp[0] * axis[0];\r\n\t\tRotate[0][1] = temp[0] * axis[1] + s * axis[2];\r\n\t\tRotate[0][2] = temp[0] * axis[2] - s * axis[1];\r\n\r\n\t\tRotate[1][0] = temp[1] * axis[0] - s * axis[2];\r\n\t\tRotate[1][1] = c + temp[1] * axis[1];\r\n\t\tRotate[1][2] = temp[1] * axis[2] + s * axis[0];\r\n\r\n\t\tRotate[2][0] = temp[2] * axis[0] + s * axis[1];\r\n\t\tRotate[2][1] = temp[2] * axis[1] - s * axis[0];\r\n\t\tRotate[2][2] = c + temp[2] * axis[2];\r\n\r\n\t\ttmat4x4<T, P> Result(uninitialize);\r\n\t\tResult[0] = m[0] * Rotate[0][0] + m[1] * Rotate[0][1] + m[2] * Rotate[0][2];\r\n\t\tResult[1] = m[0] * Rotate[1][0] + m[1] * Rotate[1][1] + m[2] * Rotate[1][2];\r\n\t\tResult[2] = m[0] * Rotate[2][0] + m[1] * Rotate[2][1] + m[2] * Rotate[2][2];\r\n\t\tResult[3] = m[3];\r\n\t\treturn Result;\r\n\t}\r\n\t\t\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> rotate_slow(tmat4x4<T, P> const & m, T angle, tvec3<T, P> const & v)\r\n\t{\r\n\t\tT const a = angle;\r\n\t\tT const c = cos(a);\r\n\t\tT const s = sin(a);\r\n\t\ttmat4x4<T, P> Result;\r\n\r\n\t\ttvec3<T, P> axis = normalize(v);\r\n\r\n\t\tResult[0][0] = c + (static_cast<T>(1) - c)      * axis.x     * axis.x;\r\n\t\tResult[0][1] = (static_cast<T>(1) - c) * axis.x * axis.y + s * axis.z;\r\n\t\tResult[0][2] = (static_cast<T>(1) - c) * axis.x * axis.z - s * axis.y;\r\n\t\tResult[0][3] = static_cast<T>(0);\r\n\r\n\t\tResult[1][0] = (static_cast<T>(1) - c) * axis.y * axis.x - s * axis.z;\r\n\t\tResult[1][1] = c + (static_cast<T>(1) - c) * axis.y * axis.y;\r\n\t\tResult[1][2] = (static_cast<T>(1) - c) * axis.y * axis.z + s * axis.x;\r\n\t\tResult[1][3] = static_cast<T>(0);\r\n\r\n\t\tResult[2][0] = (static_cast<T>(1) - c) * axis.z * axis.x + s * axis.y;\r\n\t\tResult[2][1] = (static_cast<T>(1) - c) * axis.z * axis.y - s * axis.x;\r\n\t\tResult[2][2] = c + (static_cast<T>(1) - c) * axis.z * axis.z;\r\n\t\tResult[2][3] = static_cast<T>(0);\r\n\r\n\t\tResult[3] = tvec4<T, P>(0, 0, 0, 1);\r\n\t\treturn m * Result;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> scale(tmat4x4<T, P> const & m, tvec3<T, P> const & v)\r\n\t{\r\n\t\ttmat4x4<T, P> Result(uninitialize);\r\n\t\tResult[0] = m[0] * v[0];\r\n\t\tResult[1] = m[1] * v[1];\r\n\t\tResult[2] = m[2] * v[2];\r\n\t\tResult[3] = m[3];\r\n\t\treturn Result;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> scale_slow(tmat4x4<T, P> const & m, tvec3<T, P> const & v)\r\n\t{\r\n\t\ttmat4x4<T, P> Result(T(1));\r\n\t\tResult[0][0] = v.x;\r\n\t\tResult[1][1] = v.y;\r\n\t\tResult[2][2] = v.z;\r\n\t\treturn m * Result;\r\n\t}\r\n\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> ortho\r\n\t(\r\n\t\tT left, T right,\r\n\t\tT bottom, T top,\r\n\t\tT zNear, T zFar\r\n\t)\r\n\t{\r\n#\t\tif GLM_COORDINATE_SYSTEM == GLM_LEFT_HANDED\r\n\t\t\treturn orthoLH(left, right, bottom, top, zNear, zFar);\r\n#\t\telse\r\n\t\t\treturn orthoRH(left, right, bottom, top, zNear, zFar);\r\n#\t\tendif\r\n\t}\r\n\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> orthoLH\r\n\t(\r\n\t\tT left, T right,\r\n\t\tT bottom, T top,\r\n\t\tT zNear, T zFar\r\n\t)\r\n\t{\r\n\t\ttmat4x4<T, defaultp> Result(1);\r\n\t\tResult[0][0] = static_cast<T>(2) / (right - left);\r\n\t\tResult[1][1] = static_cast<T>(2) / (top - bottom);\r\n\t\tResult[3][0] = - (right + left) / (right - left);\r\n\t\tResult[3][1] = - (top + bottom) / (top - bottom);\r\n\r\n#\t\tif GLM_DEPTH_CLIP_SPACE == GLM_DEPTH_ZERO_TO_ONE\r\n\t\t\tResult[2][2] = static_cast<T>(1) / (zFar - zNear);\r\n\t\t\tResult[3][2] = - zNear / (zFar - zNear);\r\n#\t\telse\r\n\t\t\tResult[2][2] = static_cast<T>(2) / (zFar - zNear);\r\n\t\t\tResult[3][2] = - (zFar + zNear) / (zFar - zNear);\r\n#\t\tendif\r\n\r\n\t\treturn Result;\r\n\t}\r\n\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> orthoRH\r\n\t(\r\n\t\tT left, T right,\r\n\t\tT bottom, T top,\r\n\t\tT zNear, T zFar\r\n\t)\r\n\t{\r\n\t\ttmat4x4<T, defaultp> Result(1);\r\n\t\tResult[0][0] = static_cast<T>(2) / (right - left);\r\n\t\tResult[1][1] = static_cast<T>(2) / (top - bottom);\r\n\t\tResult[3][0] = - (right + left) / (right - left);\r\n\t\tResult[3][1] = - (top + bottom) / (top - bottom);\r\n\r\n#\t\tif GLM_DEPTH_CLIP_SPACE == GLM_DEPTH_ZERO_TO_ONE\r\n\t\t\tResult[2][2] = - static_cast<T>(1) / (zFar - zNear);\r\n\t\t\tResult[3][2] = - zNear / (zFar - zNear);\r\n#\t\telse\r\n\t\t\tResult[2][2] = - static_cast<T>(2) / (zFar - zNear);\r\n\t\t\tResult[3][2] = - (zFar + zNear) / (zFar - zNear);\r\n#\t\tendif\r\n\r\n\t\treturn Result;\r\n\t}\r\n\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> ortho\r\n\t(\r\n\t\tT left, T right,\r\n\t\tT bottom, T top\r\n\t)\r\n\t{\r\n\t\ttmat4x4<T, defaultp> Result(static_cast<T>(1));\r\n\t\tResult[0][0] = static_cast<T>(2) / (right - left);\r\n\t\tResult[1][1] = static_cast<T>(2) / (top - bottom);\r\n\t\tResult[2][2] = - static_cast<T>(1);\r\n\t\tResult[3][0] = - (right + left) / (right - left);\r\n\t\tResult[3][1] = - (top + bottom) / (top - bottom);\r\n\t\treturn Result;\r\n\t}\r\n\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> frustum\r\n\t(\r\n\t\tT left, T right,\r\n\t\tT bottom, T top,\r\n\t\tT nearVal, T farVal\r\n\t)\r\n\t{\r\n#\t\tif GLM_COORDINATE_SYSTEM == GLM_LEFT_HANDED\r\n\t\t\treturn frustumLH(left, right, bottom, top, nearVal, farVal);\r\n#\t\telse\r\n\t\t\treturn frustumRH(left, right, bottom, top, nearVal, farVal);\r\n#\t\tendif\r\n\t}\r\n\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> frustumLH\r\n\t(\r\n\t\tT left, T right,\r\n\t\tT bottom, T top,\r\n\t\tT nearVal, T farVal\r\n\t)\r\n\t{\r\n\t\ttmat4x4<T, defaultp> Result(0);\r\n\t\tResult[0][0] = (static_cast<T>(2) * nearVal) / (right - left);\r\n\t\tResult[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);\r\n\t\tResult[2][0] = (right + left) / (right - left);\r\n\t\tResult[2][1] = (top + bottom) / (top - bottom);\r\n\t\tResult[2][3] = static_cast<T>(1);\r\n\r\n#\t\tif GLM_DEPTH_CLIP_SPACE == GLM_DEPTH_ZERO_TO_ONE\r\n\t\t\tResult[2][2] = farVal / (farVal - nearVal);\r\n\t\t\tResult[3][2] = -(farVal * nearVal) / (farVal - nearVal);\r\n#\t\telse\r\n\t\t\tResult[2][2] = (farVal + nearVal) / (farVal - nearVal);\r\n\t\t\tResult[3][2] = - (static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);\r\n#\t\tendif\r\n\r\n\t\treturn Result;\r\n\t}\r\n\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> frustumRH\r\n\t(\r\n\t\tT left, T right,\r\n\t\tT bottom, T top,\r\n\t\tT nearVal, T farVal\r\n\t)\r\n\t{\r\n\t\ttmat4x4<T, defaultp> Result(0);\r\n\t\tResult[0][0] = (static_cast<T>(2) * nearVal) / (right - left);\r\n\t\tResult[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);\r\n\t\tResult[2][0] = (right + left) / (right - left);\r\n\t\tResult[2][1] = (top + bottom) / (top - bottom);\r\n\t\tResult[2][3] = static_cast<T>(-1);\r\n\r\n#\t\tif GLM_DEPTH_CLIP_SPACE == GLM_DEPTH_ZERO_TO_ONE\r\n\t\t\tResult[2][2] = farVal / (nearVal - farVal);\r\n\t\t\tResult[3][2] = -(farVal * nearVal) / (farVal - nearVal);\r\n#\t\telse\r\n\t\t\tResult[2][2] = - (farVal + nearVal) / (farVal - nearVal);\r\n\t\t\tResult[3][2] = - (static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);\r\n#\t\tendif\r\n\r\n\t\treturn Result;\r\n\t}\r\n\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> perspective(T fovy, T aspect, T zNear, T zFar)\r\n\t{\r\n#\t\tif GLM_COORDINATE_SYSTEM == GLM_LEFT_HANDED\r\n\t\t\treturn perspectiveLH(fovy, aspect, zNear, zFar);\r\n#\t\telse\r\n\t\t\treturn perspectiveRH(fovy, aspect, zNear, zFar);\r\n#\t\tendif\r\n\t}\r\n\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> perspectiveRH(T fovy, T aspect, T zNear, T zFar)\r\n\t{\r\n\t\tassert(abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0));\r\n\r\n\t\tT const tanHalfFovy = tan(fovy / static_cast<T>(2));\r\n\r\n\t\ttmat4x4<T, defaultp> Result(static_cast<T>(0));\r\n\t\tResult[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);\r\n\t\tResult[1][1] = static_cast<T>(1) / (tanHalfFovy);\r\n\t\tResult[2][3] = - static_cast<T>(1);\r\n\r\n#\t\tif GLM_DEPTH_CLIP_SPACE == GLM_DEPTH_ZERO_TO_ONE\r\n\t\t\tResult[2][2] = zFar / (zNear - zFar);\r\n\t\t\tResult[3][2] = -(zFar * zNear) / (zFar - zNear);\r\n#\t\telse\r\n\t\t\tResult[2][2] = - (zFar + zNear) / (zFar - zNear);\r\n\t\t\tResult[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);\r\n#\t\tendif\r\n\r\n\t\treturn Result;\r\n\t}\r\n\t\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> perspectiveLH(T fovy, T aspect, T zNear, T zFar)\r\n\t{\r\n\t\tassert(abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0));\r\n\r\n\t\tT const tanHalfFovy = tan(fovy / static_cast<T>(2));\r\n\t\t\r\n\t\ttmat4x4<T, defaultp> Result(static_cast<T>(0));\r\n\t\tResult[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);\r\n\t\tResult[1][1] = static_cast<T>(1) / (tanHalfFovy);\r\n\t\tResult[2][3] = static_cast<T>(1);\r\n\r\n#\t\tif GLM_DEPTH_CLIP_SPACE == GLM_DEPTH_ZERO_TO_ONE\r\n\t\t\tResult[2][2] = zFar / (zFar - zNear);\r\n\t\t\tResult[3][2] = -(zFar * zNear) / (zFar - zNear);\r\n#\t\telse\r\n\t\t\tResult[2][2] = (zFar + zNear) / (zFar - zNear);\r\n\t\t\tResult[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);\r\n#\t\tendif\r\n\r\n\t\treturn Result;\r\n\t}\r\n\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> perspectiveFov(T fov, T width, T height, T zNear, T zFar)\r\n\t{\r\n#\t\tif GLM_COORDINATE_SYSTEM == GLM_LEFT_HANDED\r\n\t\t\treturn perspectiveFovLH(fov, width, height, zNear, zFar);\r\n#\t\telse\r\n\t\t\treturn perspectiveFovRH(fov, width, height, zNear, zFar);\r\n#\t\tendif\r\n\t}\r\n\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> perspectiveFovRH(T fov, T width, T height, T zNear, T zFar)\r\n\t{\r\n\t\tassert(width > static_cast<T>(0));\r\n\t\tassert(height > static_cast<T>(0));\r\n\t\tassert(fov > static_cast<T>(0));\r\n\t\r\n\t\tT const rad = fov;\r\n\t\tT const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);\r\n\t\tT const w = h * height / width; ///todo max(width , Height) / min(width , Height)?\r\n\r\n\t\ttmat4x4<T, defaultp> Result(static_cast<T>(0));\r\n\t\tResult[0][0] = w;\r\n\t\tResult[1][1] = h;\r\n\t\tResult[2][3] = - static_cast<T>(1);\r\n\r\n#\t\tif GLM_DEPTH_CLIP_SPACE == GLM_DEPTH_ZERO_TO_ONE\r\n\t\t\tResult[2][2] = zFar / (zNear - zFar);\r\n\t\t\tResult[3][2] = -(zFar * zNear) / (zFar - zNear);\r\n#\t\telse\r\n\t\t\tResult[2][2] = - (zFar + zNear) / (zFar - zNear);\r\n\t\t\tResult[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);\r\n#\t\tendif\r\n\r\n\t\treturn Result;\r\n\t}\r\n\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> perspectiveFovLH(T fov, T width, T height, T zNear, T zFar)\r\n\t{\r\n\t\tassert(width > static_cast<T>(0));\r\n\t\tassert(height > static_cast<T>(0));\r\n\t\tassert(fov > static_cast<T>(0));\r\n\t\r\n\t\tT const rad = fov;\r\n\t\tT const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);\r\n\t\tT const w = h * height / width; ///todo max(width , Height) / min(width , Height)?\r\n\r\n\t\ttmat4x4<T, defaultp> Result(static_cast<T>(0));\r\n\t\tResult[0][0] = w;\r\n\t\tResult[1][1] = h;\r\n\t\tResult[2][3] = static_cast<T>(1);\r\n\r\n#\t\tif GLM_DEPTH_CLIP_SPACE == GLM_DEPTH_ZERO_TO_ONE\r\n\t\t\tResult[2][2] = zFar / (zFar - zNear);\r\n\t\t\tResult[3][2] = -(zFar * zNear) / (zFar - zNear);\r\n#\t\telse\r\n\t\t\tResult[2][2] = (zFar + zNear) / (zFar - zNear);\r\n\t\t\tResult[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);\r\n#\t\tendif\r\n\r\n\t\treturn Result;\r\n\t}\r\n\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> infinitePerspective(T fovy, T aspect, T zNear)\r\n\t{\r\n#\t\tif GLM_COORDINATE_SYSTEM == GLM_LEFT_HANDED\r\n\t\t\treturn infinitePerspectiveLH(fovy, aspect, zNear);\r\n#\t\telse\r\n\t\t\treturn infinitePerspectiveRH(fovy, aspect, zNear);\r\n#\t\tendif\r\n\t}\r\n\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> infinitePerspectiveRH(T fovy, T aspect, T zNear)\r\n\t{\r\n\t\tT const range = tan(fovy / static_cast<T>(2)) * zNear;\r\n\t\tT const left = -range * aspect;\r\n\t\tT const right = range * aspect;\r\n\t\tT const bottom = -range;\r\n\t\tT const top = range;\r\n\r\n\t\ttmat4x4<T, defaultp> Result(static_cast<T>(0));\r\n\t\tResult[0][0] = (static_cast<T>(2) * zNear) / (right - left);\r\n\t\tResult[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);\r\n\t\tResult[2][2] = - static_cast<T>(1);\r\n\t\tResult[2][3] = - static_cast<T>(1);\r\n\t\tResult[3][2] = - static_cast<T>(2) * zNear;\r\n\t\treturn Result;\r\n\t}\r\n\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> infinitePerspectiveLH(T fovy, T aspect, T zNear)\r\n\t{\r\n\t\tT const range = tan(fovy / static_cast<T>(2)) * zNear;\r\n\t\tT const left = -range * aspect;\r\n\t\tT const right = range * aspect;\r\n\t\tT const bottom = -range;\r\n\t\tT const top = range;\r\n\r\n\t\ttmat4x4<T, defaultp> Result(T(0));\r\n\t\tResult[0][0] = (static_cast<T>(2) * zNear) / (right - left);\r\n\t\tResult[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);\r\n\t\tResult[2][2] = static_cast<T>(1);\r\n\t\tResult[2][3] = static_cast<T>(1);\r\n\t\tResult[3][2] = - static_cast<T>(2) * zNear;\r\n\t\treturn Result;\r\n\t}\r\n\r\n\t// Infinite projection matrix: http://www.terathon.com/gdc07_lengyel.pdf\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> tweakedInfinitePerspective(T fovy, T aspect, T zNear, T ep)\r\n\t{\r\n\t\tT const range = tan(fovy / static_cast<T>(2)) * zNear;\t\r\n\t\tT const left = -range * aspect;\r\n\t\tT const right = range * aspect;\r\n\t\tT const bottom = -range;\r\n\t\tT const top = range;\r\n\r\n\t\ttmat4x4<T, defaultp> Result(static_cast<T>(0));\r\n\t\tResult[0][0] = (static_cast<T>(2) * zNear) / (right - left);\r\n\t\tResult[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);\r\n\t\tResult[2][2] = ep - static_cast<T>(1);\r\n\t\tResult[2][3] = static_cast<T>(-1);\r\n\t\tResult[3][2] = (ep - static_cast<T>(2)) * zNear;\r\n\t\treturn Result;\r\n\t}\r\n\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> tweakedInfinitePerspective(T fovy, T aspect, T zNear)\r\n\t{\r\n\t\treturn tweakedInfinitePerspective(fovy, aspect, zNear, epsilon<T>());\r\n\t}\r\n\r\n\ttemplate <typename T, typename U, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> project\r\n\t(\r\n\t\ttvec3<T, P> const & obj,\r\n\t\ttmat4x4<T, P> const & model,\r\n\t\ttmat4x4<T, P> const & proj,\r\n\t\ttvec4<U, P> const & viewport\r\n\t)\r\n\t{\r\n\t\ttvec4<T, P> tmp = tvec4<T, P>(obj, static_cast<T>(1));\r\n\t\ttmp = model * tmp;\r\n\t\ttmp = proj * tmp;\r\n\r\n\t\ttmp /= tmp.w;\r\n#\t\tif GLM_DEPTH_CLIP_SPACE == GLM_DEPTH_ZERO_TO_ONE\r\n\t\t\ttmp.x = tmp.x * static_cast<T>(0.5) + static_cast<T>(0.5);\r\n\t\t\ttmp.y = tmp.y * static_cast<T>(0.5) + static_cast<T>(0.5);\r\n#\t\telse\r\n\t\t\ttmp = tmp * static_cast<T>(0.5) + static_cast<T>(0.5);\r\n#\t\tendif\r\n\t\ttmp[0] = tmp[0] * T(viewport[2]) + T(viewport[0]);\r\n\t\ttmp[1] = tmp[1] * T(viewport[3]) + T(viewport[1]);\r\n\r\n\t\treturn tvec3<T, P>(tmp);\r\n\t}\r\n\r\n\ttemplate <typename T, typename U, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> unProject\r\n\t(\r\n\t\ttvec3<T, P> const & win,\r\n\t\ttmat4x4<T, P> const & model,\r\n\t\ttmat4x4<T, P> const & proj,\r\n\t\ttvec4<U, P> const & viewport\r\n\t)\r\n\t{\r\n\t\ttmat4x4<T, P> Inverse = inverse(proj * model);\r\n\r\n\t\ttvec4<T, P> tmp = tvec4<T, P>(win, T(1));\r\n\t\ttmp.x = (tmp.x - T(viewport[0])) / T(viewport[2]);\r\n\t\ttmp.y = (tmp.y - T(viewport[1])) / T(viewport[3]);\r\n#\t\tif GLM_DEPTH_CLIP_SPACE == GLM_DEPTH_ZERO_TO_ONE\r\n\t\t\ttmp.x = tmp.x * static_cast<T>(2) - static_cast<T>(1);\r\n\t\t\ttmp.y = tmp.y * static_cast<T>(2) - static_cast<T>(1);\r\n#\t\telse\r\n\t\t\ttmp = tmp * static_cast<T>(2) - static_cast<T>(1);\r\n#\t\tendif\r\n\r\n\t\ttvec4<T, P> obj = Inverse * tmp;\r\n\t\tobj /= obj.w;\r\n\r\n\t\treturn tvec3<T, P>(obj);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P, typename U>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> pickMatrix(tvec2<T, P> const & center, tvec2<T, P> const & delta, tvec4<U, P> const & viewport)\r\n\t{\r\n\t\tassert(delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0));\r\n\t\ttmat4x4<T, P> Result(static_cast<T>(1));\r\n\r\n\t\tif(!(delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)))\r\n\t\t\treturn Result; // Error\r\n\r\n\t\ttvec3<T, P> Temp(\r\n\t\t\t(static_cast<T>(viewport[2]) - static_cast<T>(2) * (center.x - static_cast<T>(viewport[0]))) / delta.x,\r\n\t\t\t(static_cast<T>(viewport[3]) - static_cast<T>(2) * (center.y - static_cast<T>(viewport[1]))) / delta.y,\r\n\t\t\tstatic_cast<T>(0));\r\n\r\n\t\t// Translate and scale the picked region to the entire window\r\n\t\tResult = translate(Result, Temp);\r\n\t\treturn scale(Result, tvec3<T, P>(static_cast<T>(viewport[2]) / delta.x, static_cast<T>(viewport[3]) / delta.y, static_cast<T>(1)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> lookAt(tvec3<T, P> const & eye, tvec3<T, P> const & center, tvec3<T, P> const & up)\r\n\t{\r\n#\t\tif GLM_COORDINATE_SYSTEM == GLM_LEFT_HANDED\r\n\t\t\treturn lookAtLH(eye, center, up);\r\n#\t\telse\r\n\t\t\treturn lookAtRH(eye, center, up);\r\n#\t\tendif\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> lookAtRH\r\n\t(\r\n\t\ttvec3<T, P> const & eye,\r\n\t\ttvec3<T, P> const & center,\r\n\t\ttvec3<T, P> const & up\r\n\t)\r\n\t{\r\n\t\ttvec3<T, P> const f(normalize(center - eye));\r\n\t\ttvec3<T, P> const s(normalize(cross(f, up)));\r\n\t\ttvec3<T, P> const u(cross(s, f));\r\n\r\n\t\ttmat4x4<T, P> Result(1);\r\n\t\tResult[0][0] = s.x;\r\n\t\tResult[1][0] = s.y;\r\n\t\tResult[2][0] = s.z;\r\n\t\tResult[0][1] = u.x;\r\n\t\tResult[1][1] = u.y;\r\n\t\tResult[2][1] = u.z;\r\n\t\tResult[0][2] =-f.x;\r\n\t\tResult[1][2] =-f.y;\r\n\t\tResult[2][2] =-f.z;\r\n\t\tResult[3][0] =-dot(s, eye);\r\n\t\tResult[3][1] =-dot(u, eye);\r\n\t\tResult[3][2] = dot(f, eye);\r\n\t\treturn Result;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, P> lookAtLH\r\n\t(\r\n\t\ttvec3<T, P> const & eye,\r\n\t\ttvec3<T, P> const & center,\r\n\t\ttvec3<T, P> const & up\r\n\t)\r\n\t{\r\n\t\ttvec3<T, P> const f(normalize(center - eye));\r\n\t\ttvec3<T, P> const s(normalize(cross(up, f)));\r\n\t\ttvec3<T, P> const u(cross(f, s));\r\n\r\n\t\ttmat4x4<T, P> Result(1);\r\n\t\tResult[0][0] = s.x;\r\n\t\tResult[1][0] = s.y;\r\n\t\tResult[2][0] = s.z;\r\n\t\tResult[0][1] = u.x;\r\n\t\tResult[1][1] = u.y;\r\n\t\tResult[2][1] = u.z;\r\n\t\tResult[0][2] = f.x;\r\n\t\tResult[1][2] = f.y;\r\n\t\tResult[2][2] = f.z;\r\n\t\tResult[3][0] = -dot(s, eye);\r\n\t\tResult[3][1] = -dot(u, eye);\r\n\t\tResult[3][2] = -dot(f, eye);\r\n\t\treturn Result;\r\n\t}\r\n}//namespace glm\r\n","/// @ref core\r\n/// @file glm/detail/type_tvec3.inl\r\n\r\nnamespace glm\r\n{\r\n\r\n#\tifdef GLM_STATIC_CONST_MEMBERS\r\n\ttemplate <typename T, precision P>\r\n\tconst tvec3<T, P> tvec3<T, P>::ZERO(static_cast<T>(0), static_cast<T>(0), static_cast<T>(0));\r\n\r\n\ttemplate <typename T, precision P>\r\n\tconst tvec3<T, P> tvec3<T, P>::X(static_cast<T>(1), static_cast<T>(0), static_cast<T>(0));\r\n\r\n\ttemplate <typename T, precision P>\r\n\tconst tvec3<T, P> tvec3<T, P>::Y(static_cast<T>(0), static_cast<T>(1), static_cast<T>(0));\r\n\r\n\ttemplate <typename T, precision P>\r\n\tconst tvec3<T, P> tvec3<T, P>::Z(static_cast<T>(0), static_cast<T>(0), static_cast<T>(1));\r\n\r\n\ttemplate <typename T, precision P>\r\n\tconst tvec3<T, P> tvec3<T, P>::XY(static_cast<T>(1), static_cast<T>(1), static_cast<T>(0));\r\n\r\n\ttemplate <typename T, precision P>\r\n\tconst tvec3<T, P> tvec3<T, P>::XZ(static_cast<T>(1), static_cast<T>(0), static_cast<T>(1));\r\n\r\n\ttemplate <typename T, precision P>\r\n\tconst tvec3<T, P> tvec3<T, P>::YZ(static_cast<T>(0), static_cast<T>(1), static_cast<T>(1));\r\n\r\n\ttemplate <typename T, precision P>\r\n\tconst tvec3<T, P> tvec3<T, P>::XYZ(static_cast<T>(1), static_cast<T>(1), static_cast<T>(1));\r\n#\tendif\r\n\t// -- Implicit basic constructors --\r\n\r\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS || !defined(GLM_FORCE_NO_CTOR_INIT)\r\n\t\ttemplate <typename T, precision P>\r\n\t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3()\r\n#\t\t\tifndef GLM_FORCE_NO_CTOR_INIT \r\n\t\t\t\t: x(0), y(0), z(0)\r\n#\t\t\tendif\r\n\t\t{}\r\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\r\n\r\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\r\n\t\ttemplate <typename T, precision P>\r\n\t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(tvec3<T, P> const & v)\r\n\t\t\t: x(v.x), y(v.y), z(v.z)\r\n\t\t{}\r\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(tvec3<T, Q> const & v)\r\n\t\t: x(v.x), y(v.y), z(v.z)\r\n\t{}\r\n\r\n\t// -- Explicit basic constructors --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(ctor)\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(T scalar)\r\n\t\t: x(scalar), y(scalar), z(scalar)\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(T a, T b, T c)\r\n\t\t: x(a), y(b), z(c)\r\n\t{}\r\n\r\n\t// -- Conversion scalar constructors --\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, typename C>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(A a, B b, C c) :\r\n\t\tx(static_cast<T>(a)),\r\n\t\ty(static_cast<T>(b)),\r\n\t\tz(static_cast<T>(c))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, typename C>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c) :\r\n\t\tx(static_cast<T>(a)),\r\n\t\ty(static_cast<T>(b)),\r\n\t\tz(static_cast<T>(c))\r\n\t{}\r\n\r\n\t// -- Conversion vector constructors --\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(tvec2<A, Q> const & a, B b) :\r\n\t\tx(static_cast<T>(a.x)),\r\n\t\ty(static_cast<T>(a.y)),\r\n\t\tz(static_cast<T>(b))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(tvec2<A, Q> const & a, tvec1<B, Q> const & b) :\r\n\t\tx(static_cast<T>(a.x)),\r\n\t\ty(static_cast<T>(a.y)),\r\n\t\tz(static_cast<T>(b.x))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(A a, tvec2<B, Q> const & b) :\r\n\t\tx(static_cast<T>(a)),\r\n\t\ty(static_cast<T>(b.x)),\r\n\t\tz(static_cast<T>(b.y))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(tvec1<A, Q> const & a, tvec2<B, Q> const & b) :\r\n\t\tx(static_cast<T>(a.x)),\r\n\t\ty(static_cast<T>(b.x)),\r\n\t\tz(static_cast<T>(b.y))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U, precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(tvec3<U, Q> const & v) :\r\n\t\tx(static_cast<T>(v.x)),\r\n\t\ty(static_cast<T>(v.y)),\r\n\t\tz(static_cast<T>(v.z))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U, precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec3<T, P>::tvec3(tvec4<U, Q> const & v) :\r\n\t\tx(static_cast<T>(v.x)),\r\n\t\ty(static_cast<T>(v.y)),\r\n\t\tz(static_cast<T>(v.z))\r\n\t{}\r\n\r\n\t// -- Component accesses --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T & tvec3<T, P>::operator[](typename tvec3<T, P>::length_type i)\r\n\t{\r\n\t\tassert(i >= 0 && i < this->length());\r\n\t\treturn (&x)[i];\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T const & tvec3<T, P>::operator[](typename tvec3<T, P>::length_type i) const\r\n\t{\r\n\t\tassert(i >= 0 && i < this->length());\r\n\t\treturn (&x)[i];\r\n\t}\r\n\r\n\t// -- Unary arithmetic operators --\r\n\r\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\r\n\t\ttemplate <typename T, precision P>\r\n\t\tGLM_FUNC_QUALIFIER tvec3<T, P>& tvec3<T, P>::operator=(tvec3<T, P> const & v)\r\n\t\t{\r\n\t\t\tthis->x = v.x;\r\n\t\t\tthis->y = v.y;\r\n\t\t\tthis->z = v.z;\r\n\t\t\treturn *this;\r\n\t\t}\r\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P>& tvec3<T, P>::operator=(tvec3<U, P> const & v)\r\n\t{\r\n\t\tthis->x = static_cast<T>(v.x);\r\n\t\tthis->y = static_cast<T>(v.y);\r\n\t\tthis->z = static_cast<T>(v.z);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator+=(U scalar)\r\n\t{\r\n\t\tthis->x += static_cast<T>(scalar);\r\n\t\tthis->y += static_cast<T>(scalar);\r\n\t\tthis->z += static_cast<T>(scalar);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator+=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x += static_cast<T>(v.x);\r\n\t\tthis->y += static_cast<T>(v.x);\r\n\t\tthis->z += static_cast<T>(v.x);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator+=(tvec3<U, P> const & v)\r\n\t{\r\n\t\tthis->x += static_cast<T>(v.x);\r\n\t\tthis->y += static_cast<T>(v.y);\r\n\t\tthis->z += static_cast<T>(v.z);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator-=(U scalar)\r\n\t{\r\n\t\tthis->x -= static_cast<T>(scalar);\r\n\t\tthis->y -= static_cast<T>(scalar);\r\n\t\tthis->z -= static_cast<T>(scalar);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator-=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x -= static_cast<T>(v.x);\r\n\t\tthis->y -= static_cast<T>(v.x);\r\n\t\tthis->z -= static_cast<T>(v.x);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator-=(tvec3<U, P> const & v)\r\n\t{\r\n\t\tthis->x -= static_cast<T>(v.x);\r\n\t\tthis->y -= static_cast<T>(v.y);\r\n\t\tthis->z -= static_cast<T>(v.z);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator*=(U scalar)\r\n\t{\r\n\t\tthis->x *= static_cast<T>(scalar);\r\n\t\tthis->y *= static_cast<T>(scalar);\r\n\t\tthis->z *= static_cast<T>(scalar);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator*=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x *= static_cast<T>(v.x);\r\n\t\tthis->y *= static_cast<T>(v.x);\r\n\t\tthis->z *= static_cast<T>(v.x);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator*=(tvec3<U, P> const & v)\r\n\t{\r\n\t\tthis->x *= static_cast<T>(v.x);\r\n\t\tthis->y *= static_cast<T>(v.y);\r\n\t\tthis->z *= static_cast<T>(v.z);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator/=(U v)\r\n\t{\r\n\t\tthis->x /= static_cast<T>(v);\r\n\t\tthis->y /= static_cast<T>(v);\r\n\t\tthis->z /= static_cast<T>(v);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator/=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x /= static_cast<T>(v.x);\r\n\t\tthis->y /= static_cast<T>(v.x);\r\n\t\tthis->z /= static_cast<T>(v.x);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator/=(tvec3<U, P> const & v)\r\n\t{\r\n\t\tthis->x /= static_cast<T>(v.x);\r\n\t\tthis->y /= static_cast<T>(v.y);\r\n\t\tthis->z /= static_cast<T>(v.z);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\t// -- Increment and decrement operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator++()\r\n\t{\r\n\t\t++this->x;\r\n\t\t++this->y;\r\n\t\t++this->z;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator--()\r\n\t{\r\n\t\t--this->x;\r\n\t\t--this->y;\r\n\t\t--this->z;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> tvec3<T, P>::operator++(int)\r\n\t{\r\n\t\ttvec3<T, P> Result(*this);\r\n\t\t++*this;\r\n\t\treturn Result;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> tvec3<T, P>::operator--(int)\r\n\t{\r\n\t\ttvec3<T, P> Result(*this);\r\n\t\t--*this;\r\n\t\treturn Result;\r\n\t}\r\n\r\n\t// -- Unary bit operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator%=(U scalar)\r\n\t{\r\n\t\tthis->x %= scalar;\r\n\t\tthis->y %= scalar;\r\n\t\tthis->z %= scalar;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator%=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x %= v.x;\r\n\t\tthis->y %= v.x;\r\n\t\tthis->z %= v.x;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator%=(tvec3<U, P> const & v)\r\n\t{\r\n\t\tthis->x %= v.x;\r\n\t\tthis->y %= v.y;\r\n\t\tthis->z %= v.z;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator&=(U scalar)\r\n\t{\r\n\t\tthis->x &= scalar;\r\n\t\tthis->y &= scalar;\r\n\t\tthis->z &= scalar;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator&=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x &= v.x;\r\n\t\tthis->y &= v.x;\r\n\t\tthis->z &= v.x;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator&=(tvec3<U, P> const & v)\r\n\t{\r\n\t\tthis->x &= v.x;\r\n\t\tthis->y &= v.y;\r\n\t\tthis->z &= v.z;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator|=(U scalar)\r\n\t{\r\n\t\tthis->x |= scalar;\r\n\t\tthis->y |= scalar;\r\n\t\tthis->z |= scalar;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator|=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x |= v.x;\r\n\t\tthis->y |= v.x;\r\n\t\tthis->z |= v.x;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator|=(tvec3<U, P> const & v)\r\n\t{\r\n\t\tthis->x |= v.x;\r\n\t\tthis->y |= v.y;\r\n\t\tthis->z |= v.z;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator^=(U scalar)\r\n\t{\r\n\t\tthis->x ^= scalar;\r\n\t\tthis->y ^= scalar;\r\n\t\tthis->z ^= scalar;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator^=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x ^= v.x;\r\n\t\tthis->y ^= v.x;\r\n\t\tthis->z ^= v.x;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator^=(tvec3<U, P> const & v)\r\n\t{\r\n\t\tthis->x ^= v.x;\r\n\t\tthis->y ^= v.y;\r\n\t\tthis->z ^= v.z;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator<<=(U scalar)\r\n\t{\r\n\t\tthis->x <<= scalar;\r\n\t\tthis->y <<= scalar;\r\n\t\tthis->z <<= scalar;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator<<=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x <<= static_cast<T>(v.x);\r\n\t\tthis->y <<= static_cast<T>(v.x);\r\n\t\tthis->z <<= static_cast<T>(v.x);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator<<=(tvec3<U, P> const & v)\r\n\t{\r\n\t\tthis->x <<= static_cast<T>(v.x);\r\n\t\tthis->y <<= static_cast<T>(v.y);\r\n\t\tthis->z <<= static_cast<T>(v.z);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator>>=(U scalar)\r\n\t{\r\n\t\tthis->x >>= static_cast<T>(scalar);\r\n\t\tthis->y >>= static_cast<T>(scalar);\r\n\t\tthis->z >>= static_cast<T>(scalar);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator>>=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x >>= static_cast<T>(v.x);\r\n\t\tthis->y >>= static_cast<T>(v.x);\r\n\t\tthis->z >>= static_cast<T>(v.x);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator>>=(tvec3<U, P> const & v)\r\n\t{\r\n\t\tthis->x >>= static_cast<T>(v.x);\r\n\t\tthis->y >>= static_cast<T>(v.y);\r\n\t\tthis->z >>= static_cast<T>(v.z);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\t// -- Unary arithmetic operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn v;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\t-v.x, \r\n\t\t\t-v.y, \r\n\t\t\t-v.z);\r\n\t}\r\n\r\n\t// -- Binary arithmetic operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(tvec3<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x + scalar,\r\n\t\t\tv.y + scalar,\r\n\t\t\tv.z + scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x + scalar.x,\r\n\t\t\tv.y + scalar.x,\r\n\t\t\tv.z + scalar.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(T scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar + v.x,\r\n\t\t\tscalar + v.y,\r\n\t\t\tscalar + v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar.x + v.x,\r\n\t\t\tscalar.x + v.y,\r\n\t\t\tscalar.x + v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv1.x + v2.x,\r\n\t\t\tv1.y + v2.y,\r\n\t\t\tv1.z + v2.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(tvec3<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x - scalar,\r\n\t\t\tv.y - scalar,\r\n\t\t\tv.z - scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x - scalar.x,\r\n\t\t\tv.y - scalar.x,\r\n\t\t\tv.z - scalar.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(T scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar - v.x,\r\n\t\t\tscalar - v.y,\r\n\t\t\tscalar - v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar.x - v.x,\r\n\t\t\tscalar.x - v.y,\r\n\t\t\tscalar.x - v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv1.x - v2.x,\r\n\t\t\tv1.y - v2.y,\r\n\t\t\tv1.z - v2.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator*(tvec3<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x * scalar,\r\n\t\t\tv.y * scalar,\r\n\t\t\tv.z * scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator*(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x * scalar.x,\r\n\t\t\tv.y * scalar.x,\r\n\t\t\tv.z * scalar.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator*(T scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar * v.x,\r\n\t\t\tscalar * v.y,\r\n\t\t\tscalar * v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator*(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar.x * v.x,\r\n\t\t\tscalar.x * v.y,\r\n\t\t\tscalar.x * v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator*(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv1.x * v2.x,\r\n\t\t\tv1.y * v2.y,\r\n\t\t\tv1.z * v2.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator/(tvec3<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x / scalar,\r\n\t\t\tv.y / scalar,\r\n\t\t\tv.z / scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator/(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x / scalar.x,\r\n\t\t\tv.y / scalar.x,\r\n\t\t\tv.z / scalar.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator/(T scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar / v.x,\r\n\t\t\tscalar / v.y,\r\n\t\t\tscalar / v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator/(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar.x / v.x,\r\n\t\t\tscalar.x / v.y,\r\n\t\t\tscalar.x / v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator/(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv1.x / v2.x,\r\n\t\t\tv1.y / v2.y,\r\n\t\t\tv1.z / v2.z);\r\n\t}\r\n\r\n\t// -- Binary bit operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator%(tvec3<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x % scalar,\r\n\t\t\tv.y % scalar,\r\n\t\t\tv.z % scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator%(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x % scalar.x,\r\n\t\t\tv.y % scalar.x,\r\n\t\t\tv.z % scalar.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator%(T scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar % v.x,\r\n\t\t\tscalar % v.y,\r\n\t\t\tscalar % v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator%(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar.x % v.x,\r\n\t\t\tscalar.x % v.y,\r\n\t\t\tscalar.x % v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator%(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv1.x % v2.x,\r\n\t\t\tv1.y % v2.y,\r\n\t\t\tv1.z % v2.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator&(tvec3<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x & scalar,\r\n\t\t\tv.y & scalar,\r\n\t\t\tv.z & scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator&(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x & scalar.x,\r\n\t\t\tv.y & scalar.x,\r\n\t\t\tv.z & scalar.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator&(T scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar & v.x,\r\n\t\t\tscalar & v.y,\r\n\t\t\tscalar & v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator&(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar.x & v.x,\r\n\t\t\tscalar.x & v.y,\r\n\t\t\tscalar.x & v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator&(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv1.x & v2.x,\r\n\t\t\tv1.y & v2.y,\r\n\t\t\tv1.z & v2.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator|(tvec3<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x | scalar,\r\n\t\t\tv.y | scalar,\r\n\t\t\tv.z | scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator|(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x | scalar.x,\r\n\t\t\tv.y | scalar.x,\r\n\t\t\tv.z | scalar.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator|(T scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar | v.x,\r\n\t\t\tscalar | v.y,\r\n\t\t\tscalar | v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator|(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar.x | v.x,\r\n\t\t\tscalar.x | v.y,\r\n\t\t\tscalar.x | v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator|(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv1.x | v2.x,\r\n\t\t\tv1.y | v2.y,\r\n\t\t\tv1.z | v2.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator^(tvec3<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x ^ scalar,\r\n\t\t\tv.y ^ scalar,\r\n\t\t\tv.z ^ scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator^(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x ^ scalar.x,\r\n\t\t\tv.y ^ scalar.x,\r\n\t\t\tv.z ^ scalar.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator^(T scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar ^ v.x,\r\n\t\t\tscalar ^ v.y,\r\n\t\t\tscalar ^ v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator^(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar.x ^ v.x,\r\n\t\t\tscalar.x ^ v.y,\r\n\t\t\tscalar.x ^ v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator^(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv1.x ^ v2.x,\r\n\t\t\tv1.y ^ v2.y,\r\n\t\t\tv1.z ^ v2.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator<<(tvec3<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x << scalar,\r\n\t\t\tv.y << scalar,\r\n\t\t\tv.z << scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator<<(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x << scalar.x,\r\n\t\t\tv.y << scalar.x,\r\n\t\t\tv.z << scalar.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator<<(T scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar << v.x,\r\n\t\t\tscalar << v.y,\r\n\t\t\tscalar << v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator<<(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar.x << v.x,\r\n\t\t\tscalar.x << v.y,\r\n\t\t\tscalar.x << v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator<<(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv1.x << v2.x,\r\n\t\t\tv1.y << v2.y,\r\n\t\t\tv1.z << v2.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator>>(tvec3<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x >> scalar,\r\n\t\t\tv.y >> scalar,\r\n\t\t\tv.z >> scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator>>(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x >> scalar.x,\r\n\t\t\tv.y >> scalar.x,\r\n\t\t\tv.z >> scalar.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator>>(T scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar >> v.x,\r\n\t\t\tscalar >> v.y,\r\n\t\t\tscalar >> v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator>>(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar.x >> v.x,\r\n\t\t\tscalar.x >> v.y,\r\n\t\t\tscalar.x >> v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator>>(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv1.x >> v2.x,\r\n\t\t\tv1.y >> v2.y,\r\n\t\t\tv1.z >> v2.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator~(tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\t~v.x,\r\n\t\t\t~v.y,\r\n\t\t\t~v.z);\r\n\t}\r\n\r\n\t// -- Boolean operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER bool operator==(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER bool operator!=(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z);\r\n\t}\r\n\r\n\ttemplate <precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<bool, P> operator&&(tvec3<bool, P> const & v1, tvec3<bool, P> const & v2)\r\n\t{\r\n\t\treturn tvec3<bool, P>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z);\r\n\t}\r\n\r\n\ttemplate <precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<bool, P> operator||(tvec3<bool, P> const & v1, tvec3<bool, P> const & v2)\r\n\t{\r\n\t\treturn tvec3<bool, P>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z);\r\n\t}\r\n}//namespace glm\r\n","#pragma once\r\n\r\n#if defined(__EMSCRIPTEN__)\r\n#include <SDL2/SDL_opengles2.h>\r\n//#include <GLES3/gl3.h>\r\n#else\r\n// #include <GLES3/gl3.h>\r\n#include <glad/glad.h>\r\n#endif \r\n\r\n\r\n#include <glm/detail/type_vec2.hpp>\r\n#include <glm/detail/type_vec3.hpp>\r\n#include \"Graphics/Shader.h\"\r\n\r\n// #include <stdlib.h>\r\n// #include <vector>\r\n\r\n// #include \"graphics/GraphicsSystem.h\"\r\n// #include <core/Texture2D.h>\r\n// #include <core/Utils.h>\r\n\r\n\r\nnamespace engine {\r\n\tclass LineRenderer\r\n\t{\r\n\tpublic:\r\n\t\tLineRenderer();\r\n\r\n\t\tvoid Init();\r\n\r\n\t\t~LineRenderer() {}\r\n\r\n\t\tvoid Clear();\r\n\r\n\t\tvoid DrawPoint(float x, float y);\r\n\t\tvoid DrawLine (float x0, float y0, float x1, float y1);\r\n\t\tvoid DrawBox  (float x0, float y0, float x1, float y1);\r\n\r\n\t\tvoid Render(glm::mat4* cam);\r\n\r\n\t\tfloat LineWidth = 1.0f;\r\n\t\tfloat Thickness = 1.0f;\r\n\r\n\r\n\t\tint count = 0;\r\n\t\tstd::vector<unsigned int> _lineIndices;\r\n\t\tVertex* _pointVertices = 0;\r\n\t\tVertex* _lineVertices = 0;\r\n\tprivate:\r\n\r\n\t\tengine::Shader _pointShader;\r\n\t\tengine::Shader _lineShader;\r\n\t};\r\n}\r\n","#include <Graphics/LineRenderer.h>\r\n#include <iostream>\r\n// #include <graphics/error.h>\r\n// #include <core/Utils.h>\r\n\r\n\r\n#ifdef __EMSCRIPTEN__\r\n#undef glBindVertexArray\r\n#define glBindVertexArray(...) glBindVertexArrayOES(__VA_ARGS__)\r\n#endif\r\n\r\nnamespace engine\r\n{\r\n\r\n\tnamespace\r\n\t{\r\n\t\t// vColor = color;\r\n\t// attribute vec2 aTexCoord; \r\n\t// attribute vec4 aColor;\r\n\t// varying vec4 vColor;\r\n\r\n\t\tconst char pointShaderVrx[] = R\"(\r\nprecision mediump float; \r\nuniform mat4 projection;\r\nuniform float uThickness;\r\nuniform vec4 color;\r\n\r\nattribute vec2 position;\r\n\r\n\r\nvoid main() {\r\n    vec4 position = projection * vec4(position.xy, 0.0, 1.0);\r\n    gl_PointSize = uThickness;\r\n    gl_Position =  position;  \r\n} )\";\r\n\t\tconst char pointShaderFrag[] = R\"(\r\n// varying vec4 vColor;\r\nprecision mediump float; \r\nuniform vec4 color;\r\n\r\nvoid main() \r\n{\r\n   gl_FragColor = color;\r\n} )\";\r\n\r\n\t\tconst char lineVrx[] =\r\n\t\t\t\"attribute vec2 vPosition;    \\n\"\r\n\t\t\t\"uniform mat4 projection;    \\n\"\r\n\t\t\t\"void main()                  \\n\"\r\n\t\t\t\"{                            \\n\"\r\n\t\t\t\"   gl_Position =  projection * vec4(vPosition.xy, 0.0, 1.0);  \\n\"\r\n\t\t\t\"}                            \\n\";\r\n\r\n\t\tconst char lineFrag[] =\r\n\t\t\t\"precision mediump float;\\n\"\r\n\t\t\t\"void main()                                  \\n\"\r\n\t\t\t\"{                                            \\n\"\r\n\t\t\t\"  gl_FragColor = vec4 (0.5, 1.0, 1.0, 1.0 );\\n\"\r\n\t\t\t\"}                                            \\n\";\r\n\r\n\tconst char lineVrxIns[] =\r\n\t\t\t\"attribute vec2 vPosition;    \\n\"\r\n\t\t\t\"attribute vec2 position;    \\n\"\r\n\t\t\t\"uniform mat4 projection;    \\n\"\r\n\t\t\t\"void main()                  \\n\"\r\n\t\t\t\"{                            \\n\"\r\n\t\t\t\"   gl_Position =  projection * vec4(vPosition.xy, 0.0, 1.0);  \\n\"\r\n\t\t\t\"}                            \\n\";\r\n\r\n\t\tconst char lineFragIns[] =\r\n\t\t\t\"precision mediump float;\\n\"\r\n\t\t\t\"void main()                                  \\n\"\r\n\t\t\t\"{                                            \\n\"\r\n\t\t\t\"  gl_FragColor = vec4 (0.5, 1.0, 1.0, 1.0 ); \\n\"\r\n\t\t\t\"}                                            \\n\";\r\n\r\n\t}\r\n\r\n\tLineRenderer::LineRenderer() : _pointShader(0, 0), _lineShader(0, 0)\r\n\t{\r\n\t\t_pointShader.compileShadersFromSource(pointShaderVrx, pointShaderFrag, \"pointShader\",\r\n\t\t\t\"pointShader\");\r\n\t\t_lineShader.compileShadersFromSource(lineVrx, lineFrag,\r\n\t\t\t\"lineshader\", \"lineshader\");\r\n\r\n\t\tglCheckError();\r\n\t\tglCheckError();\r\n\t}\r\n\r\n\tvoid LineRenderer::Clear()\r\n\t{\r\n#if 0\r\n\t\t_lineVertices.clear();\r\n\r\n#else\r\n\t\tda_clear(_lineVertices);\r\n\t\tda_clear(_pointVertices);\r\n#endif\r\n\t\t// todo: laske viime framen size ja resize sen mukaan\r\n\t}\r\n\r\n\tvoid LineRenderer::DrawPoint(float x, float y)\r\n\t{\r\n\t\t// int currentCount = _pointVertex.size();         \r\n#if 0\r\n\t\t_pointVertex.push_back({ x, y });\r\n#endif\r\n\t}\r\n\r\n\t// TODO:\r\n\t// void DrawBox\r\n\t// void DrawCircle\r\n\t//  oma lineWidth ???\r\n\tenum class Geometry\r\n\t{\r\n\t\tLine, Point, Triangles, Quads,\r\n\t};\r\n\r\n\tstatic unsigned int vbo = 0;\r\n\tstatic unsigned int vao = 0;\r\n\r\n\r\n\tstatic unsigned int pointVao = 0;\r\n\r\n\r\n\tstatic unsigned int circleVbo, realCircleVbo, circleVao = 0;\r\n\r\n\tstatic engine::Shader shader(0, 0);\r\n\tvoid LineRenderer::Init()\r\n\t{\r\n\t\tglGenBuffers(1, &vbo);\r\n\r\n#ifndef __EMSCRIPTEN__\r\n\t\tglGenVertexArrays(1, &vao);\r\n#else\r\n\t\tglGenVertexArraysOES(1, &vao);\r\n#endif\r\n\t\tglBindVertexArray(vao);\r\n\r\n\t\tglBindBuffer(GL_ARRAY_BUFFER, vbo);\r\n\t\tglEnableVertexAttribArray(0);\r\n\t\tglVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, 0);\r\n\r\n\r\n#ifndef __EMSCRIPTEN__\r\n\t\tglGenVertexArrays(1, &pointVao);\r\n#else\r\n\t\tglGenVertexArraysOES(1, &pointVao);\r\n#endif\r\n\t\tglBindVertexArray(pointVao);\r\n\r\n\t\tglBindBuffer(GL_ARRAY_BUFFER, vbo);\r\n\t\tglEnableVertexAttribArray(0);\r\n\t\tglVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, 0);\r\n\r\n\r\n#if 0\r\n\t\tglGenVertexArrays(1, &circleVao);\r\n\t\tglGenBuffers(1, &circleVbo);\r\n\t\tglGenBuffers(1, &realCircleVbo);\r\n\r\n\t\tglBindVertexArray(circleVao);\r\n\t\tglBindBuffer(GL_ARRAY_BUFFER, circleVbo);\r\n\r\n\t\tvec2f points[200];\r\n\t\t{\r\n#define PI 3.141592f\r\n\t\t\tconst int NUM_VERTS = 100;\r\n\t\t\tconst int radius = 20.f;\r\n\t\t\tconst vec2f center{ 0.f, 0.f };\r\n\t\t\tfloat x = cosf(0) * radius + center.x;\r\n\t\t\tfloat y = sinf(0) * radius + center.y;\r\n\t\t\tVec2 last{ x, y };\r\n\t\t\tfor (int i = 0, j = 0; i < NUM_VERTS; i++, j += 2)\r\n\t\t\t{\r\n\t\t\t\tfloat angle = ((float)i / NUM_VERTS) * PI * 2.0f;\r\n\t\t\t\tfloat x = cos(angle) * radius + center.x;\r\n\t\t\t\tfloat y = sin(angle) * radius + center.y;\r\n\t\t\t\tVec2 pos{ x, y };\r\n\t\t\t\tpoints[j] = pos;\r\n\t\t\t\tpoints[j + 1] = last;\r\n\t\t\t\t// da_push(*lines, pos);\r\n\t\t\t\t// da_push(*lines, last);\r\n\t\t\t\tlast.x = x;\r\n\t\t\t\tlast.y = y;\r\n\t\t\t\t// m_verts[start + i].color = color;\r\n\t\t\t}\r\n\t\t\tVec2 pos = { x, y };\r\n\t\t\t// points[]\r\n\t\t}\r\n\r\n\t\tglBindBuffer(GL_ARRAY_BUFFER, realCircleVbo);\r\n\t\tglBufferData(GL_ARRAY_BUFFER, 200, points, GL_STATIC_DRAW);\r\n\t\tglEnableVertexAttribArray(0);\r\n\t\tglVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 2, (void*)(0));\r\n\r\n\t\tglBindBuffer(GL_ARRAY_BUFFER, circleVbo);\r\n\t\tglEnableVertexAttribArray(1);\r\n\t\tglVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 2, (void*)(0));\r\n\t\tglVertexAttribDivisor(1, 1);\r\n#endif\r\n\r\n\t}\r\n\r\n\tvoid DrawGeometry(Geometry mode, engine::Shader* shader, Vertex* vertices,\r\n\t\tVertex* indices, int count)\r\n\t{\r\n\t\tswitch (mode) {\r\n\t\tcase Geometry::Line:\r\n\t\t{\r\n#if 1\r\n\t\t\tglBindBuffer(GL_ARRAY_BUFFER, vbo);\r\n\t\t\tglBufferData(GL_ARRAY_BUFFER, sizeof(Vertex) * count, vertices, GL_DYNAMIC_DRAW);\r\n\r\n\t\t\tglBindVertexArray(vao);\r\n\t\t\tglDrawArrays(GL_LINES, 0, count);\r\n#else\r\n\t\t\tglVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, vertices->data());\r\n\t\t\tglDrawArrays(GL_LINES, 0, count);\r\n#endif\r\n\t\t} break;\r\n\t\tcase Geometry::Point:\r\n\t\t{\r\n\t\t\tglBindBuffer(GL_ARRAY_BUFFER, vbo);\r\n\t\t\tglBufferData(GL_ARRAY_BUFFER, sizeof(Vertex) * count, vertices, GL_DYNAMIC_DRAW);\r\n\r\n\t\t\t// glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, 0);\r\n\t\t\t// glEnableVertexAttribArray(0);\r\n\t\t\tglBindVertexArray(pointVao);\r\n\r\n\t\t\tglDrawArrays(GL_POINTS, 0, count);\r\n\t\t\tglBindBuffer(GL_ARRAY_BUFFER, 0);\r\n\t\t} break;\r\n\t\tcase Geometry::Triangles: break;\r\n\t\tcase Geometry::Quads:     break;\r\n\t\tdefault:;\r\n\t\t}\r\n\t}\r\n\r\n\tvoid LineRenderer::DrawLine(float x0, float y0, float x1, float y1)\r\n\t{\r\n#if 0\r\n\t\t_lineVertices.push_back({ x0, y0 });\r\n\t\t_lineVertices.push_back({ x1, y1 });\r\n#endif\r\n\t}\r\n\r\n\tvoid LineRenderer::DrawBox(float x, float y, float w, float h)\r\n\t{\r\n\t\t// TODO: GL_line_loop / line_strip\r\n#if 0 \r\n\t\tDrawLine(x, y, x + w, y);\r\n\t\tDrawLine(x, y, x, y + h);\r\n\t\tDrawLine(x + w, y, x + w, y + h);\r\n\t\tDrawLine(x, y + h, x + w, y + h);\r\n#endif\r\n\t}\r\n\r\n\tvec2f _positions[100]{\r\n\t\t0.4f, 0.4f,\r\n\t\t100.f, 100.f,\r\n\t\t500.f, 500.f,\r\n\t\t500.f, 800.f,\r\n\t};\r\n\r\n\tvoid LineRenderer::Render(glm::mat4* cam)\r\n\t{\r\n#if 1\r\n\t\t_lineShader.use();\r\n\t\t_lineShader.setMat4(\"projection\", *cam);\r\n\t\tglLineWidth(LineWidth);\r\n\t\tDrawGeometry(Geometry::Line, &_lineShader, _lineVertices, 0, da_size(_lineVertices));\r\n#endif\r\n\r\n\t\t// draw instanced stuff\r\n\t\t//glBindBuffer(GL_ARRAY_BUFFER, circleVbo);\r\n\t\t//glBufferData(GL_ARRAY_BUFFER, sizeof(Vertex) * count, _positions, GL_DYNAMIC_DRAW);\r\n\t\t//glDrawArraysInstanced(GL_LINES, 0, 100, 100); // 100 ymp ja 100 niita\r\n\t\t// glDrawElementsInstanced(mode, count ,ttype indices ,instacne count)\r\n\r\n\r\n\r\n\t\t// glLineWidth(1.0f);\r\n#if 1\r\n\t\t_pointShader.use();\r\n\t\t_pointShader.setMat4(\"projection\", *cam);\r\n\t\t_pointShader.setFloat4(\"color\", glm::vec4{ 1.0f, 1.0f, 1.0f, 1.f });\r\n\t\t_pointShader.setFloat(\"uThickness\", Thickness);\r\n\r\n\t\tDrawGeometry(Geometry::Point, &_pointShader, _pointVertices, 0, da_size(_pointVertices));\r\n#endif\r\n\r\n\t}\r\n\t}\r\n","// -*- C++ -*-\n//===------------------------------ vector --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_VECTOR\n#define _LIBCPP_VECTOR\n\n/*\n    vector synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Allocator = allocator<T> >\nclass vector\n{\npublic:\n    typedef T                                        value_type;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n);\n    explicit vector(size_type n, const allocator_type&); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value); // C++17\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    value_type*       data() noexcept;\n    const value_type* data() const noexcept;\n\n    void push_back(const value_type& x);\n    void push_back(value_type&& x);\n    template <class... Args>\n        reference emplace_back(Args&&... args); // reference in C++17\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, value_type&& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, const value_type& c);\n\n    void swap(vector&)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator = allocator<T> >\nclass vector<bool, Allocator>\n{\npublic:\n    typedef bool                                     value_type;\n    typedef Allocator                                allocator_type;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef iterator                                 pointer;\n    typedef const_iterator                           const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class reference\n    {\n    public:\n        reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        reference& operator=(const bool x) noexcept;\n        reference& operator=(const reference& x) noexcept;\n        iterator operator&() const noexcept;\n        void flip() noexcept;\n    };\n\n    class const_reference\n    {\n    public:\n        const_reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        const_iterator operator&() const noexcept;\n    };\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n, const allocator_type& a = allocator_type()); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value); // C++17\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    void push_back(const value_type& x);\n    template <class... Args> reference emplace_back(Args&&... args);  // C++14; reference in C++17\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);  // C++14\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, value_type x);\n\n    void swap(vector&)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n    void flip() noexcept;\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator> struct hash<std::vector<bool, Allocator>>;\n\ntemplate <class T, class Allocator> bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\n\ntemplate <class T, class Allocator>\nvoid swap(vector<T,Allocator>& x, vector<T,Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd> // for forward declaration of vector\n#include <__bit_reference>\n#include <type_traits>\n#include <climits>\n#include <limits>\n#include <initializer_list>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n#include <cstring>\n#include <__split_buffer>\n#include <__functional_base>\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __vector_base_common\n{\nprotected:\n    _LIBCPP_ALWAYS_INLINE __vector_base_common() {}\n    _LIBCPP_NORETURN void __throw_length_error() const;\n    _LIBCPP_NORETURN void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_length_error() const\n{\n    _VSTD::__throw_length_error(\"vector\");\n}\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_out_of_range() const\n{\n    _VSTD::__throw_out_of_range(\"vector\");\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __vector_base_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\ntemplate <class _Tp, class _Allocator>\nclass __vector_base\n    : protected __vector_base_common<true>\n{\nprotected:\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer& __end_cap() _NOEXCEPT\n        {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const pointer& __end_cap() const _NOEXCEPT\n        {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY __vector_base(const allocator_type& __a);\n    ~__vector_base();\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return static_cast<size_type>(__end_cap() - __begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c)\n        {__copy_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n            {\n                clear();\n                __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n                __begin_ = __end_ = __end_cap() = nullptr;\n            }\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base&, false_type)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base&, false_type)\n        _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), _VSTD::__to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__vector_base<_Tp, _Allocator>::~__vector_base()\n{\n    if (__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n    }\n}\n\ntemplate <class _Tp, class _Allocator /* = allocator<_Tp> */>\nclass _LIBCPP_TEMPLATE_VIS vector\n    : private __vector_base<_Tp, _Allocator>\n{\nprivate:\n    typedef __vector_base<_Tp, _Allocator>           __base;\n    typedef allocator<_Tp>                           __default_allocator_type;\npublic:\n    typedef vector                                   __self;\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef typename __base::__alloc_traits          __alloc_traits;\n    typedef typename __base::reference               reference;\n    typedef typename __base::const_reference         const_reference;\n    typedef typename __base::size_type               size_type;\n    typedef typename __base::difference_type         difference_type;\n    typedef typename __base::pointer                 pointer;\n    typedef typename __base::const_pointer           const_pointer;\n    typedef __wrap_iter<pointer>                     iterator;\n    typedef __wrap_iter<const_pointer>               const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector() _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n        : __base(__a)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const_reference __x);\n    vector(size_type __n, const_reference __x, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value,\n                                 _InputIterator>::type __last);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value,\n                                 _ForwardIterator>::type __last);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    ~vector()\n    {\n        __get_db()->__erase_c(this);\n    }\n#endif\n\n    vector(const vector& __x);\n    vector(const vector& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(const vector& __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __x)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const_reference __u);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return this->__alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY iterator               begin() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         begin()   const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY iterator               end() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         end()     const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin()  const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()    const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return static_cast<size_type>(this->__end_ - this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __base::capacity();}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return this->__begin_ == this->__end_;}\n    size_type max_size() const _NOEXCEPT;\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n);\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const;\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY reference       back()\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    value_type*       data() _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY void push_back(value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n#if _LIBCPP_STD_VER > 14\n        reference emplace_back(_Args&&... __args);\n#else\n        void      emplace_back(_Args&&... __args);\n#endif\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n\n    iterator insert(const_iterator __position, const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        iterator emplace(const_iterator __position, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n    {\n        size_type __old_size = size();\n        __base::clear();\n        __annotate_shrink(__old_size);\n        __invalidate_all_iterators();\n    }\n\n    void resize(size_type __sz);\n    void resize(size_type __sz, const_reference __x);\n\n    void swap(vector&)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG;\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n\n    bool __invariants() const;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(pointer __new_last);\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type __recommend(size_type __new_size) const;\n    void __construct_at_end(size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n);\n    void __append(size_type __n);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       __make_iter(pointer __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(const_pointer __p) const _NOEXCEPT;\n    void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);\n    pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);\n    void __move_range(pointer __from_s, pointer __from_e, pointer __to);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    void __move_assign(vector& __c, false_type)\n        _NOEXCEPT_(__alloc_traits::is_always_equal::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n    {\n        __invalidate_iterators_past(__new_last);\n        size_type __old_size = size();\n        __base::__destruct_at_end(__new_last);\n        __annotate_shrink(__old_size);\n    }\n    template <class _Up>\n        void\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        __push_back_slow_path(_Up&& __x);\n#else\n        __push_back_slow_path(_Up& __x);\n#endif\n#if !defined(_LIBCPP_HAS_NO_VARIADICS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class... _Args>\n        void\n        __emplace_back_slow_path(_Args&&... __args);\n#endif\n    // The following functions are no-ops outside of AddressSanitizer mode.\n    // We call annotatations only for the default Allocator because other allocators\n    // may not meet the AddressSanitizer alignment constraints.\n    // See the documentation for __sanitizer_annotate_contiguous_container for more details.\n#ifndef _LIBCPP_HAS_NO_ASAN\n    void __annotate_contiguous_container(const void *__beg, const void *__end,\n                                         const void *__old_mid,\n                                         const void *__new_mid) const\n    {\n\n      if (__beg && is_same<allocator_type, __default_allocator_type>::value)\n        __sanitizer_annotate_contiguous_container(__beg, __end, __old_mid, __new_mid);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_contiguous_container(const void*, const void*, const void*,\n                                         const void*) const {}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_new(size_type __current_size) const {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + capacity(), data() + __current_size);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_delete() const {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + capacity());\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_increase(size_type __n) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + size() + __n);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_shrink(size_type __old_size) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + __old_size, data() + size());\n    }\n#ifndef _LIBCPP_HAS_NO_ASAN\n    // The annotation for size increase should happen before the actual increase,\n    // but if an exception is thrown after that the annotation has to be undone.\n    struct __RAII_IncreaseAnnotator {\n      __RAII_IncreaseAnnotator(const vector &__v, size_type __n = 1)\n        : __commit(false), __v(__v), __old_size(__v.size() + __n) {\n        __v.__annotate_increase(__n);\n      }\n      void __done() { __commit = true; }\n      ~__RAII_IncreaseAnnotator() {\n        if (__commit) return;\n        __v.__annotate_shrink(__old_size);\n      }\n      bool __commit;\n      const vector &__v;\n      size_type __old_size;\n    };\n#else\n    struct __RAII_IncreaseAnnotator {\n      _LIBCPP_INLINE_VISIBILITY\n      __RAII_IncreaseAnnotator(const vector &, size_type = 1) {}\n      _LIBCPP_INLINE_VISIBILITY void __done() {}\n    };\n#endif\n\n};\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)\n{\n    __annotate_delete();\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::pointer\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)\n{\n    __annotate_delete();\n    pointer __r = __v.__begin_;\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, __p, __v.__begin_);\n    __alloc_traits::__construct_forward(this->__alloc(), __p, this->__end_, __v.__end_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n    return __r;\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __end_cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);\n    this->__end_cap() = this->__begin_ + __n;\n    __annotate_new(0);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());\n        this->__begin_ = this->__end_ = this->__end_cap() = nullptr;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::max_size() const _NOEXCEPT\n{\n    return _VSTD::min<size_type>(__alloc_traits::max_size(this->__alloc()),\n                                 numeric_limits<difference_type>::max());\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max<size_type>(2*__cap, __new_size);\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    __RAII_IncreaseAnnotator __annotator(*this, __n);\n    __alloc_traits::__construct_range_forward(__a, __first, __last, this->__end_);\n    __annotator.__done();\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n, __x);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n, __x);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n#endif\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value,\n                          _InputIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value,\n                                                   _ForwardIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x)\n    : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_, __n);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#endif\n    : __base(_VSTD::move(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__x);\n#endif\n    this->__begin_ = __x.__begin_;\n    this->__end_ = __x.__end_;\n    this->__end_cap() = __x.__end_cap();\n    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a == __x.__alloc())\n    {\n        this->__begin_ = __x.__begin_;\n        this->__end_ = __x.__end_;\n        this->__end_cap() = __x.__end_cap();\n        __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->swap(this, &__x);\n#endif\n    }\n    else\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__x.begin()), _Ip(__x.end()));\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end(), __il.size());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end(), __il.size());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(vector&& __x)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__x, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)\n    _NOEXCEPT_(__alloc_traits::is_always_equal::value)\n{\n    if (__base::__alloc() != __c.__alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __base::__move_assign_alloc(__c); // this can throw\n    this->__begin_ = __c.__begin_;\n    this->__end_ = __c.__end_;\n    this->__end_cap() = __c.__end_cap();\n    __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__c);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(const vector& __x)\n{\n    if (this != &__x)\n    {\n        __base::__copy_assign_alloc(__x);\n        assign(__x.__begin_, __x.__end_);\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __new_size = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__new_size <= capacity())\n    {\n        _ForwardIterator __mid = __last;\n        bool __growing = false;\n        if (__new_size > size())\n        {\n            __growing = true;\n            __mid =  __first;\n            _VSTD::advance(__mid, size());\n        }\n        pointer __m = _VSTD::copy(__first, __mid, this->__begin_);\n        if (__growing)\n            __construct_at_end(__mid, __last, __new_size - size());\n        else\n            this->__destruct_at_end(__m);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(__new_size));\n        __construct_at_end(__first, __last, __new_size);\n    }\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)\n{\n    if (__n <= capacity())\n    {\n        size_type __s = size();\n        _VSTD::fill_n(this->__begin_, _VSTD::min(__n, __s), __u);\n        if (__n > __s)\n            __construct_at_end(__n - __s, __u);\n        else\n            this->__destruct_at_end(this->__begin_ + __n);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(static_cast<size_type>(__n)));\n        __construct_at_end(__n, __u);\n    }\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::__make_iter(pointer __p) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(this, __p);\n#else\n    return iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::__make_iter(const_pointer __p) const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(this, __p);\n#else\n    return const_iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::begin() _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::begin() const _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::end() _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::end() const _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::operator[](size_type __n)\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::operator[](size_type __n) const\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);\n            __swap_out_circular_buffer(__v);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _Up>\nvoid\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)\n#else\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up& __x)\n#endif\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n    // __v.push_back(_VSTD::forward<_Up>(__x));\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Up>(__x));\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (this->__end_ != this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_), __x);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(__x);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(__x));\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(_VSTD::move(__x));\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\nvector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args)\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n//    __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Args>(__args)...);\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ninline\n#if _LIBCPP_STD_VER > 14\ntypename vector<_Tp, _Allocator>::reference\n#else\nvoid\n#endif\nvector<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::forward<_Args>(__args)...);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __emplace_back_slow_path(_VSTD::forward<_Args>(__args)...);\n#if _LIBCPP_STD_VER > 14\n    return this->back();\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\nvector<_Tp, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"vector::pop_back called for empty vector\");\n    this->__destruct_at_end(this->__end_ - 1);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __position)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::erase(iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__position != end(),\n        \"vector::erase(iterator) called with a non-dereferenceable iterator\");\n    difference_type __ps = __position - cbegin();\n    pointer __p = this->__begin_ + __ps;\n    this->__destruct_at_end(_VSTD::move(__p + 1, this->__end_, __p));\n    this->__invalidate_iterators_past(__p-1);\n    iterator __r = __make_iter(__p);\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"vector::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this vector\");\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__last) == this,\n        \"vector::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"vector::erase(first, last) called with invalid range\");\n    pointer __p = this->__begin_ + (__first - begin());\n    if (__first != __last) {\n        this->__destruct_at_end(_VSTD::move(__p + (__last - __first), this->__end_, __p));\n        this->__invalidate_iterators_past(__p - 1);\n    }\n    iterator __r = __make_iter(__p);\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)\n{\n    pointer __old_last = this->__end_;\n    difference_type __n = __old_last - __to;\n    for (pointer __i = __from_s + __n; __i < __from_e; ++__i, ++this->__end_)\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(*__i));\n    _VSTD::move_backward(__from_s, __from_s + __n, __old_last);\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_), __x);\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n            if (__p <= __xr && __xr < this->__end_)\n                ++__xr;\n            *__p = *__xr;\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(__x);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::move(__x));\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__x);\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(_VSTD::move(__x));\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::emplace(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::forward<_Args>(__args)...);\n            ++this->__end_;\n        }\n        else\n        {\n            __temp_value<value_type, _Allocator> __tmp(this->__alloc(), _VSTD::forward<_Args>(__args)...);\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__tmp.get());\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, n, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (__n > 0)\n    {\n        if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            if (__n > static_cast<size_type>(this->__end_ - __p))\n            {\n                size_type __cx = __n - (this->__end_ - __p);\n                __construct_at_end(__cx, __x);\n                __n -= __cx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this, __n);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n                if (__p <= __xr && __xr < this->__end_)\n                    __xr += __old_n;\n                _VSTD::fill_n(__p, __n, *__xr);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__n, __x);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    difference_type __off = __position - begin();\n    pointer __p = this->__begin_ + __off;\n    allocator_type& __a = this->__alloc();\n    pointer __old_last = this->__end_;\n    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_),\n                                  *__first);\n        ++this->__end_;\n        __annotator.__done();\n    }\n    __split_buffer<value_type, allocator_type&> __v(__a);\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.__construct_at_end(__first, __last);\n            difference_type __old_size = __old_last - this->__begin_;\n            difference_type __old_p = __p - this->__begin_;\n            reserve(__recommend(size() + __v.size()));\n            __p = this->__begin_ + __old_p;\n            __old_last = this->__begin_ + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__make_iter(__old_last), end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_last, this->__end_);\n    insert(__make_iter(__p), make_move_iterator(__v.begin()),\n                                    make_move_iterator(__v.end()));\n    return begin() + __off;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n > 0)\n    {\n        if (__n <= this->__end_cap() - this->__end_)\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            _ForwardIterator __m = __last;\n            difference_type __dx = this->__end_ - __p;\n            if (__n > __dx)\n            {\n                __m = __first;\n                difference_type __diff = this->__end_ - __p;\n                _VSTD::advance(__m, __diff);\n                __construct_at_end(__m, __last, __n - __diff);\n                __n = __dx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this, __n);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                _VSTD::copy(__first, __m, __p);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__first, __last);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs, __x);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::swap(vector& __x)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT_DEBUG\n#else\n    _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n    _LIBCPP_ASSERT(__alloc_traits::propagate_on_container_swap::value ||\n                   this->__alloc() == __x.__alloc(),\n                   \"vector::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__end_, __x.__end_);\n    _VSTD::swap(this->__end_cap(), __x.__end_cap());\n    __swap_allocator(this->__alloc(), __x.__alloc(), \n        integral_constant<bool,__alloc_traits::propagate_on_container_swap::value>());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__x);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__end_ != nullptr || this->__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (this->__begin_ > this->__end_)\n            return false;\n        if (this->__begin_ == this->__end_cap())\n            return false;\n        if (this->__end_ > this->__end_cap())\n            return false;\n    }\n    return true;\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->__begin_ <= __i->base() && __i->base() < this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->__begin_ < __i->base() && __i->base() <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p < this->__end_;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__invalidate_iterators_past(pointer __new_last) {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n  __c_node* __c = __get_db()->__find_c_and_lock(this);\n  for (__i_node** __p = __c->end_; __p != __c->beg_; ) {\n    --__p;\n    const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n    if (__i->base() > __new_last) {\n      (*__p)->__c_ = nullptr;\n      if (--__c->end_ != __p)\n        memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n    }\n  }\n  __get_db()->unlock();\n#else\n  ((void)__new_last);\n#endif\n}\n\n// vector<bool>\n\ntemplate <class _Allocator> class vector<bool, _Allocator>;\n\ntemplate <class _Allocator> struct hash<vector<bool, _Allocator> >;\n\ntemplate <class _Allocator>\nstruct __has_storage_type<vector<bool, _Allocator> >\n{\n    static const bool value = true;\n};\n\ntemplate <class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS vector<bool, _Allocator>\n    : private __vector_base_common<true>\n{\npublic:\n    typedef vector                                   __self;\n    typedef bool                                     value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef size_type __storage_type;\n    typedef __bit_iterator<vector, false>            pointer;\n    typedef __bit_iterator<vector, true>             const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\nprivate:\n    typedef typename __rebind_alloc_helper<__alloc_traits, __storage_type>::type __storage_allocator;\n    typedef allocator_traits<__storage_allocator>    __storage_traits;\n    typedef typename __storage_traits::pointer       __storage_pointer;\n    typedef typename __storage_traits::const_pointer __const_storage_pointer;\n\n    __storage_pointer                                      __begin_;\n    size_type                                              __size_;\n    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;\npublic:\n    typedef __bit_reference<vector>                  reference;\n    typedef __bit_const_reference<vector>            const_reference;\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& __cap() _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& __cap() const _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    __storage_allocator& __alloc() _NOEXCEPT\n        {return __cap_alloc_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __storage_allocator& __alloc() const _NOEXCEPT\n        {return __cap_alloc_.second();}\n\n    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __internal_cap_to_external(size_type __n) _NOEXCEPT\n        {return __n * __bits_per_word;}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __external_cap_to_internal(size_type __n) _NOEXCEPT\n        {return (__n - 1) / __bits_per_word + 1;}\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    vector() _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n    ~vector();\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const value_type& __v);\n    vector(size_type __n, const value_type& __v, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n\n    vector(const vector& __v);\n    vector(const vector& __v, const allocator_type& __a);\n    vector& operator=(const vector& __v);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    vector(initializer_list<value_type> __il);\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __v)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#endif\n    vector(vector&& __v, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __v)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value &&\n           !__is_forward_iterator<_InputIterator>::value,\n           void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n           void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const value_type& __x);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(this->__alloc());}\n\n    size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __internal_cap_to_external(__cap());}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return __size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return __size_ == 0;}\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT\n        {return __make_iter(__size_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()   const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n)       {return __make_ref(__n);}\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const {return __make_ref(__n);}\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()       {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY reference       back()        {return __make_ref(__size_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const {return __make_ref(__size_ - 1);}\n\n    void push_back(const value_type& __x);\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY reference emplace_back(_Args&&... __args)\n#else\n    _LIBCPP_INLINE_VISIBILITY void      emplace_back(_Args&&... __args)\n#endif\n    {\n        push_back ( value_type ( _VSTD::forward<_Args>(__args)... ));\n#if _LIBCPP_STD_VER > 14\n        return this->back();\n#endif\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {--__size_;}\n\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n   _LIBCPP_INLINE_VISIBILITY iterator emplace(const_iterator position, _Args&&... __args)\n        { return insert ( position, value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    iterator insert(const_iterator __position, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__size_ = 0;}\n\n    void swap(vector&)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n    static void swap(reference __x, reference __y) _NOEXCEPT { _VSTD::swap(__x, __y); }\n\n    void resize(size_type __sz, value_type __x = false);\n    void flip() _NOEXCEPT;\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __align_it(size_type __new_size) _NOEXCEPT\n        {return __new_size + (__bits_per_word-1) & ~((size_type)__bits_per_word-1);};\n    _LIBCPP_INLINE_VISIBILITY  size_type __recommend(size_type __new_size) const;\n    _LIBCPP_INLINE_VISIBILITY void __construct_at_end(size_type __n, bool __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    reference __make_ref(size_type __pos) _NOEXCEPT\n        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference __make_ref(size_type __pos) const _NOEXCEPT\n        {return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __make_iter(size_type __pos) _NOEXCEPT\n        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(size_type __pos) const _NOEXCEPT\n        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __const_iterator_cast(const_iterator __p) _NOEXCEPT\n        {return begin() + (__p - cbegin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __v)\n        {__copy_assign_alloc(__v, integral_constant<bool,\n                      __storage_traits::propagate_on_container_copy_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n                deallocate();\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector&, false_type)\n        {}\n\n    void __move_assign(vector& __c, false_type);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c)\n        _NOEXCEPT_(\n            !__storage_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __storage_traits::propagate_on_container_move_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector&, false_type)\n        _NOEXCEPT\n        {}\n\n    size_t __hash_code() const _NOEXCEPT;\n\n    friend class __bit_reference<vector>;\n    friend class __bit_const_reference<vector>;\n    friend class __bit_iterator<vector, false>;\n    friend class __bit_iterator<vector, true>;\n    friend struct __bit_array<vector>;\n    friend struct _LIBCPP_TEMPLATE_VIS hash<vector>;\n};\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__invalidate_all_iterators()\n{\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    __n = __external_cap_to_internal(__n);\n    this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);\n    this->__size_ = 0;\n    this->__cap() = __n;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());\n        __invalidate_all_iterators();\n        this->__begin_ = nullptr;\n        this->__size_ = this->__cap() = 0;\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __amax = __storage_traits::max_size(__alloc());\n    size_type __nmax = numeric_limits<size_type>::max() / 2;  // end() >= begin(), always\n    if (__nmax / __bits_per_word <= __amax)\n        return __nmax;\n    return __internal_cap_to_external(__amax);\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max(2*__cap, __align_it(__new_size));\n}\n\n//  Default constructs __n objects starting at __end_\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += __n;\n    _VSTD::fill_n(__make_iter(__old_size), __n, __x);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += _VSTD::distance(__first, __last);\n    _VSTD::copy(__first, __last, __make_iter(__old_size));\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n#endif\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::~vector()\n{\n    if (__begin_ != nullptr)\n        __storage_traits::deallocate(__alloc(), __begin_, __cap());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(const vector& __v)\n{\n    if (this != &__v)\n    {\n        __copy_assign_alloc(__v);\n        if (__v.__size_)\n        {\n            if (__v.__size_ > capacity())\n            {\n                deallocate();\n                allocate(__v.__size_);\n            }\n            _VSTD::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);\n        }\n        __size_ = __v.__size_;\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(vector&& __v)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#endif\n    : __begin_(__v.__begin_),\n      __size_(__v.__size_),\n      __cap_alloc_(__v.__cap_alloc_)\n{\n    __v.__begin_ = nullptr;\n    __v.__size_ = 0;\n    __v.__cap() = 0;\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(vector&& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__a == allocator_type(__v.__alloc()))\n    {\n        this->__begin_ = __v.__begin_;\n        this->__size_ = __v.__size_;\n        this->__cap() = __v.__cap();\n        __v.__begin_ = nullptr;\n        __v.__cap() = __v.__size_ = 0;\n    }\n    else if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(vector&& __v)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__v, integral_constant<bool,\n          __storage_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, false_type)\n{\n    if (__alloc() != __c.__alloc())\n        assign(__c.begin(), __c.end());\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __move_assign_alloc(__c);\n    this->__begin_ = __c.__begin_;\n    this->__size_ = __c.__size_;\n    this->__cap() = __c.__cap();\n    __c.__begin_ = nullptr;\n    __c.__cap() = __c.__size_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::assign(size_type __n, const value_type& __x)\n{\n    __size_ = 0;\n    if (__n > 0)\n    {\n        size_type __c = capacity();\n        if (__n <= __c)\n            __size_ = __n;\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__n));\n            __v.__size_ = __n;\n            swap(__v);\n        }\n        _VSTD::fill_n(begin(), __n, __x);\n    }\n  __invalidate_all_iterators();\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_forward_iterator<_InputIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    clear();\n    difference_type __ns = _VSTD::distance(__first, __last);\n    _LIBCPP_ASSERT(__ns >= 0, \"invalid range specified\");\n    const size_t __n = static_cast<size_type>(__ns);\n    if (__n)\n    {\n        if (__n > capacity())\n        {\n            deallocate();\n            allocate(__n);\n        }\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        vector __v(this->__alloc());\n        __v.allocate(__n);\n        __v.__construct_at_end(this->begin(), this->end());\n        swap(__v);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (__external_cap_to_internal(size()) > __cap())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            vector(*this, allocator_type(__alloc())).swap(*this);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::reference\nvector<bool, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::const_reference\nvector<bool, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::push_back(const value_type& __x)\n{\n    if (this->__size_ == this->capacity())\n        reserve(__recommend(this->__size_ + 1));\n    ++this->__size_;\n    back() = __x;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)\n{\n    iterator __r;\n    if (size() < capacity())\n    {\n        const_iterator __old_end = end();\n        ++__size_;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + 1));\n        __v.__size_ = __size_ + 1;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    *__r = __x;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)\n{\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::fill_n(__r, __n, __x);\n    return __r;\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n    difference_type __off = __position - begin();\n    iterator __p = __const_iterator_cast(__position);\n    iterator __old_end = end();\n    for (; size() != capacity() && __first != __last; ++__first)\n    {\n        ++this->__size_;\n        back() = *__first;\n    }\n    vector __v(__alloc());\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.assign(__first, __last);\n            difference_type __old_size = static_cast<difference_type>(__old_end - begin());\n            difference_type __old_p = __p - begin();\n            reserve(__recommend(size() + __v.size()));\n            __p = begin() + __old_p;\n            __old_end = begin() + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__old_end, end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_end, end());\n    insert(__p, __v.begin(), __v.end());\n    return begin() + __off;\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n    const difference_type __n_signed = _VSTD::distance(__first, __last);\n    _LIBCPP_ASSERT(__n_signed >= 0, \"invalid range specified\");\n    const size_type __n = static_cast<size_type>(__n_signed);\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::copy(__first, __last, __r);\n    return __r;\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __position)\n{\n    iterator __r = __const_iterator_cast(__position);\n    _VSTD::copy(__position + 1, this->cend(), __r);\n    --__size_;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n    iterator __r = __const_iterator_cast(__first);\n    difference_type __d = __last - __first;\n    _VSTD::copy(__last, this->cend(), __r);\n    __size_ -= __d;\n    return __r;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::swap(vector& __x)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__size_, __x.__size_);\n    _VSTD::swap(this->__cap(), __x.__cap());\n    __swap_allocator(this->__alloc(), __x.__alloc(), \n        integral_constant<bool, __alloc_traits::propagate_on_container_swap::value>());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::resize(size_type __sz, value_type __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n    {\n        iterator __r;\n        size_type __c = capacity();\n        size_type __n = __sz - __cs;\n        if (__n <= __c && __cs <= __c - __n)\n        {\n            __r = end();\n            __size_ += __n;\n        }\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__size_ + __n));\n            __v.__size_ = __size_ + __n;\n            __r = _VSTD::copy(cbegin(), cend(), __v.begin());\n            swap(__v);\n        }\n        _VSTD::fill_n(__r, __n, __x);\n    }\n    else\n        __size_ = __sz;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::flip() _NOEXCEPT\n{\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        *__p = ~*__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __storage_type __b = *__p & __m;\n        *__p &= ~__m;\n        *__p |= ~__b & __m;\n    }\n}\n\ntemplate <class _Allocator>\nbool\nvector<bool, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__size_ != 0 || this->__cap() != 0)\n            return false;\n    }\n    else\n    {\n        if (this->__cap() == 0)\n            return false;\n        if (this->__size_ > this->capacity())\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Allocator>\nsize_t\nvector<bool, _Allocator>::__hash_code() const _NOEXCEPT\n{\n    size_t __h = 0;\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        __h ^= *__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __h ^= *__p & __m;\n    }\n    return __h;\n}\n\ntemplate <class _Allocator>\nstruct _LIBCPP_TEMPLATE_VIS hash<vector<bool, _Allocator> >\n    : public unary_function<vector<bool, _Allocator>, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const vector<bool, _Allocator>& __vec) const _NOEXCEPT\n        {return __vec.__hash_code();}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();\n    return __sz == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_VECTOR\n","/// @ref core\r\n/// @file glm/detail/type_tvec4.inl\r\n\r\nnamespace glm{\r\nnamespace detail\r\n{\r\n\ttemplate <typename T>\r\n\tstruct is_int\r\n\t{\r\n\t\tenum test {value = 0};\r\n\t};\r\n\r\n\ttemplate <>\r\n\tstruct is_int<uint32>\r\n\t{\r\n\t\tenum test {value = ~0};\r\n\t};\r\n\r\n\ttemplate <>\r\n\tstruct is_int<int32>\r\n\t{\r\n\t\tenum test {value = ~0};\r\n\t};\r\n\r\n\ttemplate <>\r\n\tstruct is_int<uint64>\r\n\t{\r\n\t\tenum test {value = ~0};\r\n\t};\r\n\r\n\ttemplate <>\r\n\tstruct is_int<int64>\r\n\t{\r\n\t\tenum test {value = ~0};\r\n\t};\r\n\r\n\ttemplate <typename T, precision P, bool Aligned>\r\n\tstruct compute_vec4_add\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)\r\n\t\t{\r\n\t\t\treturn tvec4<T, P>(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P, bool Aligned>\r\n\tstruct compute_vec4_sub\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)\r\n\t\t{\r\n\t\t\treturn tvec4<T, P>(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P, bool Aligned>\r\n\tstruct compute_vec4_mul\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)\r\n\t\t{\r\n\t\t\treturn tvec4<T, P>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P, bool Aligned>\r\n\tstruct compute_vec4_div\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)\r\n\t\t{\r\n\t\t\treturn tvec4<T, P>(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P, bool Aligned>\r\n\tstruct compute_vec4_mod\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)\r\n\t\t{\r\n\t\t\treturn tvec4<T, P>(a.x % b.x, a.y % b.y, a.z % b.z, a.w % b.w);\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>\r\n\tstruct compute_vec4_and\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)\r\n\t\t{\r\n\t\t\treturn tvec4<T, P>(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>\r\n\tstruct compute_vec4_or\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)\r\n\t\t{\r\n\t\t\treturn tvec4<T, P>(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>\r\n\tstruct compute_vec4_xor\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)\r\n\t\t{\r\n\t\t\treturn tvec4<T, P>(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>\r\n\tstruct compute_vec4_shift_left\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)\r\n\t\t{\r\n\t\t\treturn tvec4<T, P>(a.x << b.x, a.y << b.y, a.z << b.z, a.w << b.w);\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>\r\n\tstruct compute_vec4_shift_right\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static tvec4<T, P> call(tvec4<T, P> const & a, tvec4<T, P> const & b)\r\n\t\t{\r\n\t\t\treturn tvec4<T, P>(a.x >> b.x, a.y >> b.y, a.z >> b.z, a.w >> b.w);\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>\r\n\tstruct compute_vec4_equal\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static bool call(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t\t{\r\n\t\t\treturn (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z) && (v1.w == v2.w);\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>\r\n\tstruct compute_vec4_nequal\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static bool call(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t\t{\r\n\t\t\treturn (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z) || (v1.w != v2.w);\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P, int IsInt, std::size_t Size, bool Aligned>\r\n\tstruct compute_vec4_bitwise_not\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static tvec4<T, P> call(tvec4<T, P> const & v)\r\n\t\t{\r\n\t\t\treturn tvec4<T, P>(~v.x, ~v.y, ~v.z, ~v.w);\r\n\t\t}\r\n\t};\r\n}//namespace detail\r\n\r\n\t// -- Implicit basic constructors --\r\n\r\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS || !defined(GLM_FORCE_NO_CTOR_INIT)\r\n\t\ttemplate <typename T, precision P>\r\n\t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_SIMD tvec4<T, P>::tvec4()\r\n#\t\t\tifndef GLM_FORCE_NO_CTOR_INIT\r\n\t\t\t\t: x(0), y(0), z(0), w(0)\r\n#\t\t\tendif\r\n\t\t{}\r\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\r\n\r\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\r\n\t\ttemplate <typename T, precision P>\r\n\t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_SIMD tvec4<T, P>::tvec4(tvec4<T, P> const & v)\r\n\t\t\t: x(v.x), y(v.y), z(v.z), w(v.w)\r\n\t\t{}\r\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_SIMD tvec4<T, P>::tvec4(tvec4<T, Q> const & v)\r\n\t\t: x(v.x), y(v.y), z(v.z), w(v.w)\r\n\t{}\r\n\r\n\t// -- Explicit basic constructors --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_SIMD tvec4<T, P>::tvec4(ctor)\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_SIMD tvec4<T, P>::tvec4(T scalar)\r\n\t\t: x(scalar), y(scalar), z(scalar), w(scalar)\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_SIMD tvec4<T, P>::tvec4(T a, T b, T c, T d)\r\n\t\t: x(a), y(b), z(c), w(d)\r\n\t{}\r\n\r\n\t// -- Conversion scalar constructors --\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, typename C, typename D>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_SIMD tvec4<T, P>::tvec4(A a, B b, C c, D d) :\r\n\t\tx(static_cast<T>(a)),\r\n\t\ty(static_cast<T>(b)),\r\n\t\tz(static_cast<T>(c)),\r\n\t\tw(static_cast<T>(d))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, typename C, typename D>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c, tvec1<D, P> const & d) :\r\n\t\tx(static_cast<T>(a.x)),\r\n\t\ty(static_cast<T>(b.x)),\r\n\t\tz(static_cast<T>(c.x)),\r\n\t\tw(static_cast<T>(d.x))\r\n\t{}\r\n\r\n\t// -- Conversion vector constructors --\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, typename C, precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(tvec2<A, Q> const & a, B b, C c) :\r\n\t\tx(static_cast<T>(a.x)),\r\n\t\ty(static_cast<T>(a.y)),\r\n\t\tz(static_cast<T>(b)),\r\n\t\tw(static_cast<T>(c))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, typename C, precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(tvec2<A, Q> const & a, tvec1<B, Q> const & b, tvec1<C, Q> const & c) :\r\n\t\tx(static_cast<T>(a.x)),\r\n\t\ty(static_cast<T>(a.y)),\r\n\t\tz(static_cast<T>(b.x)),\r\n\t\tw(static_cast<T>(c.x))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, typename C, precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(A s1, tvec2<B, Q> const & v, C s2) :\r\n\t\tx(static_cast<T>(s1)),\r\n\t\ty(static_cast<T>(v.x)),\r\n\t\tz(static_cast<T>(v.y)),\r\n\t\tw(static_cast<T>(s2))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, typename C, precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec2<B, Q> const & b, tvec1<C, Q> const & c) :\r\n\t\tx(static_cast<T>(a.x)),\r\n\t\ty(static_cast<T>(b.x)),\r\n\t\tz(static_cast<T>(b.y)),\r\n\t\tw(static_cast<T>(c.x))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, typename C, precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(A s1, B s2, tvec2<C, Q> const & v) :\r\n\t\tx(static_cast<T>(s1)),\r\n\t\ty(static_cast<T>(s2)),\r\n\t\tz(static_cast<T>(v.x)),\r\n\t\tw(static_cast<T>(v.y))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, typename C, precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec1<B, Q> const & b, tvec2<C, Q> const & c) :\r\n\t\tx(static_cast<T>(a.x)),\r\n\t\ty(static_cast<T>(b.x)),\r\n\t\tz(static_cast<T>(c.x)),\r\n\t\tw(static_cast<T>(c.y))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(tvec3<A, Q> const & a, B b) :\r\n\t\tx(static_cast<T>(a.x)),\r\n\t\ty(static_cast<T>(a.y)),\r\n\t\tz(static_cast<T>(a.z)),\r\n\t\tw(static_cast<T>(b))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(tvec3<A, Q> const & a, tvec1<B, Q> const & b) :\r\n\t\tx(static_cast<T>(a.x)),\r\n\t\ty(static_cast<T>(a.y)),\r\n\t\tz(static_cast<T>(a.z)),\r\n\t\tw(static_cast<T>(b.x))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(A a, tvec3<B, Q> const & b) :\r\n\t\tx(static_cast<T>(a)),\r\n\t\ty(static_cast<T>(b.x)),\r\n\t\tz(static_cast<T>(b.y)),\r\n\t\tw(static_cast<T>(b.z))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec3<B, Q> const & b) :\r\n\t\tx(static_cast<T>(a.x)),\r\n\t\ty(static_cast<T>(b.x)),\r\n\t\tz(static_cast<T>(b.y)),\r\n\t\tw(static_cast<T>(b.z))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(tvec2<A, Q> const & a, tvec2<B, Q> const & b) :\r\n\t\tx(static_cast<T>(a.x)),\r\n\t\ty(static_cast<T>(a.y)),\r\n\t\tz(static_cast<T>(b.x)),\r\n\t\tw(static_cast<T>(b.y))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U, precision Q>\r\n\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR_CTOR tvec4<T, P>::tvec4(tvec4<U, Q> const & v) :\r\n\t\tx(static_cast<T>(v.x)),\r\n\t\ty(static_cast<T>(v.y)),\r\n\t\tz(static_cast<T>(v.z)),\r\n\t\tw(static_cast<T>(v.w))\r\n\t{}\r\n\r\n\t// -- Component accesses --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T & tvec4<T, P>::operator[](typename tvec4<T, P>::length_type i)\r\n\t{\r\n\t\tassert(i >= 0 && i < this->length());\r\n\t\treturn (&x)[i];\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T const & tvec4<T, P>::operator[](typename tvec4<T, P>::length_type i) const\r\n\t{\r\n\t\tassert(i >= 0 && i < this->length());\r\n\t\treturn (&x)[i];\r\n\t}\r\n\r\n\t// -- Unary arithmetic operators --\r\n\r\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\r\n\t\ttemplate <typename T, precision P>\r\n\t\tGLM_FUNC_QUALIFIER tvec4<T, P>& tvec4<T, P>::operator=(tvec4<T, P> const & v)\r\n\t\t{\r\n\t\t\tthis->x = v.x;\r\n\t\t\tthis->y = v.y;\r\n\t\t\tthis->z = v.z;\r\n\t\t\tthis->w = v.w;\r\n\t\t\treturn *this;\r\n\t\t}\r\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P>& tvec4<T, P>::operator=(tvec4<U, P> const & v)\r\n\t{\r\n\t\tthis->x = static_cast<T>(v.x);\r\n\t\tthis->y = static_cast<T>(v.y);\r\n\t\tthis->z = static_cast<T>(v.z);\r\n\t\tthis->w = static_cast<T>(v.w);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator+=(U scalar)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_add<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator+=(tvec1<U, P> const & v)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_add<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator+=(tvec4<U, P> const & v)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_add<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator-=(U scalar)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_sub<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator-=(tvec1<U, P> const & v)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_sub<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator-=(tvec4<U, P> const & v)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_sub<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator*=(U scalar)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_mul<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator*=(tvec1<U, P> const & v)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_mul<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator*=(tvec4<U, P> const & v)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_mul<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator/=(U scalar)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_div<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator/=(tvec1<U, P> const & v)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_div<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v.x)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator/=(tvec4<U, P> const & v)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_div<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\r\n\t}\r\n\r\n\t// -- Increment and decrement operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator++()\r\n\t{\r\n\t\t++this->x;\r\n\t\t++this->y;\r\n\t\t++this->z;\r\n\t\t++this->w;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator--()\r\n\t{\r\n\t\t--this->x;\r\n\t\t--this->y;\r\n\t\t--this->z;\r\n\t\t--this->w;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> tvec4<T, P>::operator++(int)\r\n\t{\r\n\t\ttvec4<T, P> Result(*this);\r\n\t\t++*this;\r\n\t\treturn Result;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> tvec4<T, P>::operator--(int)\r\n\t{\r\n\t\ttvec4<T, P> Result(*this);\r\n\t\t--*this;\r\n\t\treturn Result;\r\n\t}\r\n\r\n\t// -- Unary bit operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator%=(U scalar)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_mod<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator%=(tvec1<U, P> const& v)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_mod<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator%=(tvec4<U, P> const& v)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_mod<T, P, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator&=(U scalar)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_and<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator&=(tvec1<U, P> const & v)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_and<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator&=(tvec4<U, P> const & v)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_and<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator|=(U scalar)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_or<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator|=(tvec1<U, P> const & v)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_or<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator|=(tvec4<U, P> const & v)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_or<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator^=(U scalar)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_xor<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator^=(tvec1<U, P> const & v)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_xor<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator^=(tvec4<U, P> const & v)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_xor<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator<<=(U scalar)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_shift_left<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator<<=(tvec1<U, P> const & v)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_shift_left<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator<<=(tvec4<U, P> const & v)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_shift_left<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator>>=(U scalar)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_shift_right<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(scalar)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator>>=(tvec1<U, P> const & v)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_shift_right<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> & tvec4<T, P>::operator>>=(tvec4<U, P> const & v)\r\n\t{\r\n\t\treturn (*this = detail::compute_vec4_shift_right<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(*this, tvec4<T, P>(v)));\r\n\t}\r\n\r\n\t// -- Unary constant operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator+(tvec4<T, P> const & v)\r\n\t{\r\n\t\treturn v;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator-(tvec4<T, P> const & v)\r\n\t{\r\n\t\treturn tvec4<T, P>(0) -= v;\r\n\t}\r\n\r\n\t// -- Binary arithmetic operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator+(tvec4<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec4<T, P>(v) += scalar;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec1<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1) += v2;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator+(T scalar, tvec4<T, P> const & v)\r\n\t{\r\n\t\treturn tvec4<T, P>(v) += scalar;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator+(tvec1<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v2) += v1;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1) += v2;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator-(tvec4<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec4<T, P>(v) -= scalar;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec1<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1) -= v2;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator-(T scalar, tvec4<T, P> const & v)\r\n\t{\r\n\t\treturn tvec4<T, P>(scalar) -= v;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator-(tvec1<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1.x) -= v2;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1) -= v2;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator*(tvec4<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec4<T, P>(v) *= scalar;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec1<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1) *= v2;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator*(T scalar, tvec4<T, P> const & v)\r\n\t{\r\n\t\treturn tvec4<T, P>(v) *= scalar;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator*(tvec1<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v2) *= v1;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1) *= v2;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator/(tvec4<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec4<T, P>(v) /= scalar;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec1<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1) /= v2;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator/(T scalar, tvec4<T, P> const & v)\r\n\t{\r\n\t\treturn tvec4<T, P>(scalar) /= v;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator/(tvec1<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1.x) /= v2;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1) /= v2;\r\n\t}\r\n\r\n\t// -- Binary bit operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator%(tvec4<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec4<T, P>(v) %= scalar;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator%(tvec4<T, P> const & v1, tvec1<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1) %= v2.x;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator%(T scalar, tvec4<T, P> const & v)\r\n\t{\r\n\t\treturn tvec4<T, P>(scalar) %= v;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator%(tvec1<T, P> const & scalar, tvec4<T, P> const & v)\r\n\t{\r\n\t\treturn tvec4<T, P>(scalar.x) %= v;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator%(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1) %= v2;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator&(tvec4<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec4<T, P>(v) &= scalar;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator&(tvec4<T, P> const & v, tvec1<T, P> const & scalar)\r\n\t{\r\n\t\treturn tvec4<T, P>(v) &= scalar;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator&(T scalar, tvec4<T, P> const & v)\r\n\t{\r\n\t\treturn tvec4<T, P>(scalar) &= v;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator&(tvec1<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1.x) &= v2;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator&(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1) &= v2;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator|(tvec4<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec4<T, P>(v) |= scalar;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator|(tvec4<T, P> const & v1, tvec1<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1) |= v2.x;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator|(T scalar, tvec4<T, P> const & v)\r\n\t{\r\n\t\treturn tvec4<T, P>(scalar) |= v;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator|(tvec1<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1.x) |= v2;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator|(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1) |= v2;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator^(tvec4<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec4<T, P>(v) ^= scalar;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator^(tvec4<T, P> const & v1, tvec1<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1) ^= v2.x;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator^(T scalar, tvec4<T, P> const & v)\r\n\t{\r\n\t\treturn tvec4<T, P>(scalar) ^= v;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator^(tvec1<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1.x) ^= v2;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator^(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1) ^= v2;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator<<(tvec4<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec4<T, P>(v) <<= scalar;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator<<(tvec4<T, P> const & v1, tvec1<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1) <<= v2.x;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator<<(T scalar, tvec4<T, P> const & v)\r\n\t{\r\n\t\treturn tvec4<T, P>(scalar) <<= v;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator<<(tvec1<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1.x) <<= v2;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator<<(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1) <<= v2;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator>>(tvec4<T, P> const & v, T scalar)\r\n\t{\r\n\t\treturn tvec4<T, P>(v) >>= scalar;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator>>(tvec4<T, P> const & v1, tvec1<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1) >>= v2.x;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator>>(T scalar, tvec4<T, P> const & v)\r\n\t{\r\n\t\treturn tvec4<T, P>(scalar) >>= v;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator>>(tvec1<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1.x) >>= v2;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator>>(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<T, P>(v1) >>= v2;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P> \r\n\tGLM_FUNC_QUALIFIER tvec4<T, P> operator~(tvec4<T, P> const & v)\r\n\t{\r\n\t\treturn detail::compute_vec4_bitwise_not<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(v);\r\n\t}\r\n\r\n\t// -- Boolean operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER bool operator==(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t{\r\n\t\treturn detail::compute_vec4_equal<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(v1, v2);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER bool operator!=(tvec4<T, P> const & v1, tvec4<T, P> const & v2)\r\n\t{\r\n\t\treturn detail::compute_vec4_nequal<T, P, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<P>::value>::call(v1, v2);\r\n\t}\r\n\r\n\ttemplate <precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<bool, P> operator&&(tvec4<bool, P> const & v1, tvec4<bool, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<bool, P>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z, v1.w && v2.w);\r\n\t}\r\n\r\n\ttemplate <precision P>\r\n\tGLM_FUNC_QUALIFIER tvec4<bool, P> operator||(tvec4<bool, P> const & v1, tvec4<bool, P> const & v2)\r\n\t{\r\n\t\treturn tvec4<bool, P>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z, v1.w || v2.w);\r\n\t}\r\n}//namespace glm\r\n\r\n#if GLM_ARCH != GLM_ARCH_PURE && GLM_HAS_ALIGNED_TYPE\r\n#\tinclude \"type_vec4_simd.inl\"\r\n#endif\r\n","#include <Input.h>\r\n#include <stdio.h>\r\n\r\n// #include <Graphics/Camera2D.h>\r\n// #include <core/Utils.h>\r\n\r\n// #include <ASSERT.h>\r\n\r\n// #include <core/Export.h>\r\n// #include <core/Scripting.h>\r\n// #include <core/Core.h>\r\n\r\n#if _LINUX\r\n#include <SDL2/SDL.h>\r\n#endif\r\n\r\n#if __EMSCRIPTEN__\r\n#include <SDL2/SDL_scancode.h>\r\n#endif\r\n\r\nnamespace engine {\r\n\r\n\t// TODO MOUSE:\r\n\r\n\tvoid Input::setContext(InputData* data)\r\n\t{\r\n\t\t_mousePos = &data->mousePos;\r\n\t\t_thisFrame = data->thisFrame;\r\n\t\t_lastFrame = data->lastFrame;\r\n\r\n\r\n\t\t_mouseButtons = data->mouse;\r\n\t\tmaxKeyboardButtons = data->maxKeyBoardButtons;\r\n\t\t_mouseButtonsLastFrame = data->mouseLastFrame;\r\n\r\n\t\t// touches ?\r\n\t}\r\n\r\n\tvoid Input::init(InputData* data, int maxKeyboardButtons, Touches* touches)\r\n\t{\r\n\t\t//if (!mouse || !thisFrame || !lastFrame)\r\n\t\t//{\r\n\t\t\t// failed to init\r\n\t\t\t// ASSERT(false);\r\n\t\t\t// http://www.vogella.com/tutorials/AndroidTouch/article.html\r\n\t\t//}\r\n\r\n\t\tsetContext(data);\r\n\r\n\t\t// _mousePos  = &data->mousePos;\r\n\t\t// _thisFrame = data->thisFrame;\r\n\t\t// _lastFrame = data->lastFrame;\r\n\t\t_touches = touches;\r\n\t\t// _mouseButtons = data->mouse;\r\n\t\t// _mouseButtonsLastFrame = data->mouseLastFrame;\r\n\t\t// Input::maxKeyboardButtons = (maxKeyboardButtons);\r\n\r\n\t\tif (touches)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < maxTouches; i++)\r\n\t\t\t{\r\n\t\t\t\ttouches->touch[i].id = i;\r\n\t\t\t}\r\n\t\t\ttouches->currentActiveCount = 0;\r\n\t\t}\r\n\r\n#if 0\r\n\t\tInitLua();\r\n#endif\r\n\t}\r\n#if 0\r\n\tvoid Input::InitLua()\r\n\t{\r\n\t\t// jos lua tuettu niin... ja ei ffi binding\r\n\t\tsol::state* lua = engine::Script::getState();\r\n\r\n\r\n\t\t// lua->set(\"Input\", Input());\r\n\t\t// lua->set_function(\"getMousePosition\", &Input::getMousePosition, this);\r\n\t\t// lua.set_function(\"m2\", &some_class::member_function, some_class{});\r\n\r\n\r\n\t\t// Mousepos\r\n\t\tlua->new_usertype<vec2>(\"vec2\",\r\n\t\t\t\"x\", &vec2::x,\r\n\t\t\t\"y\", &vec2::y\r\n\t\t\t);\r\n\r\n\t\tlua->new_usertype<vec4>(\"vec4\",\r\n\t\t\t\"x\", &vec4::x,\r\n\t\t\t\"y\", &vec4::y,\r\n\t\t\t\"z\", &vec4::z,\r\n\t\t\t\"w\", &vec4::w);\r\n\r\n\r\n\t\t// mouse\r\n\t\tlua->set_function(\"getMousePos\", Input::getMousePositionLua);\r\n\t\tlua->set_function(\"mouseDown\", Input::mouseDown);\r\n\r\n\t\t// keyboard\r\n\t\tlua->set_function(\"isKeyDown\", Input::isKeyDown);\r\n\t\tlua->set_function(\"isKeyPressed\", Input::isKeyPressed);\r\n\r\n\t\t// keycodes\r\n#if _LINUX\r\n\t\t(*lua)[\"input\"] = lua->create_table_with(\"a\", SDL_SCANCODE_A,\r\n\t\t\t\"d\", SDL_SCANCODE_D, \"w\", SDL_SCANCODE_W,\r\n\t\t\t\"s\", SDL_SCANCODE_S,\r\n\t\t\t\"i\", SDL_SCANCODE_I,\r\n\t\t\t\"q\", SDL_SCANCODE_Q,\r\n\t\t\t\"space\", SDL_SCANCODE_SPACE\r\n\t\t);\r\n#elif _WIN32\r\n\t\t(*lua)[\"input\"] = lua->create_table_with(\"a\", 65,\r\n\t\t\t\"d\", 68, \"w\", 87,\r\n\t\t\t\"s\", 83,\r\n\t\t\t\"i\", 0x49,\r\n\t\t\t\"q\", 0x51,\r\n\t\t\t\"space\", 0x20\r\n\t\t);\r\n\t\t// TODO:\r\n#elif __EMSCRIPTEN__\r\n\t\t(*lua)[\"input\"] = lua->create_table_with(\"a\", SDL_SCANCODE_A,\r\n\t\t\t\"d\", SDL_SCANCODE_D, \"w\", SDL_SCANCODE_W,\r\n\t\t\t\"s\", SDL_SCANCODE_S,\r\n\t\t\t\"i\", SDL_SCANCODE_I,\r\n\t\t\t\"q\", SDL_SCANCODE_Q,\r\n\t\t\t\"space\", SDL_SCANCODE_SPACE\r\n\t\t);\r\n#elif _ANDROID  // hacky android input\r\n\t\t(*lua)[\"input\"] = lua->create_table_with(\r\n\t\t\t\"a\", 0,\r\n\t\t\t\"s\", 1,\r\n\t\t\t\"w\", 2,\r\n\t\t\t\"d\", 3,\r\n\t\t\t\"space\", 4,\r\n\t\t\t\"i\", 5,\r\n\t\t\t\"q\", 6\r\n\t\t);\r\n\r\n\t\tmaxKeyboardButtons = 6;\r\n\t\tlua->set_function(\"luaLog\", luaLog);\r\n#endif\r\n\r\n\r\n\r\n\t}\r\n\r\n\r\n\tvoid Input::InitLuaCamera()\r\n\t{\r\n\t\tsol::state* lua = engine::Script::getState();     // aika hacky\r\n\t\tlua->set_function(\"moveCamera\", &Camera2D::moveLua, _mainCamera);\r\n\t\tlua->set_function(\"setCameraPosition\", &Camera2D::setPositionLua, _mainCamera);\r\n\t\tlua->set_function(\"getCameraRect\", &Camera2D::getCameraRect, _mainCamera);\r\n\t}\r\n\r\n\r\n\r\n\tvec2 Input::getMousePositionLua()\r\n\t{\r\n\t\tauto point = _mainCamera->convertScreenToWorld({ _mousePos->x, _mousePos->y });\r\n\t\treturn vec2{ point.x, point.y };\r\n\t\t// return{\r\n\t}\r\n#endif\r\n\r\n\r\n\tvoid Input::setButton(int keycode, bool state)\r\n\t{\r\n\t\t_thisFrame[keycode] = state;\r\n\t}\r\n\r\n\r\n\tvoid Input::unPressKey(int keycode)\r\n\t{\r\n\t\t//\t\tASSERT(keycode < maxKeyboardButtons);\r\n\r\n\t\t_mouseButtons[0] = false;\r\n\r\n\t\t// _thisFrame[keycode] = false;\r\n\t\t// _lastFrame[keycode] = false;\r\n\t}\r\n\r\n\tvoid Input::noHover()\r\n\t{\r\n\t\t_hovered = false;\r\n\t}\r\n\tvoid Input::hover()\r\n\t{\r\n\t\t_hovered = true;\r\n\t}\r\n\r\n\tvoid Input::setMainCamera(Camera2D* camera)\r\n\t{\r\n\t\t_mainCamera = camera;\r\n\t\t//\t\tInitLuaCamera();\r\n\t\t\t\t// sol::state* lua = engine::Script::getState();     // aika hacky\r\n\t\t\t\t// lua->set_function(\"moveCamera\", &Camera2D::moveLua, _mainCamera);\r\n\t\t\t\t// lua->set_function(\"setCameraPosition\", &Camera2D::setPositionLua, _mainCamera);\r\n\t\t\t\t// lua->set_function(\"getCameraRect\", &Camera2D::getCameraRect, _mainCamera);\r\n\t}\r\n\r\n\tvec2f Input::getMousePosition()\r\n\t{\r\n\t\treturn *_mousePos;\r\n\t}\r\n\r\n\tvec2f Input::getMousePositionWorld(EngineCore* core)\r\n\t{\r\n\t\treturn camera::convertScreenToWorld(core, Input::getMousePosition());\r\n\t}\r\n\r\n\tbool Input::mouseDown(Mouse button)\r\n\t{\r\n\t\treturn mouseDown((int)button);\r\n\t}\r\n\r\n\tbool Input::mouseDown(int numButton)\r\n\t{\r\n\r\n\r\n\t\tif (numButton >= 0 && numButton < maxMouseButtons && !_hovered)\r\n\t\t\treturn _mouseButtons[numButton];\r\n\r\n\t\t// ASSERT(false);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tbool Input::mousePressed(Mouse button)\r\n\t{\r\n\t\tint b{ (int)button };\r\n\t\tif (b >= 0 && b < maxMouseButtons && !_hovered)\r\n\t\t{\r\n\t\t\treturn _mouseButtons[b] && !_mouseButtonsLastFrame[b];\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tbool Input::isKeyPressed(Keycode keycode_)\r\n\t{\r\n\t\tint keycode = (int)keycode_;\r\n\t\t// printf(\"%i : %i : %i\", keycode_, _thisFrame[keycode], _lastFrame[keycode]);\r\n\t\tif (keycode >= 0 && keycode < maxKeyboardButtons)\r\n\t\t\treturn _thisFrame[keycode] && !_lastFrame[keycode];\r\n\r\n\t\t// ASSERT(false); // no such key\r\n\t\treturn false;\r\n\t}\r\n\r\n\tbool Input::isKeyDown(Keycode keycode_)\r\n\t{\r\n\t\tint keycode = (int)keycode_;\r\n\t\tif (keycode >= 0 && keycode < maxKeyboardButtons)\r\n\t\t\treturn _thisFrame[keycode];\r\n\r\n\t\t//ASSERT(false);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tTouches Input::getTouches()\r\n\t{\r\n\t\treturn *_touches;\r\n\t}\r\n\r\n\tvec2f Input::getTouchPosition(unsigned int touchId)\r\n\t{\r\n\t\tif (touchId < maxTouches)\r\n\t\t\treturn _touches->touch[touchId].position;\r\n\r\n\t\t//ASSERT(false);  // TODO: Logging\r\n\t\treturn { -1, -1 };\r\n\t}\r\n\r\n\t// jnky android mouse\r\n\tvoid Input::setMouseState(bool down, vec2f location)\r\n\t{\r\n\t\t*_mousePos = location;\r\n\t\t_mouseButtons[1] = down;\r\n\t}\r\n\r\n\r\n\r\n\tTouch Input::getTouch(unsigned int touchId)\r\n\t{\r\n\t\tif (touchId < maxTouches)\r\n\t\t\treturn _touches->touch[touchId];\r\n\r\n\t\t//ASSERT(false);\r\n\t\treturn {}; // TODO: ...\r\n\t}\r\n\r\n\tvec2f   Input::windowDimension{};\r\n\tvec2f*  Input::_mousePos = 0;\r\n\tbool*   Input::_thisFrame = 0;\r\n\tbool*   Input::_lastFrame = 0;\r\n\tint     Input::maxKeyboardButtons;\r\n\tbool*   Input::_mouseButtons = 0;\r\n\tbool*   Input::_mouseButtonsLastFrame = 0;\r\n\tbool    Input::_hovered = false;\r\n\r\n\tTouches* Input::_touches = 0;\r\n\r\n\tengine::Camera2D* Input::_mainCamera = 0;\r\n\r\n\t// constexpr int maxMouseButtons    = 1;\r\n}\r\n\r\n#if 0\r\nbool isKeyDown(int key)\r\n{\r\n\treturn engine::Input::isKeyDown(key);\r\n}\r\n\r\nbool isKeyPressed(int key)\r\n{\r\n\treturn engine::Input::isKeyPressed(key);\r\n}\r\n\r\n//vec2 getMousePosition()\r\n//{\r\n//\tauto mouse = engine::Input::getMousePosition();\r\n//\treturn {mouse.x, mouse.y};\r\n//}\r\n\r\nbool isMouseDown(int key)\r\n{\r\n\treturn engine::Input::mouseDown(key);\r\n}\r\n#endif\r\n","// -*- C++ -*-\n//===------------------------ functional ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL\n#define _LIBCPP_FUNCTIONAL\n\n/*\n    functional synopsis\n\nnamespace std\n{\n\ntemplate <class Arg, class Result>\nstruct unary_function\n{\n    typedef Arg    argument_type;\n    typedef Result result_type;\n};\n\ntemplate <class Arg1, class Arg2, class Result>\nstruct binary_function\n{\n    typedef Arg1   first_argument_type;\n    typedef Arg2   second_argument_type;\n    typedef Result result_type;\n};\n\ntemplate <class T>\nclass reference_wrapper\n    : public unary_function<T1, R> // if wrapping a unary functor\n    : public binary_function<T1, T2, R> // if wraping a binary functor\n{\npublic:\n    // types\n    typedef T type;\n    typedef see below result_type; // Not always defined\n\n    // construct/copy/destroy\n    reference_wrapper(T&) noexcept;\n    reference_wrapper(T&&) = delete; // do not bind to temps\n    reference_wrapper(const reference_wrapper<T>& x) noexcept;\n\n    // assignment\n    reference_wrapper& operator=(const reference_wrapper<T>& x) noexcept;\n\n    // access\n    operator T& () const noexcept;\n    T& get() const noexcept;\n\n    // invoke\n    template <class... ArgTypes>\n      typename result_of<T&(ArgTypes&&...)>::type\n          operator() (ArgTypes&&...) const;\n};\n\ntemplate <class T> reference_wrapper<T> ref(T& t) noexcept;\ntemplate <class T> void ref(const T&& t) = delete;\ntemplate <class T> reference_wrapper<T> ref(reference_wrapper<T>t) noexcept;\n\ntemplate <class T> reference_wrapper<const T> cref(const T& t) noexcept;\ntemplate <class T> void cref(const T&& t) = delete;\ntemplate <class T> reference_wrapper<const T> cref(reference_wrapper<T> t) noexcept;\n\ntemplate <class T> // <class T=void> in C++14\nstruct plus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct minus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct multiplies : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct divides : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct modulus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct negate : unary_function<T, T>\n{\n    T operator()(const T& x) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct equal_to : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct not_equal_to : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct greater : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct less : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct greater_equal : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct less_equal : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_and : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_or : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_not : unary_function<T, bool>\n{\n    bool operator()(const T& x) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_and : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_or : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_xor : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T=void> // C++14\nstruct bit_xor : unary_function<T, bool>\n{\n    bool operator()(const T& x) const;\n};\n\ntemplate <class Predicate>\nclass unary_negate\n    : public unary_function<typename Predicate::argument_type, bool>\n{\npublic:\n    explicit unary_negate(const Predicate& pred);\n    bool operator()(const typename Predicate::argument_type& x) const;\n};\n\ntemplate <class Predicate> unary_negate<Predicate> not1(const Predicate& pred);\n\ntemplate <class Predicate>\nclass binary_negate\n    : public binary_function<typename Predicate::first_argument_type,\n                             typename Predicate::second_argument_type,\n                             bool>\n{\npublic:\n    explicit binary_negate(const Predicate& pred);\n    bool operator()(const typename Predicate::first_argument_type& x,\n                    const typename Predicate::second_argument_type& y) const;\n};\n\ntemplate <class Predicate> binary_negate<Predicate> not2(const Predicate& pred);\n\ntemplate <class F> unspecified not_fn(F&& f); // C++17\n\ntemplate<class T> struct is_bind_expression;\ntemplate<class T> struct is_placeholder;\n\n    // See C++14 20.9.9, Function object binders\ntemplate <class T> constexpr bool is_bind_expression_v\n  = is_bind_expression<T>::value; // C++17\ntemplate <class T> constexpr int is_placeholder_v\n  = is_placeholder<T>::value; // C++17\n\n\ntemplate<class Fn, class... BoundArgs>\n  unspecified bind(Fn&&, BoundArgs&&...);\ntemplate<class R, class Fn, class... BoundArgs>\n  unspecified bind(Fn&&, BoundArgs&&...);\n\nnamespace placeholders {\n  // M is the implementation-defined number of placeholders\n  extern unspecified _1;\n  extern unspecified _2;\n  .\n  .\n  .\n  extern unspecified _Mp;\n}\n\ntemplate <class Operation>\nclass binder1st\n    : public unary_function<typename Operation::second_argument_type,\n                            typename Operation::result_type>\n{\nprotected:\n    Operation                               op;\n    typename Operation::first_argument_type value;\npublic:\n    binder1st(const Operation& x, const typename Operation::first_argument_type y);\n    typename Operation::result_type operator()(      typename Operation::second_argument_type& x) const;\n    typename Operation::result_type operator()(const typename Operation::second_argument_type& x) const;\n};\n\ntemplate <class Operation, class T>\nbinder1st<Operation> bind1st(const Operation& op, const T& x);\n\ntemplate <class Operation>\nclass binder2nd\n    : public unary_function<typename Operation::first_argument_type,\n                            typename Operation::result_type>\n{\nprotected:\n    Operation                                op;\n    typename Operation::second_argument_type value;\npublic:\n    binder2nd(const Operation& x, const typename Operation::second_argument_type y);\n    typename Operation::result_type operator()(      typename Operation::first_argument_type& x) const;\n    typename Operation::result_type operator()(const typename Operation::first_argument_type& x) const;\n};\n\ntemplate <class Operation, class T>\nbinder2nd<Operation> bind2nd(const Operation& op, const T& x);\n\ntemplate <class Arg, class Result>\nclass pointer_to_unary_function : public unary_function<Arg, Result>\n{\npublic:\n    explicit pointer_to_unary_function(Result (*f)(Arg));\n    Result operator()(Arg x) const;\n};\n\ntemplate <class Arg, class Result>\npointer_to_unary_function<Arg,Result> ptr_fun(Result (*f)(Arg));\n\ntemplate <class Arg1, class Arg2, class Result>\nclass pointer_to_binary_function : public binary_function<Arg1, Arg2, Result>\n{\npublic:\n    explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));\n    Result operator()(Arg1 x, Arg2 y) const;\n};\n\ntemplate <class Arg1, class Arg2, class Result>\npointer_to_binary_function<Arg1,Arg2,Result> ptr_fun(Result (*f)(Arg1,Arg2));\n\ntemplate<class S, class T>\nclass mem_fun_t : public unary_function<T*, S>\n{\npublic:\n    explicit mem_fun_t(S (T::*p)());\n    S operator()(T* p) const;\n};\n\ntemplate<class S, class T, class A>\nclass mem_fun1_t : public binary_function<T*, A, S>\n{\npublic:\n    explicit mem_fun1_t(S (T::*p)(A));\n    S operator()(T* p, A x) const;\n};\n\ntemplate<class S, class T>          mem_fun_t<S,T>    mem_fun(S (T::*f)());\ntemplate<class S, class T, class A> mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));\n\ntemplate<class S, class T>\nclass mem_fun_ref_t : public unary_function<T, S>\n{\npublic:\n    explicit mem_fun_ref_t(S (T::*p)());\n    S operator()(T& p) const;\n};\n\ntemplate<class S, class T, class A>\nclass mem_fun1_ref_t : public binary_function<T, A, S>\n{\npublic:\n    explicit mem_fun1_ref_t(S (T::*p)(A));\n    S operator()(T& p, A x) const;\n};\n\ntemplate<class S, class T>          mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)());\ntemplate<class S, class T, class A> mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A));\n\ntemplate <class S, class T>\nclass const_mem_fun_t : public unary_function<const T*, S>\n{\npublic:\n    explicit const_mem_fun_t(S (T::*p)() const);\n    S operator()(const T* p) const;\n};\n\ntemplate <class S, class T, class A>\nclass const_mem_fun1_t : public binary_function<const T*, A, S>\n{\npublic:\n    explicit const_mem_fun1_t(S (T::*p)(A) const);\n    S operator()(const T* p, A x) const;\n};\n\ntemplate <class S, class T>          const_mem_fun_t<S,T>    mem_fun(S (T::*f)() const);\ntemplate <class S, class T, class A> const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const);\n\ntemplate <class S, class T>\nclass const_mem_fun_ref_t : public unary_function<T, S>\n{\npublic:\n    explicit const_mem_fun_ref_t(S (T::*p)() const);\n    S operator()(const T& p) const;\n};\n\ntemplate <class S, class T, class A>\nclass const_mem_fun1_ref_t : public binary_function<T, A, S>\n{\npublic:\n    explicit const_mem_fun1_ref_t(S (T::*p)(A) const);\n    S operator()(const T& p, A x) const;\n};\n\ntemplate <class S, class T>          const_mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)() const);\ntemplate <class S, class T, class A> const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const);\n\ntemplate<class R, class T> unspecified mem_fn(R T::*);\n\nclass bad_function_call\n    : public exception\n{\n};\n\ntemplate<class> class function; // undefined\n\ntemplate<class R, class... ArgTypes>\nclass function<R(ArgTypes...)>\n  : public unary_function<T1, R>      // iff sizeof...(ArgTypes) == 1 and\n                                      // ArgTypes contains T1\n  : public binary_function<T1, T2, R> // iff sizeof...(ArgTypes) == 2 and\n                                      // ArgTypes contains T1 and T2\n{\npublic:\n    typedef R result_type;\n\n    // construct/copy/destroy:\n    function() noexcept;\n    function(nullptr_t) noexcept;\n    function(const function&);\n    function(function&&) noexcept;\n    template<class F>\n      function(F);\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&) noexcept;            // removed in C++17\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, nullptr_t) noexcept; // removed in C++17\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, const function&);    // removed in C++17\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, function&&);         // removed in C++17\n    template<class F, Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, F);                  // removed in C++17\n\n    function& operator=(const function&);\n    function& operator=(function&&) noexcept;\n    function& operator=(nullptr_t) noexcept;\n    template<class F>\n      function& operator=(F&&);\n    template<class F>\n      function& operator=(reference_wrapper<F>) noexcept;\n\n    ~function();\n\n    // function modifiers:\n    void swap(function&) noexcept;\n    template<class F, class Alloc>\n      void assign(F&&, const Alloc&);                 // Removed in C++17\n\n    // function capacity:\n    explicit operator bool() const noexcept;\n\n    // function invocation:\n    R operator()(ArgTypes...) const;\n\n    // function target access:\n    const std::type_info& target_type() const noexcept;\n    template <typename T>       T* target() noexcept;\n    template <typename T> const T* target() const noexcept;\n};\n\n// Null pointer comparisons:\ntemplate <class R, class ... ArgTypes>\n  bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;\n\ntemplate <class R, class ... ArgTypes>\n  bool operator==(nullptr_t, const function<R(ArgTypes...)>&) noexcept;\n\ntemplate <class R, class ... ArgTypes>\n  bool operator!=(const function<R(ArgTypes...)>&, nullptr_t) noexcept;\n\ntemplate <class  R, class ... ArgTypes>\n  bool operator!=(nullptr_t, const function<R(ArgTypes...)>&) noexcept;\n\n// specialized algorithms:\ntemplate <class  R, class ... ArgTypes>\n  void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&) noexcept;\n\ntemplate <class T> struct hash;\n\ntemplate <> struct hash<bool>;\ntemplate <> struct hash<char>;\ntemplate <> struct hash<signed char>;\ntemplate <> struct hash<unsigned char>;\ntemplate <> struct hash<char16_t>;\ntemplate <> struct hash<char32_t>;\ntemplate <> struct hash<wchar_t>;\ntemplate <> struct hash<short>;\ntemplate <> struct hash<unsigned short>;\ntemplate <> struct hash<int>;\ntemplate <> struct hash<unsigned int>;\ntemplate <> struct hash<long>;\ntemplate <> struct hash<long long>;\ntemplate <> struct hash<unsigned long>;\ntemplate <> struct hash<unsigned long long>;\n\ntemplate <> struct hash<float>;\ntemplate <> struct hash<double>;\ntemplate <> struct hash<long double>;\n\ntemplate<class T> struct hash<T*>;\n\n}  // std\n\nPOLICY:  For non-variadic implementations, the number of arguments is limited\n         to 3.  It is hoped that the need for non-variadic implementations\n         will be minimal.\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n#include <memory>\n#include <tuple>\n\n#include <__functional_base>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS plus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x + __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS plus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS minus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x - __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS minus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS multiplies : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x * __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS multiplies<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS divides : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x / __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS divides<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS modulus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x % __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS modulus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS negate : unary_function<_Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x) const\n        {return -__x;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS negate<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n    _NOEXCEPT_(noexcept(- _VSTD::forward<_Tp>(__x)))\n    -> decltype        (- _VSTD::forward<_Tp>(__x))\n        { return        - _VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS equal_to : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x == __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS equal_to<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS not_equal_to : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x != __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS not_equal_to<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS greater : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x > __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS greater<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n// less in <__functional_base>\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS greater_equal : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x >= __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS greater_equal<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS less_equal : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x <= __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS less_equal<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS logical_and : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x && __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS logical_and<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS logical_or : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x || __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS logical_or<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS logical_not : unary_function<_Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x) const\n        {return !__x;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS logical_not<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n    _NOEXCEPT_(noexcept(!_VSTD::forward<_Tp>(__x)))\n    -> decltype        (!_VSTD::forward<_Tp>(__x))\n        { return        !_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS bit_and : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x & __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS bit_and<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS bit_or : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x | __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS bit_or<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS bit_xor : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x ^ __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS bit_xor<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\nstruct _LIBCPP_TEMPLATE_VIS bit_not : unary_function<_Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x) const\n        {return ~__x;}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS bit_not<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n    _NOEXCEPT_(noexcept(~_VSTD::forward<_Tp>(__x)))\n    -> decltype        (~_VSTD::forward<_Tp>(__x))\n        { return        ~_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\ntemplate <class _Predicate>\nclass _LIBCPP_TEMPLATE_VIS unary_negate\n    : public unary_function<typename _Predicate::argument_type, bool>\n{\n    _Predicate __pred_;\npublic:\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    explicit unary_negate(const _Predicate& __pred)\n        : __pred_(__pred) {}\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const typename _Predicate::argument_type& __x) const\n        {return !__pred_(__x);}\n};\n\ntemplate <class _Predicate>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nunary_negate<_Predicate>\nnot1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}\n\ntemplate <class _Predicate>\nclass _LIBCPP_TEMPLATE_VIS binary_negate\n    : public binary_function<typename _Predicate::first_argument_type,\n                             typename _Predicate::second_argument_type,\n                             bool>\n{\n    _Predicate __pred_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit _LIBCPP_CONSTEXPR_AFTER_CXX11 \n    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const typename _Predicate::first_argument_type& __x,\n                    const typename _Predicate::second_argument_type& __y) const\n        {return !__pred_(__x, __y);}\n};\n\ntemplate <class _Predicate>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbinary_negate<_Predicate>\nnot2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}\n\ntemplate <class __Operation>\nclass _LIBCPP_TEMPLATE_VIS binder1st\n    : public unary_function<typename __Operation::second_argument_type,\n                            typename __Operation::result_type>\n{\nprotected:\n    __Operation                               op;\n    typename __Operation::first_argument_type value;\npublic:\n    _LIBCPP_INLINE_VISIBILITY binder1st(const __Operation& __x,\n                               const typename __Operation::first_argument_type __y)\n        : op(__x), value(__y) {}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (typename __Operation::second_argument_type& __x) const\n            {return op(value, __x);}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (const typename __Operation::second_argument_type& __x) const\n            {return op(value, __x);}\n};\n\ntemplate <class __Operation, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbinder1st<__Operation>\nbind1st(const __Operation& __op, const _Tp& __x)\n    {return binder1st<__Operation>(__op, __x);}\n\ntemplate <class __Operation>\nclass _LIBCPP_TEMPLATE_VIS binder2nd\n    : public unary_function<typename __Operation::first_argument_type,\n                            typename __Operation::result_type>\n{\nprotected:\n    __Operation                                op;\n    typename __Operation::second_argument_type value;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    binder2nd(const __Operation& __x, const typename __Operation::second_argument_type __y)\n        : op(__x), value(__y) {}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (      typename __Operation::first_argument_type& __x) const\n            {return op(__x, value);}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (const typename __Operation::first_argument_type& __x) const\n            {return op(__x, value);}\n};\n\ntemplate <class __Operation, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbinder2nd<__Operation>\nbind2nd(const __Operation& __op, const _Tp& __x)\n    {return binder2nd<__Operation>(__op, __x);}\n\ntemplate <class _Arg, class _Result>\nclass _LIBCPP_TEMPLATE_VIS pointer_to_unary_function\n    : public unary_function<_Arg, _Result>\n{\n    _Result (*__f_)(_Arg);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_unary_function(_Result (*__f)(_Arg))\n        : __f_(__f) {}\n    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg __x) const\n        {return __f_(__x);}\n};\n\ntemplate <class _Arg, class _Result>\ninline _LIBCPP_INLINE_VISIBILITY\npointer_to_unary_function<_Arg,_Result>\nptr_fun(_Result (*__f)(_Arg))\n    {return pointer_to_unary_function<_Arg,_Result>(__f);}\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nclass _LIBCPP_TEMPLATE_VIS pointer_to_binary_function\n    : public binary_function<_Arg1, _Arg2, _Result>\n{\n    _Result (*__f_)(_Arg1, _Arg2);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))\n        : __f_(__f) {}\n    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg1 __x, _Arg2 __y) const\n        {return __f_(__x, __y);}\n};\n\ntemplate <class _Arg1, class _Arg2, class _Result>\ninline _LIBCPP_INLINE_VISIBILITY\npointer_to_binary_function<_Arg1,_Arg2,_Result>\nptr_fun(_Result (*__f)(_Arg1,_Arg2))\n    {return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f);}\n\ntemplate<class _Sp, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS mem_fun_t : public unary_function<_Tp*, _Sp>\n{\n    _Sp (_Tp::*__p_)();\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_t(_Sp (_Tp::*__p)())\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p) const\n        {return (__p->*__p_)();}\n};\n\ntemplate<class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TEMPLATE_VIS mem_fun1_t : public binary_function<_Tp*, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p, _Ap __x) const\n        {return (__p->*__p_)(__x);}\n};\n\ntemplate<class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun_t<_Sp,_Tp>\nmem_fun(_Sp (_Tp::*__f)())\n    {return mem_fun_t<_Sp,_Tp>(__f);}\n\ntemplate<class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun1_t<_Sp,_Tp,_Ap>\nmem_fun(_Sp (_Tp::*__f)(_Ap))\n    {return mem_fun1_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate<class _Sp, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS mem_fun_ref_t : public unary_function<_Tp, _Sp>\n{\n    _Sp (_Tp::*__p_)();\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_ref_t(_Sp (_Tp::*__p)())\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p) const\n        {return (__p.*__p_)();}\n};\n\ntemplate<class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TEMPLATE_VIS mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p, _Ap __x) const\n        {return (__p.*__p_)(__x);}\n};\n\ntemplate<class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun_ref_t<_Sp,_Tp>\nmem_fun_ref(_Sp (_Tp::*__f)())\n    {return mem_fun_ref_t<_Sp,_Tp>(__f);}\n\ntemplate<class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun1_ref_t<_Sp,_Tp,_Ap>\nmem_fun_ref(_Sp (_Tp::*__f)(_Ap))\n    {return mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate <class _Sp, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS const_mem_fun_t : public unary_function<const _Tp*, _Sp>\n{\n    _Sp (_Tp::*__p_)() const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p) const\n        {return (__p->*__p_)();}\n};\n\ntemplate <class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TEMPLATE_VIS const_mem_fun1_t : public binary_function<const _Tp*, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap) const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p, _Ap __x) const\n        {return (__p->*__p_)(__x);}\n};\n\ntemplate <class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun_t<_Sp,_Tp>\nmem_fun(_Sp (_Tp::*__f)() const)\n    {return const_mem_fun_t<_Sp,_Tp>(__f);}\n\ntemplate <class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun1_t<_Sp,_Tp,_Ap>\nmem_fun(_Sp (_Tp::*__f)(_Ap) const)\n    {return const_mem_fun1_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate <class _Sp, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS const_mem_fun_ref_t : public unary_function<_Tp, _Sp>\n{\n    _Sp (_Tp::*__p_)() const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p) const\n        {return (__p.*__p_)();}\n};\n\ntemplate <class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TEMPLATE_VIS const_mem_fun1_ref_t\n    : public binary_function<_Tp, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap) const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p, _Ap __x) const\n        {return (__p.*__p_)(__x);}\n};\n\ntemplate <class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun_ref_t<_Sp,_Tp>\nmem_fun_ref(_Sp (_Tp::*__f)() const)\n    {return const_mem_fun_ref_t<_Sp,_Tp>(__f);}\n\ntemplate <class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun1_ref_t<_Sp,_Tp,_Ap>\nmem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)\n    {return const_mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}\n\n////////////////////////////////////////////////////////////////////////////////\n//                                MEMFUN\n//==============================================================================\n\ntemplate <class _Tp>\nclass __mem_fn\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type __f_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY __mem_fn(type __f) _NOEXCEPT : __f_(__f) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    // invoke\n    template <class... _ArgTypes>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return<type, _ArgTypes...>::type\n    operator() (_ArgTypes&&... __args) const {\n        return __invoke(__f_, _VSTD::forward<_ArgTypes>(__args)...);\n    }\n#else\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return0<type, _A0>::type\n    operator() (_A0& __a0) const {\n        return __invoke(__f_, __a0);\n    }\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return0<type, _A0 const>::type\n    operator() (_A0 const& __a0) const {\n        return __invoke(__f_, __a0);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0, _A1>::type\n    operator() (_A0& __a0, _A1& __a1) const {\n        return __invoke(__f_, __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0 const, _A1>::type\n    operator() (_A0 const& __a0, _A1& __a1) const {\n        return __invoke(__f_, __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0, _A1 const>::type\n    operator() (_A0& __a0, _A1 const& __a1) const {\n        return __invoke(__f_, __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0 const, _A1 const>::type\n    operator() (_A0 const& __a0, _A1 const& __a1) const {\n        return __invoke(__f_, __a0, __a1);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1, _A2>::type\n    operator() (_A0& __a0, _A1& __a1, _A2& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1, _A2>::type\n    operator() (_A0 const& __a0, _A1& __a1, _A2& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1 const, _A2>::type\n    operator() (_A0& __a0, _A1 const& __a1, _A2& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1, _A2 const>::type\n    operator() (_A0& __a0, _A1& __a1, _A2 const& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1 const, _A2>::type\n    operator() (_A0 const& __a0, _A1 const& __a1, _A2& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1, _A2 const>::type\n    operator() (_A0 const& __a0, _A1& __a1, _A2 const& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1 const, _A2 const>::type\n    operator() (_A0& __a0, _A1 const& __a1, _A2 const& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1 const, _A2 const>::type\n    operator() (_A0 const& __a0, _A1 const& __a1, _A2 const& __a2) const {\n        return __invoke(__f_, __a0, __a1, __a2);\n    }\n#endif\n};\n\ntemplate<class _Rp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__mem_fn<_Rp _Tp::*>\nmem_fn(_Rp _Tp::* __pm) _NOEXCEPT\n{\n    return __mem_fn<_Rp _Tp::*>(__pm);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//                                FUNCTION\n//==============================================================================\n\n// bad_function_call\n\nclass _LIBCPP_EXCEPTION_ABI bad_function_call\n    : public exception\n{\n};\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_function_call()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_function_call();\n#else\n\t_VSTD::abort();\n#endif\n}\n\ntemplate<class _Fp> class _LIBCPP_TEMPLATE_VIS function; // undefined\n\nnamespace __function\n{\n\ntemplate<class _Rp>\nstruct __maybe_derive_from_unary_function\n{\n};\n\ntemplate<class _Rp, class _A1>\nstruct __maybe_derive_from_unary_function<_Rp(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate<class _Rp>\nstruct __maybe_derive_from_binary_function\n{\n};\n\ntemplate<class _Rp, class _A1, class _A2>\nstruct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Fp>\n_LIBCPP_INLINE_VISIBILITY\nbool __not_null(_Fp const&) { return true; }\n\ntemplate <class _Fp>\n_LIBCPP_INLINE_VISIBILITY\nbool __not_null(_Fp* __ptr) { return __ptr; }\n\ntemplate <class _Ret, class _Class>\n_LIBCPP_INLINE_VISIBILITY\nbool __not_null(_Ret _Class::*__ptr) { return __ptr; }\n\ntemplate <class _Fp>\n_LIBCPP_INLINE_VISIBILITY\nbool __not_null(function<_Fp> const& __f) { return !!__f; }\n\n} // namespace __function\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\nnamespace __function {\n\ntemplate<class _Fp> class __base;\n\ntemplate<class _Rp, class ..._ArgTypes>\nclass __base<_Rp(_ArgTypes...)>\n{\n    __base(const __base&);\n    __base& operator=(const __base&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY __base() {}\n    _LIBCPP_INLINE_VISIBILITY virtual ~__base() {}\n    virtual __base* __clone() const = 0;\n    virtual void __clone(__base*) const = 0;\n    virtual void destroy() _NOEXCEPT = 0;\n    virtual void destroy_deallocate() _NOEXCEPT = 0;\n    virtual _Rp operator()(_ArgTypes&& ...) = 0;\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* target(const type_info&) const _NOEXCEPT = 0;\n    virtual const std::type_info& target_type() const _NOEXCEPT = 0;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _FD, class _Alloc, class _FB> class __func;\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nclass __func<_Fp, _Alloc, _Rp(_ArgTypes...)>\n    : public  __base<_Rp(_ArgTypes...)>\n{\n    __compressed_pair<_Fp, _Alloc> __f_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(_Fp&& __f)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),\n                                    _VSTD::forward_as_tuple()) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(const _Fp& __f, const _Alloc& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),\n                                    _VSTD::forward_as_tuple(__a)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(const _Fp& __f, _Alloc&& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),\n                                    _VSTD::forward_as_tuple(_VSTD::move(__a))) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(_Fp&& __f, _Alloc&& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),\n                                    _VSTD::forward_as_tuple(_VSTD::move(__a))) {}\n    virtual __base<_Rp(_ArgTypes...)>* __clone() const;\n    virtual void __clone(__base<_Rp(_ArgTypes...)>*) const;\n    virtual void destroy() _NOEXCEPT;\n    virtual void destroy_deallocate() _NOEXCEPT;\n    virtual _Rp operator()(_ArgTypes&& ... __arg);\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* target(const type_info&) const _NOEXCEPT;\n    virtual const std::type_info& target_type() const _NOEXCEPT;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\n__base<_Rp(_ArgTypes...)>*\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone() const\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\n    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;\n    _Ap __a(__f_.second());\n    typedef __allocator_destructor<_Ap> _Dp;\n    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));\n    return __hold.release();\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone(__base<_Rp(_ArgTypes...)>* __p) const\n{\n    ::new (__p) __func(__f_.first(), __f_.second());\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy() _NOEXCEPT\n{\n    __f_.~__compressed_pair<_Fp, _Alloc>();\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate() _NOEXCEPT\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\n    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;\n    _Ap __a(__f_.second());\n    __f_.~__compressed_pair<_Fp, _Alloc>();\n    __a.deallocate(this, 1);\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\n_Rp\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)\n{\n    typedef __invoke_void_return_wrapper<_Rp> _Invoker;\n    return _Invoker::__call(__f_.first(), _VSTD::forward<_ArgTypes>(__arg)...);\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nconst void*\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target(const type_info& __ti) const _NOEXCEPT\n{\n    if (__ti == typeid(_Fp))\n        return &__f_.first();\n    return (const void*)0;\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nconst std::type_info&\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target_type() const _NOEXCEPT\n{\n    return typeid(_Fp);\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\n}  // __function\n\ntemplate<class _Rp, class ..._ArgTypes>\nclass _LIBCPP_TEMPLATE_VIS function<_Rp(_ArgTypes...)>\n    : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>,\n      public __function::__maybe_derive_from_binary_function<_Rp(_ArgTypes...)>\n{\n    typedef __function::__base<_Rp(_ArgTypes...)> __base;\n    typename aligned_storage<3*sizeof(void*)>::type __buf_;\n    __base* __f_;\n\n    _LIBCPP_NO_CFI static __base *__as_base(void *p) {\n      return reinterpret_cast<__base*>(p);\n    }\n\n    template <class _Fp, bool = !is_same<_Fp, function>::value &&\n                                __invokable<_Fp&, _ArgTypes...>::value>\n        struct __callable;\n    template <class _Fp>\n        struct __callable<_Fp, true>\n        {\n            static const bool value = is_same<void, _Rp>::value ||\n                is_convertible<typename __invoke_of<_Fp&, _ArgTypes...>::type,\n                               _Rp>::value;\n        };\n    template <class _Fp>\n        struct __callable<_Fp, false>\n        {\n            static const bool value = false;\n        };\npublic:\n    typedef _Rp result_type;\n\n    // construct/copy/destroy:\n    _LIBCPP_INLINE_VISIBILITY\n    function() _NOEXCEPT : __f_(0) {}\n    _LIBCPP_INLINE_VISIBILITY\n    function(nullptr_t) _NOEXCEPT : __f_(0) {}\n    function(const function&);\n    function(function&&) _NOEXCEPT;\n    template<class _Fp, class = typename enable_if<\n        __callable<_Fp>::value && !is_same<_Fp, function>::value\n    >::type>\n    function(_Fp);\n\n#if _LIBCPP_STD_VER <= 14\n    template<class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      function(allocator_arg_t, const _Alloc&) _NOEXCEPT : __f_(0) {}\n    template<class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      function(allocator_arg_t, const _Alloc&, nullptr_t) _NOEXCEPT : __f_(0) {}\n    template<class _Alloc>\n      function(allocator_arg_t, const _Alloc&, const function&);\n    template<class _Alloc>\n      function(allocator_arg_t, const _Alloc&, function&&);\n    template<class _Fp, class _Alloc, class = typename enable_if<__callable<_Fp>::value>::type>\n      function(allocator_arg_t, const _Alloc& __a, _Fp __f);\n#endif\n\n    function& operator=(const function&);\n    function& operator=(function&&) _NOEXCEPT;\n    function& operator=(nullptr_t) _NOEXCEPT;\n    template<class _Fp>\n      typename enable_if\n      <\n        __callable<typename decay<_Fp>::type>::value &&\n        !is_same<typename remove_reference<_Fp>::type, function>::value,\n        function&\n      >::type\n      operator=(_Fp&&);\n\n    ~function();\n\n    // function modifiers:\n    void swap(function&) _NOEXCEPT;\n\n#if _LIBCPP_STD_VER <= 14\n    template<class _Fp, class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      void assign(_Fp&& __f, const _Alloc& __a)\n        {function(allocator_arg, __a, _VSTD::forward<_Fp>(__f)).swap(*this);}\n#endif\n\n    // function capacity:\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return __f_;}\n\n    // deleted overloads close possible hole in the type system\n    template<class _R2, class... _ArgTypes2>\n      bool operator==(const function<_R2(_ArgTypes2...)>&) const = delete;\n    template<class _R2, class... _ArgTypes2>\n      bool operator!=(const function<_R2(_ArgTypes2...)>&) const = delete;\npublic:\n    // function invocation:\n    _Rp operator()(_ArgTypes...) const;\n\n#ifndef _LIBCPP_NO_RTTI\n    // function target access:\n    const std::type_info& target_type() const _NOEXCEPT;\n    template <typename _Tp> _Tp* target() _NOEXCEPT;\n    template <typename _Tp> const _Tp* target() const _NOEXCEPT;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::function(const function& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f_ = __as_base(&__buf_);\n        __f.__f_->__clone(__f_);\n    }\n    else\n        __f_ = __f.__f_->__clone();\n}\n\n#if _LIBCPP_STD_VER <= 14\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,\n                                     const function& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f_ = __as_base(&__buf_);\n        __f.__f_->__clone(__f_);\n    }\n    else\n        __f_ = __f.__f_->__clone();\n}\n#endif\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::function(function&& __f) _NOEXCEPT\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f_ = __as_base(&__buf_);\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n}\n\n#if _LIBCPP_STD_VER <= 14\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,\n                                     function&& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f_ = __as_base(&__buf_);\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n}\n#endif\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp, class>\nfunction<_Rp(_ArgTypes...)>::function(_Fp __f)\n    : __f_(0)\n{\n    if (__function::__not_null(__f))\n    {\n        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_ArgTypes...)> _FF;\n        if (sizeof(_FF) <= sizeof(__buf_) && is_nothrow_copy_constructible<_Fp>::value)\n        {\n            __f_ = ::new((void*)&__buf_) _FF(_VSTD::move(__f));\n        }\n        else\n        {\n            typedef allocator<_FF> _Ap;\n            _Ap __a;\n            typedef __allocator_destructor<_Ap> _Dp;\n            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n            ::new (__hold.get()) _FF(_VSTD::move(__f), allocator<_Fp>(__a));\n            __f_ = __hold.release();\n        }\n    }\n}\n\n#if _LIBCPP_STD_VER <= 14\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp, class _Alloc, class>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f)\n    : __f_(0)\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\n    if (__function::__not_null(__f))\n    {\n        typedef __function::__func<_Fp, _Alloc, _Rp(_ArgTypes...)> _FF;\n        typedef typename __rebind_alloc_helper<__alloc_traits, _FF>::type _Ap;\n        _Ap __a(__a0);\n        if (sizeof(_FF) <= sizeof(__buf_) && \n            is_nothrow_copy_constructible<_Fp>::value && is_nothrow_copy_constructible<_Ap>::value)\n        {\n            __f_ = ::new((void*)&__buf_) _FF(_VSTD::move(__f), _Alloc(__a));\n        }\n        else\n        {\n            typedef __allocator_destructor<_Ap> _Dp;\n            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n            ::new (__hold.get()) _FF(_VSTD::move(__f), _Alloc(__a));\n            __f_ = __hold.release();\n        }\n    }\n}\n#endif\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(const function& __f)\n{\n    function(__f).swap(*this);\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(function&& __f) _NOEXCEPT\n{\n    if ((void *)__f_ == &__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n    __f_ = 0;\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f_ = __as_base(&__buf_);\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(nullptr_t) _NOEXCEPT\n{\n    if ((void *)__f_ == &__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n    __f_ = 0;\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp>\ntypename enable_if\n<\n    function<_Rp(_ArgTypes...)>::template __callable<typename decay<_Fp>::type>::value &&\n    !is_same<typename remove_reference<_Fp>::type, function<_Rp(_ArgTypes...)>>::value,\n    function<_Rp(_ArgTypes...)>&\n>::type\nfunction<_Rp(_ArgTypes...)>::operator=(_Fp&& __f)\n{\n    function(_VSTD::forward<_Fp>(__f)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::~function()\n{\n    if ((void *)__f_ == &__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nvoid\nfunction<_Rp(_ArgTypes...)>::swap(function& __f) _NOEXCEPT\n{\n    if (_VSTD::addressof(__f) == this)\n      return;\n    if ((void *)__f_ == &__buf_ && (void *)__f.__f_ == &__f.__buf_)\n    {\n        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;\n        __base* __t = __as_base(&__tempbuf);\n        __f_->__clone(__t);\n        __f_->destroy();\n        __f_ = 0;\n        __f.__f_->__clone(__as_base(&__buf_));\n        __f.__f_->destroy();\n        __f.__f_ = 0;\n        __f_ = __as_base(&__buf_);\n        __t->__clone(__as_base(&__f.__buf_));\n        __t->destroy();\n        __f.__f_ = __as_base(&__f.__buf_);\n    }\n    else if ((void *)__f_ == &__buf_)\n    {\n        __f_->__clone(__as_base(&__f.__buf_));\n        __f_->destroy();\n        __f_ = __f.__f_;\n        __f.__f_ = __as_base(&__f.__buf_);\n    }\n    else if ((void *)__f.__f_ == &__f.__buf_)\n    {\n        __f.__f_->__clone(__as_base(&__buf_));\n        __f.__f_->destroy();\n        __f.__f_ = __f_;\n        __f_ = __as_base(&__buf_);\n    }\n    else\n        _VSTD::swap(__f_, __f.__f_);\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\n_Rp\nfunction<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const\n{\n    if (__f_ == 0)\n        __throw_bad_function_call();\n    return (*__f_)(_VSTD::forward<_ArgTypes>(__arg)...);\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Rp, class ..._ArgTypes>\nconst std::type_info&\nfunction<_Rp(_ArgTypes...)>::target_type() const _NOEXCEPT\n{\n    if (__f_ == 0)\n        return typeid(void);\n    return __f_->target_type();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <typename _Tp>\n_Tp*\nfunction<_Rp(_ArgTypes...)>::target() _NOEXCEPT\n{\n    if (__f_ == 0)\n        return (_Tp*)0;\n    return (_Tp*)__f_->target(typeid(_Tp));\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <typename _Tp>\nconst _Tp*\nfunction<_Rp(_ArgTypes...)>::target() const _NOEXCEPT\n{\n    if (__f_ == 0)\n        return (const _Tp*)0;\n    return (const _Tp*)__f_->target(typeid(_Tp));\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return !__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return !__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return (bool)__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return (bool)__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(function<_Rp(_ArgTypes...)>& __x, function<_Rp(_ArgTypes...)>& __y) _NOEXCEPT\n{return __x.swap(__y);}\n\n#else // _LIBCPP_HAS_NO_VARIADICS\n\n#include <__functional_03>\n\n#endif\n\n////////////////////////////////////////////////////////////////////////////////\n//                                  BIND\n//==============================================================================\n\ntemplate<class _Tp> struct __is_bind_expression : public false_type {};\ntemplate<class _Tp> struct _LIBCPP_TEMPLATE_VIS is_bind_expression\n    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp>\nconstexpr size_t is_bind_expression_v = is_bind_expression<_Tp>::value;\n#endif\n\ntemplate<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};\ntemplate<class _Tp> struct _LIBCPP_TEMPLATE_VIS is_placeholder\n    : public __is_placeholder<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp>\nconstexpr size_t is_placeholder_v = is_placeholder<_Tp>::value;\n#endif\n\nnamespace placeholders\n{\n\ntemplate <int _Np> struct __ph {};\n\n#if defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_BIND)\n_LIBCPP_FUNC_VIS extern const __ph<1>   _1;\n_LIBCPP_FUNC_VIS extern const __ph<2>   _2;\n_LIBCPP_FUNC_VIS extern const __ph<3>   _3;\n_LIBCPP_FUNC_VIS extern const __ph<4>   _4;\n_LIBCPP_FUNC_VIS extern const __ph<5>   _5;\n_LIBCPP_FUNC_VIS extern const __ph<6>   _6;\n_LIBCPP_FUNC_VIS extern const __ph<7>   _7;\n_LIBCPP_FUNC_VIS extern const __ph<8>   _8;\n_LIBCPP_FUNC_VIS extern const __ph<9>   _9;\n_LIBCPP_FUNC_VIS extern const __ph<10> _10;\n#else\nconstexpr __ph<1>   _1{};\nconstexpr __ph<2>   _2{};\nconstexpr __ph<3>   _3{};\nconstexpr __ph<4>   _4{};\nconstexpr __ph<5>   _5{};\nconstexpr __ph<6>   _6{};\nconstexpr __ph<7>   _7{};\nconstexpr __ph<8>   _8{};\nconstexpr __ph<9>   _9{};\nconstexpr __ph<10> _10{};\n#endif // defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_BIND)\n\n}  // placeholders\n\ntemplate<int _Np>\nstruct __is_placeholder<placeholders::__ph<_Np> >\n    : public integral_constant<int, _Np> {};\n\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\n__mu(reference_wrapper<_Tp> __t, _Uj&)\n{\n    return __t.get();\n}\n\ntemplate <class _Ti, class ..._Uj, size_t ..._Indx>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __invoke_of<_Ti&, _Uj...>::type\n__mu_expand(_Ti& __ti, tuple<_Uj...>& __uj, __tuple_indices<_Indx...>)\n{\n    return __ti(_VSTD::forward<_Uj>(_VSTD::get<_Indx>(__uj))...);\n}\n\ntemplate <class _Ti, class ..._Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __lazy_enable_if\n<\n    is_bind_expression<_Ti>::value,\n    __invoke_of<_Ti&, _Uj...>\n>::type\n__mu(_Ti& __ti, tuple<_Uj...>& __uj)\n{\n    typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;\n    return  __mu_expand(__ti, __uj, __indices());\n}\n\ntemplate <bool IsPh, class _Ti, class _Uj>\nstruct __mu_return2 {};\n\ntemplate <class _Ti, class _Uj>\nstruct __mu_return2<true, _Ti, _Uj>\n{\n    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;\n};\n\ntemplate <class _Ti, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    0 < is_placeholder<_Ti>::value,\n    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type\n>::type\n__mu(_Ti&, _Uj& __uj)\n{\n    const size_t _Indx = is_placeholder<_Ti>::value - 1;\n    return _VSTD::forward<typename tuple_element<_Indx, _Uj>::type>(_VSTD::get<_Indx>(__uj));\n}\n\ntemplate <class _Ti, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_bind_expression<_Ti>::value &&\n    is_placeholder<_Ti>::value == 0 &&\n    !__is_reference_wrapper<_Ti>::value,\n    _Ti&\n>::type\n__mu(_Ti& __ti, _Uj&)\n{\n    return __ti;\n}\n\ntemplate <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,\n          class _TupleUj>\nstruct ____mu_return;\n\ntemplate <bool _Invokable, class _Ti, class ..._Uj>\nstruct ____mu_return_invokable  // false\n{\n    typedef __nat type;\n};\n\ntemplate <class _Ti, class ..._Uj>\nstruct ____mu_return_invokable<true, _Ti, _Uj...>\n{\n    typedef typename __invoke_of<_Ti&, _Uj...>::type type;\n};\n\ntemplate <class _Ti, class ..._Uj>\nstruct ____mu_return<_Ti, false, true, false, tuple<_Uj...> >\n    : public ____mu_return_invokable<__invokable<_Ti&, _Uj...>::value, _Ti, _Uj...>\n{\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, false, false, true, _TupleUj>\n{\n    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,\n                                   _TupleUj>::type&& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, true, false, false, _TupleUj>\n{\n    typedef typename _Ti::type& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, false, false, false, _TupleUj>\n{\n    typedef _Ti& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct __mu_return\n    : public ____mu_return<_Ti,\n                           __is_reference_wrapper<_Ti>::value,\n                           is_bind_expression<_Ti>::value,\n                           0 < is_placeholder<_Ti>::value &&\n                           is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value,\n                           _TupleUj>\n{\n};\n\ntemplate <class _Fp, class _BoundArgs, class _TupleUj>\nstruct __is_valid_bind_return\n{\n    static const bool value = false;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj>\n{\n    static const bool value = __invokable<_Fp,\n                    typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj>\n{\n    static const bool value = __invokable<_Fp,\n                    typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;\n};\n\ntemplate <class _Fp, class _BoundArgs, class _TupleUj,\n          bool = __is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>\nstruct __bind_return;\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true>\n{\n    typedef typename __invoke_of\n    <\n        _Fp&,\n        typename __mu_return\n        <\n            _BoundArgs,\n            _TupleUj\n        >::type...\n    >::type type;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true>\n{\n    typedef typename __invoke_of\n    <\n        _Fp&,\n        typename __mu_return\n        <\n            const _BoundArgs,\n            _TupleUj\n        >::type...\n    >::type type;\n};\n\ntemplate <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __bind_return<_Fp, _BoundArgs, _Args>::type\n__apply_functor(_Fp& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,\n                _Args&& __args)\n{\n    return __invoke(__f, __mu(_VSTD::get<_Indx>(__bound_args), __args)...);\n}\n\ntemplate<class _Fp, class ..._BoundArgs>\nclass __bind\n    : public __weak_result_type<typename decay<_Fp>::type>\n{\nprotected:\n    typedef typename decay<_Fp>::type _Fd;\n    typedef tuple<typename decay<_BoundArgs>::type...> _Td;\nprivate:\n    _Fd __f_;\n    _Td __bound_args_;\n\n    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;\npublic:\n    template <class _Gp, class ..._BA,\n              class = typename enable_if\n                               <\n                                  is_constructible<_Fd, _Gp>::value &&\n                                  !is_same<typename remove_reference<_Gp>::type,\n                                           __bind>::value\n                               >::type>\n      _LIBCPP_INLINE_VISIBILITY\n      explicit __bind(_Gp&& __f, _BA&& ...__bound_args)\n        : __f_(_VSTD::forward<_Gp>(__f)),\n          __bound_args_(_VSTD::forward<_BA>(__bound_args)...) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type\n        operator()(_Args&& ...__args)\n        {\n            return __apply_functor(__f_, __bound_args_, __indices(),\n                                  tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));\n        }\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type\n        operator()(_Args&& ...__args) const\n        {\n            return __apply_functor(__f_, __bound_args_, __indices(),\n                                   tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));\n        }\n};\n\ntemplate<class _Fp, class ..._BoundArgs>\nstruct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {};\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\nclass __bind_r\n    : public __bind<_Fp, _BoundArgs...>\n{\n    typedef __bind<_Fp, _BoundArgs...> base;\n    typedef typename base::_Fd _Fd;\n    typedef typename base::_Td _Td;\npublic:\n    typedef _Rp result_type;\n\n\n    template <class _Gp, class ..._BA,\n              class = typename enable_if\n                               <\n                                  is_constructible<_Fd, _Gp>::value &&\n                                  !is_same<typename remove_reference<_Gp>::type,\n                                           __bind_r>::value\n                               >::type>\n      _LIBCPP_INLINE_VISIBILITY\n      explicit __bind_r(_Gp&& __f, _BA&& ...__bound_args)\n        : base(_VSTD::forward<_Gp>(__f),\n               _VSTD::forward<_BA>(__bound_args)...) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type,\n                           result_type>::value || is_void<_Rp>::value,\n            result_type\n        >::type\n        operator()(_Args&& ...__args)\n        {\n            typedef __invoke_void_return_wrapper<_Rp> _Invoker;\n            return _Invoker::__call(static_cast<base&>(*this), _VSTD::forward<_Args>(__args)...);\n        }\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            is_convertible<typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type,\n                           result_type>::value || is_void<_Rp>::value,\n            result_type\n        >::type\n        operator()(_Args&& ...__args) const\n        {\n            typedef __invoke_void_return_wrapper<_Rp> _Invoker;\n            return _Invoker::__call(static_cast<base const&>(*this), _VSTD::forward<_Args>(__args)...);\n        }\n};\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\nstruct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...> > : public true_type {};\n\ntemplate<class _Fp, class ..._BoundArgs>\ninline _LIBCPP_INLINE_VISIBILITY\n__bind<_Fp, _BoundArgs...>\nbind(_Fp&& __f, _BoundArgs&&... __bound_args)\n{\n    typedef __bind<_Fp, _BoundArgs...> type;\n    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);\n}\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\ninline _LIBCPP_INLINE_VISIBILITY\n__bind_r<_Rp, _Fp, _BoundArgs...>\nbind(_Fp&& __f, _BoundArgs&&... __bound_args)\n{\n    typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;\n    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<bool>\n    : public unary_function<bool, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(bool __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<char>\n    : public unary_function<char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<signed char>\n    : public unary_function<signed char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(signed char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned char>\n    : public unary_function<unsigned char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<char16_t>\n    : public unary_function<char16_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char16_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<char32_t>\n    : public unary_function<char32_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char32_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<wchar_t>\n    : public unary_function<wchar_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(wchar_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<short>\n    : public unary_function<short, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned short>\n    : public unary_function<unsigned short, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<int>\n    : public unary_function<int, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned int>\n    : public unary_function<unsigned int, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<long>\n    : public unary_function<long, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned long>\n    : public unary_function<unsigned long, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<long long>\n    : public __scalar_hash<long long>\n{\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<unsigned long long>\n    : public __scalar_hash<unsigned long long>\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_INT128\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<__int128_t>\n    : public __scalar_hash<__int128_t>\n{\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<__uint128_t>\n    : public __scalar_hash<__uint128_t>\n{\n};\n\n#endif\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<float>\n    : public __scalar_hash<float>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(float __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n       if (__v == 0)\n           return 0;\n        return __scalar_hash<float>::operator()(__v);\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<double>\n    : public __scalar_hash<double>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(double __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n       if (__v == 0)\n           return 0;\n        return __scalar_hash<double>::operator()(__v);\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS hash<long double>\n    : public __scalar_hash<long double>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(long double __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n        if (__v == 0)\n            return 0;\n#if defined(__i386__)\n        // Zero out padding bits\n        union\n        {\n            long double __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            } __s;\n        } __u;\n        __u.__s.__a = 0;\n        __u.__s.__b = 0;\n        __u.__s.__c = 0;\n        __u.__s.__d = 0;\n        __u.__t = __v;\n        return __u.__s.__a ^ __u.__s.__b ^ __u.__s.__c ^ __u.__s.__d;\n#elif defined(__x86_64__)\n        // Zero out padding bits\n        union\n        {\n            long double __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            } __s;\n        } __u;\n        __u.__s.__a = 0;\n        __u.__s.__b = 0;\n        __u.__t = __v;\n        return __u.__s.__a ^ __u.__s.__b;\n#else\n        return __scalar_hash<long double>::operator()(__v);\n#endif\n    }\n};\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp, bool = is_enum<_Tp>::value>\nstruct _LIBCPP_TEMPLATE_VIS __enum_hash\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        typedef typename underlying_type<_Tp>::type type;\n        return hash<type>{}(static_cast<type>(__v));\n    }\n};\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS __enum_hash<_Tp, false> {\n    __enum_hash() = delete;\n    __enum_hash(__enum_hash const&) = delete;\n    __enum_hash& operator=(__enum_hash const&) = delete;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash : public __enum_hash<_Tp>\n{\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 14\n\n#define __cpp_lib_invoke 201411\n\ntemplate <class _Fn, class ..._Args>\nresult_of_t<_Fn&&(_Args&&...)>\ninvoke(_Fn&& __f, _Args&&... __args)\n    noexcept(noexcept(_VSTD::__invoke(_VSTD::forward<_Fn>(__f), _VSTD::forward<_Args>(__args)...)))\n{\n    return _VSTD::__invoke(_VSTD::forward<_Fn>(__f), _VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _DecayFunc>\nclass _LIBCPP_TEMPLATE_VIS __not_fn_imp {\n  _DecayFunc __fd;\n\npublic:\n    __not_fn_imp() = delete;\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Args&& ...__args) &\n            noexcept(noexcept(!_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...)))\n        -> decltype(          !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...))\n        { return              !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...); }\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Args&& ...__args) &&\n            noexcept(noexcept(!_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...)))\n        -> decltype(          !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...))\n        { return              !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...); }\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Args&& ...__args) const&\n            noexcept(noexcept(!_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...)))\n        -> decltype(          !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...))\n        { return              !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...); }\n\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Args&& ...__args) const&&\n            noexcept(noexcept(!_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...)))\n        -> decltype(          !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...))\n        { return              !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...); }\n\nprivate:\n    template <class _RawFunc,\n              class = enable_if_t<!is_same<decay_t<_RawFunc>, __not_fn_imp>::value>>\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __not_fn_imp(_RawFunc&& __rf)\n        : __fd(_VSTD::forward<_RawFunc>(__rf)) {}\n\n    template <class _RawFunc>\n    friend inline _LIBCPP_INLINE_VISIBILITY\n    __not_fn_imp<decay_t<_RawFunc>> not_fn(_RawFunc&&);\n};\n\ntemplate <class _RawFunc>\ninline _LIBCPP_INLINE_VISIBILITY\n__not_fn_imp<decay_t<_RawFunc>> not_fn(_RawFunc&& __fn) {\n    return __not_fn_imp<decay_t<_RawFunc>>(_VSTD::forward<_RawFunc>(__fn));\n}\n\n#endif\n\n// struct hash<T*> in <memory>\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL\n","/* stb_image_write - v1.07 - public domain - http://nothings.org/stb/stb_image_write.h\r\n   writes out PNG/BMP/TGA/JPEG/HDR images to C stdio - Sean Barrett 2010-2015\r\n                                     no warranty implied; use at your own risk\r\n\r\n   Before #including,\r\n\r\n       #define STB_IMAGE_WRITE_IMPLEMENTATION\r\n\r\n   in the file that you want to have the implementation.\r\n\r\n   Will probably not work correctly with strict-aliasing optimizations.\r\n\r\nABOUT:\r\n\r\n   This header file is a library for writing images to C stdio. It could be\r\n   adapted to write to memory or a general streaming interface; let me know.\r\n\r\n   The PNG output is not optimal; it is 20-50% larger than the file\r\n   written by a decent optimizing implementation. This library is designed\r\n   for source code compactness and simplicity, not optimal image file size\r\n   or run-time performance.\r\n\r\nBUILDING:\r\n\r\n   You can #define STBIW_ASSERT(x) before the #include to avoid using assert.h.\r\n   You can #define STBIW_MALLOC(), STBIW_REALLOC(), and STBIW_FREE() to replace\r\n   malloc,realloc,free.\r\n   You can define STBIW_MEMMOVE() to replace memmove()\r\n\r\nUSAGE:\r\n\r\n   There are four functions, one for each image file format:\r\n\r\n     int stbi_write_png(char const *filename, int w, int h, int comp, const void *data, int stride_in_bytes);\r\n     int stbi_write_bmp(char const *filename, int w, int h, int comp, const void *data);\r\n     int stbi_write_tga(char const *filename, int w, int h, int comp, const void *data);\r\n     int stbi_write_hdr(char const *filename, int w, int h, int comp, const float *data);\r\n     int stbi_write_jpg(char const *filename, int w, int h, int comp, const float *data);\r\n\r\n   There are also four equivalent functions that use an arbitrary write function. You are\r\n   expected to open/close your file-equivalent before and after calling these:\r\n\r\n     int stbi_write_png_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data, int stride_in_bytes);\r\n     int stbi_write_bmp_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);\r\n     int stbi_write_tga_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);\r\n     int stbi_write_hdr_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const float *data);\r\n     int stbi_write_jpg_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data, int quality);\r\n\r\n   where the callback is:\r\n      void stbi_write_func(void *context, void *data, int size);\r\n\r\n   You can define STBI_WRITE_NO_STDIO to disable the file variant of these\r\n   functions, so the library will not use stdio.h at all. However, this will\r\n   also disable HDR writing, because it requires stdio for formatted output.\r\n\r\n   Each function returns 0 on failure and non-0 on success.\r\n\r\n   The functions create an image file defined by the parameters. The image\r\n   is a rectangle of pixels stored from left-to-right, top-to-bottom.\r\n   Each pixel contains 'comp' channels of data stored interleaved with 8-bits\r\n   per channel, in the following order: 1=Y, 2=YA, 3=RGB, 4=RGBA. (Y is\r\n   monochrome color.) The rectangle is 'w' pixels wide and 'h' pixels tall.\r\n   The *data pointer points to the first byte of the top-left-most pixel.\r\n   For PNG, \"stride_in_bytes\" is the distance in bytes from the first byte of\r\n   a row of pixels to the first byte of the next row of pixels.\r\n\r\n   PNG creates output files with the same number of components as the input.\r\n   The BMP format expands Y to RGB in the file format and does not\r\n   output alpha.\r\n\r\n   PNG supports writing rectangles of data even when the bytes storing rows of\r\n   data are not consecutive in memory (e.g. sub-rectangles of a larger image),\r\n   by supplying the stride between the beginning of adjacent rows. The other\r\n   formats do not. (Thus you cannot write a native-format BMP through the BMP\r\n   writer, both because it is in BGR order and because it may have padding\r\n   at the end of the line.)\r\n\r\n   HDR expects linear float data. Since the format is always 32-bit rgb(e)\r\n   data, alpha (if provided) is discarded, and for monochrome data it is\r\n   replicated across all three channels.\r\n\r\n   TGA supports RLE or non-RLE compressed data. To use non-RLE-compressed\r\n   data, set the global variable 'stbi_write_tga_with_rle' to 0.\r\n   \r\n   JPEG does ignore alpha channels in input data; quality is between 1 and 100.\r\n   Higher quality looks better but results in a bigger image.\r\n   JPEG baseline (no JPEG progressive).\r\n\r\nCREDITS:\r\n\r\n   PNG/BMP/TGA\r\n      Sean Barrett\r\n   HDR\r\n      Baldur Karlsson\r\n   TGA monochrome:\r\n      Jean-Sebastien Guay\r\n   misc enhancements:\r\n      Tim Kelsey\r\n   TGA RLE\r\n      Alan Hickman\r\n   initial file IO callback implementation\r\n      Emmanuel Julien\r\n   JPEG\r\n      Jon Olick (original jo_jpeg.cpp code)\r\n      Daniel Gibson\r\n   bugfixes:\r\n      github:Chribba\r\n      Guillaume Chereau\r\n      github:jry2\r\n      github:romigrou\r\n      Sergio Gonzalez\r\n      Jonas Karlsson\r\n      Filip Wasil\r\n      Thatcher Ulrich\r\n      github:poppolopoppo\r\n      Patrick Boettcher\r\n      \r\nLICENSE\r\n\r\n  See end of file for license information.\r\n\r\n*/\r\n\r\n#ifndef INCLUDE_STB_IMAGE_WRITE_H\r\n#define INCLUDE_STB_IMAGE_WRITE_H\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#ifdef STB_IMAGE_WRITE_STATIC\r\n#define STBIWDEF static\r\n#else\r\n#define STBIWDEF extern\r\nextern int stbi_write_tga_with_rle;\r\n#endif\r\n\r\n#ifndef STBI_WRITE_NO_STDIO\r\nSTBIWDEF int stbi_write_png(char const *filename, int w, int h, int comp, const void  *data, int stride_in_bytes);\r\nSTBIWDEF int stbi_write_bmp(char const *filename, int w, int h, int comp, const void  *data);\r\nSTBIWDEF int stbi_write_tga(char const *filename, int w, int h, int comp, const void  *data);\r\nSTBIWDEF int stbi_write_hdr(char const *filename, int w, int h, int comp, const float *data);\r\nSTBIWDEF int stbi_write_jpg(char const *filename, int x, int y, int comp, const void  *data, int quality);\r\n#endif\r\n\r\ntypedef void stbi_write_func(void *context, void *data, int size);\r\n\r\nSTBIWDEF int stbi_write_png_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data, int stride_in_bytes);\r\nSTBIWDEF int stbi_write_bmp_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);\r\nSTBIWDEF int stbi_write_tga_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);\r\nSTBIWDEF int stbi_write_hdr_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const float *data);\r\nSTBIWDEF int stbi_write_jpg_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void  *data, int quality);\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif//INCLUDE_STB_IMAGE_WRITE_H\r\n\r\n#ifdef STB_IMAGE_WRITE_IMPLEMENTATION\r\n\r\n#ifdef _WIN32\r\n   #ifndef _CRT_SECURE_NO_WARNINGS\r\n   #define _CRT_SECURE_NO_WARNINGS\r\n   #endif\r\n   #ifndef _CRT_NONSTDC_NO_DEPRECATE\r\n   #define _CRT_NONSTDC_NO_DEPRECATE\r\n   #endif\r\n#endif\r\n\r\n#ifndef STBI_WRITE_NO_STDIO\r\n#include <stdio.h>\r\n#endif // STBI_WRITE_NO_STDIO\r\n\r\n#include <stdarg.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <math.h>\r\n\r\n#if defined(STBIW_MALLOC) && defined(STBIW_FREE) && (defined(STBIW_REALLOC) || defined(STBIW_REALLOC_SIZED))\r\n// ok\r\n#elif !defined(STBIW_MALLOC) && !defined(STBIW_FREE) && !defined(STBIW_REALLOC) && !defined(STBIW_REALLOC_SIZED)\r\n// ok\r\n#else\r\n#error \"Must define all or none of STBIW_MALLOC, STBIW_FREE, and STBIW_REALLOC (or STBIW_REALLOC_SIZED).\"\r\n#endif\r\n\r\n#ifndef STBIW_MALLOC\r\n#define STBIW_MALLOC(sz)        malloc(sz)\r\n#define STBIW_REALLOC(p,newsz)  realloc(p,newsz)\r\n#define STBIW_FREE(p)           free(p)\r\n#endif\r\n\r\n#ifndef STBIW_REALLOC_SIZED\r\n#define STBIW_REALLOC_SIZED(p,oldsz,newsz) STBIW_REALLOC(p,newsz)\r\n#endif\r\n\r\n\r\n#ifndef STBIW_MEMMOVE\r\n#define STBIW_MEMMOVE(a,b,sz) memmove(a,b,sz)\r\n#endif\r\n\r\n\r\n#ifndef STBIW_ASSERT\r\n#include <assert.h>\r\n#define STBIW_ASSERT(x) assert(x)\r\n#endif\r\n\r\n#define STBIW_UCHAR(x) (unsigned char) ((x) & 0xff)\r\n\r\ntypedef struct\r\n{\r\n   stbi_write_func *func;\r\n   void *context;\r\n} stbi__write_context;\r\n\r\n// initialize a callback-based context\r\nstatic void stbi__start_write_callbacks(stbi__write_context *s, stbi_write_func *c, void *context)\r\n{\r\n   s->func    = c;\r\n   s->context = context;\r\n}\r\n\r\n#ifndef STBI_WRITE_NO_STDIO\r\n\r\nstatic void stbi__stdio_write(void *context, void *data, int size)\r\n{\r\n   fwrite(data,1,size,(FILE*) context);\r\n}\r\n\r\nstatic int stbi__start_write_file(stbi__write_context *s, const char *filename)\r\n{\r\n   FILE *f = fopen(filename, \"wb\");\r\n   stbi__start_write_callbacks(s, stbi__stdio_write, (void *) f);\r\n   return f != NULL;\r\n}\r\n\r\nstatic void stbi__end_write_file(stbi__write_context *s)\r\n{\r\n   fclose((FILE *)s->context);\r\n}\r\n\r\n#endif // !STBI_WRITE_NO_STDIO\r\n\r\ntypedef unsigned int stbiw_uint32;\r\ntypedef int stb_image_write_test[sizeof(stbiw_uint32)==4 ? 1 : -1];\r\n\r\n#ifdef STB_IMAGE_WRITE_STATIC\r\nstatic int stbi_write_tga_with_rle = 1;\r\n#else\r\nint stbi_write_tga_with_rle = 1;\r\n#endif\r\n\r\nstatic void stbiw__writefv(stbi__write_context *s, const char *fmt, va_list v)\r\n{\r\n   while (*fmt) {\r\n      switch (*fmt++) {\r\n         case ' ': break;\r\n         case '1': { unsigned char x = STBIW_UCHAR(va_arg(v, int));\r\n                     s->func(s->context,&x,1);\r\n                     break; }\r\n         case '2': { int x = va_arg(v,int);\r\n                     unsigned char b[2];\r\n                     b[0] = STBIW_UCHAR(x);\r\n                     b[1] = STBIW_UCHAR(x>>8);\r\n                     s->func(s->context,b,2);\r\n                     break; }\r\n         case '4': { stbiw_uint32 x = va_arg(v,int);\r\n                     unsigned char b[4];\r\n                     b[0]=STBIW_UCHAR(x);\r\n                     b[1]=STBIW_UCHAR(x>>8);\r\n                     b[2]=STBIW_UCHAR(x>>16);\r\n                     b[3]=STBIW_UCHAR(x>>24);\r\n                     s->func(s->context,b,4);\r\n                     break; }\r\n         default:\r\n            STBIW_ASSERT(0);\r\n            return;\r\n      }\r\n   }\r\n}\r\n\r\nstatic void stbiw__writef(stbi__write_context *s, const char *fmt, ...)\r\n{\r\n   va_list v;\r\n   va_start(v, fmt);\r\n   stbiw__writefv(s, fmt, v);\r\n   va_end(v);\r\n}\r\n\r\nstatic void stbiw__putc(stbi__write_context *s, unsigned char c)\r\n{\r\n   s->func(s->context, &c, 1);\r\n}\r\n\r\nstatic void stbiw__write3(stbi__write_context *s, unsigned char a, unsigned char b, unsigned char c)\r\n{\r\n   unsigned char arr[3];\r\n   arr[0] = a, arr[1] = b, arr[2] = c;\r\n   s->func(s->context, arr, 3);\r\n}\r\n\r\nstatic void stbiw__write_pixel(stbi__write_context *s, int rgb_dir, int comp, int write_alpha, int expand_mono, unsigned char *d)\r\n{\r\n   unsigned char bg[3] = { 255, 0, 255}, px[3];\r\n   int k;\r\n\r\n   if (write_alpha < 0)\r\n      s->func(s->context, &d[comp - 1], 1);\r\n\r\n   switch (comp) {\r\n      case 2: // 2 pixels = mono + alpha, alpha is written separately, so same as 1-channel case\r\n      case 1:\r\n         if (expand_mono)\r\n            stbiw__write3(s, d[0], d[0], d[0]); // monochrome bmp\r\n         else\r\n            s->func(s->context, d, 1);  // monochrome TGA\r\n         break;\r\n      case 4:\r\n         if (!write_alpha) {\r\n            // composite against pink background\r\n            for (k = 0; k < 3; ++k)\r\n               px[k] = bg[k] + ((d[k] - bg[k]) * d[3]) / 255;\r\n            stbiw__write3(s, px[1 - rgb_dir], px[1], px[1 + rgb_dir]);\r\n            break;\r\n         }\r\n         /* FALLTHROUGH */\r\n      case 3:\r\n         stbiw__write3(s, d[1 - rgb_dir], d[1], d[1 + rgb_dir]);\r\n         break;\r\n   }\r\n   if (write_alpha > 0)\r\n      s->func(s->context, &d[comp - 1], 1);\r\n}\r\n\r\nstatic void stbiw__write_pixels(stbi__write_context *s, int rgb_dir, int vdir, int x, int y, int comp, void *data, int write_alpha, int scanline_pad, int expand_mono)\r\n{\r\n   stbiw_uint32 zero = 0;\r\n   int i,j, j_end;\r\n\r\n   if (y <= 0)\r\n      return;\r\n\r\n   if (vdir < 0)\r\n      j_end = -1, j = y-1;\r\n   else\r\n      j_end =  y, j = 0;\r\n\r\n   for (; j != j_end; j += vdir) {\r\n      for (i=0; i < x; ++i) {\r\n         unsigned char *d = (unsigned char *) data + (j*x+i)*comp;\r\n         stbiw__write_pixel(s, rgb_dir, comp, write_alpha, expand_mono, d);\r\n      }\r\n      s->func(s->context, &zero, scanline_pad);\r\n   }\r\n}\r\n\r\nstatic int stbiw__outfile(stbi__write_context *s, int rgb_dir, int vdir, int x, int y, int comp, int expand_mono, void *data, int alpha, int pad, const char *fmt, ...)\r\n{\r\n   if (y < 0 || x < 0) {\r\n      return 0;\r\n   } else {\r\n      va_list v;\r\n      va_start(v, fmt);\r\n      stbiw__writefv(s, fmt, v);\r\n      va_end(v);\r\n      stbiw__write_pixels(s,rgb_dir,vdir,x,y,comp,data,alpha,pad, expand_mono);\r\n      return 1;\r\n   }\r\n}\r\n\r\nstatic int stbi_write_bmp_core(stbi__write_context *s, int x, int y, int comp, const void *data)\r\n{\r\n   int pad = (-x*3) & 3;\r\n   return stbiw__outfile(s,-1,-1,x,y,comp,1,(void *) data,0,pad,\r\n           \"11 4 22 4\" \"4 44 22 444444\",\r\n           'B', 'M', 14+40+(x*3+pad)*y, 0,0, 14+40,  // file header\r\n            40, x,y, 1,24, 0,0,0,0,0,0);             // bitmap header\r\n}\r\n\r\nSTBIWDEF int stbi_write_bmp_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data)\r\n{\r\n   stbi__write_context s;\r\n   stbi__start_write_callbacks(&s, func, context);\r\n   return stbi_write_bmp_core(&s, x, y, comp, data);\r\n}\r\n\r\n#ifndef STBI_WRITE_NO_STDIO\r\nSTBIWDEF int stbi_write_bmp(char const *filename, int x, int y, int comp, const void *data)\r\n{\r\n   stbi__write_context s;\r\n   if (stbi__start_write_file(&s,filename)) {\r\n      int r = stbi_write_bmp_core(&s, x, y, comp, data);\r\n      stbi__end_write_file(&s);\r\n      return r;\r\n   } else\r\n      return 0;\r\n}\r\n#endif //!STBI_WRITE_NO_STDIO\r\n\r\nstatic int stbi_write_tga_core(stbi__write_context *s, int x, int y, int comp, void *data)\r\n{\r\n   int has_alpha = (comp == 2 || comp == 4);\r\n   int colorbytes = has_alpha ? comp-1 : comp;\r\n   int format = colorbytes < 2 ? 3 : 2; // 3 color channels (RGB/RGBA) = 2, 1 color channel (Y/YA) = 3\r\n\r\n   if (y < 0 || x < 0)\r\n      return 0;\r\n\r\n   if (!stbi_write_tga_with_rle) {\r\n      return stbiw__outfile(s, -1, -1, x, y, comp, 0, (void *) data, has_alpha, 0,\r\n         \"111 221 2222 11\", 0, 0, format, 0, 0, 0, 0, 0, x, y, (colorbytes + has_alpha) * 8, has_alpha * 8);\r\n   } else {\r\n      int i,j,k;\r\n\r\n      stbiw__writef(s, \"111 221 2222 11\", 0,0,format+8, 0,0,0, 0,0,x,y, (colorbytes + has_alpha) * 8, has_alpha * 8);\r\n\r\n      for (j = y - 1; j >= 0; --j) {\r\n          unsigned char *row = (unsigned char *) data + j * x * comp;\r\n         int len;\r\n\r\n         for (i = 0; i < x; i += len) {\r\n            unsigned char *begin = row + i * comp;\r\n            int diff = 1;\r\n            len = 1;\r\n\r\n            if (i < x - 1) {\r\n               ++len;\r\n               diff = memcmp(begin, row + (i + 1) * comp, comp);\r\n               if (diff) {\r\n                  const unsigned char *prev = begin;\r\n                  for (k = i + 2; k < x && len < 128; ++k) {\r\n                     if (memcmp(prev, row + k * comp, comp)) {\r\n                        prev += comp;\r\n                        ++len;\r\n                     } else {\r\n                        --len;\r\n                        break;\r\n                     }\r\n                  }\r\n               } else {\r\n                  for (k = i + 2; k < x && len < 128; ++k) {\r\n                     if (!memcmp(begin, row + k * comp, comp)) {\r\n                        ++len;\r\n                     } else {\r\n                        break;\r\n                     }\r\n                  }\r\n               }\r\n            }\r\n\r\n            if (diff) {\r\n               unsigned char header = STBIW_UCHAR(len - 1);\r\n               s->func(s->context, &header, 1);\r\n               for (k = 0; k < len; ++k) {\r\n                  stbiw__write_pixel(s, -1, comp, has_alpha, 0, begin + k * comp);\r\n               }\r\n            } else {\r\n               unsigned char header = STBIW_UCHAR(len - 129);\r\n               s->func(s->context, &header, 1);\r\n               stbiw__write_pixel(s, -1, comp, has_alpha, 0, begin);\r\n            }\r\n         }\r\n      }\r\n   }\r\n   return 1;\r\n}\r\n\r\nSTBIWDEF int stbi_write_tga_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data)\r\n{\r\n   stbi__write_context s;\r\n   stbi__start_write_callbacks(&s, func, context);\r\n   return stbi_write_tga_core(&s, x, y, comp, (void *) data);\r\n}\r\n\r\n#ifndef STBI_WRITE_NO_STDIO\r\nSTBIWDEF int stbi_write_tga(char const *filename, int x, int y, int comp, const void *data)\r\n{\r\n   stbi__write_context s;\r\n   if (stbi__start_write_file(&s,filename)) {\r\n      int r = stbi_write_tga_core(&s, x, y, comp, (void *) data);\r\n      stbi__end_write_file(&s);\r\n      return r;\r\n   } else\r\n      return 0;\r\n}\r\n#endif\r\n\r\n// *************************************************************************************************\r\n// Radiance RGBE HDR writer\r\n// by Baldur Karlsson\r\n\r\n#define stbiw__max(a, b)  ((a) > (b) ? (a) : (b))\r\n\r\nvoid stbiw__linear_to_rgbe(unsigned char *rgbe, float *linear)\r\n{\r\n   int exponent;\r\n   float maxcomp = stbiw__max(linear[0], stbiw__max(linear[1], linear[2]));\r\n\r\n   if (maxcomp < 1e-32f) {\r\n      rgbe[0] = rgbe[1] = rgbe[2] = rgbe[3] = 0;\r\n   } else {\r\n      float normalize = (float) frexp(maxcomp, &exponent) * 256.0f/maxcomp;\r\n\r\n      rgbe[0] = (unsigned char)(linear[0] * normalize);\r\n      rgbe[1] = (unsigned char)(linear[1] * normalize);\r\n      rgbe[2] = (unsigned char)(linear[2] * normalize);\r\n      rgbe[3] = (unsigned char)(exponent + 128);\r\n   }\r\n}\r\n\r\nvoid stbiw__write_run_data(stbi__write_context *s, int length, unsigned char databyte)\r\n{\r\n   unsigned char lengthbyte = STBIW_UCHAR(length+128);\r\n   STBIW_ASSERT(length+128 <= 255);\r\n   s->func(s->context, &lengthbyte, 1);\r\n   s->func(s->context, &databyte, 1);\r\n}\r\n\r\nvoid stbiw__write_dump_data(stbi__write_context *s, int length, unsigned char *data)\r\n{\r\n   unsigned char lengthbyte = STBIW_UCHAR(length);\r\n   STBIW_ASSERT(length <= 128); // inconsistent with spec but consistent with official code\r\n   s->func(s->context, &lengthbyte, 1);\r\n   s->func(s->context, data, length);\r\n}\r\n\r\nvoid stbiw__write_hdr_scanline(stbi__write_context *s, int width, int ncomp, unsigned char *scratch, float *scanline)\r\n{\r\n   unsigned char scanlineheader[4] = { 2, 2, 0, 0 };\r\n   unsigned char rgbe[4];\r\n   float linear[3];\r\n   int x;\r\n\r\n   scanlineheader[2] = (width&0xff00)>>8;\r\n   scanlineheader[3] = (width&0x00ff);\r\n\r\n   /* skip RLE for images too small or large */\r\n   if (width < 8 || width >= 32768) {\r\n      for (x=0; x < width; x++) {\r\n         switch (ncomp) {\r\n            case 4: /* fallthrough */\r\n            case 3: linear[2] = scanline[x*ncomp + 2];\r\n                    linear[1] = scanline[x*ncomp + 1];\r\n                    linear[0] = scanline[x*ncomp + 0];\r\n                    break;\r\n            default:\r\n                    linear[0] = linear[1] = linear[2] = scanline[x*ncomp + 0];\r\n                    break;\r\n         }\r\n         stbiw__linear_to_rgbe(rgbe, linear);\r\n         s->func(s->context, rgbe, 4);\r\n      }\r\n   } else {\r\n      int c,r;\r\n      /* encode into scratch buffer */\r\n      for (x=0; x < width; x++) {\r\n         switch(ncomp) {\r\n            case 4: /* fallthrough */\r\n            case 3: linear[2] = scanline[x*ncomp + 2];\r\n                    linear[1] = scanline[x*ncomp + 1];\r\n                    linear[0] = scanline[x*ncomp + 0];\r\n                    break;\r\n            default:\r\n                    linear[0] = linear[1] = linear[2] = scanline[x*ncomp + 0];\r\n                    break;\r\n         }\r\n         stbiw__linear_to_rgbe(rgbe, linear);\r\n         scratch[x + width*0] = rgbe[0];\r\n         scratch[x + width*1] = rgbe[1];\r\n         scratch[x + width*2] = rgbe[2];\r\n         scratch[x + width*3] = rgbe[3];\r\n      }\r\n\r\n      s->func(s->context, scanlineheader, 4);\r\n\r\n      /* RLE each component separately */\r\n      for (c=0; c < 4; c++) {\r\n         unsigned char *comp = &scratch[width*c];\r\n\r\n         x = 0;\r\n         while (x < width) {\r\n            // find first run\r\n            r = x;\r\n            while (r+2 < width) {\r\n               if (comp[r] == comp[r+1] && comp[r] == comp[r+2])\r\n                  break;\r\n               ++r;\r\n            }\r\n            if (r+2 >= width)\r\n               r = width;\r\n            // dump up to first run\r\n            while (x < r) {\r\n               int len = r-x;\r\n               if (len > 128) len = 128;\r\n               stbiw__write_dump_data(s, len, &comp[x]);\r\n               x += len;\r\n            }\r\n            // if there's a run, output it\r\n            if (r+2 < width) { // same test as what we break out of in search loop, so only true if we break'd\r\n               // find next byte after run\r\n               while (r < width && comp[r] == comp[x])\r\n                  ++r;\r\n               // output run up to r\r\n               while (x < r) {\r\n                  int len = r-x;\r\n                  if (len > 127) len = 127;\r\n                  stbiw__write_run_data(s, len, comp[x]);\r\n                  x += len;\r\n               }\r\n            }\r\n         }\r\n      }\r\n   }\r\n}\r\n\r\nstatic int stbi_write_hdr_core(stbi__write_context *s, int x, int y, int comp, float *data)\r\n{\r\n   if (y <= 0 || x <= 0 || data == NULL)\r\n      return 0;\r\n   else {\r\n      // Each component is stored separately. Allocate scratch space for full output scanline.\r\n      unsigned char *scratch = (unsigned char *) STBIW_MALLOC(x*4);\r\n      int i, len;\r\n      char buffer[128];\r\n      char header[] = \"#?RADIANCE\\n# Written by stb_image_write.h\\nFORMAT=32-bit_rle_rgbe\\n\";\r\n      s->func(s->context, header, sizeof(header)-1);\r\n\r\n      len = sprintf(buffer, \"EXPOSURE=          1.0000000000000\\n\\n-Y %d +X %d\\n\", y, x);\r\n      s->func(s->context, buffer, len);\r\n\r\n      for(i=0; i < y; i++)\r\n         stbiw__write_hdr_scanline(s, x, comp, scratch, data + comp*i*x);\r\n      STBIW_FREE(scratch);\r\n      return 1;\r\n   }\r\n}\r\n\r\nSTBIWDEF int stbi_write_hdr_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const float *data)\r\n{\r\n   stbi__write_context s;\r\n   stbi__start_write_callbacks(&s, func, context);\r\n   return stbi_write_hdr_core(&s, x, y, comp, (float *) data);\r\n}\r\n\r\n#ifndef STBI_WRITE_NO_STDIO\r\nSTBIWDEF int stbi_write_hdr(char const *filename, int x, int y, int comp, const float *data)\r\n{\r\n   stbi__write_context s;\r\n   if (stbi__start_write_file(&s,filename)) {\r\n      int r = stbi_write_hdr_core(&s, x, y, comp, (float *) data);\r\n      stbi__end_write_file(&s);\r\n      return r;\r\n   } else\r\n      return 0;\r\n}\r\n#endif // STBI_WRITE_NO_STDIO\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// PNG writer\r\n//\r\n\r\n// stretchy buffer; stbiw__sbpush() == vector<>::push_back() -- stbiw__sbcount() == vector<>::size()\r\n#define stbiw__sbraw(a) ((int *) (a) - 2)\r\n#define stbiw__sbm(a)   stbiw__sbraw(a)[0]\r\n#define stbiw__sbn(a)   stbiw__sbraw(a)[1]\r\n\r\n#define stbiw__sbneedgrow(a,n)  ((a)==0 || stbiw__sbn(a)+n >= stbiw__sbm(a))\r\n#define stbiw__sbmaybegrow(a,n) (stbiw__sbneedgrow(a,(n)) ? stbiw__sbgrow(a,n) : 0)\r\n#define stbiw__sbgrow(a,n)  stbiw__sbgrowf((void **) &(a), (n), sizeof(*(a)))\r\n\r\n#define stbiw__sbpush(a, v)      (stbiw__sbmaybegrow(a,1), (a)[stbiw__sbn(a)++] = (v))\r\n#define stbiw__sbcount(a)        ((a) ? stbiw__sbn(a) : 0)\r\n#define stbiw__sbfree(a)         ((a) ? STBIW_FREE(stbiw__sbraw(a)),0 : 0)\r\n\r\nstatic void *stbiw__sbgrowf(void **arr, int increment, int itemsize)\r\n{\r\n   int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;\r\n   void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);\r\n   STBIW_ASSERT(p);\r\n   if (p) {\r\n      if (!*arr) ((int *) p)[1] = 0;\r\n      *arr = (void *) ((int *) p + 2);\r\n      stbiw__sbm(*arr) = m;\r\n   }\r\n   return *arr;\r\n}\r\n\r\nstatic unsigned char *stbiw__zlib_flushf(unsigned char *data, unsigned int *bitbuffer, int *bitcount)\r\n{\r\n   while (*bitcount >= 8) {\r\n      stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));\r\n      *bitbuffer >>= 8;\r\n      *bitcount -= 8;\r\n   }\r\n   return data;\r\n}\r\n\r\nstatic int stbiw__zlib_bitrev(int code, int codebits)\r\n{\r\n   int res=0;\r\n   while (codebits--) {\r\n      res = (res << 1) | (code & 1);\r\n      code >>= 1;\r\n   }\r\n   return res;\r\n}\r\n\r\nstatic unsigned int stbiw__zlib_countm(unsigned char *a, unsigned char *b, int limit)\r\n{\r\n   int i;\r\n   for (i=0; i < limit && i < 258; ++i)\r\n      if (a[i] != b[i]) break;\r\n   return i;\r\n}\r\n\r\nstatic unsigned int stbiw__zhash(unsigned char *data)\r\n{\r\n   stbiw_uint32 hash = data[0] + (data[1] << 8) + (data[2] << 16);\r\n   hash ^= hash << 3;\r\n   hash += hash >> 5;\r\n   hash ^= hash << 4;\r\n   hash += hash >> 17;\r\n   hash ^= hash << 25;\r\n   hash += hash >> 6;\r\n   return hash;\r\n}\r\n\r\n#define stbiw__zlib_flush() (out = stbiw__zlib_flushf(out, &bitbuf, &bitcount))\r\n#define stbiw__zlib_add(code,codebits) \\\r\n      (bitbuf |= (code) << bitcount, bitcount += (codebits), stbiw__zlib_flush())\r\n#define stbiw__zlib_huffa(b,c)  stbiw__zlib_add(stbiw__zlib_bitrev(b,c),c)\r\n// default huffman tables\r\n#define stbiw__zlib_huff1(n)  stbiw__zlib_huffa(0x30 + (n), 8)\r\n#define stbiw__zlib_huff2(n)  stbiw__zlib_huffa(0x190 + (n)-144, 9)\r\n#define stbiw__zlib_huff3(n)  stbiw__zlib_huffa(0 + (n)-256,7)\r\n#define stbiw__zlib_huff4(n)  stbiw__zlib_huffa(0xc0 + (n)-280,8)\r\n#define stbiw__zlib_huff(n)  ((n) <= 143 ? stbiw__zlib_huff1(n) : (n) <= 255 ? stbiw__zlib_huff2(n) : (n) <= 279 ? stbiw__zlib_huff3(n) : stbiw__zlib_huff4(n))\r\n#define stbiw__zlib_huffb(n) ((n) <= 143 ? stbiw__zlib_huff1(n) : stbiw__zlib_huff2(n))\r\n\r\n#define stbiw__ZHASH   16384\r\n\r\nunsigned char * stbi_zlib_compress(unsigned char *data, int data_len, int *out_len, int quality)\r\n{\r\n   static unsigned short lengthc[] = { 3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258, 259 };\r\n   static unsigned char  lengtheb[]= { 0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0 };\r\n   static unsigned short distc[]   = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 32768 };\r\n   static unsigned char  disteb[]  = { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13 };\r\n   unsigned int bitbuf=0;\r\n   int i,j, bitcount=0;\r\n   unsigned char *out = NULL;\r\n   unsigned char ***hash_table = (unsigned char***) STBIW_MALLOC(stbiw__ZHASH * sizeof(char**));\r\n   if (quality < 5) quality = 5;\r\n\r\n   stbiw__sbpush(out, 0x78);   // DEFLATE 32K window\r\n   stbiw__sbpush(out, 0x5e);   // FLEVEL = 1\r\n   stbiw__zlib_add(1,1);  // BFINAL = 1\r\n   stbiw__zlib_add(1,2);  // BTYPE = 1 -- fixed huffman\r\n\r\n   for (i=0; i < stbiw__ZHASH; ++i)\r\n      hash_table[i] = NULL;\r\n\r\n   i=0;\r\n   while (i < data_len-3) {\r\n      // hash next 3 bytes of data to be compressed\r\n      int h = stbiw__zhash(data+i)&(stbiw__ZHASH-1), best=3;\r\n      unsigned char *bestloc = 0;\r\n      unsigned char **hlist = hash_table[h];\r\n      int n = stbiw__sbcount(hlist);\r\n      for (j=0; j < n; ++j) {\r\n         if (hlist[j]-data > i-32768) { // if entry lies within window\r\n            int d = stbiw__zlib_countm(hlist[j], data+i, data_len-i);\r\n            if (d >= best) best=d,bestloc=hlist[j];\r\n         }\r\n      }\r\n      // when hash table entry is too long, delete half the entries\r\n      if (hash_table[h] && stbiw__sbn(hash_table[h]) == 2*quality) {\r\n         STBIW_MEMMOVE(hash_table[h], hash_table[h]+quality, sizeof(hash_table[h][0])*quality);\r\n         stbiw__sbn(hash_table[h]) = quality;\r\n      }\r\n      stbiw__sbpush(hash_table[h],data+i);\r\n\r\n      if (bestloc) {\r\n         // \"lazy matching\" - check match at *next* byte, and if it's better, do cur byte as literal\r\n         h = stbiw__zhash(data+i+1)&(stbiw__ZHASH-1);\r\n         hlist = hash_table[h];\r\n         n = stbiw__sbcount(hlist);\r\n         for (j=0; j < n; ++j) {\r\n            if (hlist[j]-data > i-32767) {\r\n               int e = stbiw__zlib_countm(hlist[j], data+i+1, data_len-i-1);\r\n               if (e > best) { // if next match is better, bail on current match\r\n                  bestloc = NULL;\r\n                  break;\r\n               }\r\n            }\r\n         }\r\n      }\r\n\r\n      if (bestloc) {\r\n         int d = (int) (data+i - bestloc); // distance back\r\n         STBIW_ASSERT(d <= 32767 && best <= 258);\r\n         for (j=0; best > lengthc[j+1]-1; ++j);\r\n         stbiw__zlib_huff(j+257);\r\n         if (lengtheb[j]) stbiw__zlib_add(best - lengthc[j], lengtheb[j]);\r\n         for (j=0; d > distc[j+1]-1; ++j);\r\n         stbiw__zlib_add(stbiw__zlib_bitrev(j,5),5);\r\n         if (disteb[j]) stbiw__zlib_add(d - distc[j], disteb[j]);\r\n         i += best;\r\n      } else {\r\n         stbiw__zlib_huffb(data[i]);\r\n         ++i;\r\n      }\r\n   }\r\n   // write out final bytes\r\n   for (;i < data_len; ++i)\r\n      stbiw__zlib_huffb(data[i]);\r\n   stbiw__zlib_huff(256); // end of block\r\n   // pad with 0 bits to byte boundary\r\n   while (bitcount)\r\n      stbiw__zlib_add(0,1);\r\n\r\n   for (i=0; i < stbiw__ZHASH; ++i)\r\n      (void) stbiw__sbfree(hash_table[i]);\r\n   STBIW_FREE(hash_table);\r\n\r\n   {\r\n      // compute adler32 on input\r\n      unsigned int s1=1, s2=0;\r\n      int blocklen = (int) (data_len % 5552);\r\n      j=0;\r\n      while (j < data_len) {\r\n         for (i=0; i < blocklen; ++i) s1 += data[j+i], s2 += s1;\r\n         s1 %= 65521, s2 %= 65521;\r\n         j += blocklen;\r\n         blocklen = 5552;\r\n      }\r\n      stbiw__sbpush(out, STBIW_UCHAR(s2 >> 8));\r\n      stbiw__sbpush(out, STBIW_UCHAR(s2));\r\n      stbiw__sbpush(out, STBIW_UCHAR(s1 >> 8));\r\n      stbiw__sbpush(out, STBIW_UCHAR(s1));\r\n   }\r\n   *out_len = stbiw__sbn(out);\r\n   // make returned pointer freeable\r\n   STBIW_MEMMOVE(stbiw__sbraw(out), out, *out_len);\r\n   return (unsigned char *) stbiw__sbraw(out);\r\n}\r\n\r\nstatic unsigned int stbiw__crc32(unsigned char *buffer, int len)\r\n{\r\n   static unsigned int crc_table[256] =\r\n   {\r\n      0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,\r\n      0x0eDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,\r\n      0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,\r\n      0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,\r\n      0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,\r\n      0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,\r\n      0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,\r\n      0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,\r\n      0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,\r\n      0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,\r\n      0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,\r\n      0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,\r\n      0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,\r\n      0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,\r\n      0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,\r\n      0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,\r\n      0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,\r\n      0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,\r\n      0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,\r\n      0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,\r\n      0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,\r\n      0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,\r\n      0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,\r\n      0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,\r\n      0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,\r\n      0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,\r\n      0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,\r\n      0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,\r\n      0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,\r\n      0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,\r\n      0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,\r\n      0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D\r\n   };\r\n\r\n   unsigned int crc = ~0u;\r\n   int i;\r\n   for (i=0; i < len; ++i)\r\n      crc = (crc >> 8) ^ crc_table[buffer[i] ^ (crc & 0xff)];\r\n   return ~crc;\r\n}\r\n\r\n#define stbiw__wpng4(o,a,b,c,d) ((o)[0]=STBIW_UCHAR(a),(o)[1]=STBIW_UCHAR(b),(o)[2]=STBIW_UCHAR(c),(o)[3]=STBIW_UCHAR(d),(o)+=4)\r\n#define stbiw__wp32(data,v) stbiw__wpng4(data, (v)>>24,(v)>>16,(v)>>8,(v));\r\n#define stbiw__wptag(data,s) stbiw__wpng4(data, s[0],s[1],s[2],s[3])\r\n\r\nstatic void stbiw__wpcrc(unsigned char **data, int len)\r\n{\r\n   unsigned int crc = stbiw__crc32(*data - len - 4, len+4);\r\n   stbiw__wp32(*data, crc);\r\n}\r\n\r\nstatic unsigned char stbiw__paeth(int a, int b, int c)\r\n{\r\n   int p = a + b - c, pa = abs(p-a), pb = abs(p-b), pc = abs(p-c);\r\n   if (pa <= pb && pa <= pc) return STBIW_UCHAR(a);\r\n   if (pb <= pc) return STBIW_UCHAR(b);\r\n   return STBIW_UCHAR(c);\r\n}\r\n\r\n// @OPTIMIZE: provide an option that always forces left-predict or paeth predict\r\nunsigned char *stbi_write_png_to_mem(unsigned char *pixels, int stride_bytes, int x, int y, int n, int *out_len)\r\n{\r\n   int ctype[5] = { -1, 0, 4, 2, 6 };\r\n   unsigned char sig[8] = { 137,80,78,71,13,10,26,10 };\r\n   unsigned char *out,*o, *filt, *zlib;\r\n   signed char *line_buffer;\r\n   int i,j,k,p,zlen;\r\n\r\n   if (stride_bytes == 0)\r\n      stride_bytes = x * n;\r\n\r\n   filt = (unsigned char *) STBIW_MALLOC((x*n+1) * y); if (!filt) return 0;\r\n   line_buffer = (signed char *) STBIW_MALLOC(x * n); if (!line_buffer) { STBIW_FREE(filt); return 0; }\r\n   for (j=0; j < y; ++j) {\r\n      static int mapping[] = { 0,1,2,3,4 };\r\n      static int firstmap[] = { 0,1,0,5,6 };\r\n      int *mymap = (j != 0) ? mapping : firstmap;\r\n      int best = 0, bestval = 0x7fffffff;\r\n      for (p=0; p < 2; ++p) {\r\n         for (k= p?best:0; k < 5; ++k) { // @TODO: clarity: rewrite this to go 0..5, and 'continue' the unwanted ones during 2nd pass\r\n            int type = mymap[k],est=0;\r\n            unsigned char *z = pixels + stride_bytes*j;\r\n            for (i=0; i < n; ++i)\r\n               switch (type) {\r\n                  case 0: line_buffer[i] = z[i]; break;\r\n                  case 1: line_buffer[i] = z[i]; break;\r\n                  case 2: line_buffer[i] = z[i] - z[i-stride_bytes]; break;\r\n                  case 3: line_buffer[i] = z[i] - (z[i-stride_bytes]>>1); break;\r\n                  case 4: line_buffer[i] = (signed char) (z[i] - stbiw__paeth(0,z[i-stride_bytes],0)); break;\r\n                  case 5: line_buffer[i] = z[i]; break;\r\n                  case 6: line_buffer[i] = z[i]; break;\r\n               }\r\n            for (i=n; i < x*n; ++i) {\r\n               switch (type) {\r\n                  case 0: line_buffer[i] = z[i]; break;\r\n                  case 1: line_buffer[i] = z[i] - z[i-n]; break;\r\n                  case 2: line_buffer[i] = z[i] - z[i-stride_bytes]; break;\r\n                  case 3: line_buffer[i] = z[i] - ((z[i-n] + z[i-stride_bytes])>>1); break;\r\n                  case 4: line_buffer[i] = z[i] - stbiw__paeth(z[i-n], z[i-stride_bytes], z[i-stride_bytes-n]); break;\r\n                  case 5: line_buffer[i] = z[i] - (z[i-n]>>1); break;\r\n                  case 6: line_buffer[i] = z[i] - stbiw__paeth(z[i-n], 0,0); break;\r\n               }\r\n            }\r\n            if (p) break;\r\n            for (i=0; i < x*n; ++i)\r\n               est += abs((signed char) line_buffer[i]);\r\n            if (est < bestval) { bestval = est; best = k; }\r\n         }\r\n      }\r\n      // when we get here, best contains the filter type, and line_buffer contains the data\r\n      filt[j*(x*n+1)] = (unsigned char) best;\r\n      STBIW_MEMMOVE(filt+j*(x*n+1)+1, line_buffer, x*n);\r\n   }\r\n   STBIW_FREE(line_buffer);\r\n   zlib = stbi_zlib_compress(filt, y*( x*n+1), &zlen, 8); // increase 8 to get smaller but use more memory\r\n   STBIW_FREE(filt);\r\n   if (!zlib) return 0;\r\n\r\n   // each tag requires 12 bytes of overhead\r\n   out = (unsigned char *) STBIW_MALLOC(8 + 12+13 + 12+zlen + 12);\r\n   if (!out) return 0;\r\n   *out_len = 8 + 12+13 + 12+zlen + 12;\r\n\r\n   o=out;\r\n   STBIW_MEMMOVE(o,sig,8); o+= 8;\r\n   stbiw__wp32(o, 13); // header length\r\n   stbiw__wptag(o, \"IHDR\");\r\n   stbiw__wp32(o, x);\r\n   stbiw__wp32(o, y);\r\n   *o++ = 8;\r\n   *o++ = STBIW_UCHAR(ctype[n]);\r\n   *o++ = 0;\r\n   *o++ = 0;\r\n   *o++ = 0;\r\n   stbiw__wpcrc(&o,13);\r\n\r\n   stbiw__wp32(o, zlen);\r\n   stbiw__wptag(o, \"IDAT\");\r\n   STBIW_MEMMOVE(o, zlib, zlen);\r\n   o += zlen;\r\n   STBIW_FREE(zlib);\r\n   stbiw__wpcrc(&o, zlen);\r\n\r\n   stbiw__wp32(o,0);\r\n   stbiw__wptag(o, \"IEND\");\r\n   stbiw__wpcrc(&o,0);\r\n\r\n   STBIW_ASSERT(o == out + *out_len);\r\n\r\n   return out;\r\n}\r\n\r\n#ifndef STBI_WRITE_NO_STDIO\r\nSTBIWDEF int stbi_write_png(char const *filename, int x, int y, int comp, const void *data, int stride_bytes)\r\n{\r\n   FILE *f;\r\n   int len;\r\n   unsigned char *png = stbi_write_png_to_mem((unsigned char *) data, stride_bytes, x, y, comp, &len);\r\n   if (png == NULL) return 0;\r\n   f = fopen(filename, \"wb\");\r\n   if (!f) { STBIW_FREE(png); return 0; }\r\n   fwrite(png, 1, len, f);\r\n   fclose(f);\r\n   STBIW_FREE(png);\r\n   return 1;\r\n}\r\n#endif\r\n\r\nSTBIWDEF int stbi_write_png_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data, int stride_bytes)\r\n{\r\n   int len;\r\n   unsigned char *png = stbi_write_png_to_mem((unsigned char *) data, stride_bytes, x, y, comp, &len);\r\n   if (png == NULL) return 0;\r\n   func(context, png, len);\r\n   STBIW_FREE(png);\r\n   return 1;\r\n}\r\n\r\n\r\n/* ***************************************************************************\r\n *\r\n * JPEG writer\r\n *\r\n * This is based on Jon Olick's jo_jpeg.cpp:\r\n * public domain Simple, Minimalistic JPEG writer - http://www.jonolick.com/code.html\r\n */\r\n\r\nstatic const unsigned char stbiw__jpg_ZigZag[] = { 0,1,5,6,14,15,27,28,2,4,7,13,16,26,29,42,3,8,12,17,25,30,41,43,9,11,18,\r\n      24,31,40,44,53,10,19,23,32,39,45,52,54,20,22,33,38,46,51,55,60,21,34,37,47,50,56,59,61,35,36,48,49,57,58,62,63 };\r\n\r\nstatic void stbiw__jpg_writeBits(stbi__write_context *s, int *bitBufP, int *bitCntP, const unsigned short *bs) {\r\n   int bitBuf = *bitBufP, bitCnt = *bitCntP;\r\n   bitCnt += bs[1];\r\n   bitBuf |= bs[0] << (24 - bitCnt);\r\n   while(bitCnt >= 8) {\r\n      unsigned char c = (bitBuf >> 16) & 255;\r\n      stbiw__putc(s, c);\r\n      if(c == 255) {\r\n         stbiw__putc(s, 0);\r\n      }\r\n      bitBuf <<= 8;\r\n      bitCnt -= 8;\r\n   }\r\n   *bitBufP = bitBuf;\r\n   *bitCntP = bitCnt;\r\n}\r\n\r\nstatic void stbiw__jpg_DCT(float *d0p, float *d1p, float *d2p, float *d3p, float *d4p, float *d5p, float *d6p, float *d7p) {\r\n   float d0 = *d0p, d1 = *d1p, d2 = *d2p, d3 = *d3p, d4 = *d4p, d5 = *d5p, d6 = *d6p, d7 = *d7p;\r\n   float z1, z2, z3, z4, z5, z11, z13;\r\n\r\n   float tmp0 = d0 + d7;\r\n   float tmp7 = d0 - d7;\r\n   float tmp1 = d1 + d6;\r\n   float tmp6 = d1 - d6;\r\n   float tmp2 = d2 + d5;\r\n   float tmp5 = d2 - d5;\r\n   float tmp3 = d3 + d4;\r\n   float tmp4 = d3 - d4;\r\n\r\n   // Even part\r\n   float tmp10 = tmp0 + tmp3;   // phase 2\r\n   float tmp13 = tmp0 - tmp3;\r\n   float tmp11 = tmp1 + tmp2;\r\n   float tmp12 = tmp1 - tmp2;\r\n\r\n   d0 = tmp10 + tmp11;       // phase 3\r\n   d4 = tmp10 - tmp11;\r\n\r\n   z1 = (tmp12 + tmp13) * 0.707106781f; // c4\r\n   d2 = tmp13 + z1;       // phase 5\r\n   d6 = tmp13 - z1;\r\n\r\n   // Odd part\r\n   tmp10 = tmp4 + tmp5;       // phase 2\r\n   tmp11 = tmp5 + tmp6;\r\n   tmp12 = tmp6 + tmp7;\r\n\r\n   // The rotator is modified from fig 4-8 to avoid extra negations.\r\n   z5 = (tmp10 - tmp12) * 0.382683433f; // c6\r\n   z2 = tmp10 * 0.541196100f + z5; // c2-c6\r\n   z4 = tmp12 * 1.306562965f + z5; // c2+c6\r\n   z3 = tmp11 * 0.707106781f; // c4\r\n\r\n   z11 = tmp7 + z3;      // phase 5\r\n   z13 = tmp7 - z3;\r\n\r\n   *d5p = z13 + z2;         // phase 6\r\n   *d3p = z13 - z2;\r\n   *d1p = z11 + z4;\r\n   *d7p = z11 - z4;\r\n\r\n   *d0p = d0;  *d2p = d2;  *d4p = d4;  *d6p = d6;\r\n}\r\n\r\nstatic void stbiw__jpg_calcBits(int val, unsigned short bits[2]) {\r\n   int tmp1 = val < 0 ? -val : val;\r\n   val = val < 0 ? val-1 : val;\r\n   bits[1] = 1;\r\n   while(tmp1 >>= 1) {\r\n      ++bits[1];\r\n   }\r\n   bits[0] = val & ((1<<bits[1])-1);\r\n}\r\n\r\nstatic int stbiw__jpg_processDU(stbi__write_context *s, int *bitBuf, int *bitCnt, float *CDU, float *fdtbl, int DC, const unsigned short HTDC[256][2], const unsigned short HTAC[256][2]) {\r\n   const unsigned short EOB[2] = { HTAC[0x00][0], HTAC[0x00][1] };\r\n   const unsigned short M16zeroes[2] = { HTAC[0xF0][0], HTAC[0xF0][1] };\r\n   int dataOff, i, diff, end0pos;\r\n   int DU[64];\r\n\r\n   // DCT rows\r\n   for(dataOff=0; dataOff<64; dataOff+=8) {\r\n      stbiw__jpg_DCT(&CDU[dataOff], &CDU[dataOff+1], &CDU[dataOff+2], &CDU[dataOff+3], &CDU[dataOff+4], &CDU[dataOff+5], &CDU[dataOff+6], &CDU[dataOff+7]);\r\n   }\r\n   // DCT columns\r\n   for(dataOff=0; dataOff<8; ++dataOff) {\r\n      stbiw__jpg_DCT(&CDU[dataOff], &CDU[dataOff+8], &CDU[dataOff+16], &CDU[dataOff+24], &CDU[dataOff+32], &CDU[dataOff+40], &CDU[dataOff+48], &CDU[dataOff+56]);\r\n   }\r\n   // Quantize/descale/zigzag the coefficients\r\n   for(i=0; i<64; ++i) {\r\n      float v = CDU[i]*fdtbl[i];\r\n      // DU[stbiw__jpg_ZigZag[i]] = (int)(v < 0 ? ceilf(v - 0.5f) : floorf(v + 0.5f));\r\n      // ceilf() and floorf() are C99, not C89, but I /think/ they're not needed here anyway?\r\n      DU[stbiw__jpg_ZigZag[i]] = (int)(v < 0 ? v - 0.5f : v + 0.5f);\r\n   }\r\n\r\n   // Encode DC\r\n   diff = DU[0] - DC;\r\n   if (diff == 0) {\r\n      stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTDC[0]);\r\n   } else {\r\n      unsigned short bits[2];\r\n      stbiw__jpg_calcBits(diff, bits);\r\n      stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTDC[bits[1]]);\r\n      stbiw__jpg_writeBits(s, bitBuf, bitCnt, bits);\r\n   }\r\n   // Encode ACs\r\n   end0pos = 63;\r\n   for(; (end0pos>0)&&(DU[end0pos]==0); --end0pos) {\r\n   }\r\n   // end0pos = first element in reverse order !=0\r\n   if(end0pos == 0) {\r\n      stbiw__jpg_writeBits(s, bitBuf, bitCnt, EOB);\r\n      return DU[0];\r\n   }\r\n   for(i = 1; i <= end0pos; ++i) {\r\n      int startpos = i;\r\n      int nrzeroes;\r\n      unsigned short bits[2];\r\n      for (; DU[i]==0 && i<=end0pos; ++i) {\r\n      }\r\n      nrzeroes = i-startpos;\r\n      if ( nrzeroes >= 16 ) {\r\n         int lng = nrzeroes>>4;\r\n         int nrmarker;\r\n         for (nrmarker=1; nrmarker <= lng; ++nrmarker)\r\n            stbiw__jpg_writeBits(s, bitBuf, bitCnt, M16zeroes);\r\n         nrzeroes &= 15;\r\n      }\r\n      stbiw__jpg_calcBits(DU[i], bits);\r\n      stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTAC[(nrzeroes<<4)+bits[1]]);\r\n      stbiw__jpg_writeBits(s, bitBuf, bitCnt, bits);\r\n   }\r\n   if(end0pos != 63) {\r\n      stbiw__jpg_writeBits(s, bitBuf, bitCnt, EOB);\r\n   }\r\n   return DU[0];\r\n}\r\n\r\nstatic int stbi_write_jpg_core(stbi__write_context *s, int width, int height, int comp, const void* data, int quality) {\r\n   // Constants that don't pollute global namespace\r\n   static const unsigned char std_dc_luminance_nrcodes[] = {0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0};\r\n   static const unsigned char std_dc_luminance_values[] = {0,1,2,3,4,5,6,7,8,9,10,11};\r\n   static const unsigned char std_ac_luminance_nrcodes[] = {0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0x7d};\r\n   static const unsigned char std_ac_luminance_values[] = {\r\n      0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x08,\r\n      0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,0x24,0x33,0x62,0x72,0x82,0x09,0x0a,0x16,0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,\r\n      0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,\r\n      0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,\r\n      0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,\r\n      0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,\r\n      0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa\r\n   };\r\n   static const unsigned char std_dc_chrominance_nrcodes[] = {0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0};\r\n   static const unsigned char std_dc_chrominance_values[] = {0,1,2,3,4,5,6,7,8,9,10,11};\r\n   static const unsigned char std_ac_chrominance_nrcodes[] = {0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0x77};\r\n   static const unsigned char std_ac_chrominance_values[] = {\r\n      0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,\r\n      0xa1,0xb1,0xc1,0x09,0x23,0x33,0x52,0xf0,0x15,0x62,0x72,0xd1,0x0a,0x16,0x24,0x34,0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,\r\n      0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,\r\n      0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,\r\n      0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,\r\n      0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,\r\n      0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa\r\n   };\r\n   // Huffman tables\r\n   static const unsigned short YDC_HT[256][2] = { {0,2},{2,3},{3,3},{4,3},{5,3},{6,3},{14,4},{30,5},{62,6},{126,7},{254,8},{510,9}};\r\n   static const unsigned short UVDC_HT[256][2] = { {0,2},{1,2},{2,2},{6,3},{14,4},{30,5},{62,6},{126,7},{254,8},{510,9},{1022,10},{2046,11}};\r\n   static const unsigned short YAC_HT[256][2] = {\r\n      {10,4},{0,2},{1,2},{4,3},{11,4},{26,5},{120,7},{248,8},{1014,10},{65410,16},{65411,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {12,4},{27,5},{121,7},{502,9},{2038,11},{65412,16},{65413,16},{65414,16},{65415,16},{65416,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {28,5},{249,8},{1015,10},{4084,12},{65417,16},{65418,16},{65419,16},{65420,16},{65421,16},{65422,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {58,6},{503,9},{4085,12},{65423,16},{65424,16},{65425,16},{65426,16},{65427,16},{65428,16},{65429,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {59,6},{1016,10},{65430,16},{65431,16},{65432,16},{65433,16},{65434,16},{65435,16},{65436,16},{65437,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {122,7},{2039,11},{65438,16},{65439,16},{65440,16},{65441,16},{65442,16},{65443,16},{65444,16},{65445,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {123,7},{4086,12},{65446,16},{65447,16},{65448,16},{65449,16},{65450,16},{65451,16},{65452,16},{65453,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {250,8},{4087,12},{65454,16},{65455,16},{65456,16},{65457,16},{65458,16},{65459,16},{65460,16},{65461,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {504,9},{32704,15},{65462,16},{65463,16},{65464,16},{65465,16},{65466,16},{65467,16},{65468,16},{65469,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {505,9},{65470,16},{65471,16},{65472,16},{65473,16},{65474,16},{65475,16},{65476,16},{65477,16},{65478,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {506,9},{65479,16},{65480,16},{65481,16},{65482,16},{65483,16},{65484,16},{65485,16},{65486,16},{65487,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {1017,10},{65488,16},{65489,16},{65490,16},{65491,16},{65492,16},{65493,16},{65494,16},{65495,16},{65496,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {1018,10},{65497,16},{65498,16},{65499,16},{65500,16},{65501,16},{65502,16},{65503,16},{65504,16},{65505,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {2040,11},{65506,16},{65507,16},{65508,16},{65509,16},{65510,16},{65511,16},{65512,16},{65513,16},{65514,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {65515,16},{65516,16},{65517,16},{65518,16},{65519,16},{65520,16},{65521,16},{65522,16},{65523,16},{65524,16},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {2041,11},{65525,16},{65526,16},{65527,16},{65528,16},{65529,16},{65530,16},{65531,16},{65532,16},{65533,16},{65534,16},{0,0},{0,0},{0,0},{0,0},{0,0}\r\n   };\r\n   static const unsigned short UVAC_HT[256][2] = {\r\n      {0,2},{1,2},{4,3},{10,4},{24,5},{25,5},{56,6},{120,7},{500,9},{1014,10},{4084,12},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {11,4},{57,6},{246,8},{501,9},{2038,11},{4085,12},{65416,16},{65417,16},{65418,16},{65419,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {26,5},{247,8},{1015,10},{4086,12},{32706,15},{65420,16},{65421,16},{65422,16},{65423,16},{65424,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {27,5},{248,8},{1016,10},{4087,12},{65425,16},{65426,16},{65427,16},{65428,16},{65429,16},{65430,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {58,6},{502,9},{65431,16},{65432,16},{65433,16},{65434,16},{65435,16},{65436,16},{65437,16},{65438,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {59,6},{1017,10},{65439,16},{65440,16},{65441,16},{65442,16},{65443,16},{65444,16},{65445,16},{65446,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {121,7},{2039,11},{65447,16},{65448,16},{65449,16},{65450,16},{65451,16},{65452,16},{65453,16},{65454,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {122,7},{2040,11},{65455,16},{65456,16},{65457,16},{65458,16},{65459,16},{65460,16},{65461,16},{65462,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {249,8},{65463,16},{65464,16},{65465,16},{65466,16},{65467,16},{65468,16},{65469,16},{65470,16},{65471,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {503,9},{65472,16},{65473,16},{65474,16},{65475,16},{65476,16},{65477,16},{65478,16},{65479,16},{65480,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {504,9},{65481,16},{65482,16},{65483,16},{65484,16},{65485,16},{65486,16},{65487,16},{65488,16},{65489,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {505,9},{65490,16},{65491,16},{65492,16},{65493,16},{65494,16},{65495,16},{65496,16},{65497,16},{65498,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {506,9},{65499,16},{65500,16},{65501,16},{65502,16},{65503,16},{65504,16},{65505,16},{65506,16},{65507,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {2041,11},{65508,16},{65509,16},{65510,16},{65511,16},{65512,16},{65513,16},{65514,16},{65515,16},{65516,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {16352,14},{65517,16},{65518,16},{65519,16},{65520,16},{65521,16},{65522,16},{65523,16},{65524,16},{65525,16},{0,0},{0,0},{0,0},{0,0},{0,0},\r\n      {1018,10},{32707,15},{65526,16},{65527,16},{65528,16},{65529,16},{65530,16},{65531,16},{65532,16},{65533,16},{65534,16},{0,0},{0,0},{0,0},{0,0},{0,0}\r\n   };\r\n   static const int YQT[] = {16,11,10,16,24,40,51,61,12,12,14,19,26,58,60,55,14,13,16,24,40,57,69,56,14,17,22,29,51,87,80,62,18,22,\r\n                             37,56,68,109,103,77,24,35,55,64,81,104,113,92,49,64,78,87,103,121,120,101,72,92,95,98,112,100,103,99};\r\n   static const int UVQT[] = {17,18,24,47,99,99,99,99,18,21,26,66,99,99,99,99,24,26,56,99,99,99,99,99,47,66,99,99,99,99,99,99,\r\n                              99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99};\r\n   static const float aasf[] = { 1.0f * 2.828427125f, 1.387039845f * 2.828427125f, 1.306562965f * 2.828427125f, 1.175875602f * 2.828427125f, \r\n                                 1.0f * 2.828427125f, 0.785694958f * 2.828427125f, 0.541196100f * 2.828427125f, 0.275899379f * 2.828427125f };\r\n\r\n   int row, col, i, k;\r\n   float fdtbl_Y[64], fdtbl_UV[64];\r\n   unsigned char YTable[64], UVTable[64];\r\n\r\n   if(!data || !width || !height || comp > 4 || comp < 1) {\r\n      return 0;\r\n   }\r\n\r\n   quality = quality ? quality : 90;\r\n   quality = quality < 1 ? 1 : quality > 100 ? 100 : quality;\r\n   quality = quality < 50 ? 5000 / quality : 200 - quality * 2;\r\n\r\n   for(i = 0; i < 64; ++i) {\r\n      int uvti, yti = (YQT[i]*quality+50)/100;\r\n      YTable[stbiw__jpg_ZigZag[i]] = (unsigned char) (yti < 1 ? 1 : yti > 255 ? 255 : yti);\r\n      uvti = (UVQT[i]*quality+50)/100;\r\n      UVTable[stbiw__jpg_ZigZag[i]] = (unsigned char) (uvti < 1 ? 1 : uvti > 255 ? 255 : uvti);\r\n   }\r\n\r\n   for(row = 0, k = 0; row < 8; ++row) {\r\n      for(col = 0; col < 8; ++col, ++k) {\r\n         fdtbl_Y[k]  = 1 / (YTable [stbiw__jpg_ZigZag[k]] * aasf[row] * aasf[col]);\r\n         fdtbl_UV[k] = 1 / (UVTable[stbiw__jpg_ZigZag[k]] * aasf[row] * aasf[col]);\r\n      }\r\n   }\r\n\r\n   // Write Headers\r\n   {\r\n      static const unsigned char head0[] = { 0xFF,0xD8,0xFF,0xE0,0,0x10,'J','F','I','F',0,1,1,0,0,1,0,1,0,0,0xFF,0xDB,0,0x84,0 };\r\n      static const unsigned char head2[] = { 0xFF,0xDA,0,0xC,3,1,0,2,0x11,3,0x11,0,0x3F,0 };\r\n      const unsigned char head1[] = { 0xFF,0xC0,0,0x11,8,(unsigned char)(height>>8),STBIW_UCHAR(height),(unsigned char)(width>>8),STBIW_UCHAR(width),\r\n                                      3,1,0x11,0,2,0x11,1,3,0x11,1,0xFF,0xC4,0x01,0xA2,0 };\r\n      s->func(s->context, (void*)head0, sizeof(head0));\r\n      s->func(s->context, (void*)YTable, sizeof(YTable));\r\n      stbiw__putc(s, 1);\r\n      s->func(s->context, UVTable, sizeof(UVTable));\r\n      s->func(s->context, (void*)head1, sizeof(head1));\r\n      s->func(s->context, (void*)(std_dc_luminance_nrcodes+1), sizeof(std_dc_luminance_nrcodes)-1);\r\n      s->func(s->context, (void*)std_dc_luminance_values, sizeof(std_dc_luminance_values));\r\n      stbiw__putc(s, 0x10); // HTYACinfo\r\n      s->func(s->context, (void*)(std_ac_luminance_nrcodes+1), sizeof(std_ac_luminance_nrcodes)-1);\r\n      s->func(s->context, (void*)std_ac_luminance_values, sizeof(std_ac_luminance_values));\r\n      stbiw__putc(s, 1); // HTUDCinfo\r\n      s->func(s->context, (void*)(std_dc_chrominance_nrcodes+1), sizeof(std_dc_chrominance_nrcodes)-1);\r\n      s->func(s->context, (void*)std_dc_chrominance_values, sizeof(std_dc_chrominance_values));\r\n      stbiw__putc(s, 0x11); // HTUACinfo\r\n      s->func(s->context, (void*)(std_ac_chrominance_nrcodes+1), sizeof(std_ac_chrominance_nrcodes)-1);\r\n      s->func(s->context, (void*)std_ac_chrominance_values, sizeof(std_ac_chrominance_values));\r\n      s->func(s->context, (void*)head2, sizeof(head2));\r\n   }\r\n\r\n   // Encode 8x8 macroblocks\r\n   {\r\n      static const unsigned short fillBits[] = {0x7F, 7};\r\n      const unsigned char *imageData = (const unsigned char *)data;\r\n      int DCY=0, DCU=0, DCV=0;\r\n      int bitBuf=0, bitCnt=0;\r\n      // comp == 2 is grey+alpha (alpha is ignored)\r\n      int ofsG = comp > 2 ? 1 : 0, ofsB = comp > 2 ? 2 : 0;\r\n      int x, y, pos;\r\n      for(y = 0; y < height; y += 8) {\r\n         for(x = 0; x < width; x += 8) {\r\n            float YDU[64], UDU[64], VDU[64];\r\n            for(row = y, pos = 0; row < y+8; ++row) {\r\n               for(col = x; col < x+8; ++col, ++pos) {\r\n                  int p = row*width*comp + col*comp;\r\n                  float r, g, b;\r\n                  if(row >= height) {\r\n                     p -= width*comp*(row+1 - height);\r\n                  }\r\n                  if(col >= width) {\r\n                     p -= comp*(col+1 - width);\r\n                  }\r\n\r\n                  r = imageData[p+0];\r\n                  g = imageData[p+ofsG];\r\n                  b = imageData[p+ofsB];\r\n                  YDU[pos]=+0.29900f*r+0.58700f*g+0.11400f*b-128;\r\n                  UDU[pos]=-0.16874f*r-0.33126f*g+0.50000f*b;\r\n                  VDU[pos]=+0.50000f*r-0.41869f*g-0.08131f*b;\r\n               }\r\n            }\r\n\r\n            DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);\r\n            DCU = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);\r\n            DCV = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);\r\n         }\r\n      }\r\n\r\n      // Do the bit alignment of the EOI marker\r\n      stbiw__jpg_writeBits(s, &bitBuf, &bitCnt, fillBits);\r\n   }\r\n\r\n   // EOI\r\n   stbiw__putc(s, 0xFF);\r\n   stbiw__putc(s, 0xD9);\r\n\r\n   return 1;\r\n}\r\n\r\nSTBIWDEF int stbi_write_jpg_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data, int quality)\r\n{\r\n   stbi__write_context s;\r\n   stbi__start_write_callbacks(&s, func, context);\r\n   return stbi_write_jpg_core(&s, x, y, comp, (void *) data, quality);\r\n}\r\n\r\n\r\n#ifndef STBI_WRITE_NO_STDIO\r\nSTBIWDEF int stbi_write_jpg(char const *filename, int x, int y, int comp, const void *data, int quality)\r\n{\r\n   stbi__write_context s;\r\n   if (stbi__start_write_file(&s,filename)) {\r\n      int r = stbi_write_jpg_core(&s, x, y, comp, data, quality);\r\n      stbi__end_write_file(&s);\r\n      return r;\r\n   } else\r\n      return 0;\r\n}\r\n#endif\r\n\r\n#endif // STB_IMAGE_WRITE_IMPLEMENTATION\r\n\r\n/* Revision history\r\n      1.07  (2017-07-24)\r\n             doc fix\r\n      1.06 (2017-07-23)\r\n             writing JPEG (using Jon Olick's code)\r\n      1.05   ???\r\n      1.04 (2017-03-03)\r\n             monochrome BMP expansion\r\n      1.03   ???\r\n      1.02 (2016-04-02)\r\n             avoid allocating large structures on the stack\r\n      1.01 (2016-01-16)\r\n             STBIW_REALLOC_SIZED: support allocators with no realloc support\r\n             avoid race-condition in crc initialization\r\n             minor compile issues\r\n      1.00 (2015-09-14)\r\n             installable file IO function\r\n      0.99 (2015-09-13)\r\n             warning fixes; TGA rle support\r\n      0.98 (2015-04-08)\r\n             added STBIW_MALLOC, STBIW_ASSERT etc\r\n      0.97 (2015-01-18)\r\n             fixed HDR asserts, rewrote HDR rle logic\r\n      0.96 (2015-01-17)\r\n             add HDR output\r\n             fix monochrome BMP\r\n      0.95 (2014-08-17)\r\n\t\t       add monochrome TGA output\r\n      0.94 (2014-05-31)\r\n             rename private functions to avoid conflicts with stb_image.h\r\n      0.93 (2014-05-27)\r\n             warning fixes\r\n      0.92 (2010-08-01)\r\n             casts to unsigned char to fix warnings\r\n      0.91 (2010-07-17)\r\n             first public release\r\n      0.90   first internal release\r\n*/\r\n\r\n/*\r\n------------------------------------------------------------------------------\r\nThis software is available under 2 licenses -- choose whichever you prefer.\r\n------------------------------------------------------------------------------\r\nALTERNATIVE A - MIT License\r\nCopyright (c) 2017 Sean Barrett\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of \r\nthis software and associated documentation files (the \"Software\"), to deal in \r\nthe Software without restriction, including without limitation the rights to \r\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \r\nof the Software, and to permit persons to whom the Software is furnished to do \r\nso, subject to the following conditions:\r\nThe above copyright notice and this permission notice shall be included in all \r\ncopies or substantial portions of the Software.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \r\nSOFTWARE.\r\n------------------------------------------------------------------------------\r\nALTERNATIVE B - Public Domain (www.unlicense.org)\r\nThis is free and unencumbered software released into the public domain.\r\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \r\nsoftware, either in source code form or as a compiled binary, for any purpose, \r\ncommercial or non-commercial, and by any means.\r\nIn jurisdictions that recognize copyright laws, the author or authors of this \r\nsoftware dedicate any and all copyright interest in the software to the public \r\ndomain. We make this dedication for the benefit of the public at large and to \r\nthe detriment of our heirs and successors. We intend this dedication to be an \r\novert act of relinquishment in perpetuity of all present and future rights to \r\nthis software under copyright law.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \r\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n------------------------------------------------------------------------------\r\n*/\r\n","#ifndef ANIMATION_H\r\n#define ANIMATION_H\r\n\r\nenum class Animations\r\n{\r\n\tAttack_villager,\r\n\tRun_villager,\r\n};\r\n\r\nstruct Animation\r\n{\r\n\tint count;\r\n\tvec4* uvs;\r\n};\r\n\r\nstruct SpriteSheet\r\n{\r\n\tint count;\r\n\tint texId;\r\n\tvec4* idToUvs;\r\n};\r\n\r\nstruct Anim\r\n{\r\n\tfloat nextChange;\r\n\tchar  nextId;\r\n\tSpriteSheet* sheet;\r\n};\r\n\r\nAnimation animations[10];\r\nvoid updateAnims(Anim* anims)\r\n{\r\n\tfloat currentTime = 0.f;\r\n\tif (anims->nextChange < currentTime)\r\n\t{\r\n\t\tif (++anims->nextId == anims->sheet->count)\r\n\t\t{\r\n\t\t\tanims->nextId = 0;\r\n\t\t}\r\n\t\t// newuv = anims->sheet[anims->nextId];\r\n\t}\r\n}\r\n\r\n\r\n// constexpr float SIZE_X = 12;\r\n// constexpr float SIZE_Y = 4;\r\n\r\n#define TileX(index) (int)((index) % (int)SIZE_X)\r\n#define TileY(index) (int)((index) / SIZE_X)\r\n\r\n#define getFrameUvsm(index) { TileX(index) / SIZE_X, 1.0f - ((TileY(index) + 1.f) / (float)SIZE_Y), 1.0f / SIZE_X, 1.0f / SIZE_Y }\r\n\r\n#define getFrameUv(indexX, indexY, textureW, textureH, offsetX, offsetY, perOneWidth, perOneHeight) \\\r\n\t{ (((offsetX) + ((indexX) * (perOneWidth)))    / (float)(textureW)), \\\r\n\t   1.0f - ((offsetY + (perOneHeight) * (indexY)) / (float)(textureH)), \\\r\n\t  ((perOneWidth) / (textureW)), \\\r\n\t  ((perOneHeight) / (textureH)) \\\r\n\t}\r\n\r\n#define getFrameUvWithPadding(indexX, indexY, textureW, textureH, offsetX, offsetY, perOneWidth, perOneHeight, padding) \\\r\n\t{ ( (((int)padding * (int)indexX) + (offsetX) + ((indexX) * (perOneWidth)))       / (float)(textureW)), \\\r\n\t   1.0f - ((float)(((int)padding * (int)indexY) + (offsetY) + (perOneHeight) * (indexY)) / (float)(textureH)), \\\r\n\t  ((perOneWidth) / (textureW)), \\\r\n\t  ((perOneHeight) / (textureH)) \\\r\n\t}\r\n\r\nSpriteSheet getIdToUvArray(engine::Texture2D * texture, int perWidth, int perHeight, int perOneW, int perOneH, int offsetX, int offsetY, int padding)\r\n{\r\n\tSpriteSheet result;\r\n\tresult.texId = texture->ID;\r\n\r\n\tint w = texture->width;\r\n\tint h = texture->height;\r\n\tint x = texture->width / perOneW;\r\n\tint y = texture->height / perOneH;\r\n\r\n\tconst int size = x * y;\r\n\tresult.idToUvs = new vec4[size];\r\n\r\n\tfor (int i = 0; i < size; i++)\r\n\t{\r\n\t\tint x = i % perWidth;\r\n\t\tint y = (i - x) / perWidth;\r\n\t\tresult.idToUvs[i] = getFrameUvWithPadding((float)x, (float)y, (float)w, (float)h,\r\n\t\t\t(float)offsetX, (float)offsetY, (float)perOneW, (float)perOneH, (float)padding);\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nSpriteSheet spriteSheets[10];\r\nvoid testInitAnimations(EngineCore* core)\r\n{\r\n\tauto textAlien = engine::getTexture(core->resources, textures::Texture_Alien);\r\n\tspriteSheets[0] = getIdToUvArray(textAlien, 4, 5, textAlien->width / 4, textAlien->height / 5, 0, 0, 0);\r\n}\r\n\r\n#endif // end of header\r\n\r\n#ifdef ANIMATION_IMPL\r\n\r\n#endif\r\n","#include \"Entity.h\"\r\n\r\nconstexpr int DEAD_UNIT = -1;\r\n\r\nEntityHandle* newHandle(Entities* entities, EntityHandles* entityHandles, int entityId)\r\n{\r\n\t++entityHandles->currentCount;\r\n\tint freeIndex = entityHandles->firstFreeIndex;\r\n\tEntityHandle* result = &entityHandles->handles[freeIndex];\r\n\tresult->id = entityId;\r\n\tresult->_index = freeIndex;\r\n\tresult->refCount = 1;\r\n\r\n\tentities->selfHandle[entityId] = result;\r\n\t\t\r\n\t// find next free\r\n\tfor (int i = entityHandles->firstFreeIndex + 1; i < MAX_ENTITY_COUNT; ++i)\r\n\t{\r\n\t\tif (entityHandles->handles[i].refCount == 0)\r\n\t\t{\r\n\t\t\tentityHandles->firstFreeIndex = i;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\nEntityHandle* getHandle(Entities* entities, int entityId)\r\n{\r\n\r\n\tif (!entities->selfHandle[entityId])\r\n\t{\r\n\t\treturn newHandle(entities, &entityHandles, entityId);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t++entities->selfHandle[entityId]->refCount;\r\n\t\treturn entities->selfHandle[entityId];\r\n\t}\r\n}\r\n\r\nvoid invalidateHandle(EntityHandle* handle)\r\n{\r\n\thandle->id = DEAD_UNIT;\r\n}\r\n\r\nvoid freeHandle(Entities* entities, EntityHandle* entityHandle)\r\n{\r\n\t--entityHandle->refCount;\r\n\tASSERT(entityHandle->refCount >= 0); // -1 == baaaaaaaaaaad\r\n\r\n\tif (entityHandle->refCount == 0)\r\n\t{\r\n\t\tentities->selfHandle[entityHandle->id] = 0;\r\n\r\n\t\tif (entityHandles.firstFreeIndex > entityHandle->_index)\r\n\t\t{\r\n\t\t\tentityHandles.firstFreeIndex = entityHandle->_index;\r\n\t\t}\r\n\t\tentityHandles.handles[entityHandle->_index] = {}; //notice\r\n\t}\r\n}\r\n","// stb_sprintf - v1.03 - public domain snprintf() implementation\r\n// originally by Jeff Roberts / RAD Game Tools, 2015/10/20\r\n// http://github.com/nothings/stb\r\n//\r\n// allowed types:  sc uidBboXx p AaGgEef n\r\n// lengths      :  h ll j z t I64 I32 I\r\n//\r\n// Contributors:\r\n//    Fabian \"ryg\" Giesen (reformatting)\r\n//\r\n// Contributors (bugfixes):\r\n//    github:d26435\r\n//    github:trex78\r\n//    Jari Komppa (SI suffixes)\r\n//\r\n// LICENSE:\r\n//\r\n//   See end of file for license information.\r\n\r\n#ifndef STB_SPRINTF_H_INCLUDE\r\n#define STB_SPRINTF_H_INCLUDE\r\n\r\n/*\r\nSingle file sprintf replacement.\r\n\r\nOriginally written by Jeff Roberts at RAD Game Tools - 2015/10/20.\r\nHereby placed in public domain.\r\n\r\nThis is a full sprintf replacement that supports everything that\r\nthe C runtime sprintfs support, including float/double, 64-bit integers,\r\nhex floats, field parameters (%*.*d stuff), length reads backs, etc.\r\n\r\nWhy would you need this if sprintf already exists?  Well, first off,\r\nit's *much* faster (see below). It's also much smaller than the CRT\r\nversions code-space-wise. We've also added some simple improvements\r\nthat are super handy (commas in thousands, callbacks at buffer full,\r\nfor example). Finally, the format strings for MSVC and GCC differ\r\nfor 64-bit integers (among other small things), so this lets you use\r\nthe same format strings in cross platform code.\r\n\r\nIt uses the standard single file trick of being both the header file\r\nand the source itself. If you just include it normally, you just get\r\nthe header file function definitions. To get the code, you include\r\nit from a C or C++ file and define STB_SPRINTF_IMPLEMENTATION first.\r\n\r\nIt only uses va_args macros from the C runtime to do it's work. It\r\ndoes cast doubles to S64s and shifts and divides U64s, which does\r\ndrag in CRT code on most platforms.\r\n\r\nIt compiles to roughly 8K with float support, and 4K without.\r\nAs a comparison, when using MSVC static libs, calling sprintf drags\r\nin 16K.\r\n\r\nAPI:\r\n====\r\nint stbsp_sprintf( char * buf, char const * fmt, ... )\r\nint stbsp_snprintf( char * buf, int count, char const * fmt, ... )\r\n  Convert an arg list into a buffer.  stbsp_snprintf always returns\r\n  a zero-terminated string (unlike regular snprintf).\r\n\r\nint stbsp_vsprintf( char * buf, char const * fmt, va_list va )\r\nint stbsp_vsnprintf( char * buf, int count, char const * fmt, va_list va )\r\n  Convert a va_list arg list into a buffer.  stbsp_vsnprintf always returns\r\n  a zero-terminated string (unlike regular snprintf).\r\n\r\nint stbsp_vsprintfcb( STBSP_SPRINTFCB * callback, void * user, char * buf, char const * fmt, va_list va )\r\n    typedef char * STBSP_SPRINTFCB( char const * buf, void * user, int len );\r\n  Convert into a buffer, calling back every STB_SPRINTF_MIN chars.\r\n  Your callback can then copy the chars out, print them or whatever.\r\n  This function is actually the workhorse for everything else.\r\n  The buffer you pass in must hold at least STB_SPRINTF_MIN characters.\r\n    // you return the next buffer to use or 0 to stop converting\r\n\r\nvoid stbsp_set_separators( char comma, char period )\r\n  Set the comma and period characters to use.\r\n\r\nFLOATS/DOUBLES:\r\n===============\r\nThis code uses a internal float->ascii conversion method that uses\r\ndoubles with error correction (double-doubles, for ~105 bits of\r\nprecision).  This conversion is round-trip perfect - that is, an atof\r\nof the values output here will give you the bit-exact double back.\r\n\r\nOne difference is that our insignificant digits will be different than\r\nwith MSVC or GCC (but they don't match each other either).  We also\r\ndon't attempt to find the minimum length matching float (pre-MSVC15\r\ndoesn't either).\r\n\r\nIf you don't need float or doubles at all, define STB_SPRINTF_NOFLOAT\r\nand you'll save 4K of code space.\r\n\r\n64-BIT INTS:\r\n============\r\nThis library also supports 64-bit integers and you can use MSVC style or\r\nGCC style indicators (%I64d or %lld).  It supports the C99 specifiers\r\nfor size_t and ptr_diff_t (%jd %zd) as well.\r\n\r\nEXTRAS:\r\n=======\r\nLike some GCCs, for integers and floats, you can use a ' (single quote)\r\nspecifier and commas will be inserted on the thousands: \"%'d\" on 12345\r\nwould print 12,345.\r\n\r\nFor integers and floats, you can use a \"$\" specifier and the number\r\nwill be converted to float and then divided to get kilo, mega, giga or\r\ntera and then printed, so \"%$d\" 1000 is \"1.0 k\", \"%$.2d\" 2536000 is\r\n\"2.53 M\", etc. For byte values, use two $:s, like \"%$$d\" to turn\r\n2536000 to \"2.42 Mi\". If you prefer JEDEC suffixes to SI ones, use three\r\n$:s: \"%$$$d\" -> \"2.42 M\". To remove the space between the number and the\r\nsuffix, add \"_\" specifier: \"%_$d\" -> \"2.53M\".\r\n\r\nIn addition to octal and hexadecimal conversions, you can print\r\nintegers in binary: \"%b\" for 256 would print 100.\r\n\r\nPERFORMANCE vs MSVC 2008 32-/64-bit (GCC is even slower than MSVC):\r\n===================================================================\r\n\"%d\" across all 32-bit ints (4.8x/4.0x faster than 32-/64-bit MSVC)\r\n\"%24d\" across all 32-bit ints (4.5x/4.2x faster)\r\n\"%x\" across all 32-bit ints (4.5x/3.8x faster)\r\n\"%08x\" across all 32-bit ints (4.3x/3.8x faster)\r\n\"%f\" across e-10 to e+10 floats (7.3x/6.0x faster)\r\n\"%e\" across e-10 to e+10 floats (8.1x/6.0x faster)\r\n\"%g\" across e-10 to e+10 floats (10.0x/7.1x faster)\r\n\"%f\" for values near e-300 (7.9x/6.5x faster)\r\n\"%f\" for values near e+300 (10.0x/9.1x faster)\r\n\"%e\" for values near e-300 (10.1x/7.0x faster)\r\n\"%e\" for values near e+300 (9.2x/6.0x faster)\r\n\"%.320f\" for values near e-300 (12.6x/11.2x faster)\r\n\"%a\" for random values (8.6x/4.3x faster)\r\n\"%I64d\" for 64-bits with 32-bit values (4.8x/3.4x faster)\r\n\"%I64d\" for 64-bits > 32-bit values (4.9x/5.5x faster)\r\n\"%s%s%s\" for 64 char strings (7.1x/7.3x faster)\r\n\"...512 char string...\" ( 35.0x/32.5x faster!)\r\n*/\r\n\r\n#if defined(__has_feature)\r\n   #if __has_feature(address_sanitizer)\r\n      #define STBI__ASAN __attribute__((no_sanitize(\"address\")))\r\n   #endif\r\n#endif\r\n#ifndef STBI__ASAN\r\n#define STBI__ASAN\r\n#endif\r\n\r\n#ifdef STB_SPRINTF_STATIC\r\n#define STBSP__PUBLICDEC static\r\n#define STBSP__PUBLICDEF static STBI__ASAN\r\n#else\r\n#ifdef __cplusplus\r\n#define STBSP__PUBLICDEC extern \"C\"\r\n#define STBSP__PUBLICDEF extern \"C\" STBI__ASAN\r\n#else\r\n#define STBSP__PUBLICDEC extern\r\n#define STBSP__PUBLICDEF STBI__ASAN\r\n#endif\r\n#endif\r\n\r\n#include <stdarg.h> // for va_list()\r\n\r\n#ifndef STB_SPRINTF_MIN\r\n#define STB_SPRINTF_MIN 512 // how many characters per callback\r\n#endif\r\ntypedef char *STBSP_SPRINTFCB(char *buf, void *user, int len);\r\n\r\n#ifndef STB_SPRINTF_DECORATE\r\n#define STB_SPRINTF_DECORATE(name) stbsp_##name // define this before including if you want to change the names\r\n#endif\r\n\r\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE(vsprintf)(char *buf, char const *fmt, va_list va);\r\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE(vsnprintf)(char *buf, int count, char const *fmt, va_list va);\r\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE(sprintf)(char *buf, char const *fmt, ...);\r\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE(snprintf)(char *buf, int count, char const *fmt, ...);\r\n\r\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE(vsprintfcb)(STBSP_SPRINTFCB *callback, void *user, char *buf, char const *fmt, va_list va);\r\nSTBSP__PUBLICDEF void STB_SPRINTF_DECORATE(set_separators)(char comma, char period);\r\n\r\n#endif // STB_SPRINTF_H_INCLUDE\r\n\r\n#ifdef STB_SPRINTF_IMPLEMENTATION\r\n\r\n#include <stdlib.h> // for va_arg()\r\n\r\n#define stbsp__uint32 unsigned int\r\n#define stbsp__int32 signed int\r\n\r\n#ifdef _MSC_VER\r\n#define stbsp__uint64 unsigned __int64\r\n#define stbsp__int64 signed __int64\r\n#else\r\n#define stbsp__uint64 unsigned long long\r\n#define stbsp__int64 signed long long\r\n#endif\r\n#define stbsp__uint16 unsigned short\r\n\r\n#ifndef stbsp__uintptr\r\n#if defined(__ppc64__) || defined(__aarch64__) || defined(_M_X64) || defined(__x86_64__) || defined(__x86_64)\r\n#define stbsp__uintptr stbsp__uint64\r\n#else\r\n#define stbsp__uintptr stbsp__uint32\r\n#endif\r\n#endif\r\n\r\n#ifndef STB_SPRINTF_MSVC_MODE // used for MSVC2013 and earlier (MSVC2015 matches GCC)\r\n#if defined(_MSC_VER) && (_MSC_VER < 1900)\r\n#define STB_SPRINTF_MSVC_MODE\r\n#endif\r\n#endif\r\n\r\n#ifdef STB_SPRINTF_NOUNALIGNED // define this before inclusion to force stbsp_sprintf to always use aligned accesses\r\n#define STBSP__UNALIGNED(code)\r\n#else\r\n#define STBSP__UNALIGNED(code) code\r\n#endif\r\n\r\n#ifndef STB_SPRINTF_NOFLOAT\r\n// internal float utility functions\r\nstatic stbsp__int32 stbsp__real_to_str(char const **start, stbsp__uint32 *len, char *out, stbsp__int32 *decimal_pos, double value, stbsp__uint32 frac_digits);\r\nstatic stbsp__int32 stbsp__real_to_parts(stbsp__int64 *bits, stbsp__int32 *expo, double value);\r\n#define STBSP__SPECIAL 0x7000\r\n#endif\r\n\r\nstatic char stbsp__period = '.';\r\nstatic char stbsp__comma = ',';\r\nstatic char stbsp__digitpair[201] =\r\n   \"0001020304050607080910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576\"\r\n   \"7778798081828384858687888990919293949596979899\";\r\n\r\nSTBSP__PUBLICDEF void STB_SPRINTF_DECORATE(set_separators)(char pcomma, char pperiod)\r\n{\r\n   stbsp__period = pperiod;\r\n   stbsp__comma = pcomma;\r\n}\r\n\r\n#define STBSP__LEFTJUST 1\r\n#define STBSP__LEADINGPLUS 2\r\n#define STBSP__LEADINGSPACE 4\r\n#define STBSP__LEADING_0X 8\r\n#define STBSP__LEADINGZERO 16\r\n#define STBSP__INTMAX 32\r\n#define STBSP__TRIPLET_COMMA 64\r\n#define STBSP__NEGATIVE 128\r\n#define STBSP__METRIC_SUFFIX 256\r\n#define STBSP__HALFWIDTH 512\r\n#define STBSP__METRIC_NOSPACE 1024\r\n#define STBSP__METRIC_1024 2048\r\n#define STBSP__METRIC_JEDEC 4096\r\n\r\nstatic void stbsp__lead_sign(stbsp__uint32 fl, char *sign)\r\n{\r\n   sign[0] = 0;\r\n   if (fl & STBSP__NEGATIVE) {\r\n      sign[0] = 1;\r\n      sign[1] = '-';\r\n   } else if (fl & STBSP__LEADINGSPACE) {\r\n      sign[0] = 1;\r\n      sign[1] = ' ';\r\n   } else if (fl & STBSP__LEADINGPLUS) {\r\n      sign[0] = 1;\r\n      sign[1] = '+';\r\n   }\r\n}\r\n\r\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE(vsprintfcb)(STBSP_SPRINTFCB *callback, void *user, char *buf, char const *fmt, va_list va)\r\n{\r\n   static char hex[] = \"0123456789abcdefxp\";\r\n   static char hexu[] = \"0123456789ABCDEFXP\";\r\n   char *bf;\r\n   char const *f;\r\n   int tlen = 0;\r\n\r\n   bf = buf;\r\n   f = fmt;\r\n   for (;;) {\r\n      stbsp__int32 fw, pr, tz;\r\n      stbsp__uint32 fl;\r\n\r\n      // macros for the callback buffer stuff\r\n      #define stbsp__chk_cb_bufL(bytes)                        \\\r\n         {                                                     \\\r\n            int len = (int)(bf - buf);                         \\\r\n            if ((len + (bytes)) >= STB_SPRINTF_MIN) {          \\\r\n               tlen += len;                                    \\\r\n               if (0 == (bf = buf = callback(buf, user, len))) \\\r\n                  goto done;                                   \\\r\n            }                                                  \\\r\n         }\r\n      #define stbsp__chk_cb_buf(bytes)    \\\r\n         {                                \\\r\n            if (callback) {               \\\r\n               stbsp__chk_cb_bufL(bytes); \\\r\n            }                             \\\r\n         }\r\n      #define stbsp__flush_cb()                      \\\r\n         {                                           \\\r\n            stbsp__chk_cb_bufL(STB_SPRINTF_MIN - 1); \\\r\n         } // flush if there is even one byte in the buffer\r\n      #define stbsp__cb_buf_clamp(cl, v)                \\\r\n         cl = v;                                        \\\r\n         if (callback) {                                \\\r\n            int lg = STB_SPRINTF_MIN - (int)(bf - buf); \\\r\n            if (cl > lg)                                \\\r\n               cl = lg;                                 \\\r\n         }\r\n\r\n      // fast copy everything up to the next % (or end of string)\r\n      for (;;) {\r\n         while (((stbsp__uintptr)f) & 3) {\r\n         schk1:\r\n            if (f[0] == '%')\r\n               goto scandd;\r\n         schk2:\r\n            if (f[0] == 0)\r\n               goto endfmt;\r\n            stbsp__chk_cb_buf(1);\r\n            *bf++ = f[0];\r\n            ++f;\r\n         }\r\n         for (;;) {\r\n            // Check if the next 4 bytes contain %(0x25) or end of string.\r\n            // Using the 'hasless' trick:\r\n            // https://graphics.stanford.edu/~seander/bithacks.html#HasLessInWord\r\n            stbsp__uint32 v, c;\r\n            v = *(stbsp__uint32 *)f;\r\n            c = (~v) & 0x80808080;\r\n            if (((v ^ 0x25252525) - 0x01010101) & c)\r\n               goto schk1;\r\n            if ((v - 0x01010101) & c)\r\n               goto schk2;\r\n            if (callback)\r\n               if ((STB_SPRINTF_MIN - (int)(bf - buf)) < 4)\r\n                  goto schk1;\r\n            *(stbsp__uint32 *)bf = v;\r\n            bf += 4;\r\n            f += 4;\r\n         }\r\n      }\r\n   scandd:\r\n\r\n      ++f;\r\n\r\n      // ok, we have a percent, read the modifiers first\r\n      fw = 0;\r\n      pr = -1;\r\n      fl = 0;\r\n      tz = 0;\r\n\r\n      // flags\r\n      for (;;) {\r\n         switch (f[0]) {\r\n         // if we have left justify\r\n         case '-':\r\n            fl |= STBSP__LEFTJUST;\r\n            ++f;\r\n            continue;\r\n         // if we have leading plus\r\n         case '+':\r\n            fl |= STBSP__LEADINGPLUS;\r\n            ++f;\r\n            continue;\r\n         // if we have leading space\r\n         case ' ':\r\n            fl |= STBSP__LEADINGSPACE;\r\n            ++f;\r\n            continue;\r\n         // if we have leading 0x\r\n         case '#':\r\n            fl |= STBSP__LEADING_0X;\r\n            ++f;\r\n            continue;\r\n         // if we have thousand commas\r\n         case '\\'':\r\n            fl |= STBSP__TRIPLET_COMMA;\r\n            ++f;\r\n            continue;\r\n         // if we have kilo marker (none->kilo->kibi->jedec)\r\n         case '$':\r\n            if (fl & STBSP__METRIC_SUFFIX) {\r\n               if (fl & STBSP__METRIC_1024) {\r\n                  fl |= STBSP__METRIC_JEDEC;\r\n               } else {\r\n                  fl |= STBSP__METRIC_1024;\r\n               }\r\n            } else {\r\n               fl |= STBSP__METRIC_SUFFIX;\r\n            }\r\n            ++f;\r\n            continue;\r\n         // if we don't want space between metric suffix and number\r\n         case '_':\r\n            fl |= STBSP__METRIC_NOSPACE;\r\n            ++f;\r\n            continue;\r\n         // if we have leading zero\r\n         case '0':\r\n            fl |= STBSP__LEADINGZERO;\r\n            ++f;\r\n            goto flags_done;\r\n         default: goto flags_done;\r\n         }\r\n      }\r\n   flags_done:\r\n\r\n      // get the field width\r\n      if (f[0] == '*') {\r\n         fw = va_arg(va, stbsp__uint32);\r\n         ++f;\r\n      } else {\r\n         while ((f[0] >= '0') && (f[0] <= '9')) {\r\n            fw = fw * 10 + f[0] - '0';\r\n            f++;\r\n         }\r\n      }\r\n      // get the precision\r\n      if (f[0] == '.') {\r\n         ++f;\r\n         if (f[0] == '*') {\r\n            pr = va_arg(va, stbsp__uint32);\r\n            ++f;\r\n         } else {\r\n            pr = 0;\r\n            while ((f[0] >= '0') && (f[0] <= '9')) {\r\n               pr = pr * 10 + f[0] - '0';\r\n               f++;\r\n            }\r\n         }\r\n      }\r\n\r\n      // handle integer size overrides\r\n      switch (f[0]) {\r\n      // are we halfwidth?\r\n      case 'h':\r\n         fl |= STBSP__HALFWIDTH;\r\n         ++f;\r\n         break;\r\n      // are we 64-bit (unix style)\r\n      case 'l':\r\n         ++f;\r\n         if (f[0] == 'l') {\r\n            fl |= STBSP__INTMAX;\r\n            ++f;\r\n         }\r\n         break;\r\n      // are we 64-bit on intmax? (c99)\r\n      case 'j':\r\n         fl |= STBSP__INTMAX;\r\n         ++f;\r\n         break;\r\n      // are we 64-bit on size_t or ptrdiff_t? (c99)\r\n      case 'z':\r\n      case 't':\r\n         fl |= ((sizeof(char *) == 8) ? STBSP__INTMAX : 0);\r\n         ++f;\r\n         break;\r\n      // are we 64-bit (msft style)\r\n      case 'I':\r\n         if ((f[1] == '6') && (f[2] == '4')) {\r\n            fl |= STBSP__INTMAX;\r\n            f += 3;\r\n         } else if ((f[1] == '3') && (f[2] == '2')) {\r\n            f += 3;\r\n         } else {\r\n            fl |= ((sizeof(void *) == 8) ? STBSP__INTMAX : 0);\r\n            ++f;\r\n         }\r\n         break;\r\n      default: break;\r\n      }\r\n\r\n      // handle each replacement\r\n      switch (f[0]) {\r\n         #define STBSP__NUMSZ 512 // big enough for e308 (with commas) or e-307\r\n         char num[STBSP__NUMSZ];\r\n         char lead[8];\r\n         char tail[8];\r\n         char *s;\r\n         char const *h;\r\n         stbsp__uint32 l, n, cs;\r\n         stbsp__uint64 n64;\r\n#ifndef STB_SPRINTF_NOFLOAT\r\n         double fv;\r\n#endif\r\n         stbsp__int32 dp;\r\n         char const *sn;\r\n\r\n      case 's':\r\n         // get the string\r\n         s = va_arg(va, char *);\r\n         if (s == 0)\r\n            s = (char *)\"null\";\r\n         // get the length\r\n         sn = s;\r\n         for (;;) {\r\n            if ((((stbsp__uintptr)sn) & 3) == 0)\r\n               break;\r\n         lchk:\r\n            if (sn[0] == 0)\r\n               goto ld;\r\n            ++sn;\r\n         }\r\n         n = 0xffffffff;\r\n         if (pr >= 0) {\r\n            n = (stbsp__uint32)(sn - s);\r\n            if (n >= (stbsp__uint32)pr)\r\n               goto ld;\r\n            n = ((stbsp__uint32)(pr - n)) >> 2;\r\n         }\r\n         while (n) {\r\n            stbsp__uint32 v = *(stbsp__uint32 *)sn;\r\n            if ((v - 0x01010101) & (~v) & 0x80808080UL)\r\n               goto lchk;\r\n            sn += 4;\r\n            --n;\r\n         }\r\n         goto lchk;\r\n      ld:\r\n\r\n         l = (stbsp__uint32)(sn - s);\r\n         // clamp to precision\r\n         if (l > (stbsp__uint32)pr)\r\n            l = pr;\r\n         lead[0] = 0;\r\n         tail[0] = 0;\r\n         pr = 0;\r\n         dp = 0;\r\n         cs = 0;\r\n         // copy the string in\r\n         goto scopy;\r\n\r\n      case 'c': // char\r\n         // get the character\r\n         s = num + STBSP__NUMSZ - 1;\r\n         *s = (char)va_arg(va, int);\r\n         l = 1;\r\n         lead[0] = 0;\r\n         tail[0] = 0;\r\n         pr = 0;\r\n         dp = 0;\r\n         cs = 0;\r\n         goto scopy;\r\n\r\n      case 'n': // weird write-bytes specifier\r\n      {\r\n         int *d = va_arg(va, int *);\r\n         *d = tlen + (int)(bf - buf);\r\n      } break;\r\n\r\n#ifdef STB_SPRINTF_NOFLOAT\r\n      case 'A':              // float\r\n      case 'a':              // hex float\r\n      case 'G':              // float\r\n      case 'g':              // float\r\n      case 'E':              // float\r\n      case 'e':              // float\r\n      case 'f':              // float\r\n         va_arg(va, double); // eat it\r\n         s = (char *)\"No float\";\r\n         l = 8;\r\n         lead[0] = 0;\r\n         tail[0] = 0;\r\n         pr = 0;\r\n         dp = 0;\r\n         cs = 0;\r\n         goto scopy;\r\n#else\r\n      case 'A': // hex float\r\n      case 'a': // hex float\r\n         h = (f[0] == 'A') ? hexu : hex;\r\n         fv = va_arg(va, double);\r\n         if (pr == -1)\r\n            pr = 6; // default is 6\r\n         // read the double into a string\r\n         if (stbsp__real_to_parts((stbsp__int64 *)&n64, &dp, fv))\r\n            fl |= STBSP__NEGATIVE;\r\n\r\n         s = num + 64;\r\n\r\n         stbsp__lead_sign(fl, lead);\r\n\r\n         if (dp == -1023)\r\n            dp = (n64) ? -1022 : 0;\r\n         else\r\n            n64 |= (((stbsp__uint64)1) << 52);\r\n         n64 <<= (64 - 56);\r\n         if (pr < 15)\r\n            n64 += ((((stbsp__uint64)8) << 56) >> (pr * 4));\r\n// add leading chars\r\n\r\n#ifdef STB_SPRINTF_MSVC_MODE\r\n         *s++ = '0';\r\n         *s++ = 'x';\r\n#else\r\n         lead[1 + lead[0]] = '0';\r\n         lead[2 + lead[0]] = 'x';\r\n         lead[0] += 2;\r\n#endif\r\n         *s++ = h[(n64 >> 60) & 15];\r\n         n64 <<= 4;\r\n         if (pr)\r\n            *s++ = stbsp__period;\r\n         sn = s;\r\n\r\n         // print the bits\r\n         n = pr;\r\n         if (n > 13)\r\n            n = 13;\r\n         if (pr > (stbsp__int32)n)\r\n            tz = pr - n;\r\n         pr = 0;\r\n         while (n--) {\r\n            *s++ = h[(n64 >> 60) & 15];\r\n            n64 <<= 4;\r\n         }\r\n\r\n         // print the expo\r\n         tail[1] = h[17];\r\n         if (dp < 0) {\r\n            tail[2] = '-';\r\n            dp = -dp;\r\n         } else\r\n            tail[2] = '+';\r\n         n = (dp >= 1000) ? 6 : ((dp >= 100) ? 5 : ((dp >= 10) ? 4 : 3));\r\n         tail[0] = (char)n;\r\n         for (;;) {\r\n            tail[n] = '0' + dp % 10;\r\n            if (n <= 3)\r\n               break;\r\n            --n;\r\n            dp /= 10;\r\n         }\r\n\r\n         dp = (int)(s - sn);\r\n         l = (int)(s - (num + 64));\r\n         s = num + 64;\r\n         cs = 1 + (3 << 24);\r\n         goto scopy;\r\n\r\n      case 'G': // float\r\n      case 'g': // float\r\n         h = (f[0] == 'G') ? hexu : hex;\r\n         fv = va_arg(va, double);\r\n         if (pr == -1)\r\n            pr = 6;\r\n         else if (pr == 0)\r\n            pr = 1; // default is 6\r\n         // read the double into a string\r\n         if (stbsp__real_to_str(&sn, &l, num, &dp, fv, (pr - 1) | 0x80000000))\r\n            fl |= STBSP__NEGATIVE;\r\n\r\n         // clamp the precision and delete extra zeros after clamp\r\n         n = pr;\r\n         if (l > (stbsp__uint32)pr)\r\n            l = pr;\r\n         while ((l > 1) && (pr) && (sn[l - 1] == '0')) {\r\n            --pr;\r\n            --l;\r\n         }\r\n\r\n         // should we use %e\r\n         if ((dp <= -4) || (dp > (stbsp__int32)n)) {\r\n            if (pr > (stbsp__int32)l)\r\n               pr = l - 1;\r\n            else if (pr)\r\n               --pr; // when using %e, there is one digit before the decimal\r\n            goto doexpfromg;\r\n         }\r\n         // this is the insane action to get the pr to match %g sematics for %f\r\n         if (dp > 0) {\r\n            pr = (dp < (stbsp__int32)l) ? l - dp : 0;\r\n         } else {\r\n            pr = -dp + ((pr > (stbsp__int32)l) ? l : pr);\r\n         }\r\n         goto dofloatfromg;\r\n\r\n      case 'E': // float\r\n      case 'e': // float\r\n         h = (f[0] == 'E') ? hexu : hex;\r\n         fv = va_arg(va, double);\r\n         if (pr == -1)\r\n            pr = 6; // default is 6\r\n         // read the double into a string\r\n         if (stbsp__real_to_str(&sn, &l, num, &dp, fv, pr | 0x80000000))\r\n            fl |= STBSP__NEGATIVE;\r\n      doexpfromg:\r\n         tail[0] = 0;\r\n         stbsp__lead_sign(fl, lead);\r\n         if (dp == STBSP__SPECIAL) {\r\n            s = (char *)sn;\r\n            cs = 0;\r\n            pr = 0;\r\n            goto scopy;\r\n         }\r\n         s = num + 64;\r\n         // handle leading chars\r\n         *s++ = sn[0];\r\n\r\n         if (pr)\r\n            *s++ = stbsp__period;\r\n\r\n         // handle after decimal\r\n         if ((l - 1) > (stbsp__uint32)pr)\r\n            l = pr + 1;\r\n         for (n = 1; n < l; n++)\r\n            *s++ = sn[n];\r\n         // trailing zeros\r\n         tz = pr - (l - 1);\r\n         pr = 0;\r\n         // dump expo\r\n         tail[1] = h[0xe];\r\n         dp -= 1;\r\n         if (dp < 0) {\r\n            tail[2] = '-';\r\n            dp = -dp;\r\n         } else\r\n            tail[2] = '+';\r\n#ifdef STB_SPRINTF_MSVC_MODE\r\n         n = 5;\r\n#else\r\n         n = (dp >= 100) ? 5 : 4;\r\n#endif\r\n         tail[0] = (char)n;\r\n         for (;;) {\r\n            tail[n] = '0' + dp % 10;\r\n            if (n <= 3)\r\n               break;\r\n            --n;\r\n            dp /= 10;\r\n         }\r\n         cs = 1 + (3 << 24); // how many tens\r\n         goto flt_lead;\r\n\r\n      case 'f': // float\r\n         fv = va_arg(va, double);\r\n      doafloat:\r\n         // do kilos\r\n         if (fl & STBSP__METRIC_SUFFIX) {\r\n            double divisor;\r\n            divisor = 1000.0f;\r\n            if (fl & STBSP__METRIC_1024)\r\n               divisor = 1024.0;\r\n            while (fl < 0x4000000) {\r\n               if ((fv < divisor) && (fv > -divisor))\r\n                  break;\r\n               fv /= divisor;\r\n               fl += 0x1000000;\r\n            }\r\n         }\r\n         if (pr == -1)\r\n            pr = 6; // default is 6\r\n         // read the double into a string\r\n         if (stbsp__real_to_str(&sn, &l, num, &dp, fv, pr))\r\n            fl |= STBSP__NEGATIVE;\r\n      dofloatfromg:\r\n         tail[0] = 0;\r\n         stbsp__lead_sign(fl, lead);\r\n         if (dp == STBSP__SPECIAL) {\r\n            s = (char *)sn;\r\n            cs = 0;\r\n            pr = 0;\r\n            goto scopy;\r\n         }\r\n         s = num + 64;\r\n\r\n         // handle the three decimal varieties\r\n         if (dp <= 0) {\r\n            stbsp__int32 i;\r\n            // handle 0.000*000xxxx\r\n            *s++ = '0';\r\n            if (pr)\r\n               *s++ = stbsp__period;\r\n            n = -dp;\r\n            if ((stbsp__int32)n > pr)\r\n               n = pr;\r\n            i = n;\r\n            while (i) {\r\n               if ((((stbsp__uintptr)s) & 3) == 0)\r\n                  break;\r\n               *s++ = '0';\r\n               --i;\r\n            }\r\n            while (i >= 4) {\r\n               *(stbsp__uint32 *)s = 0x30303030;\r\n               s += 4;\r\n               i -= 4;\r\n            }\r\n            while (i) {\r\n               *s++ = '0';\r\n               --i;\r\n            }\r\n            if ((stbsp__int32)(l + n) > pr)\r\n               l = pr - n;\r\n            i = l;\r\n            while (i) {\r\n               *s++ = *sn++;\r\n               --i;\r\n            }\r\n            tz = pr - (n + l);\r\n            cs = 1 + (3 << 24); // how many tens did we write (for commas below)\r\n         } else {\r\n            cs = (fl & STBSP__TRIPLET_COMMA) ? ((600 - (stbsp__uint32)dp) % 3) : 0;\r\n            if ((stbsp__uint32)dp >= l) {\r\n               // handle xxxx000*000.0\r\n               n = 0;\r\n               for (;;) {\r\n                  if ((fl & STBSP__TRIPLET_COMMA) && (++cs == 4)) {\r\n                     cs = 0;\r\n                     *s++ = stbsp__comma;\r\n                  } else {\r\n                     *s++ = sn[n];\r\n                     ++n;\r\n                     if (n >= l)\r\n                        break;\r\n                  }\r\n               }\r\n               if (n < (stbsp__uint32)dp) {\r\n                  n = dp - n;\r\n                  if ((fl & STBSP__TRIPLET_COMMA) == 0) {\r\n                     while (n) {\r\n                        if ((((stbsp__uintptr)s) & 3) == 0)\r\n                           break;\r\n                        *s++ = '0';\r\n                        --n;\r\n                     }\r\n                     while (n >= 4) {\r\n                        *(stbsp__uint32 *)s = 0x30303030;\r\n                        s += 4;\r\n                        n -= 4;\r\n                     }\r\n                  }\r\n                  while (n) {\r\n                     if ((fl & STBSP__TRIPLET_COMMA) && (++cs == 4)) {\r\n                        cs = 0;\r\n                        *s++ = stbsp__comma;\r\n                     } else {\r\n                        *s++ = '0';\r\n                        --n;\r\n                     }\r\n                  }\r\n               }\r\n               cs = (int)(s - (num + 64)) + (3 << 24); // cs is how many tens\r\n               if (pr) {\r\n                  *s++ = stbsp__period;\r\n                  tz = pr;\r\n               }\r\n            } else {\r\n               // handle xxxxx.xxxx000*000\r\n               n = 0;\r\n               for (;;) {\r\n                  if ((fl & STBSP__TRIPLET_COMMA) && (++cs == 4)) {\r\n                     cs = 0;\r\n                     *s++ = stbsp__comma;\r\n                  } else {\r\n                     *s++ = sn[n];\r\n                     ++n;\r\n                     if (n >= (stbsp__uint32)dp)\r\n                        break;\r\n                  }\r\n               }\r\n               cs = (int)(s - (num + 64)) + (3 << 24); // cs is how many tens\r\n               if (pr)\r\n                  *s++ = stbsp__period;\r\n               if ((l - dp) > (stbsp__uint32)pr)\r\n                  l = pr + dp;\r\n               while (n < l) {\r\n                  *s++ = sn[n];\r\n                  ++n;\r\n               }\r\n               tz = pr - (l - dp);\r\n            }\r\n         }\r\n         pr = 0;\r\n\r\n         // handle k,m,g,t\r\n         if (fl & STBSP__METRIC_SUFFIX) {\r\n            char idx;\r\n            idx = 1;\r\n            if (fl & STBSP__METRIC_NOSPACE)\r\n               idx = 0;\r\n            tail[0] = idx;\r\n            tail[1] = ' ';\r\n            {\r\n               if (fl >> 24) { // SI kilo is 'k', JEDEC and SI kibits are 'K'.\r\n                  if (fl & STBSP__METRIC_1024)\r\n                     tail[idx + 1] = \"_KMGT\"[fl >> 24];\r\n                  else\r\n                     tail[idx + 1] = \"_kMGT\"[fl >> 24];\r\n                  idx++;\r\n                  // If printing kibits and not in jedec, add the 'i'.\r\n                  if (fl & STBSP__METRIC_1024 && !(fl & STBSP__METRIC_JEDEC)) {\r\n                     tail[idx + 1] = 'i';\r\n                     idx++;\r\n                  }\r\n                  tail[0] = idx;\r\n               }\r\n            }\r\n         };\r\n\r\n      flt_lead:\r\n         // get the length that we copied\r\n         l = (stbsp__uint32)(s - (num + 64));\r\n         s = num + 64;\r\n         goto scopy;\r\n#endif\r\n\r\n      case 'B': // upper binary\r\n      case 'b': // lower binary\r\n         h = (f[0] == 'B') ? hexu : hex;\r\n         lead[0] = 0;\r\n         if (fl & STBSP__LEADING_0X) {\r\n            lead[0] = 2;\r\n            lead[1] = '0';\r\n            lead[2] = h[0xb];\r\n         }\r\n         l = (8 << 4) | (1 << 8);\r\n         goto radixnum;\r\n\r\n      case 'o': // octal\r\n         h = hexu;\r\n         lead[0] = 0;\r\n         if (fl & STBSP__LEADING_0X) {\r\n            lead[0] = 1;\r\n            lead[1] = '0';\r\n         }\r\n         l = (3 << 4) | (3 << 8);\r\n         goto radixnum;\r\n\r\n      case 'p': // pointer\r\n         fl |= (sizeof(void *) == 8) ? STBSP__INTMAX : 0;\r\n         pr = sizeof(void *) * 2;\r\n         fl &= ~STBSP__LEADINGZERO; // 'p' only prints the pointer with zeros\r\n                                    // drop through to X\r\n\r\n      case 'X': // upper hex\r\n      case 'x': // lower hex\r\n         h = (f[0] == 'X') ? hexu : hex;\r\n         l = (4 << 4) | (4 << 8);\r\n         lead[0] = 0;\r\n         if (fl & STBSP__LEADING_0X) {\r\n            lead[0] = 2;\r\n            lead[1] = '0';\r\n            lead[2] = h[16];\r\n         }\r\n      radixnum:\r\n         // get the number\r\n         if (fl & STBSP__INTMAX)\r\n            n64 = va_arg(va, stbsp__uint64);\r\n         else\r\n            n64 = va_arg(va, stbsp__uint32);\r\n\r\n         s = num + STBSP__NUMSZ;\r\n         dp = 0;\r\n         // clear tail, and clear leading if value is zero\r\n         tail[0] = 0;\r\n         if (n64 == 0) {\r\n            lead[0] = 0;\r\n            if (pr == 0) {\r\n               l = 0;\r\n               cs = (((l >> 4) & 15)) << 24;\r\n               goto scopy;\r\n            }\r\n         }\r\n         // convert to string\r\n         for (;;) {\r\n            *--s = h[n64 & ((1 << (l >> 8)) - 1)];\r\n            n64 >>= (l >> 8);\r\n            if (!((n64) || ((stbsp__int32)((num + STBSP__NUMSZ) - s) < pr)))\r\n               break;\r\n            if (fl & STBSP__TRIPLET_COMMA) {\r\n               ++l;\r\n               if ((l & 15) == ((l >> 4) & 15)) {\r\n                  l &= ~15;\r\n                  *--s = stbsp__comma;\r\n               }\r\n            }\r\n         };\r\n         // get the tens and the comma pos\r\n         cs = (stbsp__uint32)((num + STBSP__NUMSZ) - s) + ((((l >> 4) & 15)) << 24);\r\n         // get the length that we copied\r\n         l = (stbsp__uint32)((num + STBSP__NUMSZ) - s);\r\n         // copy it\r\n         goto scopy;\r\n\r\n      case 'u': // unsigned\r\n      case 'i':\r\n      case 'd': // integer\r\n         // get the integer and abs it\r\n         if (fl & STBSP__INTMAX) {\r\n            stbsp__int64 i64 = va_arg(va, stbsp__int64);\r\n            n64 = (stbsp__uint64)i64;\r\n            if ((f[0] != 'u') && (i64 < 0)) {\r\n               n64 = (stbsp__uint64)-i64;\r\n               fl |= STBSP__NEGATIVE;\r\n            }\r\n         } else {\r\n            stbsp__int32 i = va_arg(va, stbsp__int32);\r\n            n64 = (stbsp__uint32)i;\r\n            if ((f[0] != 'u') && (i < 0)) {\r\n               n64 = (stbsp__uint32)-i;\r\n               fl |= STBSP__NEGATIVE;\r\n            }\r\n         }\r\n\r\n#ifndef STB_SPRINTF_NOFLOAT\r\n         if (fl & STBSP__METRIC_SUFFIX) {\r\n            if (n64 < 1024)\r\n               pr = 0;\r\n            else if (pr == -1)\r\n               pr = 1;\r\n            fv = (double)(stbsp__int64)n64;\r\n            goto doafloat;\r\n         }\r\n#endif\r\n\r\n         // convert to string\r\n         s = num + STBSP__NUMSZ;\r\n         l = 0;\r\n\r\n         for (;;) {\r\n            // do in 32-bit chunks (avoid lots of 64-bit divides even with constant denominators)\r\n            char *o = s - 8;\r\n            if (n64 >= 100000000) {\r\n               n = (stbsp__uint32)(n64 % 100000000);\r\n               n64 /= 100000000;\r\n            } else {\r\n               n = (stbsp__uint32)n64;\r\n               n64 = 0;\r\n            }\r\n            if ((fl & STBSP__TRIPLET_COMMA) == 0) {\r\n               while (n) {\r\n                  s -= 2;\r\n                  *(stbsp__uint16 *)s = *(stbsp__uint16 *)&stbsp__digitpair[(n % 100) * 2];\r\n                  n /= 100;\r\n               }\r\n            }\r\n            while (n) {\r\n               if ((fl & STBSP__TRIPLET_COMMA) && (l++ == 3)) {\r\n                  l = 0;\r\n                  *--s = stbsp__comma;\r\n                  --o;\r\n               } else {\r\n                  *--s = (char)(n % 10) + '0';\r\n                  n /= 10;\r\n               }\r\n            }\r\n            if (n64 == 0) {\r\n               if ((s[0] == '0') && (s != (num + STBSP__NUMSZ)))\r\n                  ++s;\r\n               break;\r\n            }\r\n            while (s != o)\r\n               if ((fl & STBSP__TRIPLET_COMMA) && (l++ == 3)) {\r\n                  l = 0;\r\n                  *--s = stbsp__comma;\r\n                  --o;\r\n               } else {\r\n                  *--s = '0';\r\n               }\r\n         }\r\n\r\n         tail[0] = 0;\r\n         stbsp__lead_sign(fl, lead);\r\n\r\n         // get the length that we copied\r\n         l = (stbsp__uint32)((num + STBSP__NUMSZ) - s);\r\n         if (l == 0) {\r\n            *--s = '0';\r\n            l = 1;\r\n         }\r\n         cs = l + (3 << 24);\r\n         if (pr < 0)\r\n            pr = 0;\r\n\r\n      scopy:\r\n         // get fw=leading/trailing space, pr=leading zeros\r\n         if (pr < (stbsp__int32)l)\r\n            pr = l;\r\n         n = pr + lead[0] + tail[0] + tz;\r\n         if (fw < (stbsp__int32)n)\r\n            fw = n;\r\n         fw -= n;\r\n         pr -= l;\r\n\r\n         // handle right justify and leading zeros\r\n         if ((fl & STBSP__LEFTJUST) == 0) {\r\n            if (fl & STBSP__LEADINGZERO) // if leading zeros, everything is in pr\r\n            {\r\n               pr = (fw > pr) ? fw : pr;\r\n               fw = 0;\r\n            } else {\r\n               fl &= ~STBSP__TRIPLET_COMMA; // if no leading zeros, then no commas\r\n            }\r\n         }\r\n\r\n         // copy the spaces and/or zeros\r\n         if (fw + pr) {\r\n            stbsp__int32 i;\r\n            stbsp__uint32 c;\r\n\r\n            // copy leading spaces (or when doing %8.4d stuff)\r\n            if ((fl & STBSP__LEFTJUST) == 0)\r\n               while (fw > 0) {\r\n                  stbsp__cb_buf_clamp(i, fw);\r\n                  fw -= i;\r\n                  while (i) {\r\n                     if ((((stbsp__uintptr)bf) & 3) == 0)\r\n                        break;\r\n                     *bf++ = ' ';\r\n                     --i;\r\n                  }\r\n                  while (i >= 4) {\r\n                     *(stbsp__uint32 *)bf = 0x20202020;\r\n                     bf += 4;\r\n                     i -= 4;\r\n                  }\r\n                  while (i) {\r\n                     *bf++ = ' ';\r\n                     --i;\r\n                  }\r\n                  stbsp__chk_cb_buf(1);\r\n               }\r\n\r\n            // copy leader\r\n            sn = lead + 1;\r\n            while (lead[0]) {\r\n               stbsp__cb_buf_clamp(i, lead[0]);\r\n               lead[0] -= (char)i;\r\n               while (i) {\r\n                  *bf++ = *sn++;\r\n                  --i;\r\n               }\r\n               stbsp__chk_cb_buf(1);\r\n            }\r\n\r\n            // copy leading zeros\r\n            c = cs >> 24;\r\n            cs &= 0xffffff;\r\n            cs = (fl & STBSP__TRIPLET_COMMA) ? ((stbsp__uint32)(c - ((pr + cs) % (c + 1)))) : 0;\r\n            while (pr > 0) {\r\n               stbsp__cb_buf_clamp(i, pr);\r\n               pr -= i;\r\n               if ((fl & STBSP__TRIPLET_COMMA) == 0) {\r\n                  while (i) {\r\n                     if ((((stbsp__uintptr)bf) & 3) == 0)\r\n                        break;\r\n                     *bf++ = '0';\r\n                     --i;\r\n                  }\r\n                  while (i >= 4) {\r\n                     *(stbsp__uint32 *)bf = 0x30303030;\r\n                     bf += 4;\r\n                     i -= 4;\r\n                  }\r\n               }\r\n               while (i) {\r\n                  if ((fl & STBSP__TRIPLET_COMMA) && (cs++ == c)) {\r\n                     cs = 0;\r\n                     *bf++ = stbsp__comma;\r\n                  } else\r\n                     *bf++ = '0';\r\n                  --i;\r\n               }\r\n               stbsp__chk_cb_buf(1);\r\n            }\r\n         }\r\n\r\n         // copy leader if there is still one\r\n         sn = lead + 1;\r\n         while (lead[0]) {\r\n            stbsp__int32 i;\r\n            stbsp__cb_buf_clamp(i, lead[0]);\r\n            lead[0] -= (char)i;\r\n            while (i) {\r\n               *bf++ = *sn++;\r\n               --i;\r\n            }\r\n            stbsp__chk_cb_buf(1);\r\n         }\r\n\r\n         // copy the string\r\n         n = l;\r\n         while (n) {\r\n            stbsp__int32 i;\r\n            stbsp__cb_buf_clamp(i, n);\r\n            n -= i;\r\n            STBSP__UNALIGNED(while (i >= 4) {\r\n               *(stbsp__uint32 *)bf = *(stbsp__uint32 *)s;\r\n               bf += 4;\r\n               s += 4;\r\n               i -= 4;\r\n            })\r\n            while (i) {\r\n               *bf++ = *s++;\r\n               --i;\r\n            }\r\n            stbsp__chk_cb_buf(1);\r\n         }\r\n\r\n         // copy trailing zeros\r\n         while (tz) {\r\n            stbsp__int32 i;\r\n            stbsp__cb_buf_clamp(i, tz);\r\n            tz -= i;\r\n            while (i) {\r\n               if ((((stbsp__uintptr)bf) & 3) == 0)\r\n                  break;\r\n               *bf++ = '0';\r\n               --i;\r\n            }\r\n            while (i >= 4) {\r\n               *(stbsp__uint32 *)bf = 0x30303030;\r\n               bf += 4;\r\n               i -= 4;\r\n            }\r\n            while (i) {\r\n               *bf++ = '0';\r\n               --i;\r\n            }\r\n            stbsp__chk_cb_buf(1);\r\n         }\r\n\r\n         // copy tail if there is one\r\n         sn = tail + 1;\r\n         while (tail[0]) {\r\n            stbsp__int32 i;\r\n            stbsp__cb_buf_clamp(i, tail[0]);\r\n            tail[0] -= (char)i;\r\n            while (i) {\r\n               *bf++ = *sn++;\r\n               --i;\r\n            }\r\n            stbsp__chk_cb_buf(1);\r\n         }\r\n\r\n         // handle the left justify\r\n         if (fl & STBSP__LEFTJUST)\r\n            if (fw > 0) {\r\n               while (fw) {\r\n                  stbsp__int32 i;\r\n                  stbsp__cb_buf_clamp(i, fw);\r\n                  fw -= i;\r\n                  while (i) {\r\n                     if ((((stbsp__uintptr)bf) & 3) == 0)\r\n                        break;\r\n                     *bf++ = ' ';\r\n                     --i;\r\n                  }\r\n                  while (i >= 4) {\r\n                     *(stbsp__uint32 *)bf = 0x20202020;\r\n                     bf += 4;\r\n                     i -= 4;\r\n                  }\r\n                  while (i--)\r\n                     *bf++ = ' ';\r\n                  stbsp__chk_cb_buf(1);\r\n               }\r\n            }\r\n         break;\r\n\r\n      default: // unknown, just copy code\r\n         s = num + STBSP__NUMSZ - 1;\r\n         *s = f[0];\r\n         l = 1;\r\n         fw = pr = fl = 0;\r\n         lead[0] = 0;\r\n         tail[0] = 0;\r\n         pr = 0;\r\n         dp = 0;\r\n         cs = 0;\r\n         goto scopy;\r\n      }\r\n      ++f;\r\n   }\r\nendfmt:\r\n\r\n   if (!callback)\r\n      *bf = 0;\r\n   else\r\n      stbsp__flush_cb();\r\n\r\ndone:\r\n   return tlen + (int)(bf - buf);\r\n}\r\n\r\n// cleanup\r\n#undef STBSP__LEFTJUST\r\n#undef STBSP__LEADINGPLUS\r\n#undef STBSP__LEADINGSPACE\r\n#undef STBSP__LEADING_0X\r\n#undef STBSP__LEADINGZERO\r\n#undef STBSP__INTMAX\r\n#undef STBSP__TRIPLET_COMMA\r\n#undef STBSP__NEGATIVE\r\n#undef STBSP__METRIC_SUFFIX\r\n#undef STBSP__NUMSZ\r\n#undef stbsp__chk_cb_bufL\r\n#undef stbsp__chk_cb_buf\r\n#undef stbsp__flush_cb\r\n#undef stbsp__cb_buf_clamp\r\n\r\n// ============================================================================\r\n//   wrapper functions\r\n\r\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE(sprintf)(char *buf, char const *fmt, ...)\r\n{\r\n   int result;\r\n   va_list va;\r\n   va_start(va, fmt);\r\n   result = STB_SPRINTF_DECORATE(vsprintfcb)(0, 0, buf, fmt, va);\r\n   va_end(va);\r\n   return result;\r\n}\r\n\r\ntypedef struct stbsp__context {\r\n   char *buf;\r\n   int count;\r\n   char tmp[STB_SPRINTF_MIN];\r\n} stbsp__context;\r\n\r\nstatic char *stbsp__clamp_callback(char *buf, void *user, int len)\r\n{\r\n   stbsp__context *c = (stbsp__context *)user;\r\n\r\n   if (len > c->count)\r\n      len = c->count;\r\n\r\n   if (len) {\r\n      if (buf != c->buf) {\r\n         char *s, *d, *se;\r\n         d = c->buf;\r\n         s = buf;\r\n         se = buf + len;\r\n         do {\r\n            *d++ = *s++;\r\n         } while (s < se);\r\n      }\r\n      c->buf += len;\r\n      c->count -= len;\r\n   }\r\n\r\n   if (c->count <= 0)\r\n      return 0;\r\n   return (c->count >= STB_SPRINTF_MIN) ? c->buf : c->tmp; // go direct into buffer if you can\r\n}\r\n\r\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE(vsnprintf)(char *buf, int count, char const *fmt, va_list va)\r\n{\r\n   stbsp__context c;\r\n   int l;\r\n\r\n   if (count == 0)\r\n      return 0;\r\n\r\n   c.buf = buf;\r\n   c.count = count;\r\n\r\n   STB_SPRINTF_DECORATE(vsprintfcb)(stbsp__clamp_callback, &c, stbsp__clamp_callback(0, &c, 0), fmt, va);\r\n\r\n   // zero-terminate\r\n   l = (int)(c.buf - buf);\r\n   if (l >= count) // should never be greater, only equal (or less) than count\r\n      l = count - 1;\r\n   buf[l] = 0;\r\n\r\n   return l;\r\n}\r\n\r\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE(snprintf)(char *buf, int count, char const *fmt, ...)\r\n{\r\n   int result;\r\n   va_list va;\r\n   va_start(va, fmt);\r\n\r\n   result = STB_SPRINTF_DECORATE(vsnprintf)(buf, count, fmt, va);\r\n   va_end(va);\r\n\r\n   return result;\r\n}\r\n\r\nSTBSP__PUBLICDEF int STB_SPRINTF_DECORATE(vsprintf)(char *buf, char const *fmt, va_list va)\r\n{\r\n   return STB_SPRINTF_DECORATE(vsprintfcb)(0, 0, buf, fmt, va);\r\n}\r\n\r\n// =======================================================================\r\n//   low level float utility functions\r\n\r\n#ifndef STB_SPRINTF_NOFLOAT\r\n\r\n// copies d to bits w/ strict aliasing (this compiles to nothing on /Ox)\r\n#define STBSP__COPYFP(dest, src)                   \\\r\n   {                                               \\\r\n      int cn;                                      \\\r\n      for (cn = 0; cn < 8; cn++)                   \\\r\n         ((char *)&dest)[cn] = ((char *)&src)[cn]; \\\r\n   }\r\n\r\n// get float info\r\nstatic stbsp__int32 stbsp__real_to_parts(stbsp__int64 *bits, stbsp__int32 *expo, double value)\r\n{\r\n   double d;\r\n   stbsp__int64 b = 0;\r\n\r\n   // load value and round at the frac_digits\r\n   d = value;\r\n\r\n   STBSP__COPYFP(b, d);\r\n\r\n   *bits = b & ((((stbsp__uint64)1) << 52) - 1);\r\n   *expo = (stbsp__int32)(((b >> 52) & 2047) - 1023);\r\n\r\n   return (stbsp__int32)(b >> 63);\r\n}\r\n\r\nstatic double const stbsp__bot[23] = {\r\n   1e+000, 1e+001, 1e+002, 1e+003, 1e+004, 1e+005, 1e+006, 1e+007, 1e+008, 1e+009, 1e+010, 1e+011,\r\n   1e+012, 1e+013, 1e+014, 1e+015, 1e+016, 1e+017, 1e+018, 1e+019, 1e+020, 1e+021, 1e+022\r\n};\r\nstatic double const stbsp__negbot[22] = {\r\n   1e-001, 1e-002, 1e-003, 1e-004, 1e-005, 1e-006, 1e-007, 1e-008, 1e-009, 1e-010, 1e-011,\r\n   1e-012, 1e-013, 1e-014, 1e-015, 1e-016, 1e-017, 1e-018, 1e-019, 1e-020, 1e-021, 1e-022\r\n};\r\nstatic double const stbsp__negboterr[22] = {\r\n   -5.551115123125783e-018,  -2.0816681711721684e-019, -2.0816681711721686e-020, -4.7921736023859299e-021, -8.1803053914031305e-022, 4.5251888174113741e-023,\r\n   4.5251888174113739e-024,  -2.0922560830128471e-025, -6.2281591457779853e-026, -3.6432197315497743e-027, 6.0503030718060191e-028,  2.0113352370744385e-029,\r\n   -3.0373745563400371e-030, 1.1806906454401013e-032,  -7.7705399876661076e-032, 2.0902213275965398e-033,  -7.1542424054621921e-034, -7.1542424054621926e-035,\r\n   2.4754073164739869e-036,  5.4846728545790429e-037,  9.2462547772103625e-038,  -4.8596774326570872e-039\r\n};\r\nstatic double const stbsp__top[13] = {\r\n   1e+023, 1e+046, 1e+069, 1e+092, 1e+115, 1e+138, 1e+161, 1e+184, 1e+207, 1e+230, 1e+253, 1e+276, 1e+299\r\n};\r\nstatic double const stbsp__negtop[13] = {\r\n   1e-023, 1e-046, 1e-069, 1e-092, 1e-115, 1e-138, 1e-161, 1e-184, 1e-207, 1e-230, 1e-253, 1e-276, 1e-299\r\n};\r\nstatic double const stbsp__toperr[13] = {\r\n   8388608,\r\n   6.8601809640529717e+028,\r\n   -7.253143638152921e+052,\r\n   -4.3377296974619174e+075,\r\n   -1.5559416129466825e+098,\r\n   -3.2841562489204913e+121,\r\n   -3.7745893248228135e+144,\r\n   -1.7356668416969134e+167,\r\n   -3.8893577551088374e+190,\r\n   -9.9566444326005119e+213,\r\n   6.3641293062232429e+236,\r\n   -5.2069140800249813e+259,\r\n   -5.2504760255204387e+282\r\n};\r\nstatic double const stbsp__negtoperr[13] = {\r\n   3.9565301985100693e-040,  -2.299904345391321e-063,  3.6506201437945798e-086,  1.1875228833981544e-109,\r\n   -5.0644902316928607e-132, -6.7156837247865426e-155, -2.812077463003139e-178,  -5.7778912386589953e-201,\r\n   7.4997100559334532e-224,  -4.6439668915134491e-247, -6.3691100762962136e-270, -9.436808465446358e-293,\r\n   8.0970921678014997e-317\r\n};\r\n\r\n#if defined(_MSC_VER) && (_MSC_VER <= 1200)\r\nstatic stbsp__uint64 const stbsp__powten[20] = {\r\n   1,\r\n   10,\r\n   100,\r\n   1000,\r\n   10000,\r\n   100000,\r\n   1000000,\r\n   10000000,\r\n   100000000,\r\n   1000000000,\r\n   10000000000,\r\n   100000000000,\r\n   1000000000000,\r\n   10000000000000,\r\n   100000000000000,\r\n   1000000000000000,\r\n   10000000000000000,\r\n   100000000000000000,\r\n   1000000000000000000,\r\n   10000000000000000000U\r\n};\r\n#define stbsp__tento19th ((stbsp__uint64)1000000000000000000)\r\n#else\r\nstatic stbsp__uint64 const stbsp__powten[20] = {\r\n   1,\r\n   10,\r\n   100,\r\n   1000,\r\n   10000,\r\n   100000,\r\n   1000000,\r\n   10000000,\r\n   100000000,\r\n   1000000000,\r\n   10000000000ULL,\r\n   100000000000ULL,\r\n   1000000000000ULL,\r\n   10000000000000ULL,\r\n   100000000000000ULL,\r\n   1000000000000000ULL,\r\n   10000000000000000ULL,\r\n   100000000000000000ULL,\r\n   1000000000000000000ULL,\r\n   10000000000000000000ULL\r\n};\r\n#define stbsp__tento19th (1000000000000000000ULL)\r\n#endif\r\n\r\n#define stbsp__ddmulthi(oh, ol, xh, yh)                            \\\r\n   {                                                               \\\r\n      double ahi = 0, alo, bhi = 0, blo;                           \\\r\n      stbsp__int64 bt;                                             \\\r\n      oh = xh * yh;                                                \\\r\n      STBSP__COPYFP(bt, xh);                                       \\\r\n      bt &= ((~(stbsp__uint64)0) << 27);                           \\\r\n      STBSP__COPYFP(ahi, bt);                                      \\\r\n      alo = xh - ahi;                                              \\\r\n      STBSP__COPYFP(bt, yh);                                       \\\r\n      bt &= ((~(stbsp__uint64)0) << 27);                           \\\r\n      STBSP__COPYFP(bhi, bt);                                      \\\r\n      blo = yh - bhi;                                              \\\r\n      ol = ((ahi * bhi - oh) + ahi * blo + alo * bhi) + alo * blo; \\\r\n   }\r\n\r\n#define stbsp__ddtoS64(ob, xh, xl)          \\\r\n   {                                        \\\r\n      double ahi = 0, alo, vh, t;           \\\r\n      ob = (stbsp__int64)ph;                \\\r\n      vh = (double)ob;                      \\\r\n      ahi = (xh - vh);                      \\\r\n      t = (ahi - xh);                       \\\r\n      alo = (xh - (ahi - t)) - (vh + t);    \\\r\n      ob += (stbsp__int64)(ahi + alo + xl); \\\r\n   }\r\n\r\n#define stbsp__ddrenorm(oh, ol) \\\r\n   {                            \\\r\n      double s;                 \\\r\n      s = oh + ol;              \\\r\n      ol = ol - (s - oh);       \\\r\n      oh = s;                   \\\r\n   }\r\n\r\n#define stbsp__ddmultlo(oh, ol, xh, xl, yh, yl) ol = ol + (xh * yl + xl * yh);\r\n\r\n#define stbsp__ddmultlos(oh, ol, xh, yl) ol = ol + (xh * yl);\r\n\r\nstatic void stbsp__raise_to_power10(double *ohi, double *olo, double d, stbsp__int32 power) // power can be -323 to +350\r\n{\r\n   double ph, pl;\r\n   if ((power >= 0) && (power <= 22)) {\r\n      stbsp__ddmulthi(ph, pl, d, stbsp__bot[power]);\r\n   } else {\r\n      stbsp__int32 e, et, eb;\r\n      double p2h, p2l;\r\n\r\n      e = power;\r\n      if (power < 0)\r\n         e = -e;\r\n      et = (e * 0x2c9) >> 14; /* %23 */\r\n      if (et > 13)\r\n         et = 13;\r\n      eb = e - (et * 23);\r\n\r\n      ph = d;\r\n      pl = 0.0;\r\n      if (power < 0) {\r\n         if (eb) {\r\n            --eb;\r\n            stbsp__ddmulthi(ph, pl, d, stbsp__negbot[eb]);\r\n            stbsp__ddmultlos(ph, pl, d, stbsp__negboterr[eb]);\r\n         }\r\n         if (et) {\r\n            stbsp__ddrenorm(ph, pl);\r\n            --et;\r\n            stbsp__ddmulthi(p2h, p2l, ph, stbsp__negtop[et]);\r\n            stbsp__ddmultlo(p2h, p2l, ph, pl, stbsp__negtop[et], stbsp__negtoperr[et]);\r\n            ph = p2h;\r\n            pl = p2l;\r\n         }\r\n      } else {\r\n         if (eb) {\r\n            e = eb;\r\n            if (eb > 22)\r\n               eb = 22;\r\n            e -= eb;\r\n            stbsp__ddmulthi(ph, pl, d, stbsp__bot[eb]);\r\n            if (e) {\r\n               stbsp__ddrenorm(ph, pl);\r\n               stbsp__ddmulthi(p2h, p2l, ph, stbsp__bot[e]);\r\n               stbsp__ddmultlos(p2h, p2l, stbsp__bot[e], pl);\r\n               ph = p2h;\r\n               pl = p2l;\r\n            }\r\n         }\r\n         if (et) {\r\n            stbsp__ddrenorm(ph, pl);\r\n            --et;\r\n            stbsp__ddmulthi(p2h, p2l, ph, stbsp__top[et]);\r\n            stbsp__ddmultlo(p2h, p2l, ph, pl, stbsp__top[et], stbsp__toperr[et]);\r\n            ph = p2h;\r\n            pl = p2l;\r\n         }\r\n      }\r\n   }\r\n   stbsp__ddrenorm(ph, pl);\r\n   *ohi = ph;\r\n   *olo = pl;\r\n}\r\n\r\n// given a float value, returns the significant bits in bits, and the position of the\r\n//   decimal point in decimal_pos.  +/-INF and NAN are specified by special values\r\n//   returned in the decimal_pos parameter.\r\n// frac_digits is absolute normally, but if you want from first significant digits (got %g and %e), or in 0x80000000\r\nstatic stbsp__int32 stbsp__real_to_str(char const **start, stbsp__uint32 *len, char *out, stbsp__int32 *decimal_pos, double value, stbsp__uint32 frac_digits)\r\n{\r\n   double d;\r\n   stbsp__int64 bits = 0;\r\n   stbsp__int32 expo, e, ng, tens;\r\n\r\n   d = value;\r\n   STBSP__COPYFP(bits, d);\r\n   expo = (stbsp__int32)((bits >> 52) & 2047);\r\n   ng = (stbsp__int32)(bits >> 63);\r\n   if (ng)\r\n      d = -d;\r\n\r\n   if (expo == 2047) // is nan or inf?\r\n   {\r\n      *start = (bits & ((((stbsp__uint64)1) << 52) - 1)) ? \"NaN\" : \"Inf\";\r\n      *decimal_pos = STBSP__SPECIAL;\r\n      *len = 3;\r\n      return ng;\r\n   }\r\n\r\n   if (expo == 0) // is zero or denormal\r\n   {\r\n      if ((bits << 1) == 0) // do zero\r\n      {\r\n         *decimal_pos = 1;\r\n         *start = out;\r\n         out[0] = '0';\r\n         *len = 1;\r\n         return ng;\r\n      }\r\n      // find the right expo for denormals\r\n      {\r\n         stbsp__int64 v = ((stbsp__uint64)1) << 51;\r\n         while ((bits & v) == 0) {\r\n            --expo;\r\n            v >>= 1;\r\n         }\r\n      }\r\n   }\r\n\r\n   // find the decimal exponent as well as the decimal bits of the value\r\n   {\r\n      double ph, pl;\r\n\r\n      // log10 estimate - very specifically tweaked to hit or undershoot by no more than 1 of log10 of all expos 1..2046\r\n      tens = expo - 1023;\r\n      tens = (tens < 0) ? ((tens * 617) / 2048) : (((tens * 1233) / 4096) + 1);\r\n\r\n      // move the significant bits into position and stick them into an int\r\n      stbsp__raise_to_power10(&ph, &pl, d, 18 - tens);\r\n\r\n      // get full as much precision from double-double as possible\r\n      stbsp__ddtoS64(bits, ph, pl);\r\n\r\n      // check if we undershot\r\n      if (((stbsp__uint64)bits) >= stbsp__tento19th)\r\n         ++tens;\r\n   }\r\n\r\n   // now do the rounding in integer land\r\n   frac_digits = (frac_digits & 0x80000000) ? ((frac_digits & 0x7ffffff) + 1) : (tens + frac_digits);\r\n   if ((frac_digits < 24)) {\r\n      stbsp__uint32 dg = 1;\r\n      if ((stbsp__uint64)bits >= stbsp__powten[9])\r\n         dg = 10;\r\n      while ((stbsp__uint64)bits >= stbsp__powten[dg]) {\r\n         ++dg;\r\n         if (dg == 20)\r\n            goto noround;\r\n      }\r\n      if (frac_digits < dg) {\r\n         stbsp__uint64 r;\r\n         // add 0.5 at the right position and round\r\n         e = dg - frac_digits;\r\n         if ((stbsp__uint32)e >= 24)\r\n            goto noround;\r\n         r = stbsp__powten[e];\r\n         bits = bits + (r / 2);\r\n         if ((stbsp__uint64)bits >= stbsp__powten[dg])\r\n            ++tens;\r\n         bits /= r;\r\n      }\r\n   noround:;\r\n   }\r\n\r\n   // kill long trailing runs of zeros\r\n   if (bits) {\r\n      stbsp__uint32 n;\r\n      for (;;) {\r\n         if (bits <= 0xffffffff)\r\n            break;\r\n         if (bits % 1000)\r\n            goto donez;\r\n         bits /= 1000;\r\n      }\r\n      n = (stbsp__uint32)bits;\r\n      while ((n % 1000) == 0)\r\n         n /= 1000;\r\n      bits = n;\r\n   donez:;\r\n   }\r\n\r\n   // convert to string\r\n   out += 64;\r\n   e = 0;\r\n   for (;;) {\r\n      stbsp__uint32 n;\r\n      char *o = out - 8;\r\n      // do the conversion in chunks of U32s (avoid most 64-bit divides, worth it, constant denomiators be damned)\r\n      if (bits >= 100000000) {\r\n         n = (stbsp__uint32)(bits % 100000000);\r\n         bits /= 100000000;\r\n      } else {\r\n         n = (stbsp__uint32)bits;\r\n         bits = 0;\r\n      }\r\n      while (n) {\r\n         out -= 2;\r\n         *(stbsp__uint16 *)out = *(stbsp__uint16 *)&stbsp__digitpair[(n % 100) * 2];\r\n         n /= 100;\r\n         e += 2;\r\n      }\r\n      if (bits == 0) {\r\n         if ((e) && (out[0] == '0')) {\r\n            ++out;\r\n            --e;\r\n         }\r\n         break;\r\n      }\r\n      while (out != o) {\r\n         *--out = '0';\r\n         ++e;\r\n      }\r\n   }\r\n\r\n   *decimal_pos = tens;\r\n   *start = out;\r\n   *len = e;\r\n   return ng;\r\n}\r\n\r\n#undef stbsp__ddmulthi\r\n#undef stbsp__ddrenorm\r\n#undef stbsp__ddmultlo\r\n#undef stbsp__ddmultlos\r\n#undef STBSP__SPECIAL\r\n#undef STBSP__COPYFP\r\n\r\n#endif // STB_SPRINTF_NOFLOAT\r\n\r\n// clean up\r\n#undef stbsp__uint16\r\n#undef stbsp__uint32\r\n#undef stbsp__int32\r\n#undef stbsp__uint64\r\n#undef stbsp__int64\r\n#undef STBSP__UNALIGNED\r\n\r\n#endif // STB_SPRINTF_IMPLEMENTATION\r\n\r\n/*\r\n------------------------------------------------------------------------------\r\nThis software is available under 2 licenses -- choose whichever you prefer.\r\n------------------------------------------------------------------------------\r\nALTERNATIVE A - MIT License\r\nCopyright (c) 2017 Sean Barrett\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of\r\nthis software and associated documentation files (the \"Software\"), to deal in\r\nthe Software without restriction, including without limitation the rights to\r\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\nof the Software, and to permit persons to whom the Software is furnished to do\r\nso, subject to the following conditions:\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n------------------------------------------------------------------------------\r\nALTERNATIVE B - Public Domain (www.unlicense.org)\r\nThis is free and unencumbered software released into the public domain.\r\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\r\nsoftware, either in source code form or as a compiled binary, for any purpose,\r\ncommercial or non-commercial, and by any means.\r\nIn jurisdictions that recognize copyright laws, the author or authors of this\r\nsoftware dedicate any and all copyright interest in the software to the public\r\ndomain. We make this dedication for the benefit of the public at large and to\r\nthe detriment of our heirs and successors. We intend this dedication to be an\r\novert act of relinquishment in perpetuity of all present and future rights to\r\nthis software under copyright law.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\r\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n------------------------------------------------------------------------------\r\n*/\r\n","// stb_perlin.h - v0.3 - perlin noise\r\n// public domain single-file C implementation by Sean Barrett\r\n//\r\n// LICENSE\r\n//\r\n//   See end of file.\r\n//\r\n//\r\n// to create the implementation,\r\n//     #define STB_PERLIN_IMPLEMENTATION\r\n// in *one* C/CPP file that includes this file.\r\n//\r\n//\r\n// Documentation:\r\n//\r\n// float  stb_perlin_noise3( float x,\r\n//                           float y,\r\n//                           float z,\r\n//                           int   x_wrap=0,\r\n//                           int   y_wrap=0,\r\n//                           int   z_wrap=0)\r\n//\r\n// This function computes a random value at the coordinate (x,y,z).\r\n// Adjacent random values are continuous but the noise fluctuates\r\n// its randomness with period 1, i.e. takes on wholly unrelated values\r\n// at integer points. Specifically, this implements Ken Perlin's\r\n// revised noise function from 2002.\r\n//\r\n// The \"wrap\" parameters can be used to create wraparound noise that\r\n// wraps at powers of two. The numbers MUST be powers of two. Specify\r\n// 0 to mean \"don't care\". (The noise always wraps every 256 due\r\n// details of the implementation, even if you ask for larger or no\r\n// wrapping.)\r\n//\r\n// Fractal Noise:\r\n//\r\n// Three common fractal noise functions are included, which produce \r\n// a wide variety of nice effects depending on the parameters \r\n// provided. Note that each function will call stb_perlin_noise3 \r\n// 'octaves' times, so this parameter will affect runtime.\r\n//\r\n// float stb_perlin_ridge_noise3(float x, float y, float z,\r\n//                               float lacunarity, float gain, float offset, int octaves,\r\n//                               int x_wrap, int y_wrap, int z_wrap);\r\n//\r\n// float stb_perlin_fbm_noise3(float x, float y, float z,\r\n//                             float lacunarity, float gain, int octaves,\r\n//                             int x_wrap, int y_wrap, int z_wrap);\r\n//\r\n// float stb_perlin_turbulence_noise3(float x, float y, float z,\r\n//                                    float lacunarity, float gain,int octaves,\r\n//                                    int x_wrap, int y_wrap, int z_wrap);\r\n//\r\n// Typical values to start playing with:\r\n//     octaves    =   6     -- number of \"octaves\" of noise3() to sum\r\n//     lacunarity = ~ 2.0   -- spacing between successive octaves (use exactly 2.0 for wrapping output)\r\n//     gain       =   0.5   -- relative weighting applied to each successive octave\r\n//     offset     =   1.0?  -- used to invert the ridges, may need to be larger, not sure\r\n//    \r\n//\r\n// Contributors:\r\n//    Jack Mott - additional noise functions\r\n//\r\n\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\nextern float stb_perlin_noise3(float x, float y, float z, int x_wrap, int y_wrap, int z_wrap);\r\nextern float stb_perlin_ridge_noise3(float x, float y, float z,float lacunarity, float gain, float offset, int octaves,int x_wrap, int y_wrap, int z_wrap);\r\nextern float stb_perlin_fbm_noise3(float x, float y, float z,float lacunarity, float gain, int octaves,int x_wrap, int y_wrap, int z_wrap);\r\nextern float stb_perlin_turbulence_noise3(float x, float y, float z, float lacunarity, float gain, int octaves,int x_wrap, int y_wrap, int z_wrap);\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#ifdef STB_PERLIN_IMPLEMENTATION\r\n\r\n// not same permutation table as Perlin's reference to avoid copyright issues;\r\n// Perlin's table can be found at http://mrl.nyu.edu/~perlin/noise/\r\n// @OPTIMIZE: should this be unsigned char instead of int for cache?\r\nstatic unsigned char stb__perlin_randtab[512] =\r\n{\r\n   23, 125, 161, 52, 103, 117, 70, 37, 247, 101, 203, 169, 124, 126, 44, 123, \r\n   152, 238, 145, 45, 171, 114, 253, 10, 192, 136, 4, 157, 249, 30, 35, 72, \r\n   175, 63, 77, 90, 181, 16, 96, 111, 133, 104, 75, 162, 93, 56, 66, 240, \r\n   8, 50, 84, 229, 49, 210, 173, 239, 141, 1, 87, 18, 2, 198, 143, 57, \r\n   225, 160, 58, 217, 168, 206, 245, 204, 199, 6, 73, 60, 20, 230, 211, 233, \r\n   94, 200, 88, 9, 74, 155, 33, 15, 219, 130, 226, 202, 83, 236, 42, 172, \r\n   165, 218, 55, 222, 46, 107, 98, 154, 109, 67, 196, 178, 127, 158, 13, 243, \r\n   65, 79, 166, 248, 25, 224, 115, 80, 68, 51, 184, 128, 232, 208, 151, 122, \r\n   26, 212, 105, 43, 179, 213, 235, 148, 146, 89, 14, 195, 28, 78, 112, 76, \r\n   250, 47, 24, 251, 140, 108, 186, 190, 228, 170, 183, 139, 39, 188, 244, 246, \r\n   132, 48, 119, 144, 180, 138, 134, 193, 82, 182, 120, 121, 86, 220, 209, 3, \r\n   91, 241, 149, 85, 205, 150, 113, 216, 31, 100, 41, 164, 177, 214, 153, 231, \r\n   38, 71, 185, 174, 97, 201, 29, 95, 7, 92, 54, 254, 191, 118, 34, 221, \r\n   131, 11, 163, 99, 234, 81, 227, 147, 156, 176, 17, 142, 69, 12, 110, 62, \r\n   27, 255, 0, 194, 59, 116, 242, 252, 19, 21, 187, 53, 207, 129, 64, 135, \r\n   61, 40, 167, 237, 102, 223, 106, 159, 197, 189, 215, 137, 36, 32, 22, 5,  \r\n\r\n   // and a second copy so we don't need an extra mask or static initializer\r\n   23, 125, 161, 52, 103, 117, 70, 37, 247, 101, 203, 169, 124, 126, 44, 123, \r\n   152, 238, 145, 45, 171, 114, 253, 10, 192, 136, 4, 157, 249, 30, 35, 72, \r\n   175, 63, 77, 90, 181, 16, 96, 111, 133, 104, 75, 162, 93, 56, 66, 240, \r\n   8, 50, 84, 229, 49, 210, 173, 239, 141, 1, 87, 18, 2, 198, 143, 57, \r\n   225, 160, 58, 217, 168, 206, 245, 204, 199, 6, 73, 60, 20, 230, 211, 233, \r\n   94, 200, 88, 9, 74, 155, 33, 15, 219, 130, 226, 202, 83, 236, 42, 172, \r\n   165, 218, 55, 222, 46, 107, 98, 154, 109, 67, 196, 178, 127, 158, 13, 243, \r\n   65, 79, 166, 248, 25, 224, 115, 80, 68, 51, 184, 128, 232, 208, 151, 122, \r\n   26, 212, 105, 43, 179, 213, 235, 148, 146, 89, 14, 195, 28, 78, 112, 76, \r\n   250, 47, 24, 251, 140, 108, 186, 190, 228, 170, 183, 139, 39, 188, 244, 246, \r\n   132, 48, 119, 144, 180, 138, 134, 193, 82, 182, 120, 121, 86, 220, 209, 3, \r\n   91, 241, 149, 85, 205, 150, 113, 216, 31, 100, 41, 164, 177, 214, 153, 231, \r\n   38, 71, 185, 174, 97, 201, 29, 95, 7, 92, 54, 254, 191, 118, 34, 221, \r\n   131, 11, 163, 99, 234, 81, 227, 147, 156, 176, 17, 142, 69, 12, 110, 62, \r\n   27, 255, 0, 194, 59, 116, 242, 252, 19, 21, 187, 53, 207, 129, 64, 135, \r\n   61, 40, 167, 237, 102, 223, 106, 159, 197, 189, 215, 137, 36, 32, 22, 5,  \r\n};\r\n\r\nstatic float stb__perlin_lerp(float a, float b, float t)\r\n{\r\n   return a + (b-a) * t;\r\n}\r\n\r\nstatic int stb__perlin_fastfloor(float a)\r\n{\r\n\tint ai = (int) a;\r\n\treturn (a < ai) ? ai-1 : ai;\r\n}\r\n\r\n// different grad function from Perlin's, but easy to modify to match reference\r\nstatic float stb__perlin_grad(int hash, float x, float y, float z)\r\n{\r\n   static float basis[12][4] =\r\n   {\r\n      {  1, 1, 0 },\r\n      { -1, 1, 0 },\r\n      {  1,-1, 0 },\r\n      { -1,-1, 0 },\r\n      {  1, 0, 1 },\r\n      { -1, 0, 1 },\r\n      {  1, 0,-1 },\r\n      { -1, 0,-1 },\r\n      {  0, 1, 1 },\r\n      {  0,-1, 1 },\r\n      {  0, 1,-1 },\r\n      {  0,-1,-1 },\r\n   };\r\n\r\n   // perlin's gradient has 12 cases so some get used 1/16th of the time\r\n   // and some 2/16ths. We reduce bias by changing those fractions\r\n   // to 5/64ths and 6/64ths, and the same 4 cases get the extra weight.\r\n   static unsigned char indices[64] =\r\n   {\r\n      0,1,2,3,4,5,6,7,8,9,10,11,\r\n      0,9,1,11,\r\n      0,1,2,3,4,5,6,7,8,9,10,11,\r\n      0,1,2,3,4,5,6,7,8,9,10,11,\r\n      0,1,2,3,4,5,6,7,8,9,10,11,\r\n      0,1,2,3,4,5,6,7,8,9,10,11,\r\n   };\r\n\r\n   // if you use reference permutation table, change 63 below to 15 to match reference\r\n   // (this is why the ordering of the table above is funky)\r\n   float *grad = basis[indices[hash & 63]];\r\n   return grad[0]*x + grad[1]*y + grad[2]*z;\r\n}\r\n\r\nfloat stb_perlin_noise3(float x, float y, float z, int x_wrap, int y_wrap, int z_wrap)\r\n{\r\n   float u,v,w;\r\n   float n000,n001,n010,n011,n100,n101,n110,n111;\r\n   float n00,n01,n10,n11;\r\n   float n0,n1;\r\n\r\n   unsigned int x_mask = (x_wrap-1) & 255;\r\n   unsigned int y_mask = (y_wrap-1) & 255;\r\n   unsigned int z_mask = (z_wrap-1) & 255;\r\n   int px = stb__perlin_fastfloor(x);\r\n   int py = stb__perlin_fastfloor(y);\r\n   int pz = stb__perlin_fastfloor(z);\r\n   int x0 = px & x_mask, x1 = (px+1) & x_mask;\r\n   int y0 = py & y_mask, y1 = (py+1) & y_mask;\r\n   int z0 = pz & z_mask, z1 = (pz+1) & z_mask;\r\n   int r0,r1, r00,r01,r10,r11;\r\n\r\n   #define stb__perlin_ease(a)   (((a*6-15)*a + 10) * a * a * a)\r\n\r\n   x -= px; u = stb__perlin_ease(x);\r\n   y -= py; v = stb__perlin_ease(y);\r\n   z -= pz; w = stb__perlin_ease(z);\r\n\r\n   r0 = stb__perlin_randtab[x0];\r\n   r1 = stb__perlin_randtab[x1];\r\n\r\n   r00 = stb__perlin_randtab[r0+y0];\r\n   r01 = stb__perlin_randtab[r0+y1];\r\n   r10 = stb__perlin_randtab[r1+y0];\r\n   r11 = stb__perlin_randtab[r1+y1];\r\n\r\n   n000 = stb__perlin_grad(stb__perlin_randtab[r00+z0], x  , y  , z   );\r\n   n001 = stb__perlin_grad(stb__perlin_randtab[r00+z1], x  , y  , z-1 );\r\n   n010 = stb__perlin_grad(stb__perlin_randtab[r01+z0], x  , y-1, z   );\r\n   n011 = stb__perlin_grad(stb__perlin_randtab[r01+z1], x  , y-1, z-1 );\r\n   n100 = stb__perlin_grad(stb__perlin_randtab[r10+z0], x-1, y  , z   );\r\n   n101 = stb__perlin_grad(stb__perlin_randtab[r10+z1], x-1, y  , z-1 );\r\n   n110 = stb__perlin_grad(stb__perlin_randtab[r11+z0], x-1, y-1, z   );\r\n   n111 = stb__perlin_grad(stb__perlin_randtab[r11+z1], x-1, y-1, z-1 );\r\n\r\n   n00 = stb__perlin_lerp(n000,n001,w);\r\n   n01 = stb__perlin_lerp(n010,n011,w);\r\n   n10 = stb__perlin_lerp(n100,n101,w);\r\n   n11 = stb__perlin_lerp(n110,n111,w);\r\n\r\n   n0 = stb__perlin_lerp(n00,n01,v);\r\n   n1 = stb__perlin_lerp(n10,n11,v);\r\n\r\n   return stb__perlin_lerp(n0,n1,u);\r\n}\r\n\r\nfloat stb_perlin_ridge_noise3(float x, float y, float z,float lacunarity, float gain, float offset, int octaves,int x_wrap, int y_wrap, int z_wrap)\r\n{\r\n   int i;\r\n   float frequency = 1.0f;\r\n   float prev = 1.0f;\r\n   float amplitude = 0.5f;\r\n   float sum = 0.0f;\r\n\r\n   for (i = 0; i < octaves; i++) {\r\n      float r = (float)(stb_perlin_noise3(x*frequency,y*frequency,z*frequency,x_wrap,y_wrap,z_wrap));\r\n      r = r<0 ? -r : r; // fabs()\r\n      r = offset - r;\r\n      r = r*r;\r\n      sum += r*amplitude*prev;\r\n      prev = r;\r\n      frequency *= lacunarity;\r\n      amplitude *= gain;\r\n   }\r\n   return sum;\r\n}\r\n\r\nfloat stb_perlin_fbm_noise3(float x, float y, float z,float lacunarity, float gain, int octaves,int x_wrap, int y_wrap, int z_wrap)\r\n{\r\n   int i;\r\n   float frequency = 1.0f;\r\n   float amplitude = 1.0f;\r\n   float sum = 0.0f;\r\n   \r\n   for (i = 0; i < octaves; i++) {\r\n      sum += stb_perlin_noise3(x*frequency,y*frequency,z*frequency,x_wrap,y_wrap,z_wrap)*amplitude;\r\n      frequency *= lacunarity;\r\n      amplitude *= gain;\r\n   }\r\n   return sum;\r\n}\r\n\r\nfloat stb_perlin_turbulence_noise3(float x, float y, float z, float lacunarity, float gain, int octaves,int x_wrap, int y_wrap, int z_wrap)\r\n{\r\n   int i;\r\n   float frequency = 1.0f;\r\n   float amplitude = 1.0f;\r\n   float sum = 0.0f;\r\n   \r\n   for (i = 0; i < octaves; i++) {\r\n      float r = stb_perlin_noise3(x*frequency,y*frequency,z*frequency,x_wrap,y_wrap,z_wrap)*amplitude;\r\n      r = r<0 ? -r : r; // fabs()\r\n      sum += r;\r\n      frequency *= lacunarity;\r\n      amplitude *= gain;\r\n   }\r\n   return sum;\r\n}\r\n\r\n#endif  // STB_PERLIN_IMPLEMENTATION\r\n\r\n/*\r\n------------------------------------------------------------------------------\r\nThis software is available under 2 licenses -- choose whichever you prefer.\r\n------------------------------------------------------------------------------\r\nALTERNATIVE A - MIT License\r\nCopyright (c) 2017 Sean Barrett\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of \r\nthis software and associated documentation files (the \"Software\"), to deal in \r\nthe Software without restriction, including without limitation the rights to \r\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \r\nof the Software, and to permit persons to whom the Software is furnished to do \r\nso, subject to the following conditions:\r\nThe above copyright notice and this permission notice shall be included in all \r\ncopies or substantial portions of the Software.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \r\nSOFTWARE.\r\n------------------------------------------------------------------------------\r\nALTERNATIVE B - Public Domain (www.unlicense.org)\r\nThis is free and unencumbered software released into the public domain.\r\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \r\nsoftware, either in source code form or as a compiled binary, for any purpose, \r\ncommercial or non-commercial, and by any means.\r\nIn jurisdictions that recognize copyright laws, the author or authors of this \r\nsoftware dedicate any and all copyright interest in the software to the public \r\ndomain. We make this dedication for the benefit of the public at large and to \r\nthe detriment of our heirs and successors. We intend this dedication to be an \r\novert act of relinquishment in perpetuity of all present and future rights to \r\nthis software under copyright law.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \r\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n------------------------------------------------------------------------------\r\n*/\r\n","#include <algorithm>\r\n\r\n\r\n#define STB_PERLIN_IMPLEMENTATION\r\n#include <3rdparty/stb_perlin.h>\r\n\r\n#ifndef JAM_GAME_H\r\n#define JAM_GAME_H\r\n\r\nenum Entity_Enum {\r\n\tEntity_Player,\r\n\tEntity_Bacterio,\r\n\tEntity_Washer,\r\n\tMax,\r\n};\r\n\r\nenum Scene_enum\r\n{\r\n\tScene_Menu,\r\n\tScene_GameOver,\r\n\tScene_play\r\n};\r\n\r\nconstexpr int MAX_ENTITY = 80000;\r\nconstexpr float cell_size = 48.f;\r\n#define PLAYER_ID 0\r\n\r\n// spatial partision grid size\r\nconstexpr int GRID_W = 80;\r\nconstexpr int HASH_ARRAY_SIZE = GRID_W * GRID_W;\r\nconstexpr float defaultMultiplyTimer = 2500.f;\r\nconstexpr float bacteriaSpeed = 2.f;\r\nconstexpr int MAX_LEVEL = 4;\r\nconstexpr unsigned int TITLE_SCREEN_COLOR = 0xFFFFFFFF;\r\n\r\nstruct JamEntity\r\n{\r\n\tint count;\r\n\tEntity_Enum type;\r\n\tstruct\r\n\t{\r\n\t\tfloat speed;\r\n\t\tfloat xDir;\r\n\t} Player;\r\n\tstruct\r\n\t{\r\n\t\tvec2f moveDirection;\r\n\t\tfloat angle;\r\n\t\tfloat multiplyTimer;\r\n\t} Bacterio;\r\n};\r\n\r\nstruct CollisionBody\r\n{\r\n\tvec4* body;\r\n\tint entityID;\r\n};\r\n\r\nvec4 positionSize[MAX_ENTITY];\r\nCollisionBody* spatialPartision[HASH_ARRAY_SIZE]{};\r\n\r\nstruct JamState\r\n{\r\n\tJamEntity jamEntitys[MAX_ENTITY];\r\n\tfloat trauma;\r\n\tfloat shake;\r\n\tbool infection;\r\n\tfloat infectionAmount;\r\n\r\n\tint goalX, goalY;\r\n\tint playerX, playerY;\r\n\tbool nextLevel;\r\n\tint currentLevel;\r\n\r\n\tbool gameOver;\r\n\tScene_enum scene;\r\n};\r\n\r\nvoid jam_init(EngineCore* core, JamState* jamState);\r\nvoid jam_update(EngineCore* core, JamState* jamState);\r\nvoid jam_draw(EngineCore* core, JamState* jamState);\r\nstatic inline vec2f Vec2ToVec4(vec4* posSize);\r\nstatic inline vec2f getPosition(JamEntity* entitys, int id);\r\nstatic inline void setSize(vec2f* size, int id);\r\nvoid doCollisions(JamState* gameState);\r\n\r\nvoid createEnt(JamState* state, vec4* posSize, Entity_Enum type);\r\n\r\n\r\nconstexpr int LEVEL_SIZE = 80;\r\nchar level[LEVEL_SIZE * LEVEL_SIZE]{ };\r\nconstexpr float tile_size = 40.f;\r\n\r\nstatic void level1(JamState* state, char level[LEVEL_SIZE * LEVEL_SIZE]);\r\n\r\n#endif // end of the header\r\n\r\n#define JAM_IMPL 1\r\n#ifdef JAM_IMPL\r\n\r\nbool isWall(char id)\r\n{\r\n\treturn id == '#';\r\n}\r\n\r\nbool isGoal(char id)\r\n{\r\n\treturn id == 'G';\r\n}\r\n\r\nvoid GetTileFromWorldPosition(vec2f* collides, vec2f pos, int* index)\r\n{\r\n\tint realX = (int)((pos.x / tile_size));\r\n\tint realY = (int)((pos.y / tile_size));\r\n\tint i = realX + realY * LEVEL_SIZE;\r\n\r\n\tif (i < 0 || i > LEVEL_SIZE * LEVEL_SIZE)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\tchar id = level[i]; // collisions\r\n\r\n\t// printf(\"(pos: %f, %f):(i (%i, %i))id is %i\\n\", pos.x, pos.y, realX, realY, id);\r\n\tif (isWall(id))\r\n\t{\r\n\t\tcollides[*index] = { realX * tile_size + tile_size / 2.f, realY * tile_size + tile_size / 2.f };\r\n\t\t(*index)++;\r\n\t}\r\n}\r\n\r\nvoid testPrint()\r\n{\r\n\tfor (int i = 0; i < LEVEL_SIZE*LEVEL_SIZE; ++i)\r\n\t{\r\n\t\tprintf(\"%c\", level[i]);\r\n\t\tif (i % 80 == 0)\r\n\t\t\tprintf(\"\\n\");\r\n\t}\r\n}\r\n\r\nstatic bool inline isVirus(char c)\r\n{\r\n\treturn c == 'V';\r\n}\r\n\r\nstatic bool inline isStart(char c)\r\n{\r\n\treturn c == 'P';\r\n}\r\n\r\nstatic void parseMap(JamState* state, char level[LEVEL_SIZE * LEVEL_SIZE], char* data)\r\n{\r\n\tint k = 0;\r\n\tfor (int i = 0; i < LEVEL_SIZE * LEVEL_SIZE; ++i)\r\n\t{\r\n\t\tif (data[k] != '\\n')\r\n\t\t{\r\n\t\t\tlevel[i] = data[k];\r\n\t\t\tif (isVirus(data[k]))\r\n\t\t\t{\r\n\t\t\t\tint x = i % LEVEL_SIZE;\r\n\t\t\t\tint y = (i - x) / LEVEL_SIZE;\r\n\t\t\t\tvec4 position{ x * tile_size, y * tile_size, tile_size, tile_size };\r\n\t\t\t\tcreateEnt(state, &position, Entity_Bacterio);\r\n\t\t\t}\r\n\t\t\telse if (isGoal(data[k]))\r\n\t\t\t{\r\n\t\t\t\tint x = i % LEVEL_SIZE;\r\n\t\t\t\tint y = (i - x) / LEVEL_SIZE;\r\n\t\t\t\tstate->goalX = x;\r\n\t\t\t\tstate->goalY = y;\r\n\t\t\t}\r\n\t\t\telse if (isStart(data[k]))\r\n\t\t\t{\r\n\t\t\t\tint x = i % LEVEL_SIZE;\r\n\t\t\t\tint y = (i - x) / LEVEL_SIZE;\r\n\t\t\t\tstate->playerX = x;\r\n\t\t\t\tstate->playerY = y;\r\n\t\t\t}\r\n\t\t\t// LOGI(\"newLine: %i %i\\n\", i, k);\r\n#ifdef __EMSCRIPTEN__\r\n\t\t\t// --i;\r\n\t\t\t// ++k;\r\n#endif\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t--i;\r\n\t\t}\r\n\t\t++k;\r\n\t}\r\n}\r\n\r\n\r\nstatic void destroyViruses(JamState* state)\r\n{\r\n\tstate->jamEntitys->count = 1;\r\n}\r\n\r\nstatic void placePlayerToStart(JamState* state)\r\n{\r\n\tpositionSize[PLAYER_ID].x = state->playerX * tile_size;\r\n\tpositionSize[PLAYER_ID].y = state->playerY * tile_size;\r\n}\r\n\r\n\r\nstatic void level1(JamState* state, char level[LEVEL_SIZE * LEVEL_SIZE])\r\n{\r\n\t//for (int i = 0; i < LEVEL_SIZE; ++i)\r\n\t//{\r\n\t//\tfor (int j = 0; j < LEVEL_SIZE; ++j)\r\n\t//\t{\r\n\t//\t\t// level[i][j] = '-';\r\n\t//\t}\r\n\t//}\r\n\tint size;\r\n\r\n\r\n\tchar *map1 = engine::io::ReadEntireFile(\"assets/map1.txt\", &size);\r\n\r\n\t//for (int i = 0; i < 1000; i++)\r\n\t//\tLOGI(\"w: %c\", map2[i]);\r\n\r\n\t// LOGI(\"size %i \\n\", size);\r\n#if __EMSCRIPTEN__\r\n\t// for (int i = 0; i < LEVEL_SIZE; i++)\r\n\t\t// map1[79 * i] = '\\n';\r\n#endif\r\n\r\n\tint w = 0;\r\n\t//int h = 0;\r\n\r\n\tLOGI(\"; %i %i %i\", '\\n', '\\r', '\\r\\n');\r\n\tLOGI(\": %i, %i, %i, %i, %i, %i\\n\", map1[78], map1[79], map1[80], map1[81], map1[82], map1[83]);\r\n\r\n\r\n\t//char* map2 = map1;\r\n\t//while (map2[w] != '\\n')\r\n\t//\tw++;\r\n\r\n\r\n\tparseMap(state, level, map1);\r\n\r\n\tmap1[85] = '\\0';\r\n\tLOGI(\"%s \\n\", map1);\r\n\r\n\tfree(map1);\r\n}\r\n\r\nstatic void loadLevel(JamState* state, char level[LEVEL_SIZE * LEVEL_SIZE], char* levelName)\r\n{\r\n\tint size;\r\n\tchar *map1 = engine::io::ReadEntireFile(levelName, &size);\r\n\tparseMap(state, level, map1);\r\n\r\n\tfree(map1);\r\n}\r\n\r\nstatic void drawMap(EngineCore* core, char level[LEVEL_SIZE * LEVEL_SIZE], Layer* layer)\r\n{\r\n\t// layer->setTexture() // wall tile\r\n\tlayer->setTexture(engine::getTexture(core->resources, textures::Texture_Tile)->ID);\r\n\tvec4 defaultUV{ 0.f, 0.f, 1.f, 1.f };\r\n\tvec4 defaultColor{ 1.f, 1.f, 1.f, 1.f };\r\n\r\n\tfor (int i = 0; i < LEVEL_SIZE * LEVEL_SIZE; ++i)\r\n\t{\r\n\t\t{\r\n\t\t\tswitch (level[i])\r\n\t\t\t{\r\n\t\t\tcase 'P': // player start position aka empty\r\n\t\t\tcase 'S': // spawner start aka empty\r\n\t\t\tcase '-': // empty\r\n\t\t\tcase 'V': // virust start\r\n\t\t\t\tbreak;\r\n\t\t\tcase '#': // wall\r\n\t\t\t{\r\n\t\t\t\tint x = i % LEVEL_SIZE;\r\n\t\t\t\tint y = (i - x) / LEVEL_SIZE;\r\n\t\t\t\tvec4 posSize{ x * tile_size, y * tile_size, tile_size, tile_size };\r\n\r\n\t\t\t\tlayer->draw(&posSize, &defaultUV, &defaultColor);\r\n\t\t\t\t// graphics::drawBox(core->lines, &posSize); // wall !!!\r\n\t\t\t} break;\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid tileCollision(JamEntity* entitys)\r\n{\r\n\tvec2f collides[4];\r\n\r\n\tfor (int i = 0; i < entitys->count; i++)\r\n\t{\r\n\t\t// if no collision\r\n\t\t//\tcontinue;\r\n\r\n\t\tint count = 0;\r\n\t\tvec4* firstPos = &positionSize[i];\r\n\r\n\t\t// check tiles positions\r\n\t\tfloat halfW = std::abs(firstPos->w * 0.5f);\r\n\t\tfloat halfH = std::abs(firstPos->h * 0.5f);\r\n\r\n\t\tvec2f corner0 = { firstPos->x, firstPos->y };   // TODO: W VAI H\r\n\t\tvec2f corner1 = { firstPos->x + halfW * 2, firstPos->y };\r\n\t\tvec2f corner2 = { firstPos->x, firstPos->y + halfW * 2 };\r\n\t\tvec2f corner3 = { firstPos->x + halfW * 2, firstPos->y + halfW * 2 };\r\n\r\n\t\tGetTileFromWorldPosition(collides, corner0, &count);\r\n\t\tGetTileFromWorldPosition(collides, corner1, &count);\r\n\t\tGetTileFromWorldPosition(collides, corner2, &count);\r\n\t\tGetTileFromWorldPosition(collides, corner3, &count);\r\n\r\n\t\tstatic const float TILE_RADIUS = tile_size / 2.f;\r\n\t\tconst float MIN_DISTANCE = halfW + TILE_RADIUS;\r\n\r\n\t\tfor (int j = 0; j < count; j++)\r\n\t\t{\r\n\t\t\tvec2f centerEntityPos{ firstPos->x + halfW, firstPos->y + halfH };\r\n\t\t\tvec2f distVec = centerEntityPos - collides[j];\r\n\r\n\t\t\tfloat xDepth = MIN_DISTANCE - abs(distVec.x);\r\n\t\t\tfloat yDepth = MIN_DISTANCE - abs(distVec.y);\r\n\r\n\t\t\tif (xDepth > 0 && yDepth > 0)\r\n\t\t\t{\r\n\t\t\t\tif (std::max(xDepth, 0.0f) < std::max(yDepth, 0.0f))\r\n\t\t\t\t{\r\n\t\t\t\t\tif (distVec.x < 0.0f)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(*firstPos).x -= xDepth;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(*firstPos).x += xDepth;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// kimpoaminen x ?\r\n\t\t\t\t\tentitys[i].Bacterio.moveDirection.x = -entitys[i].Bacterio.moveDirection.x;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif (distVec.y < 0.0f)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(*firstPos).y -= yDepth;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(*firstPos).y += yDepth;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tentitys[i].Bacterio.moveDirection.y = -entitys[i].Bacterio.moveDirection.y;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfloat g_currentTime = 0.f;\r\nfloat nextBacteriaMultiply()\r\n{\r\n\treturn g_currentTime + defaultMultiplyTimer;\r\n}\r\n\r\nvoid createEnt(JamState* state, vec4* posSize, Entity_Enum type)\r\n{\r\n\tJamEntity* ents = state->jamEntitys;\r\n\r\n\tif (ents->count >= MAX_ENTITY)\r\n\t\treturn;\r\n\r\n\tint newID = state->jamEntitys->count;\r\n\tstate->jamEntitys[newID].type = type;\r\n\tpositionSize[newID] = *posSize;\r\n\r\n\tswitch (type)\r\n\t{\r\n\tcase Entity_Player:\r\n\t\tbreak;\r\n\tcase Entity_Bacterio:\r\n\t{\r\n\t\tauto Bacterio = &ents[newID].Bacterio;\r\n\t\tBacterio->multiplyTimer = nextBacteriaMultiply();\r\n\t\tBacterio->moveDirection = { RandomFloat(-1.0f, 1.0f), RandomFloat(-1.f, 1.f) };\r\n\t\tBacterio->moveDirection.safeNormalizeInPlace();\r\n\r\n\t\t// heh.\r\n\t\tpositionSize[newID].w = RandomFloat(20.f, 40.f);\r\n\t\tpositionSize[newID].h = RandomFloat(20.f, 40.f);\r\n\t} break;\r\n\tdefault:\r\n\t\tbreak;\r\n\t}\r\n\r\n\t++ents->count;\r\n}\r\n\r\nvoid jam_init(EngineCore* core, JamState* jamState)\r\n{\r\n\tJamEntity* ents = jamState->jamEntitys;\r\n\tjamState->jamEntitys->count = 2;\r\n\t// stbsp_sprintf(jamState->jamEntitys[0].Player.name, \"testi\");\r\n\tjamState->jamEntitys[0].Player.speed = 2.f;\r\n\tjamState->jamEntitys[0].type = Entity_Player;\r\n\tpositionSize[0] = { 80.f, 80.f, 40.f, 40.f };\r\n\r\n\tjamState->jamEntitys[1].type = Entity_Bacterio; // lol\r\n\tpositionSize[1] = { 100.f, 100.f, 20.f, 20.f };\r\n\tents[1].Bacterio.multiplyTimer = 1000.f;\r\n\t// vec2f size{ 20.f, 20.f };\r\n\t// seSize(&size, 1);\r\n\r\n\t// level1(jamState, level);\r\n\tloadLevel(jamState, level, \"assets/map1.txt\");\r\n\tplacePlayerToStart(jamState);\r\n\r\n\tjamState->currentLevel = 1;\r\n\r\n\tjamState->gameOver = false;\r\n\tjamState->scene = Scene_Menu;\r\n}\r\n\r\n\r\n#define GET_ENTITY(e, entity_type) ((e)->type == Entity_##entity_type ? &(e)->entity_type : 0)\r\n\r\nstatic inline vec2f getPosition(JamEntity* entitys, int id)\r\n{\r\n\treturn Vec2ToVec4(&positionSize[id]);\r\n}\r\n\r\nstatic inline void setSize(vec2f* size, int id)\r\n{\r\n\tpositionSize[id].w = size->x;\r\n\tpositionSize[id].h = size->y;\r\n}\r\n\r\nvoid setupCollision(JamState* gameState)\r\n{\r\n\tint count = gameState->jamEntitys->count;\r\n\tauto ents = &gameState->jamEntitys;\r\n\r\n\tfor (int i = 0; i < HASH_ARRAY_SIZE; ++i)\r\n\t{\r\n\t\tda_clear(spatialPartision[i])\r\n\t}\r\n\r\n\t// __pragma(omp parallel for schedule(dynamic, 1000) num_threads(7))\r\n\tfor (int j = 0; j < count; ++j)\r\n\t{\r\n\t\tvec4* poss = &positionSize[j];\r\n\r\n\t\tint x = int(poss->x / cell_size);\r\n\t\tint y = int(poss->y / cell_size);\r\n\r\n\t\tvec2i grids[5];\r\n\t\tgrids[0] = { x - 1, y - 1 };\r\n\t\tgrids[1] = { x, y - 1 };\r\n\t\tgrids[2] = { x - 1, y };\r\n\t\tgrids[3] = { x, y };\r\n\t\tgrids[4] = { x - 1, y + 1 };\r\n\r\n\t\tfor (int i = 0; i < 5; i++)\r\n\t\t{\r\n\t\t\tif (grids[i].x > 0 && grids[i].y > 0 && grids[i].x + grids[i].y * GRID_W < HASH_ARRAY_SIZE)\r\n\t\t\t{\r\n\t\t\t\tCollisionBody b = { poss, j };\r\n\t\t\t\tda_push((spatialPartision[grids[i].x + grids[i].y * GRID_W]), b);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n#define MAX_INFECTION 100\r\nvoid doCollisions(JamState* gameState)\r\n{\r\n\t// __pragma(omp parallel for schedule(dynamic, 1000) num_threads(7))\r\n\tfor (int i = 0; i < HASH_ARRAY_SIZE; ++i)\r\n\t{\r\n\t\tCollisionBody* array = spatialPartision[i];\r\n\t\tif (array)\r\n\t\t{\r\n\t\t\tint bodyCount = da_size(array);\r\n\r\n\t\t\tfor (int j = 0; j < bodyCount; ++j)\r\n\t\t\t{\r\n\t\t\t\tvec4* __restrict a = (array + j)->body;// (array)+j;\r\n\t\t\t\tfloat a_half_width = a->w / 2.f;\r\n\t\t\t\tVec2 centerPosA = Vec2{ a->x, a->y } +Vec2{ a_half_width, a_half_width };\r\n\r\n\t\t\t\tfor (int k = j + 1; k < bodyCount; ++k)\r\n\t\t\t\t{\r\n\t\t\t\t\tvec4* b = (array + k)->body;\r\n\r\n\t\t\t\t\tconst float MIN_DISTANCE = a_half_width + b->w / 2.f;\r\n\t\t\t\t\tVec2 centerPosB = Vec2{ b->x, b->y } +Vec2{ b->w / 2.f , b->w / 2.f };\r\n\t\t\t\t\tVec2 distVec = centerPosA - centerPosB;\r\n\t\t\t\t\tfloat distance = distVec.x * distVec.x + distVec.y * distVec.y;\r\n\r\n\t\t\t\t\tif (distance < MIN_DISTANCE * MIN_DISTANCE)\r\n\t\t\t\t\t{\r\n#if 1\r\n\t\t\t\t\t\tdistVec.normalizeInPlace();\r\n\t\t\t\t\t\tdistVec *= a_half_width;\r\n\r\n\t\t\t\t\t\tconst Vec2 aResolution = distVec * 0.15f; /// 1.5f; // +=\r\n\t\t\t\t\t\ta->x += aResolution.x;\r\n\t\t\t\t\t\ta->y += aResolution.y;\r\n\r\n\t\t\t\t\t\tconst Vec2 bResolution = distVec * 0.15f; /// 1.5f;  // -=\r\n\t\t\t\t\t\tb->x -= bResolution.x;\r\n\t\t\t\t\t\tb->y -= bResolution.y;\r\n\r\n\t\t\t\t\t\tif ((array + j)->entityID == PLAYER_ID)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tgameState->infection = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if ((array + k)->entityID == PLAYER_ID)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tgameState->infection = true;\r\n\t\t\t\t\t\t}\r\n#else\r\n\t\t\t\t\t\tdistVec.normalizeInPlace();\r\n\t\t\t\t\t\tfloat magnitude;\r\n\t\t\t\t\t\tif (distance < MIN_DISTANCE / 2.f) // hard\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// magnitude = 2.f;\r\n\t\t\t\t\t\t\t// gameState->entities.COLLISION_TYPES[(array + j)->entityID] = collided_hard;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tCollisionPair pair{ magnitude, distVec };\r\n\t\t\t\t\t\tpair.direction.x = -pair.direction.x;\r\n\t\t\t\t\t\tpair.direction.y = -pair.direction.y;\r\n\t\t\t\t\t\t// da_push(gameState->entities.collisionPairs[(array + j)->entityID], pair);\r\n\t\t\t\t\t\t// da_push(gameState->entities.collisionPairs[(array + k)->entityID], pair);\r\n#endif\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\nfloat BACTERIA_SIZE = 20.f;\r\nvoid multiplybacteria(JamState* state, int id)\r\n{\r\n\t// addTrauma(&state->trauma, 0.2f);\r\n\t// vec2f position = Vec2ToVec4(&positionSize[id]);\r\n\tvec4 newPosition = positionSize[id];\r\n\tnewPosition.x += BACTERIA_SIZE / 2.f;\r\n\tnewPosition.y += RandomFloat(-20.f, 20.f);\r\n\tcreateEnt(state, &newPosition, Entity_Bacterio);\r\n}\r\n\r\n\r\nfloat lerp(float n, float min, float max)\r\n{\r\n\treturn (max - min) * n + min;\r\n}\r\n\r\nvec2f worldMaxXY()\r\n{\r\n\treturn { LEVEL_SIZE * tile_size, LEVEL_SIZE * tile_size };\r\n}\r\n\r\nvoid addTrauma(float* trauma, float amount)\r\n{\r\n\t*trauma += amount;\r\n\tif (*trauma > 1.f)\r\n\t\t*trauma = 1.f;\r\n}\r\n\r\nconstexpr float cameraShakeMaxAngle = 0.5f * PI;\r\nconstexpr float cameraMaxOffset = 120.f;\r\n\r\nvoid jam_update(EngineCore* core, JamState* jamState)\r\n{\r\n\tauto layer = &core->layers[2];\r\n\tauto ents = jamState->jamEntitys;\r\n\tint eCount = ents->count;\r\n\r\n\r\n\tswitch (jamState->scene)\r\n\t{\r\n\tcase Scene_Menu:\r\n\t\t// lol\r\n\t\tif (engine::Input::isKeyPressed(Keycode::SPACE))\r\n\t\t\tjamState->scene = Scene_play;\r\n\t\treturn;\r\n\t\tbreak;\r\n\tcase Scene_GameOver:\r\n\t\tif (engine::Input::isKeyPressed(Keycode::SPACE))\r\n\t\t{\r\n\t\t\tjamState->scene = Scene_play;\r\n\t\t\tjamState->scene = Scene_Menu;\r\n\r\n\t\t\tjamState->currentLevel = 1;\r\n\t\t\tchar levelName[256];\r\n\t\t\tsprintf(levelName, \"assets/map%i.txt\", jamState->currentLevel);\r\n\t\t\tdestroyViruses(jamState);\r\n\t\t\tloadLevel(jamState, level, levelName); // init viruses!\"!\r\n\t\t\tplacePlayerToStart(jamState);\r\n\r\n\t\t\tjamState->gameOver = false;\r\n\t\t\tjamState->infectionAmount = 0.f;\r\n\t\t}\r\n\t\treturn;\r\n\t\tbreak;\r\n\tcase Scene_play:\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tbreak;\r\n\t}\r\n\r\n\r\n\tif (jamState->gameOver)\r\n\t{\r\n\t\tif (engine::Input::isKeyPressed(Keycode::SPACE))\r\n\t\t{\r\n\t\t\tjamState->gameOver = false;\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\r\n\r\n\r\n\tif (engine::Input::isKeyDown(Keycode::Z))\r\n\t{\r\n\t\tents[0].Player.speed = 10.f;\r\n\t}\r\n\r\n\tif (engine::Input::isKeyPressed(Keycode::SPACE))\r\n\t{\r\n\t\t// testPrint();\r\n\t\t// addTrauma(&jamState->trauma, 0.2);\r\n\t}\r\n\r\n\tif (jamState->trauma > 0.f)\r\n\t{\r\n\t\tfloat t = jamState->trauma;\r\n\t\tjamState->shake = t * t * t;\r\n\t}\r\n\r\n\tjamState->trauma -= 1.f / 60.f * 0.3f;\r\n\r\n\tfloat cameraOffsetX = 0.f;\r\n\tfloat cameraOffsetY = 0.f;\r\n\r\n\tif (jamState->trauma < 0.f)\r\n\t{\r\n\t\tjamState->trauma = 0.f;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfloat p1 = stb_perlin_noise3(1, g_currentTime / 100.f, 1.f, 0, 0, 0);\r\n\t\tfloat p2 = stb_perlin_noise3(2323, g_currentTime / 100.f, 1.f, 0, 0, 0);\r\n\t\tfloat p3 = stb_perlin_noise3(100, g_currentTime / 100.f, 1.f, 0, 0, 0);\r\n\r\n\t\tcamera::setCameraRotaion(core, jamState->shake * cameraShakeMaxAngle * p1);\r\n\t\t// camera::setCameraRotaion(core, )\r\n\t\tfloat shake = jamState->shake;\r\n\t\tcameraOffsetX = cameraMaxOffset * shake * p2;\r\n\t\tcameraOffsetY = cameraMaxOffset * shake * p3;\r\n\t}\r\n\r\n\tif (jamState->infection)\r\n\t{\r\n\t\tjamState->infectionAmount += 1.f;\r\n\t\tjamState->infection = false;\r\n\t\taddTrauma(&jamState->trauma, 0.05f);\r\n\t}\r\n\r\n\tif (jamState->infectionAmount > MAX_INFECTION)\r\n\t{\r\n\t\tjamState->scene = Scene_GameOver;\r\n\t\tLOGI(\"game over\\n\");\r\n\r\n\t}\r\n\r\n\tfloat currentTime = core->currentTime;\r\n\tg_currentTime = currentTime;\r\n\r\n\tfor (int i = 0; i < eCount; ++i)\r\n\t{\r\n\t\tEntity_Enum type = ents[i].type;\r\n\t\tauto e = &ents[i];\r\n\r\n\t\tif (auto player = GET_ENTITY(e, Player))\r\n\t\t{\r\n\t\t\tvec2f movement{};\r\n\t\t\tif (engine::Input::isKeyDown(Keycode::W))\r\n\t\t\t{\r\n\t\t\t\tmovement.y += 1;\r\n\t\t\t}\r\n\t\t\telse if (engine::Input::isKeyDown(Keycode::S))\r\n\t\t\t{\r\n\t\t\t\tmovement.y -= 1;\r\n\t\t\t}\r\n\t\t\tif (engine::Input::isKeyDown(Keycode::D))\r\n\t\t\t{\r\n\t\t\t\tmovement.x = 1;\r\n\t\t\t}\r\n\t\t\telse if (engine::Input::isKeyDown(Keycode::A))\r\n\t\t\t{\r\n\t\t\t\tmovement.x = -1;\r\n\t\t\t}\r\n\t\t\tmovement.safeNormalizeInPlace();\r\n\t\t\tmovement *= player->speed;\r\n\r\n\t\t\tpositionSize[i].x += movement.x;\r\n\t\t\tpositionSize[i].y += movement.y;\r\n\r\n\t\t\tint x = int(positionSize[i].x / tile_size);\r\n\t\t\tint y = int(positionSize[i].y / tile_size);\r\n\r\n\t\t\tif (x == jamState->goalX && y == jamState->goalY)\r\n\t\t\t{\r\n\t\t\t\tjamState->nextLevel = true;\r\n\t\t\t\tLOGI(\"you win \\n\");\r\n\t\t\t}\r\n\r\n\t\t\tif (movement.x < 0.f)\r\n\t\t\t\tplayer->xDir = -1.f;\r\n\t\t\telse if (movement.x > 0.f)\r\n\t\t\t\tplayer->xDir = 1.f;\r\n\r\n\t\t}\r\n\t\telse if (auto bacteria = GET_ENTITY(e, Bacterio))\r\n\t\t{\r\n\t\t\tif (bacteria->multiplyTimer < currentTime)\r\n\t\t\t{\r\n\t\t\t\tmultiplybacteria(jamState, i);\r\n\t\t\t\tbacteria->multiplyTimer = currentTime + defaultMultiplyTimer;\r\n\r\n\t\t\t\t// bacteria->moveDirection\r\n\t\t\t}\r\n\r\n\t\t\tfloat randomR = RandomFloat(-1.f, 1.f);\r\n\t\t\trotateVec(&bacteria->moveDirection, randomR);\r\n\t\t\tpositionSize[i].x += bacteria->moveDirection.x * bacteriaSpeed;\r\n\t\t\tpositionSize[i].y += bacteria->moveDirection.y * bacteriaSpeed;\r\n\t\t}\r\n\t}\r\n\r\n\tsetupCollision(jamState);\r\n\tdoCollisions(jamState);\r\n\ttileCollision(ents);\r\n\r\n\t// camera lerping\r\n\t{\r\n\t\tvec2f playerPos = Vec2ToVec4(&positionSize[0]);\r\n\r\n#if 1\r\n\t\tfloat newX = ceil(lerp(0.80f, playerPos.x, core->cameraPosition->x));\r\n\t\tfloat newY = ceil(lerp(0.80f, playerPos.y, core->cameraPosition->y));\r\n#else\r\n\t\tfloat newX = ceil((playerPos.x - core->cameraPosition->x) * 0.05f);\r\n\t\tfloat newY = ceil((playerPos.y - core->cameraPosition->y) * 0.05f);\r\n\t\tfloat oldX = core->cameraPosition->x;\r\n\t\tfloat oldY = core->cameraPosition->y;\r\n#endif\r\n\r\n\t\tfloat halfScreenW = core->screenDimensions.x / 2.f;\r\n\t\tfloat halfScreenH = core->screenDimensions.y / 2.f;\r\n\r\n\t\tif (newX < halfScreenW)\r\n\t\t\tnewX = halfScreenW;\r\n\r\n\t\tif (newY < halfScreenH)\r\n\t\t\tnewY = halfScreenH;\r\n\r\n\t\tvec2f maxCameraPosition = worldMaxXY();\r\n\t\tfloat maxX = maxCameraPosition.x - halfScreenW;\r\n\t\tif (newX > maxX)\r\n\t\t\tnewX = maxX;\r\n\r\n\t\tfloat maxY = maxCameraPosition.y - halfScreenH;\r\n\t\tif (newY > maxY)\r\n\t\t\tnewY = maxY;\r\n\r\n\t\t// vec2f newCameraPos = { oldX + newX, oldY + newY };\r\n#if 0\r\n\t\tvec2f newCameraPos = { oldX + newX + cameraOffsetX, oldY + newY + cameraOffsetY };\r\n#else\r\n\t\tvec2f newCameraPos = { newX + cameraOffsetX, newY + cameraOffsetY };\r\n#endif\r\n\t\t// vec2f newCameraPos = { oldX + newX + cameraOffsetX, newY + cameraOffsetY };\r\n\t\t// vec2f newCameraPos = { oldX + newX + cameraOffsetX, newY + cameraOffsetY };\r\n\r\n#if 0\r\n\t\tcamera::setCameraPosition(core, newCameraPos);\r\n#else\r\n\t\tcamera::setCameraPosition(core, playerPos);\r\n#endif\r\n\t}\r\n\r\n\r\n\t// win condition\r\n\t{\r\n\t\tif (jamState->nextLevel)\r\n\t\t{\r\n\t\t\t++jamState->currentLevel;\r\n\t\t\tjamState->currentLevel = 5;\r\n\t\t\tif (jamState->currentLevel == MAX_LEVEL + 1)\r\n\t\t\t{\r\n\t\t\t\tjamState->gameOver = true;\r\n\t\t\t\tjamState->scene = Scene_GameOver;\r\n\t\t\t}\r\n\t\t\telse if (jamState->currentLevel <= MAX_LEVEL)\r\n\t\t\t{\r\n\t\t\t\tchar levelName[128];\r\n\t\t\t\t// stbsp_sprintf(levelName, \"assets/map%i.txt\", jamState->currentLevel);\r\n\t\t\t\tsprintf(levelName, \"assets/map%i.txt\", jamState->currentLevel);\r\n\t\t\t\tdestroyViruses(jamState);\r\n\t\t\t\tloadLevel(jamState, level, levelName); // init viruses!\"!\r\n\t\t\t\tplacePlayerToStart(jamState);\r\n\r\n\t\t\t\tjamState->infectionAmount = 0.f;\r\n\t\t\t}\r\n\t\t\tjamState->nextLevel = false;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic inline vec2f Vec2ToVec4(vec4* posSize)\r\n{\r\n\treturn { posSize->x, posSize->y };\r\n}\r\n\r\nstatic inline float clamp(float n, float lower, float upper) {\r\n\treturn std::max(lower, std::min(n, upper));\r\n}\r\n\r\ntemplate <typename T>\r\ninline T clamp2(T x, T min, T max)\r\n{\r\n\tif (x < min) x = min;\r\n\tif (x > max) x = max;\r\n\treturn x;\r\n}\r\n\r\nvoid jam_draw(EngineCore* core, JamState* jamState)\r\n{\r\n\tauto layer = &core->layers[1];\r\n\tauto ents = jamState->jamEntitys;\r\n\tint eCount = ents->count;\r\n\r\n\tauto* bacteriaTexture = engine::getTexture(core->resources, textures::Texture_Bacterio);\r\n\tint bacterTextureID = bacteriaTexture->ID;\r\n\tvec4 defaultUV = { 0.f, 0.f, 1.f, 1.f };\r\n\tvec4 defaultColor = { 1.f, 1.f, 1.f, 1.f };\r\n\r\n\tvec4 cams = camera::cameraRect(core);\r\n\t{\r\n\t\t// world weirdest parallax scrolling\r\n\r\n\t\tauto* bgTexture = engine::getTexture(core->resources, textures::Texture_Prei);\r\n\t\tvec4 pos{ cams.x - 400.f, cams.y - 400.f, core->screenDimensions.x + 400.f, core->screenDimensions.y + 400.f };\r\n\t\tvec2f xyMax = worldMaxXY();\r\n\t\tvec2f playerPosition = Vec2ToVec4(&positionSize[PLAYER_ID]);\r\n\t\tvec4 maxUV{ 0, 0, xyMax.x, xyMax.y };\r\n\r\n\r\n\t\tfloat screenRatio = core->screenDimensions.y / core->screenDimensions.x;\r\n\t\tvec4 bgUV{ (((xyMax.x / playerPosition.x) - 0.1f) / 100.f), (((xyMax.y / playerPosition.y) - 0.1f)) / 10.f, 0.1f, 0.1f };\r\n\r\n\r\n\t\tstatic vec4 lastBgUv2{ 0.f, 0.f, 0.15f, 0.15f };\r\n\t\tlastBgUv2.x = 0.4f; // *stb_perlin_noise3(123.f, g_currentTime / 100000000.f, 20.f, 0, 0, 0);\r\n\t\tlastBgUv2.y -= 0.00001f;\r\n\r\n\t\tif (lastBgUv2.y > 0.9f)\r\n\t\t\tlastBgUv2.y = 0.1f;\r\n\t\tif (lastBgUv2.y < 0.1f)\r\n\t\t\tlastBgUv2.y = 0.9f;\r\n\r\n\t\tlayer->draw(&pos, &lastBgUv2, &defaultColor, bgTexture->ID);\r\n\r\n\t\tstatic vec4 lastBgUv{ 0.f, 0.f, 0.15f, 0.15f };\r\n\t\tlastBgUv.x += 0.00001f; // *stb_perlin_noise3(123.f, g_currentTime / 100000000.f, 20.f, 0, 0, 0);\r\n\t\tlastBgUv.y = 0.4;\r\n\r\n\t\tif (lastBgUv.x > 0.9f)\r\n\t\t\tlastBgUv.x = 0.f;\r\n\t\tif (lastBgUv.y > 0.9f)\r\n\t\t\tlastBgUv.y = 0.f;\r\n\r\n\t\tif (lastBgUv.x < 0.f)\r\n\t\t\tlastBgUv.x = 0.1f;\r\n\t\tif (lastBgUv.y < 0.1f)\r\n\t\t\tlastBgUv.y = 1.f;\r\n\r\n\t\tlayer->draw(&pos, &lastBgUv, &defaultColor, bgTexture->ID);\r\n\r\n\r\n\t\tif (bgUV.x > 0.9f)\r\n\t\t{\r\n\t\t\tbgUV.x = 0.9f;\r\n\t\t\tbgUV.w = 0.1f;\r\n\t\t}\r\n\r\n\t\tif (bgUV.y > 0.9f)\r\n\t\t{\r\n\t\t\tbgUV.y = 0.9f;\r\n\t\t\tbgUV.h = 0.1f;\r\n\t\t}\r\n\r\n\t\tlayer->draw(&pos, &bgUV, &defaultColor, bgTexture->ID);\r\n\t\tbgUV.x -= 0.1f;\r\n\t\tbgUV.y -= 0.1f;\r\n\t\tbgUV.h = 0.2f;\r\n\t\tbgUV.w = 0.2f;\r\n\t\tlayer->draw(&pos, &bgUV, &defaultColor, bgTexture->ID);\r\n\r\n\t\t// bgUV.x += 0.05f;\r\n\t\t// bgUV.y += 0.05f;\r\n\t\t// bgUV.h = 0.15;\r\n\t\t// bgUV.w = 0.15;\r\n\r\n\r\n\t}\r\n\r\n\tstatic SpriteSheet sheet = getIdToUvArray(bacteriaTexture, 2, 2, 64, 64, 0, 0, 0);\r\n\r\n\tdrawMap(core, level, layer);\r\n\r\n\t{ // draw goal\r\n\t\tvec4 position{ jamState->goalX * tile_size, jamState->goalY * tile_size, tile_size, tile_size };\r\n\t\tint goalID = engine::getTexture(core->resources, textures::Texture_Goal)->ID;\r\n\t\tlayer->draw(&position, &defaultUV, &defaultColor, goalID);\r\n\t}\r\n\r\n\t{\r\n\t\tif (jamState->scene != Scene_Menu)\r\n\t\t{\r\n\r\n\t\t\tauto* barOver = engine::getTexture(core->resources, textures::Texture_InfectionBarOver);\r\n\t\t\tauto* barUnder = engine::getTexture(core->resources, textures::Texture_InfectionBarUnderr);\r\n\r\n\t\t\tauto* HudLayer = &core->layers[2];\r\n\t\t\tvec4 posSize{ cams.x, cams.y, 200.f, 20.f };\r\n\t\t\tHudLayer->draw(&posSize, &defaultUV, &defaultColor, barUnder->ID);\r\n\t\t\tposSize.w *= jamState->infectionAmount / MAX_INFECTION;\r\n\t\t\tHudLayer->draw(&posSize, &defaultUV, &defaultColor, barOver->ID);\r\n\r\n\t\t\t// layer->drawString(\"\", )\r\n\t\t}\r\n\t}\r\n\r\n\tfor (int i = 0; i < eCount; ++i)\r\n\t{\r\n\t\tEntity_Enum type = ents[i].type;\r\n\t\tauto e = &ents[i];\r\n\r\n\t\tif (auto player = GET_ENTITY(e, Player))\r\n\t\t{\r\n\t\t\tvec2f position = getPosition(ents, i);\r\n\r\n\t\t\t// layer->drawString(player->name, &position, 0xFFFFFFFF, 0);\r\n\r\n\t\t\tauto pos = &positionSize[i];\r\n\t\t\tvec4 rotatedPos = *pos;\r\n\t\t\tif (player->xDir < 0.f)\r\n\t\t\t{\r\n\t\t\t\trotatedPos.x += rotatedPos.w;\r\n\t\t\t\trotatedPos.w = -rotatedPos.w;\r\n\t\t\t}\r\n\r\n\t\t\tlayer->draw(&rotatedPos, &defaultUV, &defaultColor, engine::getTexture(core->resources, textures::Texture_Player)->ID);\r\n\t\t\t// position.x += 10.f; position.y += 10.f;\r\n\t\t\t// graphics::setCircle(core->lines, position, 10.f);\r\n\t\t}\r\n\t\telse if (auto bacterio = GET_ENTITY(e, Bacterio))\r\n\t\t{\r\n\t\t\tlayer->setTexture(bacterTextureID);\r\n\t\t\tvec4* position = &positionSize[i];\r\n\r\n\t\t\t// vec2f pos = Vec2ToVec4(position);\r\n\t\t\t// pos.x += 10.f; pos.y += 10.f;\r\n\t\t\t// graphics::setCircle(core->lines, pos, 10.f);\r\n\t\t\tvec4 p2 = *position;\r\n\t\t\tvec4 uv = { 0.f, 0.f, 0.5f, 0.5f }; //  &sheet.idToUvs[0];\r\n\t\t\tlayer->draw(&p2, &uv, &defaultColor);\r\n\t\t}\r\n\t}\r\n\r\n\tswitch (jamState->scene)\r\n\t{\r\n\tcase Scene_Menu:\r\n\t{\r\n\t\tvec4 wholeScreen = camera::cameraRect(core);\r\n\t\twholeScreen.w = core->screenDimensions.x;\r\n\t\twholeScreen.h = core->screenDimensions.y;\r\n\t\tlayer->draw(&wholeScreen, &defaultUV, &defaultColor, engine::getTexture(core->resources, textures::Texture_Menu)->ID);\r\n\t} break;\r\n\tcase Scene_GameOver:\r\n\t{\r\n\t\tvec2f *sc = &core->screenDimensions;\r\n\t\tvec2f halfScreen = { sc->x / 10.f, sc->y / 2.f };\r\n\r\n\t\thalfScreen.x += positionSize[PLAYER_ID].x - 160.f; \r\n\t\thalfScreen.y += positionSize[PLAYER_ID].y - 160.f; \r\n\r\n\t\tbool winner = true;\r\n\r\n\t\tif (jamState->infectionAmount >= MAX_INFECTION)\r\n\t\t\twinner = false;\r\n\r\n\t\tchar buffer[256];\r\n\t\tsprintf(buffer, \"YOU %s\", winner ? \"WIN\" : \"LOSE\");\r\n\r\n\t\tlayer->drawString(buffer, &halfScreen, TITLE_SCREEN_COLOR, 0);\r\n\t\thalfScreen.y -= 40.f;\r\n\t\tlayer->drawString(\"Press space to play again\", &halfScreen, TITLE_SCREEN_COLOR, 0);\r\n\t} break;\r\n\tdefault:\r\n\t\tbreak;\r\n\t}\r\n}\r\n#endif\r\n\r\n// Lore:\r\n// olet matkalla kotiin koulusta ja viikonloppu odottaa\r\n// mik voisi menn pieleen?\r\n// viirukset XD\r\n// mekaaniikka:\r\n//\t\tviirukset yrittvt kaata pelin XD\r\n","// -*- C++ -*-\n//===-------------------------- algorithm ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ALGORITHM\n#define _LIBCPP_ALGORITHM\n\n/*\n    algorithm synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    all_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    any_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    none_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Function>\n    Function\n    for_each(InputIterator first, InputIterator last, Function f);\n\ntemplate <class InputIterator, class T>\n    InputIterator\n    find(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    InputIterator\n    find_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate<class InputIterator, class Predicate>\n    InputIterator\n    find_if_not(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class T>\n    typename iterator_traits<InputIterator>::difference_type\n    count(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    typename iterator_traits<InputIterator>::difference_type\n    count_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2,\n             BinaryPredicate pred); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2,\n          BinaryPredicate pred); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2);\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, BinaryPredicate pred);\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2,\n                   BinaryPredicate pred);  // **C++14**\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator, class Size, class T>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last, Size count, const T& value);\n\ntemplate <class ForwardIterator, class Size, class T, class BinaryPredicate>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last,\n             Size count, const T& value, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate<class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    copy_if(InputIterator first, InputIterator last,\n            OutputIterator result, Predicate pred);\n\ntemplate<class InputIterator, class Size, class OutputIterator>\n    OutputIterator\n    copy_n(InputIterator first, Size n, OutputIterator result);\n\ntemplate <class BidirectionalIterator1, class BidirectionalIterator2>\n    BidirectionalIterator2\n    copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,\n                  BidirectionalIterator2 result);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator2\n    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    void\n    iter_swap(ForwardIterator1 a, ForwardIterator2 b);\n\ntemplate <class InputIterator, class OutputIterator, class UnaryOperation>\n    OutputIterator\n    transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation>\n    OutputIterator\n    transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,\n              OutputIterator result, BinaryOperation binary_op);\n\ntemplate <class ForwardIterator, class T>\n    void\n    replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value);\n\ntemplate <class ForwardIterator, class Predicate, class T>\n    void\n    replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    replace_copy(InputIterator first, InputIterator last, OutputIterator result,\n                 const T& old_value, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate, class T>\n    OutputIterator\n    replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T& new_value);\n\ntemplate <class ForwardIterator, class T>\n    void\n    fill(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class OutputIterator, class Size, class T>\n    OutputIterator\n    fill_n(OutputIterator first, Size n, const T& value);\n\ntemplate <class ForwardIterator, class Generator>\n    void\n    generate(ForwardIterator first, ForwardIterator last, Generator gen);\n\ntemplate <class OutputIterator, class Size, class Generator>\n    OutputIterator\n    generate_n(OutputIterator first, Size n, Generator gen);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    remove(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate <class InputIterator, class OutputIterator, class BinaryPredicate>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred);\n\ntemplate <class BidirectionalIterator>\n    void\n    reverse(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class OutputIterator>\n    OutputIterator\n    reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);\n\ntemplate <class ForwardIterator, class OutputIterator>\n    OutputIterator\n    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);\n\ntemplate <class RandomAccessIterator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last); // deprecated in C++14\n\ntemplate <class RandomAccessIterator, class RandomNumberGenerator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                   RandomNumberGenerator& rand);  // deprecated in C++14\n\ntemplate<class PopulationIterator, class SampleIterator,\n         class Distance, class UniformRandomBitGenerator>\n    SampleIterator sample(PopulationIterator first, PopulationIterator last,\n                          SampleIterator out, Distance n,\n                          UniformRandomBitGenerator&& g); // C++17\n\ntemplate<class RandomAccessIterator, class UniformRandomNumberGenerator>\n    void shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                 UniformRandomNumberGenerator&& g);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    is_partitioned(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator1,\n          class OutputIterator2, class Predicate>\n    pair<OutputIterator1, OutputIterator2>\n    partition_copy(InputIterator first, InputIterator last,\n                   OutputIterator1 out_true, OutputIterator2 out_false,\n                   Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    stable_partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate<class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class ForwardIterator>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class ForwardIterator>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);\n\ntemplate <class InputIterator, class RandomAccessIterator>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last);\n\ntemplate <class InputIterator, class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last);  // constexpr in C++14\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last, Compare comp);  // constexpr in C++14\n\ntemplate <class T>\n    const T&\n    min(const T& a, const T& b);  // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    min(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    min(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    min(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    constexpr const T& clamp( const T& v, const T& lo, const T& hi );               // C++17\n\ntemplate<class T, class Compare>\n    constexpr const T& clamp( const T& v, const T& lo, const T& hi, Compare comp ); // C++17\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last);  // constexpr in C++14\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last, Compare comp);  // constexpr in C++14\n\ntemplate <class T>\n    const T&\n    max(const T& a, const T& b); // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    max(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    max(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    max(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class ForwardIterator>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last);   // constexpr in C++14\n\ntemplate<class ForwardIterator, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);   // constexpr in C++14\n\ntemplate<class T>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    pair<T, T>\n    minmax(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<T, T>\n    minmax(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n                            InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <initializer_list>\n#include <type_traits>\n#include <cstring>\n#include <utility> // needed to provide swap_ranges.\n#include <memory>\n#include <iterator>\n#include <cstddef>\n\n#if defined(__IBMCPP__)\n#include \"support/ibm/support.h\"\n#endif\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n#include \"support/win32/support.h\"\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// I'd like to replace these with _VSTD::equal_to<void>, but can't because:\n//   * That only works with C++14 and later, and\n//   * We haven't included <functional> here.\ntemplate <class _T1, class _T2 = _T1>\nstruct __equal_to\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1, class _T2 = _T1>\nstruct __less\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _Predicate>\nclass __negate\n{\nprivate:\n    _Predicate __p_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __negate() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __negate(_Predicate __p) : __p_(__p) {}\n\n    template <class _T1>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x) {return !__p_(__x);}\n\n    template <class _T1, class _T2>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x, const _T2& __y) {return !__p_(__x, __y);}\n};\n\n#ifdef _LIBCPP_DEBUG\n\ntemplate <class _Compare>\nstruct __debug_less\n{\n    _Compare __comp_;\n    __debug_less(_Compare& __c) : __comp_(__c) {}\n\n    template <class _Tp, class _Up>\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        bool __r = __comp_(__x, __y);\n        if (__r)\n            __do_compare_assert(0, __y, __x);\n        return __r;\n    }\n\n    template <class _LHS, class _RHS>\n    inline _LIBCPP_INLINE_VISIBILITY\n    decltype((void)_VSTD::declval<_Compare&>()(\n        _VSTD::declval<_LHS const&>(), _VSTD::declval<_RHS const&>()))\n    __do_compare_assert(int, _LHS const& __l, _RHS const& __r) {\n        _LIBCPP_ASSERT(!__comp_(__l, __r),\n            \"Comparator does not induce a strict weak ordering\");\n    }\n\n    template <class _LHS, class _RHS>\n    inline _LIBCPP_INLINE_VISIBILITY\n    void __do_compare_assert(long, _LHS const&, _RHS const&) {}\n};\n\n#endif  // _LIBCPP_DEBUG\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__ctz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_ctz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__ctz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_ctzl(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__ctz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_ctzll(__x));\n}\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__clz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_clz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__clz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_clzl (__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__clz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_clzll(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned           __x) {return __builtin_popcount  (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned      long __x) {return __builtin_popcountl (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned long long __x) {return __builtin_popcountll(__x);}\n\n// all_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nall_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            return false;\n    return true;\n}\n\n// any_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nany_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return true;\n    return false;\n}\n\n// none_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnone_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// for_each\n\ntemplate <class _InputIterator, class _Function>\ninline _LIBCPP_INLINE_VISIBILITY\n_Function\nfor_each(_InputIterator __first, _InputIterator __last, _Function __f)\n{\n    for (; __first != __last; ++__first)\n        __f(*__first);\n    return __f;\n}\n\n// find\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            break;\n    return __first;\n}\n\n// find_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_if_not\n\ntemplate<class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_end\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n           forward_iterator_tag, forward_iterator_tag)\n{\n    // modeled after search algorithm\n    _ForwardIterator1 __r = __last1;  // __last1 is the \"default\" answer\n    if (__first2 == __last2)\n        return __r;\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __last1)         // if source exhausted return last correct answer\n                return __r;                  //    (or __last1 if never found)\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)\n            {                         // Pattern exhaused, record answer and search for another one\n                __r = __first1;\n                ++__first1;\n                break;\n            }\n            if (++__m1 == __last1)     // Source exhausted, return last answer\n                return __r;\n            if (!__pred(*__m1, *__m2))  // mismatch, restart with a new __first\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>\n_BidirectionalIterator1\n__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,\n           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,\n           bidirectional_iterator_tag, bidirectional_iterator_tag)\n{\n    // modeled after search algorithm (in reverse)\n    if (__first2 == __last2)\n        return __last1;  // Everything matches an empty sequence\n    _BidirectionalIterator1 __l1 = __last1;\n    _BidirectionalIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        // Find last element in sequence 1 that matchs *(__last2-1), with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __l1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        // *__l1 matches *__l2, now match elements before here\n        _BidirectionalIterator1 __m1 = __l1;\n        _BidirectionalIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)  // If pattern exhausted, __m1 is the answer (works for 1 element pattern)\n                return __m1;\n            if (__m1 == __first1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*--__m1, *--__m2))  // if there is a mismatch, restart with a new __l1\n            {\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _RandomAccessIterator1\n__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __last1;\n    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);  // End of pattern match can't go before here\n    _RandomAccessIterator1 __l1 = __last1;\n    _RandomAccessIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        while (true)\n        {\n            if (__s == __l1)\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        _RandomAccessIterator1 __m1 = __l1;\n        _RandomAccessIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)\n                return __m1;\n                                 // no need to check range on __m1 because __s guarantees we have enough source\n            if (!__pred(*--__m1, *--__m2))\n            {\n                break;\n            }\n        }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// find_first_of\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _ForwardIterator1\n__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1)\n        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n            if (__pred(*__first1, *__j))\n                return __first1;\n    return __last1;\n}\n\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// adjacent_find\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__first, *__i))\n                return __first;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::adjacent_find(__first, __last, __equal_to<__v>());\n}\n\n// count\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            ++__r;\n    return __r;\n}\n\n// count_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            ++__r;\n    return __r;\n}\n\n// mismatch\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2,\n         _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n#endif\n\n// equal\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,\n        input_iterator_tag, input_iterator_tag )\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return __first1 == __last1 && __first2 == __last2;\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n      random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::equal<_RandomAccessIterator1, _RandomAccessIterator2,\n                        typename add_lvalue_reference<_BinaryPredicate>::type>\n                       (__first1, __last1, __first2, __pred );\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred )\n{\n    return _VSTD::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n#endif\n\n// is_permutation\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _BinaryPredicate __pred)\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return true;\n__not_done:\n    // __first1 != __last1 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n    if (__l1 == _D1(1))\n        return false;\n    _ForwardIterator2 __last2 = _VSTD::next(__first2, __l1);\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\nbool\n__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                 _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n                 _BinaryPredicate __pred,\n                 forward_iterator_tag, forward_iterator_tag )\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return __first1 == __last1 && __first2 == __last2;\n__not_done:\n    // __first1 != __last1 && __first2 != __last2 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n\n    typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;\n    _D2 __l2 = _VSTD::distance(__first2, __last2);\n    if (__l1 != __l2)\n        return false;\n\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\nbool\n__is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,\n               _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2,\n               _BinaryPredicate __pred,\n               random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,\n                                 typename add_lvalue_reference<_BinaryPredicate>::type>\n                                (__first1, __last1, __first2, __pred );\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n               _BinaryPredicate __pred )\n{\n    return _VSTD::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__is_permutation(__first1, __last1, __first2, __last2,\n        __equal_to<__v1, __v2>(),\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n#endif\n\n// search\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\npair<_ForwardIterator1, _ForwardIterator1>\n__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n         forward_iterator_tag, forward_iterator_tag)\n{\n    if (__first2 == __last2)\n        return make_pair(__first1, __first1);  // Everything matches an empty sequence\n    while (true)\n    {\n        // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __last1)  // return __last1 if no element matches *__first2\n                return make_pair(__last1, __last1);\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)  // If pattern exhausted, __first1 is the answer (works for 1 element pattern)\n                return make_pair(__first1, __m1);\n            if (++__m1 == __last1)  // Otherwise if source exhaused, pattern not found\n                return make_pair(__last1, __last1);\n            if (!__pred(*__m1, *__m2))  // if there is a mismatch, restart with a new __first1\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_RandomAccessIterator1, _RandomAccessIterator1>\n__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n         _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    typedef typename iterator_traits<_RandomAccessIterator1>::difference_type _D1;\n    typedef typename iterator_traits<_RandomAccessIterator2>::difference_type _D2;\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    const _D2 __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return make_pair(__first1, __first1);\n    const _D1 __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return make_pair(__last1, __last1);\n    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);  // Start of pattern match can't go beyond here\n\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __s)\n                return make_pair(__last1, __last1);\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n\n        _RandomAccessIterator1 __m1 = __first1;\n        _RandomAccessIterator2 __m2 = __first2;\n         while (true)\n         {\n             if (++__m2 == __last2)\n                 return make_pair(__first1, __first1 + __len2);\n             ++__m1;          // no need to check range on __m1 because __s guarantees we have enough source\n             if (!__pred(*__m1, *__m2))\n             {\n                 ++__first1;\n                 break;\n             }\n         }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__search<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category())\n            .first;\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// search_n\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\n__search_n(_ForwardIterator __first, _ForwardIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first == __last)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _ForwardIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n            if (++__m == __last)  // Otherwise if source exhaused, pattern not found\n                return __last;\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>\n_RandomAccessIterator\n__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    _Size __len = static_cast<_Size>(__last - __first);\n    if (__len < __count)\n        return __last;\n    const _RandomAccessIterator __s = __last - (__count - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first >= __s)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _RandomAccessIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n             ++__m;          // no need to check range on __m because __s guarantees we have enough source\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last,\n         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)\n{\n    return _VSTD::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>\n           (__first, __last, __convert_to_integral(__count), __value_, __pred,\n           typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::search_n(__first, __last, __convert_to_integral(__count),\n                           __value_, __equal_to<__v, _Tp>());\n}\n\n// copy\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n_Iter\n__unwrap_iter(_Iter __i)\n{\n    return __i;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(move_iterator<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    __wrap_iter<_Tp*>\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = *__first;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_backward\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = *--__last;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n    {\n        __result -= __n;\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    }\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\ncopy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__copy_backward(__unwrap_iter(__first),\n                                  __unwrap_iter(__last),\n                                  __unwrap_iter(__result));\n}\n\n// copy_if\n\ntemplate<class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy_if(_InputIterator __first, _InputIterator __last,\n        _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// copy_n\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    if (__n > 0)\n    {\n        *__result = *__first;\n        ++__result;\n        for (--__n; __n > 0; --__n)\n        {\n            ++__first;\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    return _VSTD::copy(__first, __first + __n, __result);\n}\n\n// move\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = _VSTD::move(*__first);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmove(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// move_backward\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = _VSTD::move(*--__last);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n    {\n        __result -= __n;\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    }\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\nmove_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// iter_swap\n\n// moved to <type_traits> for better swap / noexcept support\n\n// transform\n\ntemplate <class _InputIterator, class _OutputIterator, class _UnaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = __op(*__first);\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,\n          _OutputIterator __result, _BinaryOperation __binary_op)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2, ++__result)\n        *__result = __binary_op(*__first1, *__first2);\n    return __result;\n}\n\n// replace\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __old_value)\n            *__first = __new_value;\n}\n\n// replace_if\n\ntemplate <class _ForwardIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            *__first = __new_value;\n}\n\n// replace_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n             const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        if (*__first == __old_value)\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// replace_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n                _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        if (__pred(*__first))\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// fill_n\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n    for (; __n > 0; ++__first, (void) --__n)\n        *__first = __value_;\n    return __first;\n}\n\ntemplate <class _Tp, class _Size, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&\n    !is_same<_Tp, bool>::value &&\n    is_integral<_Up>::value && sizeof(_Up) == 1,\n    _Tp*\n>::type\n__fill_n(_Tp* __first, _Size __n,_Up __value_)\n{\n    if (__n > 0)\n        _VSTD::memset(__first, (unsigned char)__value_, (size_t)(__n));\n    return __first + __n;\n}\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nfill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n   return _VSTD::__fill_n(__first, __convert_to_integral(__n), __value_);\n}\n\n// fill\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)\n{\n    for (; __first != __last; ++__first)\n        *__first = __value_;\n}\n\ntemplate <class _RandomAccessIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)\n{\n    _VSTD::fill_n(__first, __last - __first, __value_);\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nfill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    _VSTD::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// generate\n\ntemplate <class _ForwardIterator, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ngenerate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)\n{\n    for (; __first != __last; ++__first)\n        *__first = __gen();\n}\n\n// generate_n\n\ntemplate <class _OutputIterator, class _Size, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ngenerate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    for (; __n > 0; ++__first, (void) --__n)\n        *__first = __gen();\n    return __first;\n}\n\n// remove\n\ntemplate <class _ForwardIterator, class _Tp>\n_ForwardIterator\nremove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    __first = _VSTD::find(__first, __last, __value_);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!(*__i == __value_))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_if\n\ntemplate <class _ForwardIterator, class _Predicate>\n_ForwardIterator\nremove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    __first = _VSTD::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>\n                           (__first, __last, __pred);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!(*__first == __value_))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// remove_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// unique\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    __first = _VSTD::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>\n                                 (__first, __last, __pred);\n    if (__first != __last)\n    {\n        // ...  a  a  ?  ...\n        //      f     i\n        _ForwardIterator __i = __first;\n        for (++__i; ++__i != __last;)\n            if (!__pred(*__first, *__i))\n                *++__first = _VSTD::move(*__i);\n        ++__first;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::unique(__first, __last, __equal_to<__v>());\n}\n\n// unique_copy\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        typename iterator_traits<_InputIterator>::value_type __t(*__first);\n        *__result = __t;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(__t, *__first))\n            {\n                __t = *__first;\n                *__result = __t;\n                ++__result;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              forward_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        *__result = *__i;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(*__i, *__first))\n            {\n                *__result = *__first;\n                ++__result;\n                __i = __first;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>\n_ForwardIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, forward_iterator_tag)\n{\n    if (__first != __last)\n    {\n        *__result = *__first;\n        while (++__first != __last)\n            if (!__pred(*__result, *__first))\n                *++__result = *__first;\n        ++__result;\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)\n{\n    return _VSTD::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>\n                              (__first, __last, __result, __pred,\n                               typename iterator_traits<_InputIterator>::iterator_category(),\n                               typename iterator_traits<_OutputIterator>::iterator_category());\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type __v;\n    return _VSTD::unique_copy(__first, __last, __result, __equal_to<__v>());\n}\n\n// reverse\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)\n{\n    while (__first != __last)\n    {\n        if (__first == --__last)\n            break;\n        _VSTD::iter_swap(__first, __last);\n        ++__first;\n    }\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)\n{\n    if (__first != __last)\n        for (; __first < --__last; ++__first)\n            _VSTD::iter_swap(__first, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreverse(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    _VSTD::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());\n}\n\n// reverse_copy\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__result)\n        *__result = *--__last;\n    return __result;\n}\n\n// rotate\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_left(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    value_type __tmp = _VSTD::move(*__first);\n    _ForwardIterator __lm1 = _VSTD::move(_VSTD::next(__first), __last, __first);\n    *__lm1 = _VSTD::move(__tmp);\n    return __lm1;\n}\n\ntemplate <class _BidirectionalIterator>\n_BidirectionalIterator\n__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    _BidirectionalIterator __lm1 = _VSTD::prev(__last);\n    value_type __tmp = _VSTD::move(*__lm1);\n    _BidirectionalIterator __fp1 = _VSTD::move_backward(__first, __lm1, __last);\n    *__first = _VSTD::move(__tmp);\n    return __fp1;\n}\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    _ForwardIterator __i = __middle;\n    while (true)\n    {\n        swap(*__first, *__i);\n        ++__first;\n        if (++__i == __last)\n            break;\n        if (__first == __middle)\n            __middle = __i;\n    }\n    _ForwardIterator __r = __first;\n    if (__first != __middle)\n    {\n        __i = __middle;\n        while (true)\n        {\n            swap(*__first, *__i);\n            ++__first;\n            if (++__i == __last)\n            {\n                if (__first == __middle)\n                    break;\n                __i = __middle;\n            }\n            else if (__first == __middle)\n                __middle = __i;\n        }\n    }\n    return __r;\n}\n\ntemplate<typename _Integral>\ninline _LIBCPP_INLINE_VISIBILITY\n_Integral\n__algo_gcd(_Integral __x, _Integral __y)\n{\n    do\n    {\n        _Integral __t = __x % __y;\n        __x = __y;\n        __y = __t;\n    } while (__y);\n    return __x;\n}\n\ntemplate<typename _RandomAccessIterator>\n_RandomAccessIterator\n__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n\n    const difference_type __m1 = __middle - __first;\n    const difference_type __m2 = __last - __middle;\n    if (__m1 == __m2)\n    {\n        _VSTD::swap_ranges(__first, __middle, __middle);\n        return __middle;\n    }\n    const difference_type __g = _VSTD::__algo_gcd(__m1, __m2);\n    for (_RandomAccessIterator __p = __first + __g; __p != __first;)\n    {\n        value_type __t(_VSTD::move(*--__p));\n        _RandomAccessIterator __p1 = __p;\n        _RandomAccessIterator __p2 = __p1 + __m1;\n        do\n        {\n            *__p1 = _VSTD::move(*__p2);\n            __p1 = __p2;\n            const difference_type __d = __last - __p2;\n            if (__m1 < __d)\n                __p2 += __m1;\n            else\n                __p2 = __first + (__m1 - __d);\n        } while (__p2 != __p);\n        *__p1 = _VSTD::move(__t);\n    }\n    return __first + __m2;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\n__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,\n         _VSTD::forward_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_ForwardIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator\n__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n         _VSTD::bidirectional_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_BidirectionalIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\n__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n         _VSTD::random_access_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n        return _VSTD::__rotate_gcd(__first, __middle, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nrotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    if (__first == __middle)\n        return __last;\n    if (__middle == __last)\n        return __first;\n    return _VSTD::__rotate(__first, __middle, __last,\n                           typename _VSTD::iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// rotate_copy\n\ntemplate <class _ForwardIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nrotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __middle, _VSTD::copy(__middle, __last, __result));\n}\n\n// min_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__i, *__first))\n                __first = __i;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::min_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// min\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::min(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// max_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__first, *__i))\n                __first = __i;\n    }\n    return __first;\n}\n\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::max_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// max\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__a, __b) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::max(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_STD_VER > 14\n// clamp\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nconst _Tp&\nclamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi, _Compare __comp)\n{\n    _LIBCPP_ASSERT(!__comp(__hi, __lo), \"Bad bounds passed to std::clamp\");\n    return __comp(__v, __lo) ? __lo : __comp(__hi, __v) ? __hi : __v;\n\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nconst _Tp&\nclamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi)\n{\n    return _VSTD::clamp(__v, __lo, __hi, __less<_Tp>());\n}\n#endif\n\n// minmax_element\n\ntemplate <class _ForwardIterator, class _Compare>\n_LIBCPP_CONSTEXPR_AFTER_CXX11\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);\n  if (__first != __last)\n  {\n      if (++__first != __last)\n      {\n          if (__comp(*__first, *__result.first))\n              __result.first = __first;\n          else\n              __result.second = __first;\n          while (++__first != __last)\n          {\n              _ForwardIterator __i = __first;\n              if (++__first == __last)\n              {\n                  if (__comp(*__i, *__result.first))\n                      __result.first = __i;\n                  else if (!__comp(*__i, *__result.second))\n                      __result.second = __i;\n                  break;\n              }\n              else\n              {\n                  if (__comp(*__first, *__i))\n                  {\n                      if (__comp(*__first, *__result.first))\n                          __result.first = __first;\n                      if (!__comp(*__i, *__result.second))\n                          __result.second = __i;\n                  }\n                  else\n                  {\n                      if (__comp(*__i, *__result.first))\n                          __result.first = __i;\n                      if (!__comp(*__first, *__result.second))\n                          __result.second = __first;\n                  }\n              }\n          }\n      }\n  }\n  return __result;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::minmax_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// minmax\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :\n                              pair<const _Tp&, const _Tp&>(__a, __b);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::minmax(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    typedef typename initializer_list<_Tp>::const_iterator _Iter;\n    _Iter __first = __t.begin();\n    _Iter __last  = __t.end();\n    std::pair<_Tp, _Tp> __result(*__first, *__first);\n\n    ++__first;\n    if (__t.size() % 2 == 0)\n    {\n        if (__comp(*__first,  __result.first))\n            __result.first  = *__first;\n        else\n            __result.second = *__first;\n        ++__first;\n    }\n\n    while (__first != __last)\n    {\n        _Tp __prev = *__first++;\n        if (__comp(*__first, __prev)) {\n            if ( __comp(*__first, __result.first)) __result.first  = *__first;\n            if (!__comp(__prev, __result.second))  __result.second = __prev;\n            }\n        else {\n            if ( __comp(__prev, __result.first))    __result.first  = __prev;\n            if (!__comp(*__first, __result.second)) __result.second = *__first;\n            }\n\n        __first++;\n    }\n    return __result;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t)\n{\n    return _VSTD::minmax(__t, __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// random_shuffle\n\n// __independent_bits_engine\n\ntemplate <unsigned long long _Xp, size_t _Rp>\nstruct __log2_imp\n{\n    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp\n                                           : __log2_imp<_Xp, _Rp - 1>::value;\n};\n\ntemplate <unsigned long long _Xp>\nstruct __log2_imp<_Xp, 0>\n{\n    static const size_t value = 0;\n};\n\ntemplate <size_t _Rp>\nstruct __log2_imp<0, _Rp>\n{\n    static const size_t value = _Rp + 1;\n};\n\ntemplate <class _UI, _UI _Xp>\nstruct __log2\n{\n    static const size_t value = __log2_imp<_Xp,\n                                         sizeof(_UI) * __CHAR_BIT__ - 1>::value;\n};\n\ntemplate<class _Engine, class _UIntType>\nclass __independent_bits_engine\n{\npublic:\n    // types\n    typedef _UIntType result_type;\n\nprivate:\n    typedef typename _Engine::result_type _Engine_result_type;\n    typedef typename conditional\n        <\n            sizeof(_Engine_result_type) <= sizeof(result_type),\n                result_type,\n                _Engine_result_type\n        >::type _Working_result_type;\n\n    _Engine& __e_;\n    size_t __w_;\n    size_t __w0_;\n    size_t __n_;\n    size_t __n0_;\n    _Working_result_type __y0_;\n    _Working_result_type __y1_;\n    _Engine_result_type __mask0_;\n    _Engine_result_type __mask1_;\n\n#ifdef _LIBCPP_HAS_NO_CONSTEXPR\n    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min\n                                          + _Working_result_type(1);\n#else\n    static _LIBCPP_CONSTEXPR const _Working_result_type _Rp = _Engine::max() - _Engine::min()\n                                                      + _Working_result_type(1);\n#endif\n    static _LIBCPP_CONSTEXPR const size_t __m = __log2<_Working_result_type, _Rp>::value;\n    static _LIBCPP_CONSTEXPR const size_t _WDt = numeric_limits<_Working_result_type>::digits;\n    static _LIBCPP_CONSTEXPR const size_t _EDt = numeric_limits<_Engine_result_type>::digits;\n\npublic:\n    // constructors and seeding functions\n    __independent_bits_engine(_Engine& __e, size_t __w);\n\n    // generating functions\n    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}\n\nprivate:\n    result_type __eval(false_type);\n    result_type __eval(true_type);\n};\n\ntemplate<class _Engine, class _UIntType>\n__independent_bits_engine<_Engine, _UIntType>\n    ::__independent_bits_engine(_Engine& __e, size_t __w)\n        : __e_(__e),\n          __w_(__w)\n{\n    __n_ = __w_ / __m + (__w_ % __m != 0);\n    __w0_ = __w_ / __n_;\n    if (_Rp == 0)\n        __y0_ = _Rp;\n    else if (__w0_ < _WDt)\n        __y0_ = (_Rp >> __w0_) << __w0_;\n    else\n        __y0_ = 0;\n    if (_Rp - __y0_ > __y0_ / __n_)\n    {\n        ++__n_;\n        __w0_ = __w_ / __n_;\n        if (__w0_ < _WDt)\n            __y0_ = (_Rp >> __w0_) << __w0_;\n        else\n            __y0_ = 0;\n    }\n    __n0_ = __n_ - __w_ % __n_;\n    if (__w0_ < _WDt - 1)\n        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);\n    else\n        __y1_ = 0;\n    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :\n                          _Engine_result_type(0);\n    __mask1_ = __w0_ < _EDt - 1 ?\n                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :\n                               _Engine_result_type(~0);\n}\n\ntemplate<class _Engine, class _UIntType>\ninline\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)\n{\n    return static_cast<result_type>(__e_() & __mask0_);\n}\n\ntemplate<class _Engine, class _UIntType>\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)\n{\n    result_type _Sp = 0;\n    for (size_t __k = 0; __k < __n0_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y0_);\n        if (__w0_ < _WDt)\n            _Sp <<= __w0_;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask0_;\n    }\n    for (size_t __k = __n0_; __k < __n_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y1_);\n        if (__w0_ < _WDt - 1)\n            _Sp <<= __w0_ + 1;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask1_;\n    }\n    return _Sp;\n}\n\n// uniform_int_distribution\n\ntemplate<class _IntType = int>\nclass uniform_int_distribution\n{\npublic:\n    // types\n    typedef _IntType result_type;\n\n    class param_type\n    {\n        result_type __a_;\n        result_type __b_;\n    public:\n        typedef uniform_int_distribution distribution_type;\n\n        explicit param_type(result_type __a = 0,\n                            result_type __b = numeric_limits<result_type>::max())\n            : __a_(__a), __b_(__b) {}\n\n        result_type a() const {return __a_;}\n        result_type b() const {return __b_;}\n\n        friend bool operator==(const param_type& __x, const param_type& __y)\n            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}\n        friend bool operator!=(const param_type& __x, const param_type& __y)\n            {return !(__x == __y);}\n    };\n\nprivate:\n    param_type __p_;\n\npublic:\n    // constructors and reset functions\n    explicit uniform_int_distribution(result_type __a = 0,\n                                      result_type __b = numeric_limits<result_type>::max())\n        : __p_(param_type(__a, __b)) {}\n    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}\n    void reset() {}\n\n    // generating functions\n    template<class _URNG> result_type operator()(_URNG& __g)\n        {return (*this)(__g, __p_);}\n    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);\n\n    // property functions\n    result_type a() const {return __p_.a();}\n    result_type b() const {return __p_.b();}\n\n    param_type param() const {return __p_;}\n    void param(const param_type& __p) {__p_ = __p;}\n\n    result_type min() const {return a();}\n    result_type max() const {return b();}\n\n    friend bool operator==(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n        {return __x.__p_ == __y.__p_;}\n    friend bool operator!=(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n            {return !(__x == __y);}\n};\n\ntemplate<class _IntType>\ntemplate<class _URNG>\ntypename uniform_int_distribution<_IntType>::result_type\nuniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)\n{\n    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),\n                                            uint32_t, uint64_t>::type _UIntType;\n    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);\n    if (_Rp == 1)\n        return __p.a();\n    const size_t _Dt = numeric_limits<_UIntType>::digits;\n    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;\n    if (_Rp == 0)\n        return static_cast<result_type>(_Eng(__g, _Dt)());\n    size_t __w = _Dt - __clz(_Rp) - 1;\n    if ((_Rp & (std::numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)\n        ++__w;\n    _Eng __e(__g, __w);\n    _UIntType __u;\n    do\n    {\n        __u = __e();\n    } while (__u >= _Rp);\n    return static_cast<result_type>(__u + __p.a());\n}\n\nclass _LIBCPP_TYPE_VIS __rs_default;\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\nclass _LIBCPP_TYPE_VIS __rs_default\n{\n    static unsigned __c_;\n\n    __rs_default();\npublic:\n    typedef uint_fast32_t result_type;\n\n    static const result_type _Min = 0;\n    static const result_type _Max = 0xFFFFFFFF;\n\n    __rs_default(const __rs_default&);\n    ~__rs_default();\n\n    result_type operator()();\n\n    static _LIBCPP_CONSTEXPR result_type min() {return _Min;}\n    static _LIBCPP_CONSTEXPR result_type max() {return _Max;}\n\n    friend _LIBCPP_FUNC_VIS __rs_default __rs_get();\n};\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\ntemplate <class _RandomAccessIterator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        __rs_default __g = __rs_get();\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _RandomNumberGenerator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n               _RandomNumberGenerator&& __rand)\n#else\n               _RandomNumberGenerator& __rand)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        for (--__last; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __rand(__d);\n            swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\n_LIBCPP_INLINE_VISIBILITY\n_SampleIterator __sample(_PopulationIterator __first,\n                         _PopulationIterator __last, _SampleIterator __output,\n                         _Distance __n,\n                         _UniformRandomNumberGenerator & __g,\n                         input_iterator_tag) {\n\n  _Distance __k = 0;\n  for (; __first != __last && __k < __n; ++__first, (void)++__k)\n    __output[__k] = *__first;\n  _Distance __sz = __k;\n  for (; __first != __last; ++__first, (void)++__k) {\n    _Distance __r = _VSTD::uniform_int_distribution<_Distance>(0, __k)(__g);\n    if (__r < __sz)\n      __output[__r] = *__first;\n  }\n  return __output + _VSTD::min(__n, __k);\n}\n\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\n_LIBCPP_INLINE_VISIBILITY\n_SampleIterator __sample(_PopulationIterator __first,\n                         _PopulationIterator __last, _SampleIterator __output,\n                         _Distance __n,\n                         _UniformRandomNumberGenerator& __g,\n                         forward_iterator_tag) {\n  _Distance __unsampled_sz = _VSTD::distance(__first, __last);\n  for (__n = _VSTD::min(__n, __unsampled_sz); __n != 0; ++__first) {\n    _Distance __r =\n        _VSTD::uniform_int_distribution<_Distance>(0, --__unsampled_sz)(__g);\n    if (__r < __n) {\n      *__output++ = *__first;\n      --__n;\n    }\n  }\n  return __output;\n}\n\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\n_LIBCPP_INLINE_VISIBILITY\n_SampleIterator __sample(_PopulationIterator __first,\n                         _PopulationIterator __last, _SampleIterator __output,\n                         _Distance __n, _UniformRandomNumberGenerator& __g) {\n  typedef typename iterator_traits<_PopulationIterator>::iterator_category\n        _PopCategory;\n  typedef typename iterator_traits<_PopulationIterator>::difference_type\n        _Difference;\n  static_assert(__is_forward_iterator<_PopulationIterator>::value ||\n                __is_random_access_iterator<_SampleIterator>::value,\n                \"SampleIterator must meet the requirements of RandomAccessIterator\");\n  typedef typename common_type<_Distance, _Difference>::type _CommonType;\n  _LIBCPP_ASSERT(__n >= 0, \"N must be a positive number.\");\n  return _VSTD::__sample(\n      __first, __last, __output, _CommonType(__n),\n      __g, _PopCategory());\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\ninline _LIBCPP_INLINE_VISIBILITY\n_SampleIterator sample(_PopulationIterator __first,\n                       _PopulationIterator __last, _SampleIterator __output,\n                       _Distance __n, _UniformRandomNumberGenerator&& __g) {\n    return _VSTD::__sample(__first, __last, __output, __n, __g);\n}\n#endif // _LIBCPP_STD_VER > 14\n\ntemplate<class _RandomAccessIterator, class _UniformRandomNumberGenerator>\n    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                 _UniformRandomNumberGenerator&& __g)\n#else\n                 _UniformRandomNumberGenerator& __g)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _InputIterator, class _Predicate>\nbool\nis_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    if ( __first == __last )\n        return true;\n    ++__first;\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// partition\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)\n{\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    for (_ForwardIterator __p = __first; ++__p != __last;)\n    {\n        if (__pred(*__p))\n        {\n            swap(*__first, *__p);\n            ++__first;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n            bidirectional_iterator_tag)\n{\n    while (true)\n    {\n        while (true)\n        {\n            if (__first == __last)\n                return __first;\n            if (!__pred(*__first))\n                break;\n            ++__first;\n        }\n        do\n        {\n            if (__first == --__last)\n                return __first;\n        } while (!__pred(*__last));\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\npartition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return _VSTD::__partition<typename add_lvalue_reference<_Predicate>::type>\n                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// partition_copy\n\ntemplate <class _InputIterator, class _OutputIterator1,\n          class _OutputIterator2, class _Predicate>\npair<_OutputIterator1, _OutputIterator2>\npartition_copy(_InputIterator __first, _InputIterator __last,\n               _OutputIterator1 __out_true, _OutputIterator2 __out_false,\n               _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__out_true = *__first;\n            ++__out_true;\n        }\n        else\n        {\n            *__out_false = *__first;\n            ++__out_false;\n        }\n    }\n    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);\n}\n\n// partition_point\n\ntemplate<class _ForwardIterator, class _Predicate>\n_ForwardIterator\npartition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__pred(*__m))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\n// stable_partition\n\ntemplate <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, forward_iterator_tag __fit)\n{\n    // *__first is known to be false\n    // __len >= 1\n    if (__len == 1)\n        return __first;\n    if (__len == 2)\n    {\n        _ForwardIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            return __m;\n        }\n        return __first;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        __i = __first;\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 3\n    _ForwardIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m), *__first know to be false\n    // F?????????????????\n    // f       m         l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);\n    // TTTFFFFF??????????\n    // f  ff   m         l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    _ForwardIterator __m1 = __m;\n    _ForwardIterator __second_false = __last;\n    _Distance __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF??????\n    // f  ff   m  m1     l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf   l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\nstruct __return_temporary_buffer\n{\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) const {_VSTD::return_temporary_buffer(__p);}\n};\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   forward_iterator_tag)\n{\n    const unsigned __alloc_limit = 3;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // We now have a reduced range [__first, __last)\n    // *__first is known to be false\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, forward_iterator_tag());\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)\n{\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    if (__len == 2)\n    {\n        swap(*__first, *__last);\n        return __last;\n    }\n    if (__len == 3)\n    {\n        _BidirectionalIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            swap(*__m, *__last);\n            return __last;\n        }\n        swap(*__m, *__last);\n        swap(*__first, *__m);\n        return __m;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _BidirectionalIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // move *__last, known to be true\n        *__first = _VSTD::move(*__i);\n        __i = ++__first;\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 4\n    _BidirectionalIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m-1], except reduce __m-1 until *(__m-1) is true, *__first know to be false\n    // F????????????????T\n    // f       m        l\n    _BidirectionalIterator __m1 = __m;\n    _BidirectionalIterator __first_false = __first;\n    _Distance __len_half = __len2;\n    while (!__pred(*--__m1))\n    {\n        if (__m1 == __first)\n            goto __first_half_done;\n        --__len_half;\n    }\n    // F???TFFF?????????T\n    // f   m1  m        l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);\n__first_half_done:\n    // TTTFFFFF?????????T\n    // f  ff   m        l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    __m1 = __m;\n    _BidirectionalIterator __second_false = __last;\n    ++__second_false;\n    __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF?????T\n    // f  ff   m  m1    l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf  l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   bidirectional_iterator_tag)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    const difference_type __alloc_limit = 4;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // __first points to first false, everything prior to __first is already set.\n    // Either prove [__first, __last) is all false and return __first, or point __last to last true\n    do\n    {\n        if (__first == --__last)\n            return __first;\n    } while (!__pred(*__last));\n    // We now have a reduced range [__first, __last]\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    difference_type __len = _VSTD::distance(__first, __last) + 1;\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nstable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// is_sorted_until\n\ntemplate <class _ForwardIterator, class _Compare>\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__comp(*__i, *__first))\n                return __i;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// is_sorted\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return _VSTD::is_sorted_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// sort\n\n// stable, 2-3 compares, 0-2 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)\n{\n    unsigned __r = 0;\n    if (!__c(*__y, *__x))          // if x <= y\n    {\n        if (!__c(*__z, *__y))      // if y <= z\n            return __r;            // x <= y && y <= z\n                                   // x <= y && y > z\n        swap(*__y, *__z);          // x <= z && y < z\n        __r = 1;\n        if (__c(*__y, *__x))       // if x > y\n        {\n            swap(*__x, *__y);      // x < y && y <= z\n            __r = 2;\n        }\n        return __r;                // x <= y && y < z\n    }\n    if (__c(*__z, *__y))           // x > y, if y > z\n    {\n        swap(*__x, *__z);          // x < y && y < z\n        __r = 1;\n        return __r;\n    }\n    swap(*__x, *__y);              // x > y && y <= z\n    __r = 1;                       // x < y && x <= z\n    if (__c(*__z, *__y))           // if y > z\n    {\n        swap(*__y, *__z);          // x <= y && y < z\n        __r = 2;\n    }\n    return __r;\n}                                  // x <= y && y <= z\n\n// stable, 3-6 compares, 0-5 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _Compare __c)\n{\n    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);\n    if (__c(*__x4, *__x3))\n    {\n        swap(*__x3, *__x4);\n        ++__r;\n        if (__c(*__x3, *__x2))\n        {\n            swap(*__x2, *__x3);\n            ++__r;\n            if (__c(*__x2, *__x1))\n            {\n                swap(*__x1, *__x2);\n                ++__r;\n            }\n        }\n    }\n    return __r;\n}\n\n// stable, 4-10 compares, 0-9 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)\n{\n    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);\n    if (__c(*__x5, *__x4))\n    {\n        swap(*__x4, *__x5);\n        ++__r;\n        if (__c(*__x4, *__x3))\n        {\n            swap(*__x3, *__x4);\n            ++__r;\n            if (__c(*__x3, *__x2))\n            {\n                swap(*__x2, *__x3);\n                ++__r;\n                if (__c(*__x2, *__x1))\n                {\n                    swap(*__x1, *__x2);\n                    ++__r;\n                }\n            }\n        }\n    }\n    return __r;\n}\n\n// Assumes size > 0\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    _BirdirectionalIterator __lm1 = __last;\n    for (--__lm1; __first != __lm1; ++__first)\n    {\n        _BirdirectionalIterator __i = _VSTD::min_element<_BirdirectionalIterator,\n                                                        typename add_lvalue_reference<_Compare>::type>\n                                                       (__first, __last, __comp);\n        if (__i != __first)\n            swap(*__first, *__i);\n    }\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first != __last)\n    {\n        _BirdirectionalIterator __i = __first;\n        for (++__i; __i != __last; ++__i)\n        {\n            _BirdirectionalIterator __j = __i;\n            value_type __t(_VSTD::move(*__j));\n            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t,  *--__k); --__j)\n                *__j = _VSTD::move(*__k);\n            *__j = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n        }\n        __j = __i;\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nbool\n__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    switch (__last - __first)\n    {\n    case 0:\n    case 1:\n        return true;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return true;\n    case 3:\n        _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n        return true;\n    case 4:\n        _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n        return true;\n    case 5:\n        _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n        return true;\n    }\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    const unsigned __limit = 8;\n    unsigned __count = 0;\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n            if (++__count == __limit)\n                return ++__i == __last;\n        }\n        __j = __i;\n    }\n    return true;\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,\n                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first1 != __last1)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);\n        value_type* __last2 = __first2;\n        ::new(__last2) value_type(_VSTD::move(*__first1));\n        __d.__incr((value_type*)0);\n        for (++__last2; ++__first1 != __last1; ++__last2)\n        {\n            value_type* __j2 = __last2;\n            value_type* __i2 = __j2;\n            if (__comp(*__first1, *--__i2))\n            {\n                ::new(__j2) value_type(_VSTD::move(*__i2));\n                __d.__incr((value_type*)0);\n                for (--__j2; __i2 != __first2 && __comp(*__first1,  *--__i2); --__j2)\n                    *__j2 = _VSTD::move(*__i2);\n                *__j2 = _VSTD::move(*__first1);\n            }\n            else\n            {\n                ::new(__j2) value_type(_VSTD::move(*__first1));\n                __d.__incr((value_type*)0);\n            }\n        }\n        __h.release();\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&\n                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;\n    while (true)\n    {\n    __restart:\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n            return;\n        case 4:\n            _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n            return;\n        case 5:\n            _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n            return;\n        }\n        if (__len <= __limit)\n        {\n            _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > 5\n        _RandomAccessIterator __m = __first;\n        _RandomAccessIterator __lm1 = __last;\n        --__lm1;\n        unsigned __n_swaps;\n        {\n        difference_type __delta;\n        if (__len >= 1000)\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __delta /= 2;\n            __n_swaps = _VSTD::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);\n        }\n        else\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, __lm1, __comp);\n        }\n        }\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted, sort the secod part\n                    // _VSTD::__sort<_Compare>(__i, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        // It is known that *__i < *__m\n        ++__i;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            // known that __i <= __m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i > __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        // If we were given a perfect partition, see if insertion sort is quick...\n        if (__n_swaps == 0)\n        {\n            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);\n            if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))\n            {\n                if (__fs)\n                    return;\n                __last = __i;\n                continue;\n            }\n            else\n            {\n                if (__fs)\n                {\n                    __first = ++__i;\n                    continue;\n                }\n            }\n        }\n        // sort smaller range with recursive call and larger with tail recursion elimination\n        if (__i - __first < __last - __i)\n        {\n            _VSTD::__sort<_Compare>(__first, __i, __comp);\n            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            __first = ++__i;\n        }\n        else\n        {\n            _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            // _VSTD::__sort<_Compare>(__first, __i, __comp);\n            __last = __i;\n        }\n    }\n}\n\n// This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_Tp** __first, _Tp** __last)\n{\n    _VSTD::sort((size_t*)__first, (size_t*)__last, __less<size_t>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)\n{\n    _VSTD::sort(__first.base(), __last.base());\n}\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)\n{\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    _VSTD::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231)\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&))\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif  // _LIBCPP_MSVC\n\n// lower_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::lower_bound(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// upper_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(__value_, *__m))\n            __len = __l2;\n        else\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::upper_bound(__first, __last, __value_,\n                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// equal_range\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\npair<_ForwardIterator, _ForwardIterator>\n__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else if (__comp(__value_, *__m))\n        {\n            __last = __m;\n            __len = __l2;\n        }\n        else\n        {\n            _ForwardIterator __mp1 = __m;\n            return pair<_ForwardIterator, _ForwardIterator>\n                   (\n                      __lower_bound<_Compare>(__first, __m, __value_, __comp),\n                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)\n                   );\n        }\n    }\n    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::equal_range(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// binary_search\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);\n    return __first != __last && !__comp(__value_, *__first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::binary_search(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__merge(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());\n}\n\n// inplace_merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2,\n          class _OutputIterator>\nvoid __half_inplace_merge(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2,\n                          _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            _VSTD::move(__first1, __last1, __result);\n            return;\n        }\n\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    // __first2 through __last2 are already in the right spot.\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n    if (__len1 <= __len2)\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), (void) ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        __half_inplace_merge(__buff, __p, __middle, __last, __first, __comp);\n    }\n    else\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), (void) ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        typedef reverse_iterator<_BidirectionalIterator> _RBi;\n        typedef reverse_iterator<value_type*> _Rv;\n        __half_inplace_merge(_Rv(__p), _Rv(__buff),\n                             _RBi(__middle), _RBi(__first),\n                             _RBi(__last), __negate<_Compare>(__comp));\n    }\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    while (true)\n    {\n        // if __middle == __last, we're done\n        if (__len2 == 0)\n            return;\n        if (__len1 <= __buff_size || __len2 <= __buff_size)\n            return __buffered_inplace_merge<_Compare>\n                   (__first, __middle, __last, __comp, __len1, __len2, __buff);\n        // shrink [__first, __middle) as much as possible (with no moves), returning if it shrinks to 0\n        for (; true; ++__first, (void) --__len1)\n        {\n            if (__len1 == 0)\n                return;\n            if (__comp(*__middle, *__first))\n                break;\n        }\n        // __first < __middle < __last\n        // *__first > *__middle\n        // partition [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last) such that\n        //     all elements in:\n        //         [__first, __m1)  <= [__middle, __m2)\n        //         [__middle, __m2) <  [__m1, __middle)\n        //         [__m1, __middle) <= [__m2, __last)\n        //     and __m1 or __m2 is in the middle of its range\n        _BidirectionalIterator __m1;  // \"median\" of [__first, __middle)\n        _BidirectionalIterator __m2;  // \"median\" of [__middle, __last)\n        difference_type __len11;      // distance(__first, __m1)\n        difference_type __len21;      // distance(__middle, __m2)\n        // binary search smaller range\n        if (__len1 < __len2)\n        {   // __len >= 1, __len2 >= 2\n            __len21 = __len2 / 2;\n            __m2 = __middle;\n            _VSTD::advance(__m2, __len21);\n            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);\n            __len11 = _VSTD::distance(__first, __m1);\n        }\n        else\n        {\n            if (__len1 == 1)\n            {   // __len1 >= __len2 && __len2 > 0, therefore __len2 == 1\n                // It is known *__first > *__middle\n                swap(*__first, *__middle);\n                return;\n            }\n            // __len1 >= 2, __len2 >= 1\n            __len11 = __len1 / 2;\n            __m1 = __first;\n            _VSTD::advance(__m1, __len11);\n            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);\n            __len21 = _VSTD::distance(__middle, __m2);\n        }\n        difference_type __len12 = __len1 - __len11;  // distance(__m1, __middle)\n        difference_type __len22 = __len2 - __len21;  // distance(__m2, __last)\n        // [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last)\n        // swap middle two partitions\n        __middle = _VSTD::rotate(__m1, __middle, __m2);\n        // __len12 and __len21 now have swapped meanings\n        // merge smaller range with recurisve call and larger with tail recursion elimination\n        if (__len11 + __len21 < __len12 + __len22)\n        {\n            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n            __first = __middle;\n            __middle = __m2;\n            __len1 = __len12;\n            __len2 = __len22;\n        }\n        else\n        {\n            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n            __last = __middle;\n            __middle = __m1;\n            __len1 = __len11;\n            __len2 = __len21;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n              _Compare __comp)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    difference_type __len1 = _VSTD::distance(__first, __middle);\n    difference_type __len2 = _VSTD::distance(__middle, __last);\n    difference_type __buf_size = _VSTD::min(__len1, __len2);\n    pair<value_type*, ptrdiff_t> __buf = _VSTD::get_temporary_buffer<value_type>(__buf_size);\n    unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);\n\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __c, __len1, __len2,\n                                            __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,\n                                            __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)\n{\n    _VSTD::inplace_merge(__first, __middle, __last,\n                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// stable_sort\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nvoid\n__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h(__result, __d);\n    for (; true; ++__result)\n    {\n        if (__first1 == __last1)\n        {\n            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first2));\n            __h.release();\n            return;\n        }\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first1));\n            __h.release();\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            ::new (__result) value_type(_VSTD::move(*__first2));\n            __d.__incr((value_type*)0);\n            ++__first2;\n        }\n        else\n        {\n            ::new (__result) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first1;\n        }\n    }\n}\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\nvoid\n__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result)\n                *__result = _VSTD::move(*__first1);\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    for (; __first2 != __last2; ++__first2, ++__result)\n        *__result = _VSTD::move(*__first2);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,\n                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    switch (__len)\n    {\n    case 0:\n        return;\n    case 1:\n        ::new(__first2) value_type(_VSTD::move(*__first1));\n        return;\n    case 2:\n       __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);\n         if (__comp(*--__last1, *__first1))\n        {\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n        }\n        else\n        {\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n        }\n        __h2.release();\n        return;\n    }\n    if (__len <= 8)\n    {\n        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first1 + __l2;\n    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);\n    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);\n    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);\n}\n\ntemplate <class _Tp>\nstruct __stable_sort_switch\n{\n    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    switch (__len)\n    {\n    case 0:\n    case 1:\n        return;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return;\n    }\n    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __insertion_sort<_Compare>(__first, __last, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first + __l2;\n    if (__len <= __buff_size)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);\n        __d.__set(__l2, (value_type*)0);\n        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);\n        __d.__set(__len, (value_type*)0);\n        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);\n//         __merge<_Compare>(move_iterator<value_type*>(__buff),\n//                           move_iterator<value_type*>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __len),\n//                           __first, __comp);\n        return;\n    }\n    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);\n    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);\n    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __stable_sort<_Comp_ref>(__first, __last, __c, __len, __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap_until\n\ntemplate <class _RandomAccessIterator, class _Compare>\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    difference_type __p = 0;\n    difference_type __c = 1;\n    _RandomAccessIterator __pp = __first;\n    while (__c < __len)\n    {\n        _RandomAccessIterator __cp = __first + __c;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__c;\n        ++__cp;\n        if (__c == __len)\n            return __last;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__p;\n        ++__pp;\n        __c = 2 * __p + 1;\n    }\n    return __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    return _VSTD::is_heap_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// push_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n          typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (__len > 1)\n    {\n        __len = (__len - 2) / 2;\n        _RandomAccessIterator __ptr = __first + __len;\n        if (__comp(*__ptr, *--__last))\n        {\n            value_type __t(_VSTD::move(*__last));\n            do\n            {\n                *__last = _VSTD::move(*__ptr);\n                __last = __ptr;\n                if (__len == 0)\n                    break;\n                __len = (__len - 1) / 2;\n                __ptr = __first + __len;\n            } while (__comp(*__ptr, __t));\n            *__last = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sift_up<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// pop_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_down(_RandomAccessIterator __first, _RandomAccessIterator /*__last*/,\n            _Compare __comp,\n            typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n            _RandomAccessIterator __start)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    // left-child of __start is at 2 * __start + 1\n    // right-child of __start is at 2 * __start + 2\n    difference_type __child = __start - __first;\n\n    if (__len < 2 || (__len - 2) / 2 < __child)\n        return;\n\n    __child = 2 * __child + 1;\n    _RandomAccessIterator __child_i = __first + __child;\n\n    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n        // right-child exists and is greater than left-child\n        ++__child_i;\n        ++__child;\n    }\n\n    // check if we are in heap-order\n    if (__comp(*__child_i, *__start))\n        // we are, __start is larger than it's largest child\n        return;\n\n    value_type __top(_VSTD::move(*__start));\n    do\n    {\n        // we are not in heap-order, swap the parent with it's largest child\n        *__start = _VSTD::move(*__child_i);\n        __start = __child_i;\n\n        if ((__len - 2) / 2 < __child)\n            break;\n\n        // recompute the child based off of the updated parent\n        __child = 2 * __child + 1;\n        __child_i = __first + __child;\n\n        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n            // right-child exists and is greater than left-child\n            ++__child_i;\n            ++__child;\n        }\n\n        // check if we are in heap-order\n    } while (!__comp(*__child_i, __top));\n    *__start = _VSTD::move(__top);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n           typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    if (__len > 1)\n    {\n        swap(*__first, *--__last);\n        __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __pop_heap<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// make_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __n = __last - __first;\n    if (__n > 1)\n    {\n        // start from the first parent, there is no need to consider children\n        for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start)\n        {\n            __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __make_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __make_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// sort_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)\n        __pop_heap<_Compare>(__first, __last, __comp, __n);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n    __make_heap<_Compare>(__first, __middle, __comp);\n    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;\n    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__first))\n        {\n            swap(*__i, *__first);\n            __sift_down<_Compare>(__first, __middle, __comp, __len, __first);\n        }\n    }\n    __sort_heap<_Compare>(__first, __middle, __comp);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    _VSTD::partial_sort(__first, __middle, __last,\n                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort_copy\n\ntemplate <class _Compare, class _InputIterator, class _RandomAccessIterator>\n_RandomAccessIterator\n__partial_sort_copy(_InputIterator __first, _InputIterator __last,\n                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n    _RandomAccessIterator __r = __result_first;\n    if (__r != __result_last)\n    {\n        for (; __first != __last && __r != __result_last; (void) ++__first, ++__r)\n            *__r = *__first;\n        __make_heap<_Compare>(__result_first, __r, __comp);\n        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;\n        for (; __first != __last; ++__first)\n            if (__comp(*__first, *__result_first))\n            {\n                *__result_first = *__first;\n                __sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);\n            }\n        __sort_heap<_Compare>(__result_first, __r, __comp);\n    }\n    return __r;\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)\n{\n    return _VSTD::partial_sort_copy(__first, __last, __result_first, __result_last,\n                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// nth_element\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    const difference_type __limit = 7;\n    while (true)\n    {\n    __restart:\n        if (__nth == __last)\n            return;\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            {\n            _RandomAccessIterator __m = __first;\n            _VSTD::__sort3<_Compare>(__first, ++__m, --__last, __comp);\n            return;\n            }\n        }\n        if (__len <= __limit)\n        {\n            __selection_sort<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > __limit >= 3\n        _RandomAccessIterator __m = __first + __len/2;\n        _RandomAccessIterator __lm1 = __last;\n        unsigned __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, --__lm1, __comp);\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted,\n                    if (__nth < __i)\n                        return;\n                    // __nth_element the secod part\n                    // __nth_element<_Compare>(__i, __nth, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        ++__i;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i >= __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        if (__nth == __i)\n            return;\n        if (__n_swaps == 0)\n        {\n            // We were given a perfectly partitioned sequence.  Coincidence?\n            if (__nth < __i)\n            {\n                // Check for [__first, __i) already sorted\n                __j = __m = __first;\n                while (++__j != __i)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__first, __i) sorted\n                return;\n            }\n            else\n            {\n                // Check for [__i, __last) already sorted\n                __j = __m = __i;\n                while (++__j != __last)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__i, __last) sorted\n                return;\n            }\n        }\nnot_sorted:\n        // __nth_element on range containing __nth\n        if (__nth < __i)\n        {\n            // __nth_element<_Compare>(__first, __nth, __i, __comp);\n            __last = __i;\n        }\n        else\n        {\n            // __nth_element<_Compare>(__i+1, __nth, __last, __comp);\n            __first = ++__i;\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __nth_element<_Comp_ref>(__first, __nth, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)\n{\n    _VSTD::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// includes\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n           _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1)\n    {\n        if (__first1 == __last1 || __comp(*__first2, *__first1))\n            return false;\n        if (!__comp(*__first1, *__first2))\n            ++__first2;\n    }\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n         _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::includes(__first1, __last1, __first2, __last2,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_union\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_union(_InputIterator1 __first1, _InputIterator1 __last1,\n            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            if (!__comp(*__first1, *__first2))\n                ++__first2;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_union(__first1, __last1, __first2, __last2, __result,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_intersection\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1 && __first2 != __last2)\n    {\n        if (__comp(*__first1, *__first2))\n            ++__first1;\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n            {\n                *__result = *__first1;\n                ++__result;\n                ++__first1;\n            }\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_intersection(__first1, __last1, __first2, __last2, __result,\n                                  __less<typename iterator_traits<_InputIterator1>::value_type,\n                                         typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_difference(__first1, __last1, __first2, __last2, __result,\n                                __less<typename iterator_traits<_InputIterator1>::value_type,\n                                       typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_symmetric_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (__comp(*__first2, *__first1))\n            {\n                *__result = *__first2;\n                ++__result;\n            }\n            else\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,\n                                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// lexicographical_compare\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1, (void) ++__first2)\n    {\n        if (__first1 == __last1 || __comp(*__first1, *__first2))\n            return true;\n        if (__comp(*__first2, *__first1))\n            return false;\n    }\n    return false;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::lexicographical_compare(__first1, __last1, __first2, __last2,\n                                         __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// next_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*--__i, *__ip1))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*__i, *--__j))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __next_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __next_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::next_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// prev_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*__ip1, *--__i))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*--__j, *__i))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __prev_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __prev_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::prev_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ALGORITHM\n","#pragma once\r\n\r\n#include \"console.h\"\r\n#include <cmath> \r\n\r\n#include <platform.h>\r\n#include <EngineCore.h>\r\n#include <chrono>\r\n\r\n#include \"mapgrid.h\"\r\n#include \"Entity.cpp\"\r\n\r\n\r\n#define STB_SPRINTF_IMPLEMENTATION \r\n#include <3rdparty/stb_sprintf.h>\r\n\r\n#if !__EMSCRIPTEN__\r\n#include \"../Input.cpp\"\r\n#endif\r\n\r\n\r\n#include \"jam_game.h\"\r\n// struct String // haaveeni\r\n// {\r\n// \tchar* buffer;\r\n// };\r\n\r\n// osoittaa yhteen\r\n// Ptr -> variable, johon osoittaa, ja montako niita on laskuri!\r\n\r\n#define PushStruct(Arena, type) (type *)PushSize_(Arena, sizeof(type))\r\n#define PushArray(Arena, Count, type) (type *)PushSize_(Arena, (Count)*sizeof(type))\r\n#define PushArray2(Arena, Count, Size) PushSize_(Arena, (Count)*Size)\r\n\r\nvoid* PushSize_(memory_arena *Arena, memory_index Size)\r\n{\r\n\t// ASSERT((Arena->used + Size) <= Arena->size);\r\n\tvoid *result = Arena->base + Arena->used;\r\n\tArena->used += Size;\r\n\r\n\treturn result;\r\n}\r\n\r\nenum Block\r\n{\r\n\tBlock_Empty,\r\n\r\n\tBlock_Cyan,\r\n\r\n\tBlock_Orange,\r\n\tBlock_Blue,\r\n\r\n\tBlock_Yellow,\r\n\r\n\tBlock_Red,\r\n\tBlock_Green,\r\n\tBlock_Purple,\r\n\r\n\tBlock_max,\r\n};\r\n\r\n#define makeColor(r, g, b) { r / 255.0, g / 255.0, b / 255.0, 1.0 }\r\n\r\nvec4 BlockColors[Block_max] = {\r\n\t{ 1.0, 1.0, 1.0, 1.0 },\r\n\r\n\tmakeColor(0, 255, 208), // cyan\r\n\r\n\tmakeColor(255, 161, 0), // orange\r\n\tmakeColor(0, 97, 255),\r\n\tmakeColor(255, 255, 0), // yellow?\r\n\r\n\tmakeColor(6, 186, 0),\r\n\tmakeColor(255, 0, 0),\r\n\tmakeColor(193, 0, 148),\r\n};\r\n\r\nintrospect() struct ActiveBlocks\r\n{\r\n\tVec2 positions[4];\r\n\tvec4 Color;\r\n\tBlock block;\r\n};\r\n\r\n#define ptrSingle(type, name) type *name\r\n#define ptrDArray(type, name, variable) type *name\r\n#define ptrSArray(type, name, count) type *name\r\n\r\nintrospect() struct TetrisBoard\r\n{\r\n\tint w, h;\r\n\tfloat timeTick;\r\n\tint score;\r\n\tint level;\r\n// \tptrSArray(Block, blocks, \"300\");\r\n\tBlock blocks[300];\r\n\tActiveBlocks activeShape;\r\n\tActiveBlocks nextShape;\r\n\r\n\tint countOfKasvava;\r\n\tptrSingle(int, olenYksittainen);\r\n\tptrDArray(int, olenKasvava, countOfKasvava);\r\n\tptrSArray(int, olenStaattinen, \"10\");\r\n};\r\n\r\nstatic int frame = 0;\r\nstruct TickTimer {\r\n\tint nextTick, tickDelay;\r\n\r\n\tvoid init(int tickDelay)\r\n\t{\r\n\t\tthis->tickDelay = tickDelay;\r\n\t\tthis->nextTick = frame;\r\n\t}\r\n\r\n\tbool update()\r\n\t{\r\n\t\tif (frame >= nextTick)\r\n\t\t{\r\n\t\t\tnextTick = frame + tickDelay;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n};\r\n\r\nunion Entity\r\n{\r\n\tstruct {\r\n\t\tfloat padding[500];     // <- milloin luulet jaksavasi tehd noin ison pelin\r\n\t\tint padding2[500]; // 4 * 500 = 2000\r\n\t\tchar Name[256];\r\n\t};\r\n};\r\n\r\n// Entity entities[10000];\r\n\r\n\r\nintrospect() struct Stuff\r\n{\r\n\tfloat a;\r\n\tfloat b;\t\r\n\tint c;\r\n};\r\n\r\nintrospect() struct BigStuff\r\n{\r\n\tStuff stuff;\r\n\tint howCoolIsStuff;\r\n};\r\n\r\nintrospect() struct Application\r\n{\r\n\tBigStuff biggie;\r\n};\r\n\r\nintrospect() struct TetrisGameState\r\n{\r\n\tvec4 playerPos;\r\n\tTetrisBoard tetris;\r\n\tmemory_arena memory;\r\n\tTickTimer timers[4];\r\n};\r\n\r\n// simplify needed  -> input states\r\nintrospect() struct RtsController\r\n{\r\n\tvec2f onClickPosition;\r\n\tbool dragging;\r\n\r\n\tint selectedUnits[MAX_ENTITY_COUNT];\r\n\tint selectedUnitCount;\r\n\r\n\tvec2f rightClickPosition;\r\n\tbool draggingArrow;\r\n\r\n\r\n\tvec2i placementPosition;\r\n\tbool  placingBuilding;\r\n\tvec2i buildingSize;\r\n\tBuilding_type placementBuildingType;\r\n\tType selectionType;\r\n};\r\n\r\nintrospect() struct FloatingText\r\n{\r\n\tchar  buffer[32];\r\n\tvec2f position;\r\n\tvec2f acc;\r\n\tvec2f vel;\r\n};\r\n\r\nconstexpr int MAX_FLOATING_TEXT = 10;\r\n\r\nconstexpr float GRID_WIDTH = 48.f;\r\nconstexpr float GRID_HEIGHT = 48.f;\r\n\r\nconstexpr int GRIDS_X = 200;\r\nconstexpr int GRIDS_Y = 200;\r\nconstexpr int GRIDS_MAX = 216;\r\nconstexpr int GRID_ARRAY_SIZE = GRIDS_MAX * GRIDS_MAX;\r\n\r\nstruct collisionBody\r\n{\r\n\tvec4* body;\r\n\tint entityID;\r\n};\r\n\r\n// #define NORMAL 1\r\n#if NORMAL\r\nvec4** bodyhash[GRIDS_MAX * GRIDS_MAX]{};\r\n#else\r\ncollisionBody* bodyhash[GRIDS_MAX * GRIDS_MAX]{};\r\n#endif\r\n// insertoi molemmille\r\n// target on oma velocity\r\n\r\nstruct Formation\r\n{\r\n\tint  formationCount;\r\n\tint* formationEntityId;\r\n\r\n\tfloat formationRadius;\r\n\tvec2f formationUnitsCenterPosition;\r\n\tvec2f formationUnitsMoveToCenterPosition;\r\n};\r\n\r\nintrospect() struct RtsGameState\r\n{\r\n\tEntities entities;\r\n\r\n\tint player;\r\n\tRtsController rtsController;\r\n\tMap tilemap;\r\n\tFormation PlayerLastFormation;\r\n\r\n\tFloatingText floatingTexts[MAX_FLOATING_TEXT];\r\n\tint currentFloaters;\r\n\r\n#if _WIN32\r\n\tengine::Console console;  // TODO: @IMPORTANT move\r\n#endif\r\n\r\n\tmemory_arena memory;\r\n};\r\n\r\nEXPORT ON_PLAYBACK_START(startPlayback);\r\nEXPORT INIT_GAME(gameInit);\r\nEXPORT UPDATE_GAME(gameUpdate);\r\nEXPORT DRAW_GAME(gameDraw);\r\n\r\n#define T //extern \"C\"\r\n","// #include <Input.h>\r\n\r\nstruct Timer\r\n{\r\n\tfloat next, tickTime;\r\n\r\n\tbool update(float currentTime) {\r\n\t\tif (currentTime > next) {\r\n\t\t\tnext = tickTime + currentTime;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n};\r\n\r\nenum Shapes\r\n{\r\n\tShape_I,\r\n\tShape_L,\r\n\tShape_J,\r\n\tShape_O,\r\n\tShape_S,\r\n\tShape_Z,\r\n\tShape_T,\r\n\tShape_Max,\r\n};\r\n\r\n#define BLOCK_WIDTH  26.f\r\n#define BLOCK_HEIGHT 26.f\r\n#define START_X 5\r\n#define START_Y 20\r\n#define NEXT_SHAPE_X 14\r\n#define NEXT_SHAPE_Y 12\r\n\r\n// 10 * 40  -> \r\nstatic int getRandomShapeId()\r\n{\r\n\t// return rand() % Shape_Max;\r\n\treturn WELLRNG512() % Shape_Max;\r\n}\r\n\r\nstatic ActiveBlocks getNextShape(Shapes shape, int startX, int startY)\r\n{\r\n\tActiveBlocks next;\r\n\tnext.Color = BlockColors[0]; // <- get Color\r\n\tnext.block = (Block)(shape + 1);\r\n\r\n\tswitch (shape)\r\n\t{\r\n\tcase Shape_I:\r\n\t\tnext.positions[0] = { 0, 0 };\r\n\t\tnext.positions[1] = { 0, 1 };\r\n\t\tnext.positions[2] = { 0, 2 };\r\n\t\tnext.positions[3] = { 0, 3 };\r\n\t\tbreak;\r\n\tcase Shape_L:\r\n\t\tnext.positions[0] = { 0, 0 };\r\n\t\tnext.positions[1] = { 0, 2 };\r\n\t\tnext.positions[2] = { 0, 1 }; // pivot\r\n\t\tnext.positions[3] = { 1, 0 };\r\n\t\tbreak;\r\n\tcase Shape_J:\r\n\t\tnext.positions[0] = { 1, 2 };\r\n\t\tnext.positions[1] = { 1, 0 };\r\n\t\tnext.positions[2] = { 1, 1 }; // pivot\r\n\t\tnext.positions[3] = { 0, 0 };\r\n\t\tbreak;\r\n\tcase Shape_O:\r\n\t\tnext.positions[0] = { 1, 0 };\r\n\t\tnext.positions[1] = { 1, 1 };\r\n\t\tnext.positions[2] = { 0, 0 }; // pivot\r\n\t\tnext.positions[3] = { 0, 1 };\r\n\t\tbreak;\r\n\tcase Shape_Z:\r\n\t\tnext.positions[0] = { 0, 1 };\r\n\t\tnext.positions[1] = { 1, 1 };\r\n\t\tnext.positions[2] = { 1, 0 }; // pivot\r\n\t\tnext.positions[3] = { 2, 0 };\r\n\t\tbreak;\r\n\tcase Shape_S:\r\n\t\tnext.positions[0] = { 2, 1 };\r\n\t\tnext.positions[1] = { 1, 1 };\r\n\r\n\t\tnext.positions[2] = { 1, 0 }; // pivot\r\n\t\tnext.positions[3] = { 0, 0 };\r\n\t\tbreak;\r\n\tcase Shape_T:\r\n\t\tnext.positions[0] = { 1, 1 };\r\n\t\tnext.positions[1] = { 2, 0 };\r\n\t\tnext.positions[2] = { 1, 0 }; // pivot\r\n\t\tnext.positions[3] = { 0, 0 };\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tbreak;\r\n\t}\r\n\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tnext.positions[i].x += startX;\r\n\t\tnext.positions[i].y += startY;\r\n\t}\r\n\r\n\treturn next;\r\n}\r\n\r\nstatic void setShapePosition(ActiveBlocks* active, int x, int y)\r\n{\r\n\tint xOffset = x - (int)active->positions[0].x;\r\n\tint yOffset = y - (int)active->positions[0].y;\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tactive->positions[i].x += xOffset;  // active->positions[i].x * BLOCK_WIDTH;\r\n\t\tactive->positions[i].y += yOffset;  // active->positions[i].y * BLOCK_HEIGHT;\r\n\t}\r\n}\r\n\r\nstatic void nextShape(TetrisBoard* tetris)\r\n{\r\n\ttetris->activeShape = tetris->nextShape;\r\n\tsetShapePosition(&tetris->activeShape, START_X, START_Y);\r\n\ttetris->nextShape = getNextShape((Shapes)getRandomShapeId(), NEXT_SHAPE_X, NEXT_SHAPE_Y);\r\n}\r\n\r\nstatic void initBoard(TetrisBoard* tetris, memory_arena* arena)\r\n{\r\n\ttetris->w = 10;\r\n\ttetris->h = 30;\r\n\r\n\t// tetris->blocks = (Block*)PushArray(arena, tetris->w * tetris->h, int);\r\n\tmemset(tetris->blocks, -1, ArrayCount(tetris->blocks) * sizeof(Block));\r\n\ttetris->activeShape = getNextShape(Shape_I, tetris->w / 2, tetris->h - 1);\r\n\ttetris->nextShape = getNextShape((Shapes)getRandomShapeId(), NEXT_SHAPE_X, NEXT_SHAPE_Y);\r\n\t// tetris->nextShape = getNextShape((Shapes))\r\n\r\n\tfor (int i = 0; i < tetris->w * tetris->h; i++)\r\n\t{\r\n\t\ttetris->blocks[i] = Block_Empty;\r\n\t}\r\n\r\n\ttetris->blocks[0] = Block_Blue;\r\n\ttetris->blocks[1] = Block_Blue;\r\n\ttetris->blocks[2] = Block_Blue;\r\n}\r\n\r\nstatic void moveDown(TetrisBoard* tetris, int startY)\r\n{\r\n\tfor (int y = startY; y < tetris->h - 1; y++)\r\n\t{\r\n\t\tfor (int x = 0; x < tetris->w; x++)\r\n\t\t{\r\n\t\t\tint index = y * tetris->w + x;\r\n\t\t\tint upperBlockIndex = (y + 1) * tetris->w + x;\r\n\r\n\t\t\ttetris->blocks[index] = tetris->blocks[upperBlockIndex];\r\n\t\t}\r\n\t}\r\n\r\n\tfor (int i = (tetris->w - 1) * tetris->h; i < tetris->w * tetris->h; i++)\r\n\t{\r\n\t\ttetris->blocks[i] = Block_Empty;\r\n\t}\r\n}\r\n\r\nstatic int checkForTetris(TetrisBoard* tetris)\r\n{\r\n\tfor (int y = 0; y < tetris->h; y++)\r\n\t{\r\n\t\tbool filled = true;\r\n\t\tfor (int x = 0; x < tetris->w; x++)\r\n\t\t{\r\n\t\t\tint index = y * tetris->w + x;\r\n\r\n\t\t\tif (tetris->blocks[index] == Block_Empty)\r\n\t\t\t{\r\n\t\t\t\tfilled = false;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (filled)\r\n\t\t{\r\n\t\t\tLOGI(\"Tetris on line: %d\", y);\r\n\t\t\treturn y;\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n}\r\n\r\nstatic inline vec4 getBlockColor(int id)\r\n{\r\n\treturn BlockColors[id];\r\n}\r\n\r\nstatic void renderActiveShape(ActiveBlocks* active, Layer* renderData)\r\n{\r\n\tvec4 uv = { 0.f, 0.f, 1.f, 1.f };\r\n\tvec4 color = getBlockColor(active->block);\r\n\tvec4 posSize{ 0.f, 0.f, BLOCK_WIDTH, BLOCK_HEIGHT };\r\n\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tposSize.x = active->positions[i].x * BLOCK_WIDTH;\r\n\t\tposSize.y = active->positions[i].y * BLOCK_HEIGHT;\r\n\t\trenderData->draw(&posSize, &uv, &color);\r\n\t}\r\n}\r\n\r\nstatic void renderBoard(TetrisBoard* tetris, Layer* layer)\r\n{\r\n\tvec4 uv = { 0.f, 0.f, 1.f, 1.f };\r\n\tfor (int i = 0; i < tetris->h; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < tetris->w; j++)\r\n\t\t{\r\n\t\t\tint index = i * tetris->w + j;\r\n\t\t\tint block = tetris->blocks[index];\r\n\r\n\t\t\tif (block > 0)\r\n\t\t\t{\r\n\t\t\t\tvec4 color = getBlockColor(block);\r\n\t\t\t\tvec4 pos = { j * BLOCK_WIDTH, i * BLOCK_HEIGHT, BLOCK_WIDTH, BLOCK_HEIGHT };\r\n\t\t\t\tlayer->draw(&pos, &uv, &color);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// true jos tiili uudessa sijainnissa\r\nstatic bool checkPositions(TetrisBoard* tetris, ActiveBlocks* shape, Vec2 offset)\r\n{\r\n\tbool result = false;\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tint newPosX = (int)(shape->positions[i].x + offset.x);\r\n\t\tint newPosY = (int)(shape->positions[i].y + offset.y);\r\n\r\n\t\tint index = newPosY * tetris->w + newPosX;\r\n\r\n\t\tif (newPosY < 0)\r\n\t\t{\r\n\t\t\tresult = true;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif (newPosX < 0 || newPosX >= tetris->w)\r\n\t\t{\r\n\t\t\tresult = true;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif (index < tetris->w * tetris->h)\r\n\t\t{\r\n\t\t\tint block = tetris->blocks[index];\r\n\t\t\tif (block != 0)\r\n\t\t\t{\r\n\t\t\t\tresult = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nstatic void move(ActiveBlocks* activeShape, Vec2* move)\r\n{\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tactiveShape->positions[i].x += move->x;\r\n\t\tactiveShape->positions[i].y += move->y;\r\n\t}\r\n}\r\n\r\nstatic void moveActiveShape(TetrisBoard* tetris, int directionX, int directionY)\r\n{\r\n\tauto* shape = &tetris->activeShape;\r\n\tVec2 moveDir{ (float)directionX, (float)directionY };\r\n\tbool blocked = checkPositions(tetris, &tetris->activeShape, moveDir);\r\n\r\n\tif (!blocked)\r\n\t{\r\n\t\tmove(shape, &moveDir);\r\n\t}\r\n}\r\n\r\nstatic void rotateShape(TetrisBoard* tetris, ActiveBlocks* activeShape)\r\n{\r\n\tActiveBlocks newPosition = *activeShape;\r\n\r\n\tauto* shape = &tetris->activeShape;\r\n\tint xPivot = (int)shape->positions[2].x;\r\n\tint yPivot = (int)shape->positions[2].y;\r\n\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tint xCenter = (int)shape->positions[i].x;\r\n\t\tint yCenter = (int)shape->positions[i].y;\r\n\r\n\t\tint newXCenter = xPivot + yPivot - yCenter;\r\n\t\tint newYCenter = yPivot - xPivot + xCenter;\r\n\r\n\t\tnewPosition.positions[i].x = (float)newXCenter;\r\n\t\tnewPosition.positions[i].y = (float)newYCenter;\r\n\t}\r\n\r\n\t// laita uusi activeblocks chekkaamaan collisionit\r\n\tVec2 noOffset{};\r\n\tbool blocked = checkPositions(tetris, &newPosition, noOffset);\r\n\tif (!blocked)\r\n\t{\r\n\t\t*activeShape = newPosition;\r\n\t}\r\n}\r\n\r\n// 40 (n + 1) 100 * (n+1) 300 * (n+1) 1200 * (n + 1)\r\nstatic void addScore(TetrisBoard* tetris, int combo)\r\n{\r\n\tint baseCoeffs[4]{ 40, 100, 300, 1200 };\r\n\tASSERT(combo < 4 && combo >= 0);\r\n\ttetris->score += baseCoeffs[combo] * (tetris->level + 1);\r\n}\r\n\r\nstatic void updateBoard(TetrisBoard* tetris, TickTimer* timer)\r\n{\r\n\t// float tickTime = getCurrentTime();\r\n\t// if next\r\n\t// setup + update()\r\n\t//\tstatic float timeUntil = 500.f;\r\n\t//\tstatic float nextTick = getCurrentTime() + timeUntil;\r\n\tbool stop = false;\r\n\r\n\t// static Timer timer{ getCurrentTime() + 500.f, 500.f };\r\n\r\n\t//if (getCurrentTime() > nextTick)\r\n\tif (timer->update())\r\n\t{\r\n\t\t// nextTick = getCurrentTime() + timeUntil;\r\n\r\n\t\tLOGI(\"TICK\\n\");\r\n\t\tstop = checkPositions(tetris, &tetris->activeShape, Vec2{ 0, -1 });\r\n\r\n\t\tif (!stop)\r\n\t\t{\r\n\t\t\tVec2 mov{ 0, -1 };\r\n\t\t\tmove(&tetris->activeShape, &mov);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < 4; i++)\r\n\t\t\t{\r\n\t\t\t\tint x = (int)tetris->activeShape.positions[i].x;\r\n\t\t\t\tint y = (int)tetris->activeShape.positions[i].y;\r\n\r\n\t\t\t\tint index = y * tetris->w + x;\r\n\t\t\t\ttetris->blocks[index] = tetris->activeShape.block;\r\n\t\t\t}\r\n\r\n\t\t\t// tetris->activeShape = getNextShape((Shapes)getRandomShapeId(), START_X, START_Y);\r\n\t\t\tnextShape(tetris);\r\n\r\n\t\t\tint comboCount = 0;\r\n\t\t\tfor (int i = 0; i < 5; i++)\r\n\t\t\t{\r\n\t\t\t\tint y = checkForTetris(tetris);\r\n\t\t\t\tif (y != -1)\r\n\t\t\t\t{\r\n\t\t\t\t\tmoveDown(tetris, y);\r\n\t\t\t\t\t++comboCount;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\taddScore(tetris, comboCount);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid updateTetris(EngineCore* core, TetrisGameState* gameState)\r\n{\r\n\tusing namespace engine;\r\n\r\n\tif (Input::isKeyDown(Keycode::D))\r\n\t{\r\n\t\tgameState->playerPos.x += 0.5f;\r\n\t}\r\n\telse if (Input::isKeyDown(Keycode::A))\r\n\t{\r\n\t\tgameState->playerPos.x -= 0.5f;\r\n\t}\r\n\t// static Timer moveRightLeftTimer{ getCurrentTime() + 40.f, 40.f };\r\n\tif (Input::isKeyPressed(Keycode::A))\r\n\t{\r\n\t\t// moveRightLeftTimer.next = getCurrentTime() + 40.f;\r\n\t\tgameState->timers[0].nextTick = frame + 2;\r\n\t\tmoveActiveShape(&gameState->tetris, -1, 0);\r\n\t}\r\n\telse if (Input::isKeyDown(Keycode::A))\r\n\t{\r\n\t\t// move left\r\n\t\t// if (moveRightLeftTimer.update(getCurrentTime()))\r\n\t\tif (gameState->timers[0].update())\r\n\t\t\tmoveActiveShape(&gameState->tetris, -1, 0);\r\n\t}\r\n\r\n\tif (Input::isKeyPressed(Keycode::D))\r\n\t{\r\n\t\t// moveRightLeftTimer.next = getCurrentTime() + 40.f;\r\n\t\tgameState->timers[1].nextTick = frame + 2;\r\n\t\tmoveActiveShape(&gameState->tetris, 1, 0);\r\n\t}\r\n\telse if (Input::isKeyDown(Keycode::D))\r\n\t{\r\n\t\t// move right\r\n\t//\tif (moveRightLeftTimer.update(getCurrentTime()))\r\n\t\tif (gameState->timers[1].update())\r\n\t\t\tmoveActiveShape(&gameState->tetris, 1, 0);\r\n\t}\r\n\r\n\tif (Input::isKeyDown(Keycode::S))\r\n\t{\r\n\t\t// static Timer moveDownTimer{ getCurrentTime() + 40.f, 40.f };\r\n\t\t// if (moveDownTimer.update(getCurrentTime()))\r\n\t\tif (gameState->timers[2].update())\r\n\t\t\tmoveActiveShape(&gameState->tetris, 0, -1);\r\n\r\n\t\t// LOGI(\"FRAME: %i\", core->currentFrame);\r\n\t\t// log(core->log, \"%s\", \"S DOWN\");\r\n\r\n\t\tLOG(\"%s\", \"s down\");\r\n\t}\r\n\r\n\tif (Input::isKeyPressed(Keycode::SPACE))\r\n\t{\r\n\t\trotateShape(&gameState->tetris, &gameState->tetris.activeShape);\r\n\r\n\t\t// log(core->log, \"%s\", \"spacebar\");\r\n\r\n\t\t// log(g_log, \"%s\", \"space\");\r\n\t\tLOG(\"%s\", \"spacebar\");\r\n\t}\r\n\r\n\tupdateBoard(&gameState->tetris, &gameState->timers[3]);\r\n}\r\n\r\nvoid drawTetris(EngineCore* core, TetrisGameState* gameState)\r\n{\r\n\tauto layer = &core->layers[0]; \r\n\trenderActiveShape(&gameState->tetris.activeShape, layer);\r\n\trenderActiveShape(&gameState->tetris.nextShape, layer);\r\n\trenderBoard(&gameState->tetris, layer);\r\n\r\n\tTetrisBoard* tetris = &gameState->tetris;\r\n\tchar buffer[256];\r\n\r\n\tstbsp_sprintf(buffer, \"Score: %i\", tetris);\r\n\tVec2 scorePosition{ 300, 420 };\r\n\tlayer->drawString(buffer, &scorePosition, 0xFFFFFFFF, 0);\r\n\r\n\tstbsp_sprintf(buffer, \"Level: %i\", tetris->level);\r\n\tVec2 levelPosition{ 300, 380 };\r\n\tlayer->drawString(buffer, &levelPosition, 0xFFFFFFFF, 0);\r\n}\r\n","\r\n#include \"Animation.h\"\r\n\r\n#ifndef ENTITY_H\r\n#define ENTITY_H\r\n\r\n\r\n#ifdef __EMSCRIPTEN__\r\n\r\nconstexpr int MAX_ENTITY_COUNT = 25000;\r\n#else\r\nconstexpr int MAX_ENTITY_COUNT = 1000 * 100;\r\n#endif\r\nconstexpr float UNIT_DEFAULT_SPEED = 1.5f;\r\n\r\nenum collision_type\r\n{\r\n\tcollision_soft,\r\n\tcollision_hard,\r\n\tcollision_attraction,\r\n};\r\n\r\nenum collided_type\r\n{\r\n\tcollided_soft,\r\n\tcollided_hard,\r\n\tcollided_hard_soft,\r\n};\r\n\r\nstruct collision\r\n{\r\n\tcollision_type type;\r\n\tvec4* objectPosition;\r\n};\r\n\r\nstruct CollisionPair\r\n{\r\n\tfloat magnitude;\r\n\tvec2f direction;\r\n};\r\n\r\nenum State\r\n{\r\n\tState_Move,\r\n\tState_Attack_move,\r\n\tState_Attack,\r\n\r\n\tState_Max,\r\n\t// State_Ignore, // etc...\r\n};\r\n\r\nconst char* StateToStr[State_Max] =\r\n{\r\n\t\"Moving\",\r\n\t\"Attack move\",\r\n\t\"Attack\"\r\n};\r\n\r\nenum Side\r\n{\r\n\tSide_Player,\r\n\tSide_0,\r\n\tSide_Max,\r\n};\r\n\r\nconst char* SideToStr[Side_Max] = {\r\n\t\"Player\",\r\n\t\"Enemy\",\r\n};\r\n\r\nenum AttackType // bitflag maybe\r\n{\r\n\tAttackType_Melee,\r\n\tAttackType_Range,\r\n\tAttackType_Max,\r\n};\r\n\r\nconst char* AttackTypeToStr[AttackType_Max] = \r\n{\r\n\t\"Melee\", \r\n\t\"Range\",\r\n};\r\n\r\nstruct EntityHandle\r\n{\r\n\tint id;\r\n\tint _index;\r\n\tint refCount;\r\n};\r\n\r\nstruct EntityHandles\r\n{\r\n\tint currentCount;\r\n\tint firstFreeIndex;\r\n\tEntityHandle handles[MAX_ENTITY_COUNT];\r\n} entityHandles{};\r\n\r\nenum Type\r\n{\r\n\tType_unit,\r\n\tType_building,\r\n};\r\n\r\nenum class Unit_type\r\n{\r\n\tPeasant,\r\n\tKnight,\r\n\tPaladin,\r\n\tCrusader,\r\n\tArhcer,\r\n\r\n\tBaneling,\r\n\tMarine,\r\n\tMedivac,\r\n\tHighTemplar,\r\n\r\n\tMax,\r\n};\r\n\r\nenum class Building_type     // jne jne...\r\n{\r\n\tnoBuilding,\r\n\tBallista,\r\n\tShockTower,\r\n\r\n\tWoodcutter,\r\n\tDock, \r\n\tBarrack,\r\n\tArcheryRange,\r\n\r\n\tMax,\r\n};\r\n\r\n\r\n// Unit_type ->  fun\r\n// ^^ jos tarvitsee erikoista laita eroikoinen fun\r\n// Typella enumiin -> union\r\n// molemmat\r\n// enum \r\n\r\n\r\n\r\n\r\n// resource building    -> produce resources\r\n// static defence walls -> just blocking, health, maybe mountable\r\n\r\n// defence buildings    -> shoots          / pretty much same things as units\r\n\r\n// different kinds of units:\r\n// heroes \r\n// infantry\r\n// ranged\r\n// fast mounted\r\n\r\n\r\n//\tType type;\r\n//  union\r\n//  {\r\n//\t\tfloat damage;\r\n//  } building_trap;\r\n//\t\t\r\n//  union\r\n//\t{\r\n//\t\t\r\n//\t} unit;\r\n\r\n\r\n// \r\n// animaation tyyppi\r\n// animaation aika\r\n// keyFrame <- kappa\r\n// \r\n\r\n\r\n\r\n\r\n\r\n\r\nstruct Entities\r\n{\r\n\tint current_count = 0;\r\n\r\n\tvec4 positions[MAX_ENTITY_COUNT];\r\n\tVec2 vel[MAX_ENTITY_COUNT];\r\n\tVec2 gridPosition[MAX_ENTITY_COUNT];\r\n\r\n\r\n\t// Vec2 acc[MAX_ENTITY_COUNT];\r\n\r\n\tfloat speed[MAX_ENTITY_COUNT];\r\n\r\n\tvec4 uvs[MAX_ENTITY_COUNT];\r\n\tvec4 colors[MAX_ENTITY_COUNT];\r\n\r\n\tvec2f moveToPosition[MAX_ENTITY_COUNT];\r\n\r\n\tbool  arrived[MAX_ENTITY_COUNT];\r\n\r\n\tState state[MAX_ENTITY_COUNT];\r\n\tSide  side[MAX_ENTITY_COUNT];\r\n\tAttackType attackType[MAX_ENTITY_COUNT];\r\n\tunsigned char baseDamage[MAX_ENTITY_COUNT];\r\n\tshort health[MAX_ENTITY_COUNT];\r\n\tfloat attackTimer[MAX_ENTITY_COUNT];\r\n\tfloat baseRangeSqrt[MAX_ENTITY_COUNT];\r\n\r\n\tType type[MAX_ENTITY_COUNT];\r\n\r\n\tEntityHandle* selfHandle[MAX_ENTITY_COUNT];\r\n\tEntityHandle* target[MAX_ENTITY_COUNT];\r\n\t// float attackSpeed[MAX_ENTITY_COUNT];\r\n\r\n\t/// union\r\n\tUnit_type         unitType[MAX_ENTITY_COUNT];\r\n\tBuilding_type buildingType[MAX_ENTITY_COUNT];\r\n\t/// /union\r\n\r\n\tCollisionPair* collisionPairs[MAX_ENTITY_COUNT];\r\n\tcollided_type  COLLISION_TYPES[MAX_ENTITY_COUNT];\r\n\tint collisionPairCount;\r\n\r\n\tvec2f steeringForce[MAX_ENTITY_COUNT];\r\n\r\n\t// ****\r\n\tcollision* collisionTypes[MAX_ENTITY_COUNT];\r\n\tint collisionTypesCount[MAX_ENTITY_COUNT];\r\n\t// ****\r\n\r\n\tbool moving[MAX_ENTITY_COUNT];\r\n\r\n\tunsigned int textureId[MAX_ENTITY_COUNT];\r\n};\r\n\r\n\t\t\t\t     // Entities\r\nEntityHandle* newHandle(Entities* entities, EntityHandles* entityHandles, int entityId);\r\nEntityHandle* getHandle(Entities* entities, int entityId);\r\nvoid freeHandle(Entities* entities, EntityHandle* entityHandle);\r\nvoid invalidateHandle(EntityHandle* handle);\r\n\r\nstruct Initializer\r\n{\r\n\tunion\r\n\t{\r\n\t\tUnit_type unitType;\r\n\t\tBuilding_type buildingType;\r\n\t};\r\n};\r\n#endif // end of the header file\r\n\r\n\r\n\r\n\r\n#ifdef ENTITY_IMPL\r\nvec2f getSize(Building_type type)\r\n{\r\n\treturn { 60.f, 60.f };\r\n}\r\n\r\nint createEntity(Entities* entities, Vec2* position, Type type = Type_unit, Initializer* init = 0)\r\n{\r\n\tint newID = entities->current_count;\r\n\r\n\tif (newID >= MAX_ENTITY_COUNT)\r\n\t{\r\n\t\tLOGI(\"WARNING entity max count reached not creating!\");\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t++entities->current_count;\r\n\r\n\tswitch (type)\r\n\t{\r\n\tcase Type_building: // L O L\r\n\t{\r\n\t\tentities->buildingType[newID] = init->buildingType;\r\n\t\t\r\n\t\tentities->positions[newID] = { position->x, position->y, 20.f, 20.f }; // data\r\n\t\tentities->positions[newID].w = 60.f;\r\n\t\tentities->positions[newID].h = 60.f;\r\n\t\tentities->speed[newID] = 0.f;\r\n\t\tgoto skip;\r\n\t} // fall\r\n\tcase Type_unit:\r\n\t{\r\n\t\tif (init)\r\n\t\t\tentities->unitType[newID] = init->unitType;\r\n\t\tentities->positions[newID] = { position->x, position->y, 20.f, 20.f };\r\n\t\tentities->speed[newID] = UNIT_DEFAULT_SPEED;\r\n\t\tskip:\r\n\r\n\t\tentities->moveToPosition[newID] = { position->x, position->y };\r\n\r\n\t\tentities->colors[newID] = { 1.0f, 1.0f, 1.0f, 1.0f }; //\t{ 255, 255, 255, 255 };\r\n\t\tentities->textureId[newID] = 1;\r\n\t\tentities->uvs[newID] = { 0.f, 0.f, 1.0f, 1.0f };\r\n\r\n\t\tentities->health[newID]    = 100;\r\n\t\tentities->baseRangeSqrt[newID] = 60.f * 60.f;\r\n\t\tentities->baseDamage[newID] = 10;\r\n\t} break;\r\n\tdefault:\r\n\t\tbreak;\r\n\t}\r\n\r\n\tentities->type[newID] = type;\r\n\r\n\treturn newID;\r\n}\r\n\r\nvoid removeEntity(Entities* entities, int removedId)\r\n{\r\n\tint lastEntity = entities->current_count - 1;\r\n\r\n\t// HANDLE is invalid\r\n\r\n\t// entities->selfHandle[removedId];\r\n\tif (EntityHandle* handle = getHandle(entities, removedId))\r\n\t{\r\n\t\tinvalidateHandle(handle); // pelkastaan vihollisilla handleja\r\n\t\t// freeHandle(entities, handle);\r\n\t}\r\n\r\n\r\n\tentities->positions[removedId]      = entities->positions[lastEntity];\r\n\tentities->vel[removedId] = entities->vel[lastEntity];\r\n\tentities->speed[removedId]          = entities->speed[lastEntity];\r\n\r\n\tentities->uvs[removedId] = entities->uvs[lastEntity];\r\n\tentities->colors[removedId] = entities->colors[lastEntity];\r\n\tentities->moveToPosition[removedId] = entities->moveToPosition[lastEntity];\r\n\tentities->arrived[removedId] = entities->arrived[lastEntity];\r\n\r\n\tentities->state[removedId] = entities->state[lastEntity];\r\n\tentities->side[removedId] = entities->side[lastEntity];\r\n\tentities->attackType[removedId] = entities->attackType[lastEntity];\r\n\tentities->baseDamage[removedId] = entities->baseDamage[lastEntity];\r\n\tentities->health[removedId] = entities->health[lastEntity];\r\n\tentities->baseRangeSqrt[removedId] = entities->baseRangeSqrt[lastEntity];\r\n\r\n\tentities->type[removedId] = entities->type[lastEntity];\r\n\tentities->selfHandle[removedId] = entities->selfHandle[lastEntity];\r\n\tentities->target[removedId] = entities->target[lastEntity];\r\n\r\n\tentities->collisionPairs[removedId] = entities->collisionPairs[lastEntity];\r\n\tentities->COLLISION_TYPES[removedId] = entities->COLLISION_TYPES[lastEntity];\r\n\r\n\tentities->steeringForce[removedId] = entities->steeringForce[lastEntity];\r\n\tentities->collisionTypes[removedId] = entities->collisionTypes[lastEntity];\r\n\tentities->collisionTypesCount[removedId] = entities->collisionTypesCount[lastEntity];\r\n\tentities->moving[removedId] = entities->moving[lastEntity];\r\n\tentities->textureId[removedId] = entities->textureId[lastEntity];\r\n\r\n\t--entities->current_count;\r\n}\r\n// ylempi ylempi automaattisesi automaattisesti\r\n// ylempi automaattisesi automaattisesti\r\n// alempi automaattisesi automaattisesti\r\nvoid move(Entities* entities, int entity, Vec2* amount)\r\n{\r\n\tentities->positions[entity].x += amount->x;\r\n\tentities->positions[entity].y += amount->y;\r\n}\r\n\r\nvoid setSize(Entities* entities, Vec2* size, int id)\r\n{\r\n\tentities->positions[id].w = size->x;\r\n\tentities->positions[id].h = size->y;\r\n}\r\n\r\nvoid setPos(Entities* entities, Vec2* size, int id)\r\n{\r\n\tentities->positions[id].x = size->x;\r\n\tentities->positions[id].y = size->y;\r\n}\r\n\r\nbool circleCollisionCheck(vec4* __restrict a, vec4* __restrict b)\r\n{\r\n\tconst float MIN_DISTANCE = a->w + b->w;\r\n\r\n\tVec2 centerPosA = Vec2{ a->x, a->y } + Vec2{ a->w, a->w };\r\n\tVec2 centerPosB = Vec2{ b->x, b->y } + Vec2{ b->w, b->w };\r\n\tVec2 distVec = centerPosA - centerPosB;\r\n\r\n\tconst float distance = distVec.length();\r\n\tconst float collisionDepth = MIN_DISTANCE - distance;\r\n\r\n\treturn (collisionDepth > 0);\r\n}\r\n\r\n// vec4* bodies = entities->positions;\r\n\t\t// for (int i = 0; i < entities->current_count; i++)\r\n\t\t// {\r\n\t\t\t// vec4* current = bodies + i;\r\n\t\t\t// for (int j = i + 1; j < entities->current_count; j++)\r\n\t\t\t// {\r\n\t\t\t\t// vec4* target = bodies + j;\r\n\t\t\t\t// handleCircleCollision(current, target);\r\n\t\t\t// }\r\n\t\t// }\r\n\r\n/*\tvec4* bodies = entities->positions;\r\n\t\tfor (int i = 0; i < entities->current_count; i++)\r\n\t\t{\r\n\t\t\tvec4* current = bodies + i;\r\n\t\t\tfor (int j = i + 1; j < entities->current_count; j++)\r\n\t\t\t{\r\n\t\t\t\tvec4* target = bodies + j;\r\n\t\t\t\thandleCircleCollision(current, target);\r\n\t\t\t}\r\n\t\t}\r\n*/\r\n\r\n/*__declspec(noalias)*/ \r\nstatic void phase1(Entities* gameState)\r\n{\r\n\tVec2 distVecs[MAX_ENTITY_COUNT];\r\n\r\n\tfloat distances[MAX_ENTITY_COUNT];\r\n\t// bool haha[MAX_ENTITY_COUNT];\r\n\r\n// #pragma omp parallel for\r\n// #pragma omp parallel for ordered schedule(dynamic)\r\n\tfor (int i = 0; i < gameState->current_count; i++)\r\n\t{\r\n\t\tvec4* __restrict a = &gameState->positions[i];\r\n\r\n\t\tfor (int j = i + 1; j < gameState->current_count; j++)\r\n\t\t{\r\n\t\t\tvec4* __restrict b = &gameState->positions[j];\r\n\r\n\t\t\t// const float MIN_DISTANCE = a->w + b->w;  // molempiend dist\r\n\t\t\tconst float MIN_DISTANCE = a->w / 2.f + b->w / 2.f;  // molempiend dist\r\n\t\t\tVec2 centerPosA = Vec2{ a->x, a->y } +Vec2{ a->w / 2.f , a->w / 2.f };\r\n\t\t\tVec2 centerPosB = Vec2{ b->x, b->y } +Vec2{ b->w / 2.f , b->w / 2.f };\r\n\r\n\t\t\t// distVecs[i] = distVecs[i].x * distVecs[i].x + distVecs[i].y * distVecs[i].y;\r\n\t\t\tdistVecs[j] = centerPosA - centerPosB;\r\n\r\n\t\t\t//\t\thaha[j] = std::abs(distVecs[j].x * distVecs[j].x + distVecs[j].y * distVecs[j].y) \r\n\t\t\t//\t\t\t< MIN_DISTANCE * MIN_DISTANCE ? 1 : 0;\r\n\r\n\t\t\tdistances[j] = MIN_DISTANCE * MIN_DISTANCE;\r\n#if 1\r\n\r\n#endif\r\n\t\t\t// std::abs(distVecs[j].x * distVecs[j].x + distVecs[j].y * distVecs[j].y) \r\n\t\t}\r\n\t\t// std::abs(distVecs[j].x * distVecs[j].x + distVecs[j].y\r\n\t\tfor (int j = i + 1; j < gameState->current_count; j++)\r\n\t\t{\r\n\t\t\tfloat value = std::abs(distVecs[j].x * distVecs[j].x + distVecs[j].y * distVecs[j].y);\r\n\t\t\tif (std::abs(value) < distances[j])\r\n\t\t\t{\r\n\t\t\t\t// distVecs[j].normalizeInPlace();\r\n\t\t\t\tfloat sqrtd = sqrt(value);\r\n\t\t\t\tdistVecs[j].x /= sqrtd;\r\n\t\t\t\tdistVecs[j].y /= sqrtd;\r\n\r\n\t\t\t\tdistVecs[j] *= (/*distances[j]*/ 20.f * 0.5f * 0.15f);\r\n\t\t\t\t// distVecs[j] *= (/*distances[j]*/ 20.f  0.5f * 0.15f);\r\n\r\n\t\t\t\t// vec4* a = &gameState->positions[j];\r\n\t\t\t\tvec4* __restrict b = &gameState->positions[j];\r\n\r\n\t\t\t\tconst Vec2 aResolution = distVecs[j]; /// 1.5f; // +=\r\n\t\t\t\ta->x += aResolution.x;\r\n\t\t\t\ta->y += aResolution.y;\r\n\t\t\t\tconst Vec2 bResolution = distVecs[j]; /// 1.5f;  // -=\r\n\t\t\t\tb->x -= bResolution.x;\r\n\t\t\t\tb->y -= bResolution.y;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// laita yksi for luupin sis looppi\r\n\r\n//\tfor (int i = 0; i < gameState->current_count; i++)\r\n\t{\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#if 1\r\nvoid handleCircleCollision(vec4* __restrict a, vec4* __restrict b)\r\n{\r\n#if 0\r\n\tconst float MIN_DISTANCE = a->r * 2.0f;\r\n\tglm::vec2 centerPosA = glm::vec2{ a->x, a->y } +glm::vec2(a->r);\r\n\tglm::vec2 centerPosB = glm::vec2{ b->x, b->y } +glm::vec2(b->r);\r\n\tglm::vec2 distVec = centerPosA - centerPosB;\r\n\r\n\r\n\t// const float distance = glm::length(distVec);\r\n\tconst float collisionDepth = MIN_DISTANCE - distance;\r\n#else\r\n\tconst float MIN_DISTANCE = a->w / 2.f + b->w / 2.f;  // molempiend dist\r\n\tVec2 centerPosA = Vec2{ a->x, a->y } +Vec2{ a->w / 2.f , a->w / 2.f };\r\n\tVec2 centerPosB = Vec2{ b->x, b->y } +Vec2{ b->w / 2.f , b->w / 2.f };\r\n\tVec2 distVec = centerPosA - centerPosB;\r\n#endif\r\n\tif (distVec.x * distVec.x + distVec.y * distVec.y < MIN_DISTANCE * MIN_DISTANCE)\r\n\t{\r\n\t\t//\ticonst float collisionDepth = 6.f;\r\n\t\t// const float distance = 2.f;\r\n\t\t/* if (distance == 0.f)\r\n\t\t{\r\n\t\t\ta->x += 30.f;\r\n\t\t\ta->y += 30.f;\r\n\t\t\tb->x -= 30.f;\r\n\t\t\tb->y -= 30.f;\r\n\t\t\treturn;\r\n\t\t} */\r\n\r\n\t\t// const float collisionDepth =  MIN_DISTANCE - glm::length(distVec);\r\n\t\tdistVec.normalizeInPlace();\r\n\t\tdistVec *= a->w / 2.f;\r\n\t\t// const Vec2 collisionDepthVec = distVec * 7.5f; // test\r\n\t\t//if (distVec.x < 0.1f && distVec.y < 0.1f)\r\n\t\t//{\r\n\t\t//\tconst Vec2 aResolution = distVec * 2.f; // +=\r\n\t\t//\ta->x += aResolution.x;\r\n\t\t//\ta->y += aResolution.y;\r\n\r\n\t\t//\tconst Vec2 bResolution = distVec * 2.f;  // -=\r\n\t\t//\tb->x -= bResolution.x;\r\n\t\t//\tb->y -= bResolution.y;\r\n\t\t//\tLOGI(\"PRINT INVALID\\n\");\r\n\t\t//\treturn;\r\n\t\t//}\r\n\r\n\t\t// MIN_DISTANCE / 2.f * 0.15f\r\n#if 0\r\n\t\tif (std::max(distVec.x, 0.0f) < std::max(distVec.y, 0.0f))\r\n\t\t{\r\n\t\t\tif (distVec.x < 0)\r\n\t\t\t\tb->x -= collisionDepthVec.x;\r\n\t\t\telse\r\n\t\t\t\tb->x += collisionDepthVec.x;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (distVec.y < 0)\r\n\t\t\t\tb->y += collisionDepthVec.y;\r\n\t\t\telse\r\n\t\t\t\tb->y -= collisionDepthVec.y;\r\n\t\t}\r\n\t\t// b->y += collisionDepthVec.y;\r\n#else\r\n\t\tconst Vec2 aResolution = distVec * 0.15f; /// 1.5f; // +=\r\n\t\ta->x += aResolution.x;\r\n\t\ta->y += aResolution.y;\r\n\r\n\t\tconst Vec2 bResolution = distVec * 0.15f; /// 1.5f;  // -=\r\n\t\tb->x -= bResolution.x;\r\n\t\tb->y -= bResolution.y;\r\n\t\t// agent->_position -= collisionDepthVec / 2.0f;\r\n#endif\r\n\t}\r\n}\r\n#endif\r\n\r\n// x x x\r\n// x o x\r\n// x x x\r\n\r\n\r\n// attack handle or smt...\r\n// entity handle jne..\r\n\r\nbool phase = true;\r\nstatic void updateEntitys(Entities* entities)\r\n{\r\n\r\n\tfor (int i = 0; i < entities->current_count; ++i)\r\n\t{\r\n\t\tvec2f* vel = &entities->vel[i];\r\n\r\n\t\tentities->positions[i].x += vel->x;\r\n\t\tentities->positions[i].y += vel->y;\r\n\t}\r\n\r\n\t\r\n\r\n#if 0\r\n\tif (phase)\r\n\t{\r\n\t\tphase1(entities);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tvec4* bodies = entities->positions;\r\n//\t\t #pragma omp parallel for collapse(2)\r\n\t\tfor (int i = 0; i < entities->current_count; i++)\r\n\t\t{\r\n\t\t\tvec4* current = bodies + i;\r\n\t\t\tfor (int j = i + 1; j < entities->current_count; j++)\r\n\t\t\t{\r\n\t\t\t\tvec4* target = bodies + j;\r\n\t\t\t\thandleCircleCollision(current, target);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n#endif\r\n\t// END_TIMING();\r\n\r\n\t// LET'S DO THIS\r\n\r\n\t// dispatch types?\r\n\r\n\t// liiku\r\n}\r\n\r\n// BIG optimization opportunity: \r\n// give pointer to uv's and colors...   // TO EVERYTHING\r\n\r\n// BIG optimization opportunity: \r\n// double buffer entity rendering data -> mt\r\n\r\n// small optimization oppotunity:\r\n// keep colors as unsigned int\r\n\r\nvoid debug_RenderEntitys(EngineCore* core, Entities* entities)\r\n{\r\n\tint count = entities->current_count;\r\n\r\n\tvec4 cameraRect = camera::cameraRect(core);\r\n\r\n#if 1\r\n\tfor (int i = 0; i < count; i++)\r\n\t{\r\n\t\tvec4* epos = &entities->positions[i];\r\n\t\tvec2f pos = { epos->x + epos->w / 2.f, epos->y + epos->h / 2.f };\r\n\r\n\t\tif (camera::cull(&cameraRect, pos))\r\n\t\t{\r\n\t\t\tgraphics::setCircle(core->lines, pos, epos->w / 2.f);\r\n\t\t}\r\n\t}\r\n#else\r\n//\tspatial_foreach(vec2f{ cameraRect.x, cameraRect.y }, vec2f{ cameraRect.x, cameraRect.y })\r\n\r\n#endif\r\n\r\n}\r\n\r\n\r\nvoid debug_RenderSteeringForce(EngineCore* core, Entities* entities)\r\n{\r\n\tint count = entities->current_count;\r\n\tvec4 cameraRect = camera::cameraRect(core);\r\n\tfor (int i = 0; i < count; i++)\r\n\t{\r\n\t\tvec4* epos = &entities->positions[i];\r\n\t\tvec2f pos = { epos->x + epos->w / 2.f, epos->y + epos->h / 2.f };\r\n\t\tvec2f endPoint = ((entities->steeringForce[i] * 2.5) + pos);\r\n\r\n\t\tif (camera::cull(&cameraRect, pos))\r\n\t\t{\r\n\t\t\tgraphics::drawLine(core->lines, &pos, &endPoint);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid drawEntities(Entities* entities, EngineCore* core)\r\n{\r\n\t// LOGI(\"olen fine : %i \\n\", entities->current_count);\r\n\tfor (int i = 0; i < entities->current_count; i++)\r\n\t{\r\n\t\t// LOGI(\"I: %i \\n\", i);\r\n\t\tauto* position = &entities->positions[i];\r\n\t\tauto* uv = &entities->uvs[i];\r\n\t\tauto* color = &entities->colors[i];\r\n\r\n\t\tcore->layers[0].draw(position, uv, color);\r\n\t}\r\n\t// LOGI(\"OLEN FINE\\n\");\r\n\r\n#if _WIN32\r\n\tImGui::Checkbox(\"phase \", &phase);\r\n#endif\r\n\t// LOGI(\"OLEN FINE\\n\");\r\n}\r\n#endif","#ifndef MAPGRID_H\r\n#define MAPGRID_H\r\n\r\n// buildingit gridiin vs 100 x 100 = 10000 x 1   vs   10000 x 4  \r\n// laita map kun haluat hyvaa\r\n// \r\n\r\nconstexpr float TILE_SIZE = 20.f;\r\nconstexpr int MAP_W = 100;\r\nconstexpr int MAP_H = 100;\r\n\r\nstruct Map\r\n{\r\n\tbool blocked[MAP_W * MAP_H];\r\n\tint  buildingId[MAP_W * MAP_H];\r\n};\r\n\r\nenum class TileType\r\n{\r\n\tEmpty,\r\n\tgrass,\r\n\tMax\r\n};\r\n\r\nstatic void initMap(Map* map, int width, int height);\r\n\r\nstatic int getBuildingId(Map* map, int x, int y);\r\nstatic bool blocked(Map* map, int x, int y);\r\n\r\nstatic vec2i worldToGrid(vec2f& position);\r\nstatic bool tilesBlocked(Map* map, int x, int y, const vec2i& size);\r\nstatic void blockTiles(Map* map, int x, int y, const vec2i& size);\r\n\r\n#endif // end of the header\r\n\r\n\r\n#ifdef MAPGRID_IMPL\r\nstatic void initMap(Map* map, int width, int height)\r\n{\r\n\t*map = {};\r\n\r\n\tfor (int i = 0; i < height; ++i)\r\n\t{\r\n\t\tfor (int j = 0; j < width; ++j)\r\n\t\t{\r\n\t\t\t// ...\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic int getBuildingId(Map* map, int x, int y)\r\n{\r\n\treturn { map->buildingId[x + y * MAP_W] };\r\n}\r\n\r\nstatic bool blocked(Map* map, int x, int y)\r\n{\r\n\treturn map->blocked[x + y * MAP_W];\r\n}\r\n\r\nstatic vec2i worldToGrid(vec2f& position)\r\n{\r\n\treturn { int(position.x / TILE_SIZE), int(position.y / TILE_SIZE) };\r\n}\r\n\r\nstatic bool tilesBlocked(Map* map, int x, int y, const vec2i& size)\r\n{\r\n\tfor (int j = y; j < y + size.y; ++j)\r\n\t{\r\n\t\tfor (int i = x; i < x + size.x; ++i)\r\n\t\t{\r\n\t\t\tif (map->blocked[j * MAP_W + i])\r\n\t\t\t{\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nstatic void blockTiles(Map* map, int x, int y, const vec2i& size)\r\n{\r\n\tfor (int j = y; j < y + size.y; ++j)\r\n\t{\r\n\t\tfor (int i = x; i < x + size.x; ++i)\r\n\t\t{\r\n\t\t\tmap->blocked[j * MAP_W + i] = true;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic void setBuilding(Map* map, int x, int y, const vec2i& size, int entityId)\r\n{\r\n\tfor (int j = y; j < y + size.y; ++j)\r\n\t{\r\n\t\tfor (int i = x; i < x + size.x; ++i)\r\n\t\t{\r\n\t\t\tmap->buildingId[j * MAP_W + i] = entityId;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n#define NO_BUILDING -1\r\nstatic void destroyBuilding(Map* map, int x, int y, const vec2i& size)\r\n{\r\n\tfor (int j = y; j < y + size.y; ++j)\r\n\t{\r\n\t\tfor (int i = x; i < x + size.x; ++i)\r\n\t\t{\r\n\t\t\tmap->buildingId[j * MAP_W + i] = NO_BUILDING;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid debug_RenderCollisionGrid(EngineCore* core, Map* map, vec4* cameraRect, Layer* layer)\r\n{\r\n\t// gameState\r\n\t// draw solid square here!\r\n\tvec2f xy = { cameraRect->x, cameraRect->y };\r\n\tvec2f wh = { xy.x + cameraRect->w, xy.y + cameraRect->h };\r\n\tvec2i start = worldToGrid(xy);\r\n\tvec2i end = worldToGrid(wh);\r\n\r\n\tlayer->setTexture(engine::getTexture(core->resources, textures::Texture_Block)->ID);\r\n\r\n\tstatic vec4 uv{ 0.f, 0.f, 1.0f, 1.0f };\r\n\tvec4 color = vec4{ 247.0f / 255.f, 22.f / 255.f, 22.f / 255.f, 0.4f };\r\n\tfor (int i = start.x; i < end.x; ++i)\r\n\t{\r\n\t\tfor (int j = start.y; j < end.y; ++j)\r\n\t\t{\r\n\t\t\tvec4 pos{ j * TILE_SIZE, i * TILE_SIZE, TILE_SIZE, TILE_SIZE };\r\n\r\n\t\t\tif (map->blocked[i * MAP_W + j])\r\n\t\t\t{\r\n\t\t\t\tlayer->draw(&pos, &uv, &color);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n#endif\r\n","#include \"aoe160k.h\"\r\n\r\n#define ENTITY_IMPL\r\n#include \"Entity.h\"\r\n#define MAPGRID_IMPL\r\n#include \"mapgrid.h\"\r\n\r\n#ifndef __EMSCRIPTEN__\r\n#define OPEN_MP_ENABLED 1\r\n#endif\r\n#if OPEN_MP_ENABLED\r\n#define OPEN_MP_DYNAMIC() __pragma(omp parallel for schedule(dynamic, 1000) num_threads(3))\r\n#define OPEN_MP_OMP_FOR() __pragma(omp parallel for schedule(dynamic, 1000))\r\n#else\r\n#define OPEN_MP_DYNAMIC()\r\n#define OPEN_MP_OMP_FOR()\r\n#endif\r\n\r\nint benchmarkCount = 1000;\r\n\r\nstatic void initAoe160k(EngineCore* core, RtsGameState* gameState)\r\n{\r\n\tLOGI(\"Welcome to the aoe 160k\\n\");\r\n\r\n#ifdef __EMSCRIPTEN__\r\n\tgameState->entities = { };\r\n#endif\r\n\r\n\t// Entityt\r\n\tVec2 pos{ 137.f, 137.f };\r\n\tgameState->player = createEntity(&gameState->entities, &pos);\r\n\r\n\tpos.y = 80.f;\r\n\tfloat baseY = 500.f;\r\n\tfloat baseX = 500.f;\r\n\r\n\tint lineCount = 10;\r\n\tfor (int j = 0; j < lineCount; ++j)\r\n\t{\r\n\t\tfor (int i = 0; i < benchmarkCount; ++i)\r\n\t\t{\r\n\t\t\tpos.x = baseX + (float)i * 2.f;\r\n\t\t\tpos.y = float(sin(i) * 80.f + baseY);\r\n\t\t\tcreateEntity(&gameState->entities, &pos);\r\n\t\t}\r\n\t\tbaseY += 500.f;\r\n\t}\r\n\r\n\t// LOGI(\"ENTITY COUNT %i \\n\", gameState->entities.curre)\r\n}\r\n\r\nconstexpr float dampener = 0.99f;\r\nvoid updateFloaters(FloatingText* floaters, int count)\r\n{\r\n\tfor (int i = 0; i < count; i++)\r\n\t{\r\n\t\tfloaters[i].vel += floaters[i].acc;\r\n\t\tfloaters[i].acc *= dampener;\r\n\t\tfloaters[i].position += floaters[i].vel;\r\n\t}\r\n}\r\n\r\n// unit selection rect\r\nstatic inline vec4 getSelectionRect(RtsGameState* gameState, EngineCore* core)\r\n{\r\n\tauto mouseStart = gameState->rtsController.onClickPosition;\r\n\tvec2f mouseEnd = engine::Input::getMousePositionWorld(core);\r\n\r\n\tvec2f mouseWidth = mouseEnd - mouseStart;\r\n\treturn { mouseStart.x, mouseStart.y, mouseWidth.x, mouseWidth.y };\r\n}\r\n\r\nstatic inline vec4 makeSelectionRect(vec4 rect)\r\n{\r\n\tif (rect.w < 0.f)\r\n\t{\r\n\t\trect.w = -rect.w;\r\n\t\trect.x -= rect.w;\r\n\t}\r\n\r\n\tif (rect.h < 0.f)\r\n\t{\r\n\t\trect.h = -rect.h;\r\n\t\trect.y -= rect.h;\r\n\t}\r\n\r\n\treturn rect;\r\n}\r\n\r\n\r\n\r\nstatic void selectUnits(RtsGameState* gameState, EngineCore* core)\r\n{\r\n\tRtsController* controller = &gameState->rtsController;\r\n\r\n\tint count = gameState->entities.current_count;\r\n\tint selectedUnits = 0;\r\n\tvec4 selectionRect = makeSelectionRect(getSelectionRect(gameState, core));\r\n\r\n\tfor (int i = 0; i < count; ++i)\r\n\t{\r\n\t\tvec4* position = &gameState->entities.positions[i];\r\n\r\n\t\tif (maths::isInsideRect(&selectionRect, position))\r\n\t\t{\r\n\t\t\tcontroller->selectedUnits[selectedUnits] = i;\r\n\t\t\t++selectedUnits;\r\n\t\t}\r\n\t}\r\n\r\n\tbool onlyBuildings = true;\r\n\tEntities* entities = &gameState->entities;\r\n\tfor (int i = 0; i < selectedUnits; ++i)\r\n\t{\r\n\t\tint entityId = controller->selectedUnits[i];\r\n\t\tif (entities->type[entityId] == Type_unit)\r\n\t\t{\r\n\t\t\tonlyBuildings = false;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tif (onlyBuildings)\r\n\t{\r\n\t\tcontroller->selectionType = Type_building;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcontroller->selectionType = Type_unit;\r\n\t\tfor (int i = 0; i < selectedUnits; ++i)\r\n\t\t{\r\n\t\t\tint entityId = controller->selectedUnits[i];\r\n\t\t\tif (entities->type[entityId] != Type_unit)\r\n\t\t\t{\r\n\t\t\t\t// remove building from selected\r\n\t\t\t\tentities->type[entityId] = entities->type[selectedUnits - 1];\r\n\t\t\t\t--selectedUnits;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tcontroller->selectedUnitCount = selectedUnits;\r\n\tLOGI(\"Selected %i units\\n\", selectedUnits);\r\n}\r\n\r\nstatic void setMovePosition(RtsGameState* gameState, int* moving, int count, vec2f& moveTo)\r\n{\r\n\tfor (int i = 0; i < count; ++i)\r\n\t{\r\n\t\tint entityId = *(moving + i);\r\n\t\tvec2f* position = &gameState->entities.moveToPosition[entityId];\r\n\r\n\t\t*position = moveTo;\r\n\t\tgameState->entities.moving[entityId] = true;\r\n\t}\r\n}\r\n\r\nstatic void setGroupMovePosition(RtsGameState* gameState, int* moving, int count, vec2f& moveTo)\r\n{\r\n\tEntities* ents = &gameState->entities;\r\n\t// moving [0] == ekan id\r\n\tvec2f centerPoint = { ents->positions[moving[0]].x, ents->positions[moving[0]].y };\r\n\r\n\tfor (int i = 1; i < count; ++i)\r\n\t{\r\n\t\tint entityId = moving[i];\r\n\t\tcenterPoint += { ents->positions[entityId].x, ents->positions[entityId].y };\r\n\t}\r\n\tcenterPoint /= (float)count; // kaikkien keskus paikka\r\n\r\n\r\n\t// set up debug info !\r\n\tFormation* formation = &gameState->PlayerLastFormation;\r\n\tformation->formationUnitsCenterPosition = centerPoint; // +moveTo;\r\n\tformation->formationUnitsMoveToCenterPosition = moveTo;\r\n\tformation->formationCount = count;\r\n\tformation->formationRadius = sqrtf((float)count) * 12.5f;\r\n\r\n\tfloat formationRadiusSquared = formation->formationRadius * formation->formationRadius;\r\n\r\n\tvec2f center = moveTo + centerPoint;\r\n\r\n\tfloat centeredCount = (float)count;\r\n\tfloat maxCenterCount = (float)count;\r\n\tfloat centerMax = (float)count;\r\n\tfloat fromCenter = 15.f;\r\n\r\n\r\n\tfor (int i = 0; i < count; ++i)\r\n\t{\r\n\t\tint entityId = moving[i];\r\n\t\tvec2f startingPoint = vec2f{ ents->positions[entityId].x, ents->positions[entityId].y } -centerPoint;\r\n\r\n\t\tfloat distanceSquared = abs(startingPoint.x * startingPoint.x) + abs(startingPoint.y * startingPoint.y);\r\n\r\n\t\tif (formationRadiusSquared - distanceSquared < 0.f)\r\n\t\t{\r\n#if 0\r\n\t\t\tvec2f direction = moveTo - startingPoint; // moveTo / center\r\n\t\t\tdirection.normalizeInPlace();\r\n#else\r\n\t\t\tvec2f direction = startingPoint.normalize();\r\n#endif\r\n\r\n\t\t\tfloat centerCoeff = centeredCount / maxCenterCount;\r\n\r\n\t\t\t// float dist = sqrt(std::abs(formationRadiusSquared - distanceSquared));\r\n\t\t\t// float howFarCoeff = distanceSquared / formationRadiusSquared; \r\n\t\t\tdirection *= formation->formationRadius * centerCoeff; // dist;\r\n\t\t\tents->moveToPosition[entityId] = (direction)+moveTo;\r\n\r\n\t\t\t// LOGI(\"mene keskustaan\\n\");\r\n\t\t\tcenteredCount -= fromCenter;\r\n\t\t\tif (centeredCount < 0.f || centeredCount > centerMax)\r\n\t\t\t{\r\n\t\t\t\tcenteredCount = (float)count; // MAN THE CENTERS\r\n\t\t\t\tcenteredCount = 0.f;\r\n\t\t\t\tfromCenter = -3.f;     // aletaan menn keskustasta reunoihin\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tents->moveToPosition[entityId] = startingPoint + moveTo;\r\n\t\t}\r\n\t\tents->moving[entityId] = true;\r\n\t}\r\n}\r\n\r\n// slackKirimizigg1\r\nstatic int getCount(RtsGameState* gameState)\r\n{\r\n\treturn gameState->entities.current_count;\r\n}\r\n\r\n// pelkastaan liikkuville\r\n\r\nconstexpr float arriveRange = 10.0f * 10.0f;\r\nstatic void calculateVelocities(RtsGameState* gameState)\r\n{\r\n\tauto* ents = &gameState->entities;\r\n\tint count = getCount(gameState);\r\n\r\n\tfor (int i = 0; i < count; i++)\r\n\t{\r\n\r\n\t\t// if (ents->COLLISION_TYPES[i] != collided_hard)\r\n\t\t{\r\n\t\t\tif (ents->moving[i])\r\n\t\t\t{\r\n\t\t\t\tvec4* curPos = &ents->positions[i];\r\n\t\t\t\tvec2f pos = { curPos->x, curPos->y };\r\n\t\t\t\tvec2f direction = ents->moveToPosition[i] - pos;\r\n\r\n\t\t\t\tfloat squaredDistance = direction.x * direction.x + direction.y * direction.y;\r\n\r\n\t\t\t\tif (squaredDistance > arriveRange)\r\n\t\t\t\t{\r\n#if NORMAL\r\n\t\t\t\t\tdirection.normalizeInPlace();\r\n\t\t\t\t\tents->vel[i] = direction * ents->speed[i];\r\n#else\r\n\t\t\t\t\tdirection.normalizeInPlace();\r\n\t\t\t\t\tents->vel[i] = (direction * 1.75) + ents->steeringForce[i];\r\n\t\t\t\t\tents->vel[i].normalizeInPlace();\r\n\t\t\t\t\tents->vel[i] *= ents->speed[i];\r\n#endif\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tents->vel[i] = vec2f{ 0.f, 0.f };\r\n\t\t\t\t\tents->moving[i] = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse // get pushed\r\n\t\t\t{\r\n\t\t\t\tents->vel[i] = ents->steeringForce[i];\r\n\t\t\t\tents->vel[i].safeNormalizeInPlace();\r\n\t\t\t\t// ents->vel[i] *= 2.f;\r\n\t\t\t\tents->steeringForce[i].x = 0.f;\r\n\t\t\t\tents->steeringForce[i].y = 0.f;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n// index \r\n\r\n//\r\n// [ [0], [1], [2] ] \r\n// [ [3], [4], [5] ] \r\n// [ [6], [7], [8] ]\r\n//\r\n\r\n// laske\t\t\tx ja y erikseen ?\r\n\r\n// 0, 2, 5, 8, 8, 8\r\n\r\n// tee 'groupit'\r\n\r\n// '0, 2', \r\n\r\n\r\n// x arvot        0              1               2 \r\n// y arvot        0              1               2\r\n\r\n// jos sama sama ryhm tarkista\r\n// \r\n\r\n// [1, 1] =  0, 0   1, 0   0, 1   1, 1  0, 2    |=     { entit };\r\n// [2, 1] =  1, 0   2, 0   1, 1   2, 1  1, 2    |=     { entit };  \r\n\r\n\r\nenum visibility\r\n{\r\n\tHidden,\r\n\tExplored,\r\n\tVisible,\r\n};\r\n\r\n\r\nconstexpr int VISIBILITY_GRID_SIZE = 216;\r\nconstexpr float VISIBILITY_CELL_SIZE = 20.f;\r\nunsigned int visibilityMap[216 * 216];\r\nunsigned int mask;\r\nunsigned int lastVisibility;\r\nint numPlayers = 0;\r\n\r\n\r\n// laske LOS are kaikille mahdollisille radiuksille\r\n\r\nstruct LOSTemplate\r\n{\r\n\tint verticalLines;\r\n};\r\n\r\n// 5 \r\n// \r\n//  # # x # #  // x off y off\r\n//  # x x x # \r\n//  x x x x x \r\n//  # x x x # \r\n//  # # x # # \r\n\r\n\r\n// eka bitti = fogged   | no fog\r\n// toka      = explored | unexplored\r\n\r\nvoid updateVisibility()\r\n{\r\n\t// insert to visibility map\t\t\r\n\r\n\tint x = 5;\r\n\tint y = 5;\r\n\tunsigned int currentVisiblity = visibilityMap[x + y * 216];\r\n\r\n\tif (currentVisiblity != lastVisibility)\r\n\t{\r\n\t\tunsigned int visibilityChanges = currentVisiblity ^ lastVisibility;\r\n\r\n\t\tfor (int playerN = 0; playerN < numPlayers; playerN++)\r\n\t\t{\r\n\t\t\tunsigned int playerMask = 0x0001 << playerN; // player bitmask\r\n\r\n\t\t\tif ((visibilityChanges & playerMask) != 0)\r\n\t\t\t{\r\n\t\t\t\tif ((currentVisiblity & playerMask) != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\t// addToVisibilityList playerNo\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// remove from player visibility list\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid debug_RenderVisibilityGrid(EngineCore* core, RtsGameState* gameState)\r\n{\r\n\tfloat x = core->cameraPosition->x;\r\n\tfloat y = core->cameraPosition->y;\r\n\r\n\tfloat max_size = VISIBILITY_CELL_SIZE * VISIBILITY_GRID_SIZE;\r\n\r\n\tfor (int i = 0; i < VISIBILITY_GRID_SIZE; ++i)\r\n\t{\r\n\t\tVec2 left{ i * VISIBILITY_CELL_SIZE, max_size };\r\n\t\tVec2 right{ i * VISIBILITY_CELL_SIZE, 0.f };\r\n\t\tgraphics::drawLine(core->lines, &left, &right);\r\n\t}\r\n\r\n\tfor (int i = 0; i < VISIBILITY_GRID_SIZE; ++i)\r\n\t{\r\n\t\tVec2 left{ 0.f, i * VISIBILITY_CELL_SIZE };\r\n\t\tVec2 right{ max_size, i * VISIBILITY_CELL_SIZE };\r\n\t\tgraphics::drawLine(core->lines, &left, &right);\r\n\t}\r\n\r\n\tfor (int i = 0; i < VISIBILITY_GRID_SIZE; ++i)\r\n\t{\r\n\t\tfor (int j = 0; j < VISIBILITY_GRID_SIZE; ++j)\r\n\t\t{\r\n\r\n\t\t\t//  unsigned int visibilityChanges = currentVisiblity ^ lastVisibility;\r\n\t\t\t//\tif ((visibilityChanges & playerMask) != 0)\r\n\t\t\tunsigned int mask = visibilityMap[i * VISIBILITY_GRID_SIZE + j];\r\n\t\t\tunsigned int playerMask = 0x0001 << 0; // player bitmask\r\n\r\n\t\t\tswitch (1)\r\n\t\t\t{\r\n\t\t\tcase Visible:\r\n\t\t\t{\r\n\t\t\t} break;\r\n\t\t\tcase Explored:\r\n\t\t\t{\r\n\t\t\t} break;\r\n\t\t\tcase Hidden:\r\n\t\t\t{\r\n\t\t\t} break;\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// for (int j = 0; j < VISIBILITY_GRID_SIZE; j++)\r\n\t// {\r\n}\r\n\r\n\r\nstatic inline vec2f getPosition(Entities* entities, int id)\r\n{\r\n\treturn { entities->positions[id].x, entities->positions[id].y };\r\n}\r\n\r\nvoid drawActionButton(Entities* entities, EngineCore* core, vec4* position, vec2f* mousePos, \r\n\tUnit_type unitType, float offset, int selectedId)\r\n{\r\n\tgraphics::drawBox(core->lines, position);\r\n\r\n\tbool down = engine::Input::mousePressed(Mouse::Left);\r\n\tif (down && maths::isInsideRect(position, mousePos))\r\n\t{\r\n\t\t// clicked spawn unit x or smt...\r\n\t\tvec2f position = getPosition(entities, selectedId);\r\n\t\tcreateEntity(entities, &position); // rakennuksen sijainti ???\r\n\t}\r\n\tposition->x += offset;\r\n}\r\n\r\nvoid updateBuildingSelection(RtsGameState* gameState, EngineCore* core)\r\n{\r\n\tif (gameState->rtsController.selectionType == Type_building)\r\n\t{\r\n\t\tEntities* entities = &gameState->entities;\r\n\t\tint selectedId = gameState->rtsController.selectedUnits[0];\r\n\r\n\t\tBuilding_type buildingType = Building_type::Barrack;\r\n\t\tvec4 basePosition = { 0.f, 0.f, 20.f, 20.f };\r\n\t\tvec2f mousePosition = engine::Input::getMousePositionWorld(core); // wrong with screen base impl\r\n\r\n\t\t// monta rakennusta...\r\n\t\tswitch (buildingType)\r\n\t\t{\r\n\t\tcase Building_type::noBuilding:\r\n\t\t\tbreak;\r\n\t\tcase Building_type::Ballista:\r\n\t\t\tbreak;\r\n\t\tcase Building_type::ShockTower:\r\n\t\t\tbreak;\r\n\t\tcase Building_type::Woodcutter:\r\n\t\t\tbreak;\r\n\t\tcase Building_type::Dock:\r\n\t\t\tbreak;\r\n\t\tcase Building_type::Barrack:\r\n\t\t\tdrawActionButton(entities, core, &basePosition, &mousePosition, Unit_type::Knight, 20.f, selectedId);\r\n\t\t\tdrawActionButton(entities, core, &basePosition, &mousePosition, Unit_type::Arhcer, 20.f, selectedId);\r\n\t\t\tbreak;\r\n\t\tcase Building_type::ArcheryRange:\r\n\t\t\tbreak;\r\n\t\tcase Building_type::Max:\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid setupCollision(RtsGameState* gameState)\r\n{\r\n\tint count = gameState->entities.current_count;\r\n\tauto* ents = &gameState->entities;\r\n\r\n\t// START_TIMING2();\r\n\tfor (int i = 0; i < GRID_ARRAY_SIZE; i++)\r\n\t{\r\n#ifndef VECTOR\r\n\t\tda_clear(bodyhash[i])\r\n#else\r\n\t\tt_bodies[i].clear();\r\n#endif\r\n\t}\r\n\t// END_TIMING2();\r\n\r\n\t// insertoi pointer oikeisiin ryhmiin\r\n\tOPEN_MP_DYNAMIC()\r\n\t\tfor (int j = 0; j < count; ++j)\r\n\t\t{\r\n\t\t\tvec4* poss = &ents->positions[j];\r\n\r\n\t\t\tint x = int(poss->x / GRID_WIDTH);\r\n\t\t\tint y = int(poss->y / GRID_HEIGHT);\r\n\r\n\r\n\t\t\t// laske oikeat ruudut\r\n\t\t\tvec2i grids[5];\r\n\t\t\tgrids[0] = { x - 1, y - 1 };\r\n\t\t\tgrids[1] = { x, y - 1 };\r\n\t\t\tgrids[2] = { x - 1, y };\r\n\t\t\tgrids[3] = { x, y };\r\n\t\t\tgrids[4] = { x - 1, y + 1 };\r\n\r\n\t\t\tfor (int i = 0; i < 5; i++)\r\n\t\t\t{\r\n\t\t\t\t// da_push( (bodyhash[grids[i].x + grids[i].y * GRIDS_MAX]), poss);\r\n\t\t\t\tif (grids[i].x > 0 && grids[i].y > 0 && grids[i].x + grids[i].y * GRIDS_MAX < GRIDS_MAX * GRIDS_MAX)\r\n\t\t\t\t{\r\n#ifndef VECTOR\r\n#if NORMAL\r\n\t\t\t\t\tda_push((bodyhash[grids[i].x + grids[i].y * GRIDS_MAX]), (poss));\r\n#else\r\n\t\t\t\t\tcollisionBody b = { poss, j };\r\n\t\t\t\t\tda_push((bodyhash[grids[i].x + grids[i].y * GRIDS_MAX]), b);\r\n#endif\r\n#else\r\n\t\t\t\t\tt_bodies[grids[i].x + grids[i].y * GRIDS_MAX].push_back(poss);\r\n#endif\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n}\r\n\r\n\r\n// TODO:\r\n// laita steering toimimaan.\r\n// hahaa.\r\n// hah.\r\n\r\n// if (colliding)\r\n// {\r\n//\t\tnewDirection = this.steerAwayrfromcollisions();\r\n// }\r\n\r\n\r\n// #define for_each_item(item, list) \\\r\n//   for(T * item = list->head; item != NULL; item = item->next)\r\n\r\n#define array_foreach(item, array) \\\r\n    for(int keep = 1, \\\r\n            count = 0,\\\r\n            size = sizeof (array) / sizeof *(array); \\\r\n        keep && count != size; \\\r\n        keep = !keep, count++) \\\r\n      for(item = (array) + count; keep; keep = !keep)\r\n\r\n\r\n#define spatial_foreach(start, end) \\\r\n\tint _startX = (int)start.x / GRID_WIDTH; \\\r\n\tint _startY = (int)start.y / GRID_HEIGHT; \\\r\n \\\r\n\tint _startIndex = int(_startY * GRIDS_MAX + _startX); \\\r\n\tint _endIndex = int(int(end.y / GRID_WIDTH) * GRIDS_MAX + int(end.x / GRID_HEIGHT)); \\\r\n\tLOGI(\"(%i %i)\\n\", _startIndex, _endIndex);\\\r\n \\\r\n\tfor (int i = _startIndex; i < _endIndex; ++i) \\\r\n\t{\t                     \\\r\n\t\tvec4** array = bodyhash[i]; \\\r\n\t\tif (array) \\\r\n\t\t{ \\\r\n\t\t\tint bodyCount = da_size(array); \\\r\n\t\t\tfor (int j = 0; j < bodyCount; ++j)\r\n\r\n#define spatial_getBody() *(array + j); \\\r\n\r\n// double linked-list cell->unit->unit->unit\r\n\r\nvoid doCollisions(RtsGameState* gameState)\r\n{\r\n\tOPEN_MP_DYNAMIC()\r\n\t\tfor (int i = 0; i < GRID_ARRAY_SIZE; ++i)\r\n\t\t{\r\n#if NORMAL\r\n\t\t\tvec4** array = bodyhash[i];\r\n#else\r\n\t\t\tcollisionBody* array = bodyhash[i];\r\n#endif\r\n\t\t\t// array\r\n\t\t\tif (array)\r\n\t\t\t{\r\n\t\t\t\tint bodyCount = da_size(array);\r\n\t\t\t\t//\tauto* vector = &t_bodies[i];\r\n\r\n\t\t\t\tfor (int j = 0; j < bodyCount; ++j)\r\n\t\t\t\t{\r\n\t\t\t\t\t// eka body\r\n#if NORMAL\r\n\t\t\t\t\tvec4* __restrict a = *(array + j);\r\n#else\r\n\t\t\t\t\tvec4* __restrict a = (array + j)->body;// (array)+j;\r\n#endif\r\n\t\t\t\t\tfloat a_half_width = a->w / 2.f;\r\n\t\t\t\t\tVec2 centerPosA = Vec2{ a->x, a->y } +Vec2{ a_half_width, a_half_width };\r\n\r\n#if 0 \r\n\t\t\t\t\tvec2f steeringForce{ };\r\n#endif\r\n\r\n\t\t\t\t\tfor (int k = j + 1; k < bodyCount; ++k)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// toka body\r\n#if NORMAL \r\n\t\t\t\t\t\tvec4* b = *(array + k); // (array) + k;\r\n#else\r\n\t\t\t\t\t\tvec4* b = (array + k)->body; // (array) + k;\r\n#endif\r\n\r\n//\t\t\t\t\thandleCircleCollision(body0, body1);\r\n\r\n\t\t\t\t\t\tconst float MIN_DISTANCE = a_half_width + b->w / 2.f;  // molempiend dist\r\n\t\t\t\t\t\tVec2 centerPosB = Vec2{ b->x, b->y } +Vec2{ b->w / 2.f , b->w / 2.f };\r\n\t\t\t\t\t\tVec2 distVec = centerPosA - centerPosB;\r\n\t\t\t\t\t\tfloat distance = distVec.x * distVec.x + distVec.y * distVec.y;\r\n\r\n\t\t\t\t\t\tif (distance < MIN_DISTANCE * MIN_DISTANCE)\r\n\t\t\t\t\t\t{\r\n#if NORMAL\r\n\t\t\t\t\t\t\tdistVec.normalizeInPlace();\r\n\t\t\t\t\t\t\tdistVec *= a_half_width;\r\n\r\n\t\t\t\t\t\t\tconst Vec2 aResolution = distVec * 0.15f; /// 1.5f; // +=\r\n\t\t\t\t\t\t\ta->x += aResolution.x;\r\n\t\t\t\t\t\t\ta->y += aResolution.y;\r\n\r\n\t\t\t\t\t\t\tconst Vec2 bResolution = distVec * 0.15f; /// 1.5f;  // -=\r\n\t\t\t\t\t\t\tb->x -= bResolution.x;\r\n\t\t\t\t\t\t\tb->y -= bResolution.y;\r\n#else\r\n\r\n\t\t\t\t\t\t\tdistVec.normalizeInPlace();\r\n\r\n\t\t\t\t\t\t\tfloat magnitude;\r\n\t\t\t\t\t\t\tif (distance < MIN_DISTANCE / 2.f) // hard\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tmagnitude = 2.f;\r\n\t\t\t\t\t\t\t\tgameState->entities.COLLISION_TYPES[(array + j)->entityID] = collided_hard;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse // soft\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tmagnitude = 1.f;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t//float enemyForce = 1.f;\r\n\t\t\t\t\t\t\t//if (moving)\r\n\t\t\t\t\t\t\t//\tenemyForce = 2.f;\r\n\r\n\r\n\t\t\t\t\t\t\tCollisionPair pair{ magnitude, distVec };\r\n\t\t\t\t\t\t\tda_push(gameState->entities.collisionPairs[(array + j)->entityID], pair);\r\n\r\n\t\t\t\t\t\t\t/*\tbool* moving = &gameState->entities.moving[(array + j)->entityID];\r\n\t\t\t\t\t\t\t\tif ((*moving) == false)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tvec2f p = { b->x, b->y };\r\n\t\t\t\t\t\t\t\t\tgameState->entities.moveToPosition[(array + j)->entityID] = pair.direction * 20.f + p;\r\n\t\t\t\t\t\t\t\t\t*moving = true;\r\n\t\t\t\t\t\t\t\t}*/\r\n\r\n\t\t\t\t\t\t\tpair.direction.x = -pair.direction.x;\r\n\t\t\t\t\t\t\tpair.direction.y = -pair.direction.y;\r\n\r\n\t\t\t\t\t\t\tda_push(gameState->entities.collisionPairs[(array + k)->entityID], pair);\r\n#endif\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n}\r\n\t\t}\r\n\r\n\t//for (int i = 0; i < gameState->entities.current_count; ++i)\r\n\t//{\r\n\t//\tda_clear(gameState->entities.collisionPairs[i]);\r\n\t//}\r\n\t}\r\n\r\n\r\nvoid debug_RenderFormationInfo(EngineCore* core, RtsGameState* gameState)\r\n{\r\n\tFormation* formation = &gameState->PlayerLastFormation;\r\n\r\n\tvec2f center = formation->formationUnitsCenterPosition;\r\n\tvec2f center1 = formation->formationUnitsMoveToCenterPosition;\r\n\r\n\r\n\tgraphics::setCircle(core->lines, center, formation->formationRadius);\r\n\tgraphics::setCircle(core->lines, center1, formation->formationRadius);\r\n\r\n\r\n\r\n\tfor (int i = 0; i < gameState->rtsController.selectedUnitCount; ++i)\r\n\t{\r\n\t\tint entityId = gameState->rtsController.selectedUnits[i];\r\n\r\n\t\tvec2f position = gameState->entities.moveToPosition[entityId];\r\n\r\n\t\tgraphics::setCircle(core->lines, position, 5.f);\r\n\t}\r\n}\r\n\r\nvoid buildSteeringVelocity(RtsGameState* gameState)\r\n{\r\n\tEntities* ents = &gameState->entities;\r\n\tint count = ents->current_count;\r\n\r\n\r\n\tfor (int i = 0; i < count; ++i)\r\n\t{\r\n\t\tvec2f forceVector{ 0.f, 0.f };\r\n\t\tint collisionCount = da_size(ents->collisionPairs[i]);//ents->collisionTypesCount[i];\r\n\t\tCollisionPair* pairs = ents->collisionPairs[i];\r\n\t\t// vec2f pos0{ ents->positions[i].x, ents->positions[i].y };\r\n\r\n\t\tfor (int j = 0; j < collisionCount; ++j)\r\n\t\t{\r\n\t\t\t// float forceMagnitude; \r\n\t\t\t// vec2f pos1{ ents->positions[i].x, ents->positions[i].y };\r\n\t\t\t// vec2f directionVec = pos0 - pos1;\r\n\t\t\t// directionVec.normalizeInPlace(); // gets calculated twice\r\n\r\n\t\t\t/*switch (ents->collisionTypes[i][j].type)\r\n\t\t\t{\r\n\t\t\tcase collision_hard:\r\n\t\t\t\tforceMagnitude = 2;\r\n\t\t\t\tbreak;\r\n\t\t\tcase collision_soft:\r\n\t\t\t\tforceMagnitude = 1;\r\n\t\t\t\tbreak;\r\n\t\t\tcase collision_attraction:\r\n\t\t\t\tforceMagnitude = -0.25;\r\n\t\t\t\tbreak;\r\n\t\t\t}*/\r\n\r\n\t\t\tforceVector += (pairs[j].direction * pairs[j].magnitude);\r\n\t\t}\r\n\r\n\t\tents->steeringForce[i] = forceVector;\r\n\t\t// ents->vel[i] = forceVector;\r\n\t\tda_clear(ents->collisionPairs[i]);\r\n\t}\r\n}\r\n\r\nvoid stack(RtsGameState* gameState)\r\n{\r\n\tint count = gameState->entities.current_count;\r\n\tauto* ents = &gameState->entities;\r\n\r\n#if 0\r\n\tfor (int i = 0; i < GRID_ARRAY_SIZE; i++)\r\n\t{\r\n#ifndef VECTOR\r\n\t\tda_clear(bodyhash[i])\r\n#else\r\n\t\tt_bodies[i].clear();\r\n#endif\r\n}\r\n#else\r\n\r\n\r\n#endif\r\n\r\n\tSTART_TIMING2();\r\n\t// insertoi pointer oikeisiin ryhmiin\r\n\tfor (int i = 0; i < count; ++i)\r\n\t{\r\n\t\tvec4* poss = &ents->positions[i];\r\n\r\n\t\tint x = int(poss->x / GRID_WIDTH);\r\n\t\tint y = int(poss->y / GRID_HEIGHT);\r\n\r\n\t\t// laske oikeat ruudut\r\n\t\tvec2i grids[5];\r\n\t\tgrids[0] = { x - 1, y - 1 };\r\n\t\tgrids[1] = { x, y - 1 };\r\n\t\tgrids[2] = { x - 1, y };\r\n\t\tgrids[3] = { x, y };\r\n\t\tgrids[4] = { x - 1, y + 1 };\r\n\r\n\t\tfor (int i = 0; i < 5; i++)\r\n\t\t{\r\n\t\t\t// da_push( (bodyhash[grids[i].x + grids[i].y * GRIDS_MAX]), poss);\r\n\t\t\tif (grids[i].x > 0 && grids[i].y > 0 && grids[i].x + grids[i].y * GRIDS_MAX < GRIDS_MAX * GRIDS_MAX)\r\n\t\t\t{\r\n#ifndef VECTOR\r\n\t\t\t\tda_push((bodyhash[grids[i].x + grids[i].y * GRIDS_MAX]), (poss));\r\n#else\r\n\t\t\t\tt_bodies[grids[i].x + grids[i].y * GRIDS_MAX].push_back(poss);\r\n#endif\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t}\r\n\tEND_TIMING2();\r\n}\r\n\r\nstatic inline float getDistanceSqrd(Entities* entities, int first, int second)\r\n{\r\n\tvec2f a = { entities->positions[first].x, entities->positions[first].y };\r\n\tvec2f b = { entities->positions[second].x, entities->positions[second].y };\r\n\tvec2f v = a - b;\r\n\treturn v.x * v.x + v.y * v.y;\r\n}\r\n\r\nstatic void lookForAttackTarget(RtsGameState* gameState, Entities* entities, int entityId)\r\n{\r\n\tint x = int(entities->positions[entityId].x / GRID_WIDTH);\r\n\tint y = int(entities->positions[entityId].y / GRID_HEIGHT);\r\n\tSide mySide = entities->side[entityId];\r\n\r\n\tif (x > 0 && y > 0) // TODO: @IMPORTANT tarkista yla kulmat tai lisaa yhteisiin\r\n\t{\r\n\t\tfor (int i = y - 1; i < y + 1; ++i)\r\n\t\t{\r\n\t\t\tfor (int j = x - 1; j < x + 1; ++j)\r\n\t\t\t{\r\n\t\t\t\tcollisionBody* array = bodyhash[j + i * GRIDS_MAX];\r\n\t\t\t\tif (array)\r\n\t\t\t\t{\r\n\t\t\t\t\tint bodyCount = da_size(array);\r\n\t\t\t\t\tfor (int k = 0; k < bodyCount; ++k)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcollisionBody* body = (array + k);\r\n\t\t\t\t\t\tif (entities->side[body->entityID] != mySide)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// mahdollinen vihollinen\r\n\r\n\t\t\t\t\t\t\tfloat distanceSqrtd = getDistanceSqrd(entities, entityId, body->entityID);\r\n\t\t\t\t\t\t\tif (distanceSqrtd < entities->baseRangeSqrt[entityId])\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tEntityHandle* handle = getHandle(entities, body->entityID);\r\n\r\n\t\t\t\t\t\t\t\tif (EntityHandle* target = entities->target[entityId]) // getHandle(entities, entityId))\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tfreeHandle(entities, target);\r\n\t\t\t\t\t\t\t\t\tentities->target[entityId] = 0;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tentities->target[entityId] = handle;\r\n\t\t\t\t\t\t\t\tentities->state[entityId] = State_Attack;\r\n\t\t\t\t\t\t\t\t// @IMPORTANT: // state changes leak handle\r\n\t\t\t\t\t\t\t\t// Fix: remove func\r\n\t\t\t\t\t\t\t\t// State change func\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic inline void attack(RtsGameState* gameState, Entities* entities, int entityId)\r\n{\r\n\tAttackType type = entities->attackType[entityId];\r\n\r\n\t// voinko hyokata\r\n\t// TODO: hyok timer\r\n\t// WISHLIST: hyok array 'map'\r\n\tif (false)\r\n\t\treturn;\r\n\r\n\t// entities->\r\n\tentities->attackTimer[entityId] -= 1.f / 60.f;\r\n\tif (entities->attackTimer[entityId] > 0.f)      // TODO: proper time\r\n\t\treturn;\r\n\r\n\tconstexpr float defaultTimer = 1.f;\r\n\r\n\tswitch (type)\r\n\t{\r\n\tcase AttackType_Melee:\r\n\t{\r\n\t\tEntityHandle* target = entities->target[entityId];\r\n\r\n\t\tif (target)\r\n\t\t{\r\n\t\t\tif (target->id != DEAD_UNIT && target->id != 0)\r\n\t\t\t{\r\n\t\t\t\t// boom\r\n\t\t\t\tfloat distanceSqrd = getDistanceSqrd(entities, entityId, target->id);\r\n\t\t\t\tif (distanceSqrd < entities->baseRangeSqrt[entityId])\r\n\t\t\t\t{\r\n\t\t\t\t\tentities->attackTimer[entityId] = defaultTimer;\r\n\t\t\t\t\tentities->health[target->id] -= entities->baseDamage[entityId];\r\n\r\n\t\t\t\t\tif (entities->health[target->id] <= 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// d34db33f\r\n\t\t\t\t\t\t// target is dead find new\r\n\r\n\t\t\t\t\t\t// remove target entity\r\n\t\t\t\t\t\tremoveEntity(entities, target->id);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// move closer\r\n\t\t\t\t\tvec2f pos = { entities->positions[target->id].x, entities->positions[target->id].y };\r\n\t\t\t\t\tentities->moveToPosition[entityId] = pos;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// target is dead find new \r\n\t\t\t\t// free attack target handle\r\n\t\t\t\t// ^^ should handle be freed also when changing state?\r\n\r\n\t\t\t\tif (target->id != 0) // TODO: handle leak fix\r\n\t\t\t\t{\r\n\t\t\t\t\tfreeHandle(entities, target);\r\n\t\t\t\t}\r\n\t\t\t\tentities->state[entityId] = State_Attack_move;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// no target ??? / invalid / why are you attacking\r\n\t\t}\r\n\t} break;\r\n\tcase AttackType_Range:\r\n\t{\r\n\t\t// bam\r\n\t} break;\r\n\tdefault:\r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\nstatic bool degug_selectedDebugInfo(EngineCore* core, RtsGameState* gameState)\r\n{\r\n\tRtsController* controller = &gameState->rtsController;\r\n\tEntities* entities = &gameState->entities;\r\n\tImGui::Text(\"Selected count: %i\", controller->selectedUnitCount);\r\n\r\n\tbool result = true;\r\n\r\n\tif (controller->selectedUnitCount > 0)\r\n\t{\r\n\t\tint entityId = controller->selectedUnits[0];\r\n\r\n\t\tresult = ImGui::Begin(\"Selected info\");\r\n\t\tImGui::Text(\"ID: %i\", entityId);\r\n\t\tImGui::Text(\"Pos: (%f, %f)\", entities->positions[entityId].x, entities->positions[entityId].y);\r\n\r\n\t\t{\r\n\t\t\tint state, side, attackType;\r\n\t\t\tstate = entities->state[entityId];\r\n\t\t\tside = entities->side[entityId];\r\n\t\t\tattackType = entities->attackType[entityId];\r\n\r\n\t\t\tImGui::Text(\"State: %s\", StateToStr[state]);\r\n\t\t\tImGui::Text(\"Side: %s\", SideToStr[side]);\r\n\t\t\tImGui::Text(\"AttackType: %s\", AttackTypeToStr[attackType]);\r\n\t\t\tImGui::Text(\"Health %i\", entities->health[entityId]);\r\n\t\t}\r\n\r\n\t\tImGui::End();\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\n\r\n// static vec2f rotate\r\nstatic void updateAoe160k(EngineCore* core, RtsGameState* gameState)\r\n{\r\n\tusing namespace engine;\r\n\r\n\r\n\r\n\r\n\tSTART_TIMING();\r\n\tsetupCollision(gameState);\r\n\tEND_TIMING();\r\n\r\n\tdoCollisions(gameState);\r\n\tbuildSteeringVelocity(gameState);\r\n\r\n\tupdateFloaters(gameState->floatingTexts, gameState->currentFloaters);\r\n\tcalculateVelocities(gameState);\r\n\tupdateEntitys(&gameState->entities);\r\n\r\n\t// END_TIMING();\r\n\r\n\tEntities* entities = &gameState->entities;\r\n\tfor (int i = 0; i < entities->current_count; ++i)\r\n\t{\r\n\t\tswitch (entities->state[i])\r\n\t\t{\r\n\t\tcase State_Attack_move:\r\n\t\t{\r\n\t\t\t// he attac\r\n\t\t\t// looking for targets\r\n\t\t\t// check view list/spatial\r\n\t\t\tlookForAttackTarget(gameState, entities, i);\r\n\r\n\t\t} break;\r\n\t\tcase State_Attack:\r\n\t\t{\r\n\t\t\tattack(gameState, entities, i);\r\n\t\t} break;\r\n\t\t// case State_Move:\r\n\t\t// {\r\n\t\t\t// ei etsit tarketeja\r\n\t\t// } break;\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\r\n\r\n\tVec2 moveVec{};\r\n\tfloat playerSpeed = 1.5f;\r\n\tif (Input::isKeyDown(Keycode::W))\r\n\t{\r\n\t\tmoveVec.y = 1.f;\r\n\t}\r\n\tif (Input::isKeyDown(Keycode::S))\r\n\t{\r\n\t\tmoveVec.y = -1.f;\r\n\t}\r\n\tif (Input::isKeyDown(Keycode::A))\r\n\t{\r\n\t\tmoveVec.x = -1.f;\r\n\t}\r\n\tif (Input::isKeyDown(Keycode::D))\r\n\t{\r\n\t\tmoveVec.x = 1.f;\r\n\t}\r\n\r\n\tif (Input::isKeyPressed(Keycode::SPACE))\r\n\t{\r\n\r\n\t\tFloatingText floater{};\r\n\t\tfloater.position.x = 150.f;\r\n\t\tfloater.position.y = 150.f;\r\n\t\tfloater.vel.y = 4.f;\r\n\t\tfloater.acc = { 0.f, -0.08f };\r\n\t\tstbsp_sprintf(floater.buffer, \"Mobilisoikaa Eetut\");\r\n\r\n\t\tif (gameState->currentFloaters < MAX_FLOATING_TEXT)\r\n\t\t\tgameState->floatingTexts[gameState->currentFloaters++] = floater;\r\n\t}\r\n\r\n\t// POSSESS\r\n\tif (moveVec.x != 0.f || moveVec.y != 0.f)\r\n\t{\r\n\t\tfloat x = abs(moveVec.x);\r\n\t\tfloat y = abs(moveVec.y);\r\n\t\tfloat l = sqrt(x * x + y * y);\r\n\r\n\t\tmoveVec /= l;\r\n\t\tmoveVec *= playerSpeed;\r\n\r\n\r\n\t\tmove(&gameState->entities, gameState->player, &moveVec);\r\n\t}\r\n\r\n\t// player controller\r\n\t{\r\n\t\t// TODO: STATES STATES STATES STATES STATES\r\n\t\tif (gameState->rtsController.placingBuilding)\r\n\t\t{\r\n\t\t\t// place building\r\n\r\n\t\t\tRtsController* controller = &gameState->rtsController;\r\n\t\t\tauto mousePos = Input::getMousePositionWorld(core);\r\n\t\t\tcontroller->placementPosition = worldToGrid(mousePos);\r\n\r\n\t\t\tif (Input::mousePressed(Mouse::Left))\r\n\t\t\t{\r\n\t\t\t\tvec2i* pos = &controller->placementPosition;\r\n\t\t\t\tif (!tilesBlocked(&gameState->tilemap, pos->x, pos->y, controller->buildingSize))\r\n\t\t\t\t{\r\n\t\t\t\t\t// laita rakennus\r\n\t\t\t\t\tblockTiles(&gameState->tilemap, pos->x, pos->y, controller->buildingSize);\r\n\r\n\t\t\t\t\t// vec2f position = { (float)pos->x, (float)pos->y };\r\n\t\t\t\t\tvec2f position = { pos->x * TILE_SIZE, pos->y * TILE_SIZE };\r\n\t\t\t\t\tInitializer init;\r\n\t\t\t\t\tinit.buildingType = controller->placementBuildingType;\r\n\r\n\t\t\t\t\tcreateEntity(&gameState->entities, &position, Type_building, &init);\r\n\r\n\t\t\t\t\tcontroller->placingBuilding = false;\r\n\t\t\t\t\tcontroller->buildingSize = { 0, 0 };\r\n\t\t\t\t\tcontroller->placementBuildingType = Building_type::noBuilding;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (Input::mousePressed(Mouse::Left))\r\n\t\t\t{\r\n\t\t\t\tgameState->rtsController.onClickPosition = Input::getMousePositionWorld(core);\r\n\t\t\t}\r\n\t\t\tif (Input::mouseDown(Mouse::Left))\r\n\t\t\t{\r\n\t\t\t\tgameState->rtsController.dragging = true;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (gameState->rtsController.dragging)\r\n\t\t\t\t{\r\n\t\t\t\t\t// Units selected !!!\r\n\t\t\t\t\tselectUnits(gameState, core);\r\n\t\t\t\t}\r\n\t\t\t\tgameState->rtsController.dragging = false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tif (Input::mousePressed(Mouse::Right))\r\n\t\t{\r\n\t\t\tRtsController* controller = &gameState->rtsController;\r\n\t\t\tint count = controller->selectedUnitCount;\r\n\r\n\t\t\tvec2f mousePosition = Input::getMousePositionWorld(core);\r\n\t\t\tsetMovePosition(gameState, controller->selectedUnits, count, mousePosition);\r\n\t\t}\r\n\r\n\t\tif (Input::mousePressed(Mouse::Right))\r\n\t\t{\r\n\t\t\tRtsController* controller = &gameState->rtsController;\r\n\t\t\tcontroller->draggingArrow = true;\r\n\t\t\tcontroller->rightClickPosition = Input::getMousePositionWorld(core);\r\n\t\t}\r\n\r\n\t\tif (Input::mouseDown(Mouse::Right))\r\n\t\t{\r\n\t\t\t// first\r\n\t\t\tRtsController* controller = &gameState->rtsController;\r\n\t\t\tcontroller->draggingArrow = true;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// dragging direction / move\r\n\t\t\tRtsController* controller = &gameState->rtsController;\r\n\r\n\t\t\tif (controller->draggingArrow)\r\n\t\t\t{\r\n\t\t\t\tint selectedCount = controller->selectedUnitCount;\r\n\t\t\t\tint rows = 3;\r\n\t\t\t\tint perLineMininum = 15;\r\n\r\n\t\t\t\tint lines = selectedCount / perLineMininum;\r\n\r\n\t\t\t\tint perRow = 400;\r\n\r\n\t\t\t\t// calc direction\r\n\t\t\t\tvec2f mouseEnd = Input::getMousePositionWorld(core);\r\n\t\t\t\tvec2f directionVector = mouseEnd - controller->rightClickPosition;\r\n\r\n\t\t\t\t// graphics::drawLine(core->lines)\r\n\r\n\t\t\t\tdirectionVector.normalizeInPlace();\r\n\t\t\t\tvec2f n90degrees = { -directionVector.y, directionVector.x }; // -y, x | y, -x\r\n\r\n\r\n\t\t\t\tfloat perone = 30.f;\r\n#if 0\r\n\t\t\t\tfloat startBase = -(((float)selectedCount / (float)perRow * perone / 2.f));\r\n\t\t\t\tfloat startPosition = startBase;\r\n\t\t\t\tfloat offset = perone;//startPosition * perfunction  endone / selectedCount;\r\n#else\r\n\r\n\t\t\t\t// formation height = avaible per line * perone\r\n\r\n\r\n\t\t\t\tfloat   avaiblePerLine = (float)selectedCount / (float)perRow;\r\n\t\t\t\tfloat formationHeight = perone * perRow;\r\n\t\t\t\tif (avaiblePerLine < 1.f)\r\n\t\t\t\t{\r\n\t\t\t\t\t// formationHeight *= avaiblePerLine;\r\n\t\t\t\t\tformationHeight = selectedCount * perone;\r\n\t\t\t\t}\r\n\t\t\t\tfloat hheight = -(formationHeight / 2.f);\r\n\t\t\t\tfloat startPosition = hheight;\r\n#endif\r\n\r\n\t\t\t\tvec2f linePosition = controller->rightClickPosition;\r\n\r\n\t\t\t\tfor (int i = 0, j = 0; i < selectedCount; ++i, ++j)\r\n\t\t\t\t{\r\n\t\t\t\t\tvec2f pos = linePosition + (n90degrees * (startPosition + j * perone));\r\n\t\t\t\t\tint entityId = controller->selectedUnits[i];\r\n\t\t\t\t\tgameState->entities.moveToPosition[entityId] = pos;\r\n\r\n\t\t\t\t\tif (i % perRow == 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// uusi rivi \t\t\t\t\t\t\r\n\t\t\t\t\t\tj = 0;\r\n\t\t\t\t\t\tlinePosition += directionVector * perone;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tcontroller->draggingArrow = false;\r\n\t\t}\r\n\r\n\r\n\t\t// TODO: HAZARD\r\n\t\tif (Input::mouseDown(Mouse::Middle))\r\n\t\t{\r\n\t\t\t// prei some units\r\n\t\t\tauto mouse = Input::getMousePositionWorld(core);\r\n#if 0\r\n\t\t\tfor (int i = 0; i < 16; ++i)\r\n\t\t\t{\r\n\t\t\t\tvec2f newPos = { mouse.x + RandomFloat(-20.f, 20.f), mouse.y + i * 4.f };\r\n\t\t\t\tcreateEntity(&gameState->entities, 0, &newPos);\r\n\t\t}\r\n#endif\r\n\t\t\t// setMovePosition(gameState, gameState->rtsController.selectedUnits, gameState->rtsController.selectedUnitCount, mouse);\r\n\t\t\tRtsController* controller = &gameState->rtsController;\r\n\t\t\tsetGroupMovePosition(gameState, controller->selectedUnits, controller->selectedUnitCount, mouse);\r\n\r\n\t\t\tState moveState;\r\n\t\t\tif (Input::isKeyDown(Keycode::LCTRL))\r\n\t\t\t{\r\n\t\t\t\tmoveState = State_Attack_move;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tmoveState = State_Move;\r\n\t\t\t}\r\n\r\n\t\t\tfor (int i = 0; i < controller->selectedUnitCount; ++i)\r\n\t\t\t{\r\n\t\t\t\tint entityId = controller->selectedUnits[i];\r\n\t\t\t\tentities->state[entityId] = moveState;\r\n\t\t\t}\r\n\t}\r\n\r\n\t\tbool lctrlPressed = Input::isKeyDown(Keycode::LCTRL);\r\n\t\tif (lctrlPressed && Input::isKeyPressed(Keycode::NUM_1))\r\n\t\t{\r\n\t\t\tRtsController* controller = &gameState->rtsController;\r\n\t\t\tfor (int i = 0; i < controller->selectedUnitCount; ++i)\r\n\t\t\t{\r\n\t\t\t\tint entityId = controller->selectedUnits[i];\r\n\t\t\t\tgameState->entities.side[entityId] = Side_Player;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (lctrlPressed && Input::isKeyPressed(Keycode::NUM_2))\r\n\t\t{\r\n\t\t\tRtsController* controller = &gameState->rtsController;\r\n\t\t\tfor (int i = 0; i < controller->selectedUnitCount; ++i)\r\n\t\t\t{\r\n\t\t\t\tint entityId = controller->selectedUnits[i];\r\n\t\t\t\tgameState->entities.side[entityId] = Side_0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (Input::isKeyPressed(Keycode::U))\r\n\t\t{\r\n\t\t\tLOGI(\"place building\");\r\n\t\t\tRtsController* controller = &gameState->rtsController;\r\n\t\t\tcontroller->buildingSize = { 3, 3 };\r\n\t\t\tcontroller->placingBuilding = true;\r\n\t\t\tcontroller->placementBuildingType = Building_type::Ballista;\r\n\t\t}\r\n\t\tif (Input::isKeyPressed(Keycode::H))\r\n\t\t{\r\n\t\t\tLOGI(\"place turret\");\r\n\t\t\tRtsController* controller = &gameState->rtsController;\r\n\t\t\tcontroller->buildingSize = { 3, 3 };\r\n\t\t\tcontroller->placingBuilding = true;\r\n\t\t\tcontroller->placementBuildingType = Building_type::Barrack;\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\tvec2f start{ 0.f, 0.f };\r\n\t\tvec2f end{ 6800.f, 3000.f };\r\n\t\tint count = 0;\r\n\t\tspatial_foreach(start, end)\r\n\t\t\t++count;\r\n\t\t}\r\n\t\tLOGI(\"COUNT %i \\n\", count); */\r\n}\r\n}\r\n\r\nstatic void drawAoe160k(EngineCore* core, RtsGameState* gameState)\r\n{\r\n\tusing namespace engine;\r\n\tauto layer = &core->layers[0];\r\n\r\n\t{\r\n\t\tRtsController* controller = &gameState->rtsController;\r\n\t\tif (controller->placingBuilding)\r\n\t\t{\r\n\r\n\t\t\tlayer->setTexture(engine::getTexture(core->resources, textures::Texture_Block)->ID);\r\n\r\n\t\t\tstatic vec4 defaultUv{ 0.f, 0.f, 1.f, 1.0f };\r\n\t\t\tstatic vec4 color{ 9.f / 255.f, 130.f / 255.f, 40.f / 255.f, 70.f / 255.f };\r\n\r\n\t\t\tint startX, startY, endX, endY;\r\n\t\t\tstartX = controller->placementPosition.x;\r\n\t\t\tstartY = controller->placementPosition.y;\r\n\t\t\tendX = controller->placementPosition.x + controller->buildingSize.x;\r\n\t\t\tendY = controller->placementPosition.y + controller->buildingSize.y;\r\n\t\t\tfor (int i = startY; i < endY; ++i)\r\n\t\t\t{\r\n\t\t\t\tfor (int j = startX; j < endX; ++j)\r\n\t\t\t\t{\r\n\t\t\t\t\tvec4 position{ float(j * TILE_SIZE), float(i * TILE_SIZE), TILE_SIZE, TILE_SIZE };\r\n\t\t\t\t\tlayer->draw(&position, &defaultUv, &color);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tlayer->setTexture(engine::getTexture(core->resources, textures::Texture_infantry)->ID);\r\n\tdrawEntities(&gameState->entities, core);\r\n\r\n\tfor (int i = 0; i < gameState->currentFloaters; i++)\r\n\t{\r\n\t\tFloatingText* floater = &gameState->floatingTexts[i];\r\n\t\tlayer->drawString(floater->buffer, &floater->position, 0xFFFFFFFF, 0);\r\n\t}\r\n\r\n\r\n\tint playerId = gameState->player;\r\n\tvec4* posSize = &gameState->entities.positions[playerId];\r\n\tgraphics::drawBox(core->lines, posSize);\r\n\r\n#ifndef __EMSCRIPTEN__\r\n\tImGui::Text(\"current count %i \", gameState->entities.current_count);\r\n#endif\r\n\r\n\r\n\t// Player controller\r\n\t{\r\n\t\tif (gameState->rtsController.dragging)\r\n\t\t{\r\n\t\t\tvec4 selectionRect = getSelectionRect(gameState, core);\r\n\t\t\tgraphics::drawBox(core->lines, selectionRect);\r\n\t\t}\r\n\r\n\r\n\t\tif (gameState->rtsController.draggingArrow)\r\n\t\t{\r\n\t\t\tvec2f mouseEnd = Input::getMousePositionWorld(core);\r\n\t\t\tgraphics::drawLine(core->lines, &gameState->rtsController.rightClickPosition, &mouseEnd);\r\n\t\t}\r\n\r\n\t\tupdateBuildingSelection(gameState, core);\r\n\t}\r\n\r\n\t//for (int i = 0; i < 100; i++)\r\n\t//{\r\n\t//\tgraphics::drawPoint(core->points, Vec2{ i * 10.f, 10.f });\r\n\t//}\r\n\r\n\r\n//constexpr float GRID_WIDTH = 40.f;\r\n//constexpr float GRID_HEIGHT = 40.f;\r\n//\r\n//constexpr int GRIDS_X = 60;\r\n//constexpr int GRIDS_Y = 60;\r\n\r\n\t{\r\n\t\tvec4 p{ 0.f, 0.f, GRID_WIDTH * GRIDS_MAX, GRID_HEIGHT * GRIDS_MAX };\r\n\t\tgraphics::drawBox(core->lines, p);\r\n\t}\r\n\r\n\r\n\r\n\r\n\t// DEBUG LAYER \r\n\r\n\t{\r\n#ifndef __EMSCRIPTEN__\r\n#ifndef NO_DEBUG\r\n\t\tstatic bool debugVisibilityGrid = false;\r\n\t\tstatic bool debugEntityBodies = true;\r\n\t\tstatic bool debugEntitySteeringForce = true;\r\n\t\tstatic bool debugFormation = true;\r\n\t\tstatic bool selectedDebugInfo = true;\r\n\t\tstatic bool debugmapGrid = true;\r\n#else\r\n\t\tstatic bool debugVisibilityGrid = false;\r\n\t\tstatic bool debugEntityBodies = false;\r\n#endif\r\n\r\n\t\tif (debugVisibilityGrid)\r\n\t\t\tdebug_RenderVisibilityGrid(core, gameState);\r\n\r\n\t\tif (debugEntityBodies)\r\n\t\t\tdebug_RenderEntitys(core, &gameState->entities);\r\n\r\n\t\tif (debugEntitySteeringForce)\r\n\t\t\tdebug_RenderSteeringForce(core, &gameState->entities);\r\n\r\n\t\tif (debugFormation)\r\n\t\t\tdebug_RenderFormationInfo(core, gameState);\r\n\r\n\t\tif (selectedDebugInfo)\r\n\t\t\tselectedDebugInfo = degug_selectedDebugInfo(core, gameState);\r\n\r\n\r\n\r\n\t\tif (debugmapGrid)\r\n\t\t{\r\n\t\t\tvec4 camera = camera::cameraRect(core);\r\n\t\t\tdebug_RenderCollisionGrid(core, &gameState->tilemap, &camera, layer);\r\n\t\t}\r\n\r\n\t\tlayer->setTexture(engine::getTexture(core->resources, textures::Texture_Block)->ID);\r\n\r\n\t\tImGui::Checkbox(\"Visibility Grid\", &debugVisibilityGrid);\r\n\t\tImGui::Checkbox(\"Entity collision bodies\", &debugEntityBodies);\r\n\t\tImGui::Checkbox(\"Entity steering force\", &debugEntitySteeringForce);\r\n\t\tImGui::Checkbox(\"Formation debug info\", &debugFormation);\r\n\t\tImGui::Checkbox(\"Selected unit debug info\", &selectedDebugInfo);\r\n\t\tImGui::Checkbox(\"Show Tilemap collisions\", &debugmapGrid);\r\n\r\n\t\t// Info\r\n\t\tvec2f mousePos = Input::getMousePositionWorld(core);\r\n\t\tImGui::Text(\"MousePosition (%f, %f)\", mousePos.x, mousePos.y);\r\n#endif\r\n\t}\r\n\r\n\r\n\r\n\t// TEST STUFF??????????????????????????\r\n\r\n\r\n\t//Vec2 p0{ 10.f, 10.f };\r\n\t//Vec2 p1{ 100.f, 10.f };\r\n\t//graphics::drawLine(core->lines, &p0, &p1);\r\n\t//graphics::setCircle(core->lines, { 40.f, 40.f }, 40.f);\r\n\t//graphics::setCircle(core->lines, { 80.f, 80.f }, 40.f);\r\n\r\n\r\n\t//static float timer = 0.f;\r\n\t//static int iCounter = 0;\r\n\r\n\t//p0 = { 0.f, -100.f };\r\n\t//int startI = iCounter;\r\n\t//for (int i = 0, j = iCounter; i < 100; i++, j--)\r\n\t//{\r\n\t//\tp0.y = -100.f + pow((7 * sin(timer) * cos(i + 0.1f / j + 0.1f)), 2);\r\n\t//\tif (j < 50 && j > 2)\r\n\t//\t\tgraphics::setCircle(core->lines, p0, (float)j);\r\n\t//\tp0.x += float(i * 2.f + 5.f + sqrt(i));\r\n\r\n\t//\tif (j == 100 || j == -1)\r\n\t//\t\tj = 0;\r\n\t//}\r\n\t//timer += 0.01f;\r\n\r\n\t//static int c = 0;\r\n\t//c++;\r\n\t//if (c == 10)\r\n\t//{\r\n\t//\tiCounter += 1;\r\n\t//\tc = 0;\r\n\t//}\r\n\r\n\t//if (iCounter >= 100)\r\n\t//\tiCounter = 0;\r\n\r\n\r\n\t// ImGui::text()\r\n\r\n\t/*for (int i = 0; i < 200; i += 50)\r\n\t{\r\n\t\tVec2 position{ 250, 250 };\r\n\t\tposition.y = (float)i;\r\n\t\tlayer->drawString(\"haha\", &position, 0xFFFFFFFF, 0);\r\n\t}*/\r\n}\r\n\r\n/**************************/\r\n// tiilet\r\n// rakennukset - entityt\r\n// entityt on pakko sortata z:tan mukaan koska rakennukset\r\n/**************************/\r\n","#define _CRT_SECURE_NO_WARNINGS 1\r\n\r\n// no no no no no no no no no no no no no no no no \r\n// no no no no no no no no no no no no no no no no \r\n// no no no no no no no no no no no no no no no no \r\n// #include \"../Imgui/imgui_draw.cpp\"\r\n// #include \"../Imgui/imgui.cpp\"\r\n\r\nstruct vec2i { int x, y; };\r\n\r\n#include \"../Imgui/imgui.h\"\r\n\r\n// static vec2f rotateVec(vec2f* vec, float theta);\r\n\r\nnamespace engine {\r\n\tnamespace io {\r\n\t\tchar* ReadEntireFile(const char* path);\r\n\t\tchar* ReadEntireFile(const char* path, int* count);\r\n\t}\r\n}\r\n\r\nstatic float game_time = 0.0f;\r\nstatic inline float getCurrentTime() {\r\n\treturn game_time;\r\n}\r\n#include \"game.h\"\r\n#include \"Entity.h\"\r\n\r\n#define DLL_FIX 1\r\n\r\n#if !__EMSCRIPTEN__\r\n#include \"../IO.cpp\"\r\n#include \"../platform.cpp\"\r\n#endif\r\n\r\n#include <stdio.h>\r\n#include \"meta.cpp\"\r\n\r\n#include \"tetris.cpp\"\r\n#include \"aoe160k.cpp\"\r\n\r\n#define EK_CONSOLE_IMPL\r\n#include \"console.h\"\r\n\r\n// push engine stuff \r\n// push game stuff\r\n// pop game\r\n\r\n// game jne...\r\n\r\n// omille systeemeille isoissa peleiss oma rand !!!\r\n// oikeassa releasessa seedaa rand!\r\nvoid reSeedRandom()\r\n{\r\n\t// srand(20); // LOL\r\n\t// for (int i = 0; i < 16; i++)\r\n\t// {\r\n\t\t// state[i] = rand();\r\n\t// }\r\n\tstate[0] = 1245125;\r\n\tstate[1] = 2309541724;\r\n\tstate[2] = 1093247;\r\n\tstate[3] = 12286LL;\r\n\tstate[4] = 2238456;\r\n\tstate[5] = 56082243;\r\n\tstate[6] = 23425;\r\n\tstate[7] = 1;\r\n\tstate[8] = 2354100;\r\n\r\n\tsrand(0);\r\n\tfor (int i = 9; i < 16; i++)\r\n\t{\r\n\t\tstate[i] = i + rand() % i;\r\n\t}\r\n\r\n\tr_index = 0;\r\n}\r\n\r\nEXPORT ON_PLAYBACK_START(startPlayback)\r\n{\r\n\treSeedRandom();\r\n}\r\n\r\nvoid initTetris(EngineCore* core, TetrisGameState* gameState, memory_arena* arena)\r\n{\r\n\tfor (int i = 0; i < ArrayCount(gameState->timers); i++)\r\n\t{\r\n\t\tgameState->timers[i].init(2);\r\n\t}\r\n\tgameState->timers[3].init(20);\r\n\r\n\tgameState->tetris.countOfKasvava = 5;\r\n\tgameState->tetris.olenKasvava = PushArray(arena, 5, int);\r\n\r\n\tfor (int i = 0; i < 5; i++)\r\n\t\tgameState->tetris.olenKasvava[i] = i + 1;\r\n\r\n\tgameState->tetris.olenStaattinen = PushArray(arena, 10, int);\r\n\r\n\tfor (int i = 0; i < 10; i++)\r\n\t{\r\n\t\t*(gameState->tetris.olenStaattinen + i) = i;\r\n\t}\r\n\r\n\tgameState->tetris.olenYksittainen = &gameState->tetris.countOfKasvava;\r\n\r\n\tgameState->playerPos = { 100.f, 100.f, 30.f, 30.f };\r\n\tinitBoard(&gameState->tetris, arena);\r\n}\r\n\r\n#define InitializeGameState(core, gameState, type) \\\r\n\tgameState->memory.InitalizeArena(core->memory->permanentStorageSize - sizeof(type), \\\r\n\t\t(uint8_t *)core->memory->permanentStorage + sizeof(type));\r\n\r\n\r\n\r\nvoid initGame(EngineCore* core)\r\n{\r\n\tswitch (core->currentGame)\r\n\t{\r\n\tcase Game_jam_game:\r\n\t\tjam_init(core, (JamState*)core->memory->permanentStorage);\r\n\t\tbreak;\r\n\tcase Game_aoe160k:\r\n\t\tinitAoe160k(core, (RtsGameState*)core->memory->permanentStorage);\r\n\t\tbreak;\r\n\tcase Game_tetris:\r\n\t\tinitTetris(core, (TetrisGameState*)core->memory->permanentStorage, core->arena);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\n\r\nvoid initMemory(EngineCore* core, memory_arena* arena)\r\n{\r\n\tcore->layers = PushArray(arena, 8, Layer);\r\n\tcore->layers[0] = newLayer(10000, 0);\r\n\tcore->layers[0].active = true;\r\n\r\n\tcore->layers[1] = newLayer(90000, 1);\r\n\tcore->layers[1].active = true;\r\n\r\n\tcore->layers[2] = newLayer(40000, 1);\r\n\tcore->layers[2].active = true;\r\n\r\n\t// for (int i = 3; i < 5; ++i)\r\n\t// {\r\n\t\t// core->layers[i] = newLayer(100, 1);\r\n\t// }\r\n\r\n\tcore->layers[3] = newLayer(1000, 1);\r\n\tcore->layers[3].active = true;\r\n\r\n\tcore->layerCount = 3;\r\n}\r\n\r\nEXPORT INIT_GAME(initGame)\r\n{\r\n\tRtsGameState* gameState = (RtsGameState*)memory->permanentStorage;\r\n\r\n\t// gameState->memory.InitalizeArena(core->memory->permanentStorageSize - sizeof(TetrisGameState),\r\n\t//\t(uint8_t *)core->memory->permanentStorage + sizeof(TetrisGameState));\r\n\tInitializeGameState(core, gameState, RtsGameState);\r\n\r\n\tmemory_arena* arena = &gameState->memory;\r\n\tcore->arena = arena;\r\n\r\n\tLOGI(\"Init game memory \\n\");\r\n\t{\r\n\t\tmemory->isInitialized = true;\r\n\t}\r\n\r\n\tengine::Input::setContext(core->inputData);\r\n\tg_log = core->log;\r\n\r\n\tcore->currentGame = defaultGame;\r\n\tinitGame(core);\r\n\r\n\tinitMemory(core, arena);\r\n\r\n\treSeedRandom();\r\n}\r\n\r\n\r\n// TODO: optimoi tyhmat poit !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\nvoid dumpStruct(Uint32 memberCount, member_definition* memberData, void* structPtr, int intendLevel);\r\nvoid dumpToImgui(member_definition* member, void* memberPtr, int index, int intendLevel = 0)\r\n{\r\n\tswitch (member->type)\r\n\t{\r\n\tcase MetaType_int:\r\n\tcase MetaType_Block:\r\n\t{\r\n\t\tImGui::AlignTextToFramePadding();\r\n\r\n\t\t// ImGui::Bullet();\r\n\r\n\t\tchar label[64];\r\n\t\tsprintf(label, \"%i\", index);\r\n\t\t// ImGui::LabelText();\r\n\t\t// ImGui::Selectable(label);\r\n\t\tImGui::Text(label);\r\n\t\tImGui::NextColumn();\r\n\t\tImGui::PushItemWidth(-1);\r\n\r\n\t\tImGui::InputInt(\"\", ((int*)memberPtr + index)); // index or smt\r\n\r\n\t\tImGui::PopItemWidth();\r\n\t\tImGui::NextColumn();\r\n\t} break;\r\n\tcase MetaType_float:\r\n\r\n\t\tImGui::AlignTextToFramePadding();\r\n\t\tchar label[64];\r\n\t\tsprintf(label, \"%i\", index);\r\n\t\tImGui::Text(label);\r\n\t\tImGui::NextColumn();\r\n\t\tImGui::PushItemWidth(-1);\r\n\r\n\t\tImGui::InputFloat(\"\", ((float*)memberPtr + index)); // index or smt\r\n\r\n\t\tImGui::PopItemWidth();\r\n\t\tImGui::NextColumn();\r\n\r\n\r\n\t\t// _snprintf_s(textBuffer, textBufferLeft, textBufferLeft, \"%s: %f \", member->name, *(float *)memberPtr);\r\n\t\t// ImGui::InputFloat(member->name, ((float *)memberPtr + index));\r\n\t\t// ImGui::SliderFloat(member->name, ((float *)memberPtr));\r\n\t\tbreak;\r\n\tcase MetaType_Vec2:\r\n\t{\r\n\t\tImGui::AlignTextToFramePadding();\r\n\t\tchar label[64];\r\n\t\tsprintf(label, \"%i\", index);\r\n\t\tImGui::Text(label);\r\n\t\tImGui::NextColumn();\r\n\t\tImGui::PushItemWidth(-1);\r\n\r\n\t\tImGui::DragFloat2(\"\", ((float*)memberPtr + index * 2)); // index or smt\r\n\r\n\t\tImGui::PopItemWidth();\r\n\t\tImGui::NextColumn();\r\n\t} break;\r\n\r\n\t// TODO: complexsit tyypit kutsuvat dump imguita uudestaan!!!\r\n\r\n\tdefault:\r\n\t\tASSERT(false); // implementaatio puuttu metatyypilt\r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\nvoid showArray(member_definition* member, void* memberPtr, int count)\r\n{\r\n\tif (ImGui::TreeNode(member->name)) // blocks\r\n\t{\r\n\t\tImGui::TreePush();\r\n\r\n\t\tImGuiListClipper clipper(count);\r\n\t\tclipper.Begin(count);\r\n\r\n\t\tImGui::NextColumn();\r\n\t\tImGui::NextColumn();\r\n\r\n\t\twhile (clipper.Step())\r\n\t\t{\r\n\t\t\t// ImGui::Text(\"yolo\");\r\n\t\t\tfor (int i = clipper.DisplayStart; i < clipper.DisplayEnd; ++i)\r\n\t\t\t{\r\n\t\t\t\tImGui::PushID(i);\r\n\t\t\t\tdumpToImgui(member, memberPtr, i); // members\r\n\t\t\t\tImGui::PopID();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tImGui::TreePop();\r\n\t\tImGui::TreePop();\r\n\r\n\t\tImGui::Separator();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tImGui::NextColumn();\r\n\t\tImGui::NextColumn();\r\n\t}\r\n\t// ImGui::Columns();\r\n\t// ImGui::Separator();\r\n\t// ImGui::Spacing();\r\n\t// ImGui::Spacing();\r\n}\r\n\r\nvoid dumpStruct(Uint32 memberCount, member_definition* memberData, void* structPtr, int intendLevel = 0)\r\n{\r\n\t// char buffer[512];\r\n\tfor (u32 memberIndex = 0; memberIndex < memberCount; ++memberIndex)\r\n\t{\r\n\t\tchar TextBufferBase[256];\r\n\t\tchar *textBuffer = TextBufferBase;\r\n\t\tfor (int intend = 0; intend < intendLevel; ++intend)\r\n\t\t{\r\n\t\t\t*textBuffer++ = ' ';\r\n\t\t\t*textBuffer++ = ' ';\r\n\t\t\t*textBuffer++ = ' ';\r\n\t\t\t*textBuffer++ = ' ';\r\n\t\t}\r\n\t\ttextBuffer[0] = 0;\r\n\r\n\t\tmember_definition* member = memberData + memberIndex;\r\n\t\tvoid *memberPtr = (((uint8_t *)structPtr) + member->offset);\r\n\r\n\t\tif (member->flags & MetaMemberFlag_IsPointer)\r\n\t\t{\r\n\t\t\tmemberPtr = *(void **)memberPtr;\r\n\t\t}\r\n\r\n\t\tif (member->flags & MetaMemberFlag_IsArray)\r\n\t\t{\r\n\t\t\t// WARNING: tarkista toimivuus\r\n\t\t\tint n = int((int64_t)(member->pointerData));\r\n\t\t\t// showArray(member, memberPtr, n);\r\n\t\t}\r\n\t\tif (member->flags & MetaMemberFlag_IsArrayPointer)\r\n\t\t{\r\n\t\t\tmemberPtr = *(void **)memberPtr;\r\n\r\n\t\t\t// float* test1 = (float*)memberPtr;\r\n\t\t\t// float* test2 = *(float**)memberPtr;\r\n\r\n\t\t\tint n = (int)(int64_t)(member->pointerData);\r\n\t\t\tshowArray(member, memberPtr, n);\r\n\t\t}\r\n\t\telse if (member->flags & MetaMemberFlag_IsDynamicPointer)\r\n\t\t{\r\n\t\t\tmemberPtr = *(void **)memberPtr;\r\n\r\n\t\t\tint offset = (unsigned int)(uint64_t)member->pointerData;\r\n\r\n\t\t\tvoid* n = (((uint8_t *)structPtr) + offset);\r\n\t\t\tint count = *((int*)n);\r\n\r\n\t\t\tshowArray(member, memberPtr, count);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tchar label[64]; //fix\r\n\t\t\tif (memberPtr)\r\n\t\t\t{\r\n\t\t\t\tImGui::PushID(memberIndex);\r\n\t\t\t\t// int textBufferLeft = TextBufferBase + sizeof(TextBufferBase) - textBuffer;\r\n\t\t\t\t// strcpy(label, member->name);\r\n\t\t\t\t// ImGui::Text();\r\n\r\n\t\t\t\tswitch (member->type)\r\n\t\t\t\t{\r\n\t\t\t\tcase MetaType_bool32:\r\n\t\t\t\t\t// _snprintf_s(textBuffer, textBufferLeft, textBufferLeft, \"%s: %b \", member->name, *(Uint32 *)memberPtr);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase MetaType_int:\r\n\t\t\t\t\t// _snprintf_s(textBuffer, textBufferLeft, textBufferLeft, \"%s: %i \", member->name, *(int *)memberPtr);\r\n\t\t\t\t\t// ImGui::InputInt(member->name, ((int *)memberPtr));\r\n\r\n\t\t\t\t\tImGui::AlignTextToFramePadding();\r\n\t\t\t\t\t// ImGui::Bullet();\r\n\t\t\t\t\tsprintf(label, \"%s\", member->name);\r\n\t\t\t\t\t// ImGui::LabelText();\r\n\t\t\t\t\t// ImGui::Selectable(label);\r\n\t\t\t\t\tImGui::Text(label);\r\n\t\t\t\t\tImGui::NextColumn();\r\n\t\t\t\t\tImGui::PushItemWidth(-1);\r\n\r\n\t\t\t\t\tImGui::InputInt(\"\", ((int*)memberPtr + 0)); // index or smt\r\n\r\n\t\t\t\t\tImGui::PopItemWidth();\r\n\t\t\t\t\tImGui::NextColumn();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase MetaType_float:\r\n#if 0\r\n\t\t\t\t\t// _snprintf_s(textBuffer, textBufferLeft, textBufferLeft, \"%s: %f \", member->name, *(float *)memberPtr);\r\n\t\t\t\t\tImGui::InputFloat(member->name, ((float *)memberPtr));\r\n\t\t\t\t\t// ImGui::SliderFloat(member->name, ((float *)memberPtr));\r\n#else\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tImGui::AlignTextToFramePadding();\r\n\t\t\t\t\t\t// ImGui::Bullet();\r\n\t\t\t\t\t\t// char label[64];\r\n\t\t\t\t\t\tsprintf(label, \"%s\", member->name);\r\n\t\t\t\t\t\t// ImGui::LabelText();\r\n\t\t\t\t\t\t// ImGui::Selectable(label);\r\n\t\t\t\t\t\tImGui::Text(label);\r\n\t\t\t\t\t\tImGui::NextColumn();\r\n\t\t\t\t\t\tImGui::PushItemWidth(-1);\r\n\r\n\t\t\t\t\t\tImGui::DragFloat(\"\", ((float*)memberPtr + 0)); // index or smt\r\n\r\n\t\t\t\t\t\tImGui::PopItemWidth();\r\n\t\t\t\t\t\tImGui::NextColumn();\r\n\t\t\t\t\t}\r\n#endif\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase MetaType_uint32:\r\n\t\t\t\t\t// _snprintf_s(textBuffer, textBufferLeft, textBufferLeft, \"%s: %i \", member->name, *(Uint32 *)memberPtr);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tMETA_HANDLE_TYPE_DUMD(memberPtr, intendLevel + 1)\r\n\r\n\t\t\t\t\t\t/*case MetaType_v3:\r\n\t\t\t\t\t\t\tDEbugdumpt suct ( Arraycount membersof v3,  membesfof ve3,\r\n\t\t\t\t\t\t\t\tmemberptr\r\n\t\t\t\t\t\t} break;*/\r\n\t\t\t\t}\r\n\t\t\t\t// ImGui::Text(\"%s\", textBuffer);\r\n\t\t\t\t// printf(\"%s\\n\", textBuffer);\r\n\t\t\t\tImGui::PopID();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n#define SAVEFILE \"assets/data/world.dat\"\r\nvoid serializeGamestate(TetrisGameState* gameState)\r\n{\r\n\tFILE* saveFile = fopen(SAVEFILE, \"wb\");\r\n\tif (saveFile)\r\n\t{\r\n\t\tfwrite(gameState, sizeof(TetrisGameState), 1, saveFile);\r\n\t\tfclose(saveFile);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tASSERT(false);\r\n\t}\r\n}\r\nvoid serializeGamestate(RtsGameState* gameState)\r\n{\r\n\tFILE* saveFile = fopen(SAVEFILE, \"wb\");\r\n\tif (saveFile)\r\n\t{\r\n\t\tfwrite(gameState, sizeof(RtsGameState), 1, saveFile);\r\n\t\tfclose(saveFile);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tASSERT(false);\r\n\t}\r\n}\r\n// union Entity\r\n// {\r\n//\t\ttype:\r\n//\t\tx y z, jne\r\n// }\r\n\r\n// Tai\r\n\r\n// Entity\r\n// { \r\n//\t\tpositions...\r\n//\t\tsizes...\r\n//\t\tsmt...\r\n// }\r\n\r\n// ^^ blastaa vain tiedostoon\r\n// ^^\r\n\r\n// FILE:\r\n//\t\tversion: 0.0\r\n//\r\n//\t\tentiteetti:  \r\n//\t\t\r\n//\r\n\r\n\r\n// void dumpStruct(Uint32 memberCount, member_definition* memberData, void* structPtr, int intendLevel = 0)\r\n//   {\r\n//   for (u32 memberIndex = 0; memberIndex < memberCount; ++memberIndex)\r\n//\t\tmember_definition* member = memberData + memberIndex;\r\n//\t\tvoid *memberPtr = (((uint8_t *)structPtr) + member->offset);\r\n//\t\tif (member->flags & MetaMemberFlag_IsPointer)\r\n//\t\t{\r\n//\t\t\tmemberPtr = *(void **)memberPtr;\r\n\r\nvoid serializeStruct(int memberCount, void* structPtr, member_definition* memberDefinition, void** buffer, int level = 0)\r\n{\r\n\tfor (int i = 0; i < memberCount; ++i)\r\n\t{\r\n\t\tmember_definition* member = memberDefinition + i;\r\n\t\tvoid *memberPtr = (((uint8_t *)structPtr) + member->offset);\r\n\r\n\t\tif (member->flags & MetaMemberFlag_IsPointer)\r\n\t\t{\r\n\t\t\t// do stuff\r\n\t\t}\r\n\r\n\t\tswitch (member->type)\r\n\t\t{\r\n\t\tcase MetaType_TetrisBoard:\r\n\t\t{\r\n\t\t\tserializeStruct(ArrayCount(membersOf_TetrisBoard), memberPtr, membersOf_TetrisBoard, buffer);\r\n\t\t} break;\r\n\t\tcase MetaType_vec4:\r\n\t\t{\r\n\t\t\tserializeStruct(ArrayCount(membersOf_vec4), memberPtr, membersOf_vec4, buffer);\r\n\t\t} break;\r\n\t\tcase MetaType_float:\r\n\t\t{\r\n#if binary\r\n\t\t\tfloat* buff = (float *)(*buffer); // hahaa\r\n\t\t\t*buff = *(float*)memberPtr;\r\n\t\t\tLOGI(\"serialising float %f\", *buff);\r\n\r\n\t\t\t*buffer = (void*)((float*)*buffer + 1);\r\n#else\r\n\t\t\tchar* buff = (char*)(*buffer); // ei vlttmtn\r\n\t\t\tint n = sprintf(buff, \"%s %f \", member->name, *(float*)memberPtr);\r\n\t\t\t*buffer = (void*)((char*)*buffer + n);\r\n#endif\r\n\r\n\t\t} break;\r\n\t\tcase MetaType_Application:\r\n\t\t{\r\n\t\t\tserializeStruct(ArrayCount(membersOf_Application), memberPtr, membersOf_Application, buffer);\r\n\t\t} break;\r\n\t\tcase MetaType_BigStuff:\r\n\t\t{\r\n\t\t\t// objecti alkaa\r\n\r\n\t\t\tchar* buff = (char*)(*buffer);\r\n\t\t\tint n = sprintf(buff, \"%s %s \", \"BigStuff\", member->name);\r\n\t\t\t*buffer = (void*)((char*)*buffer + n);\r\n\r\n\t\t\tserializeStruct(ArrayCount(membersOf_BigStuff), memberPtr, membersOf_BigStuff, buffer, level + 1);\r\n\r\n\t\t\tbuff = (char*)(*buffer);\r\n\t\t\tn = sprintf(buff, \"\\n\");\r\n\t\t\t*buffer = (void*)((char*)*buffer + n);\r\n\r\n\t\t\t// objecti loppuu\r\n\t\t} break;\r\n\t\tcase MetaType_Stuff:\r\n\t\t{\r\n\t\t\t// objecti alkaa\r\n\t\t\tchar* buff = (char*)(*buffer);\r\n\t\t\tint n = sprintf(buff, \"%s %s \", \"Stuff\", member->name);\r\n\t\t\t*buffer = (void*)((char*)*buffer + n);\r\n\r\n\t\t\tserializeStruct(ArrayCount(membersOf_Stuff), memberPtr, membersOf_Stuff, buffer);\r\n\r\n\t\t\tif (level == 0)\r\n\t\t\t{\r\n\t\t\t\tbuff = (char*)(*buffer);\r\n\t\t\t\tn = sprintf(buff, \"\\n\");\r\n\t\t\t\t*buffer = (void*)((char*)*buffer + n);\r\n\t\t\t}\r\n\t\t\t// objecti loppuu\r\n\t\t} break;\r\n\t\tcase MetaType_int:\r\n\t\t{\r\n#if binary\r\n\t\t\tint* buff = (int *)(*buffer); // hahaa\r\n\t\t\t*buff = *(int*)memberPtr;\r\n\t\t\tLOGI(\"serialising int %i\", *buff);\r\n\r\n\t\t\t*buffer = (void*)((int*)*buffer + 1);\r\n#else\r\n\t\t\tchar* buff = (char*)(*buffer); // ei vlttmtn\r\n\t\t\tint n = sprintf(buff, \"%s %d \", member->name, *(int*)memberPtr);\r\n\t\t\t*buffer = (void*)((char*)*buffer + n);\r\n#endif\r\n\t\t} break;\r\n\r\n\r\n\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tLOG(\" not serialising %s | \", memberDefinition->name);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\t// tallenna noi ja tallenna infot: -> donezo\r\n}\r\n\r\n// https://stackoverflow.com/questions/4143000/find-the-string-length-of-an-int\r\nint nDigits(int i)\r\n{\r\n\tif (i < 0) i = -i;\r\n\tif (i < 10) return 1;\r\n\tif (i < 100) return 2;\r\n\tif (i < 1000) return 3;\r\n\tif (i < 10000) return 4;\r\n\tif (i < 100000) return 5;\r\n\tif (i < 1000000) return 6;\r\n\tif (i < 10000000) return 7;\r\n\tif (i < 100000000) return 8;\r\n\tif (i < 1000000000) return 9;\r\n\treturn 10;\r\n}\r\n\r\n\r\n\r\nvoid deSerializeStructR(int memberCount, void* structPtr, member_definition* memberDefinition, char** buffer, int level = 0)\r\n{\r\n\tfor (int i = 0; i < memberCount; ++i)\r\n\t{\r\n\t\tmember_definition* member = memberDefinition + i;\r\n\t\tvoid *memberPtr = (((uint8_t *)structPtr) + member->offset);\r\n\r\n\t\tif (member->flags & MetaMemberFlag_IsPointer) // <- vaikeat \r\n\t\t{\r\n\t\t\t// do stuff\r\n\t\t}\r\n\r\n\t\tswitch (member->type)\r\n\t\t{\r\n\t\tcase MetaType_float:\r\n\t\t{\r\n#if binary\r\n\t\t\tfloat* buff = (float *)(*buffer); // hahaa\r\n\t\t\t*buff = *(float*)memberPtr;\r\n\t\t\tLOGI(\"serialising float %f\", *buff);\r\n\r\n\t\t\t*buffer = (void*)((float*)*buffer + 1);\r\n#else\r\n\t\t\t//char* buff = (char*)(*buffer); // ei vlttmtn\r\n\t\t\t//int n = sprintf(buff, \"F %f \", *(float*)memberPtr);\r\n\t\t\t//*buffer = (void*)((char*)*buffer + n);\r\n#endif\r\n\t\t\tfloat value = (float)atof(*buffer + strlen(member->name));\r\n\t\t\t*((float*)memberPtr) = value;\r\n\t\t\tLOGI(\"float read %f \", value);\r\n\r\n\t\t\t*buffer += strlen(member->name);\r\n\t\t\t(*buffer) += 1;\r\n\r\n\t\t\twhile (*(*buffer) != ' ')\r\n\t\t\t{\r\n\t\t\t\t(*buffer)++;\r\n\t\t\t}\r\n\t\t\t(*buffer)++; // last white space\r\n\t\t} break;\r\n#if 0\r\n\t\tcase MetaType_Application:\r\n\t\t{\r\n\t\t\t// serializeStruct(ArrayCount(membersOf_Application), memberPtr, membersOf_Application, buffer);\r\n\t\t} break;\r\n#endif\r\n#if 0\r\n\t\tcase MetaType_BigStuff:\r\n\t\t{\r\n\t\t\t*buffer = *buffer + strlen(\"BigStuff biggie \");\r\n\t\t\tdeSerializeStructR(ArrayCount(membersOf_BigStuff), memberPtr, membersOf_BigStuff, buffer, level + 1);\r\n\t\t\t// objecti alkaaName\r\n\r\n\t\t\t//char* buff = (char*)(*buffer);\r\n\t\t\t//int n = sprintf(buff, \"%s \", \"BigStuff\");\r\n\t\t\t//*buffer = (void*)((char*)*buffer + n);\r\n\r\n\t\t\t//serializeStruct(ArrayCount(membersOf_BigStuff), memberPtr, membersOf_BigStuff, buffer, level + 1);\r\n\r\n\t\t\t//buff = (char*)(*buffer);\r\n\t\t\t//n = sprintf(buff, \"\\n\");\r\n\t\t\t//*buffer = (void*)((char*)*buffer + n);\r\n\r\n\t\t\t//// objecti loppuu\r\n\t\t} break;\r\n#endif\r\n#if 0\r\n\t\tcase MetaType_Stuff:\r\n\t\t{\r\n\t\t\t*buffer = *buffer + strlen(\"Stuff stuff \");\r\n\t\t\tdeSerializeStructR(ArrayCount(membersOf_Stuff), memberPtr, membersOf_Stuff, buffer, level + 1);\r\n\r\n\t\t\t// objecti alkaa\r\n\t\t\t//char* buff = (char*)(*buffer);\r\n\t\t\t//int n = sprintf(buff, \"%s \", \"Stuff\");\r\n\t\t\t//*buffer = (void*)((char*)*buffer + n);\r\n\r\n\t\t\t//serializeStruct(ArrayCount(membersOf_Stuff), memberPtr, membersOf_Stuff, buffer);\r\n\r\n\t\t\t//if (level == 0)\r\n\t\t\t//{\r\n\t\t\t//\tbuff = (char*)(*buffer);\r\n\t\t\t//\tn = sprintf(buff, \"\\n\");\r\n\t\t\t//\t*buffer = (void*)((char*)*buffer + n);\r\n\t\t\t//}\r\n\t\t\t// objecti loppuu\r\n\t\t} break;\r\n#endif\r\n\t\tcase MetaType_int:\r\n\t\t{\r\n\r\n\t\t\tint value = atoi(*buffer + strlen(member->name));\r\n\t\t\t*((int*)memberPtr) = value;\r\n\r\n\t\t\tint n = nDigits(value);\r\n\t\t\t(*buffer) = *buffer + n + strlen(member->name);\r\n\t\t\tLOGI(\"int read %i \", value);\r\n\r\n\t\t\t(*buffer) += 1;\r\n\t\t\twhile (*(*buffer) != ' ')\r\n\t\t\t{\r\n\t\t\t\t(*buffer)++;\r\n\t\t\t}\r\n\t\t\t(*buffer) += 1;\r\n\t\t\t//\t\t\tint* buff = (int *)(*buffer); // hahaa\r\n\t\t\t//\t\t\t*buff = *(int*)memberPtr;\r\n\t\t\t//\t\t\tLOGI(\"serialising int %i\", *buff);\r\n\t\t\t//\r\n\t\t\t//\t\t\t*buffer = (void*)((int*)*buffer + 1);\r\n\t\t\t//#else\r\n\t\t\t//\t\t\tchar* buff = (char*)(*buffer); // ei vlttmtn\r\n\t\t\t//\t\t\tint n = sprintf(buff, \"I %d \", *(int*)memberPtr);\r\n\t\t\t//\t\t\t*buffer = (void*)((char*)*buffer + n);\r\n\t\t\t//#endif\r\n\t\t} break;\r\n\r\n\t\tMETA_HANDLE_SERILIZATION(memberPtr, level)\r\n\r\n\t\t\t// break;\r\n\t\tdefault:\r\n\t\t\tLOG(\" not serialising %s | \", memberDefinition->name);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// de serilizaatio: \r\n\r\n\r\n\r\n\r\n// gameState:\r\n//    * vec4\r\n//    * Board\r\n//         * Block\r\n//    * Entitys\r\n\r\n// loop and calculate types\r\n// 1 x vec4\r\n// 1 x Board\r\n// 1 x Block\r\n// 10000 x Entitys\r\n// ...\r\n\r\nvoid deSerializeGamestate(RtsGameState* gameState)\r\n{\r\n\tFILE* saveFile = fopen(SAVEFILE, \"rb\");\r\n\tif (saveFile)\r\n\t{\r\n\t\tfread(gameState, sizeof(RtsGameState), 1, saveFile);\r\n\t\tfclose(saveFile);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tASSERT(false);\r\n\t}\r\n}\r\n\r\nvoid deSerializeGamestate(TetrisGameState* gameState)\r\n{\r\n\tFILE* saveFile = fopen(SAVEFILE, \"rb\");\r\n\tif (saveFile)\r\n\t{\r\n\t\tfread(gameState, sizeof(TetrisGameState), 1, saveFile);\r\n\t\tfclose(saveFile);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tASSERT(false);\r\n\t}\r\n}\r\n\r\nvoid printBuildLog()\r\n{\r\n\tchar* buildLog = engine::io::ReadEntireFile(\"buildLog.txt\");\r\n\tLOGI(\"%s\\n\", buildLog);\r\n\tfree(buildLog);\r\n}\r\n\r\nvoid updateContext(EngineCore* core)\r\n{\r\n\tif (core->setUpContexts)\r\n\t{\r\n#if _WIN32\r\n\t\tImGui::SetCurrentContext((ImGuiContext*)core->imguiContext);\r\n#endif\r\n\t\tengine::Input::setContext(core->inputData);\r\n\r\n\t\tcore->setUpContexts = false;\r\n\t\tg_log = core->log;\r\n\r\n\t\t// let's read the build infolog\r\n#ifndef __EMSCRIPTEN__\r\n\t\tprintBuildLog();\r\n#endif\r\n\t}\r\n}\r\n\r\n\r\n// ^^ ei toimi\r\n\r\nvoid switchGame(CurrentGame nextGame, EngineCore* core)\r\n{\r\n\tgame_memory* memory = core->memory;    // \r\n\tmemory_arena* arena = core->arena;\r\n\r\n\tarena->Reset(); //\r\n\t// Init arena memory maybe\r\n\r\n\tswitch (nextGame)\r\n\t{\r\n\tcase Game_jam_game:\r\n\t{\r\n\t\tJamState* gameState = (JamState*)memory->permanentStorage;\r\n\t\tjam_init(core, gameState);\r\n\t} break;\r\n\tcase Game_unknown:\r\n\t\tASSERT(false); // no game\r\n\t\tbreak;\r\n\tcase Game_tetris:\r\n\t{\r\n\t\tTetrisGameState* gameState = (TetrisGameState*)memory->permanentStorage;\r\n\t\tinitTetris(core, gameState, arena);\r\n\t} break;\r\n\tcase Game_aoe160k:\r\n\t{\r\n\t\tRtsGameState* gameState = (RtsGameState*)memory->permanentStorage;\r\n\t\tinitAoe160k(core, gameState);\r\n\t} break;\r\n\tdefault:\r\n\t\tbreak;\r\n\t}\r\n\tcore->currentGame = nextGame;\r\n}\r\n\r\nEXPORT UPDATE_GAME(updateGame)\r\n{\r\n\tusing namespace engine;\r\n\tgame_time = core->currentTime;\r\n\tframe = core->currentFrame;\r\n\r\n\tupdateContext(core);\r\n\r\n\r\n\r\n\r\n\t//void dumpStruct(Uint32 memberCount, member_definition* memberData, void* structPtr, int intendLevel = 0)\r\n\r\n\tswitch (core->currentGame)\r\n\t{\r\n\tcase Game_unknown:\r\n\t{\r\n\t\tswitchGame(defaultGame, core);\r\n\t} break;\r\n\tcase Game_jam_game:\r\n\t{\r\n\t\tJamState* gameState = (JamState*)memory->permanentStorage;\r\n\t\tjam_update(core, gameState);\r\n\t}break;\r\n\tcase Game_tetris:\r\n\t{\r\n\t\tTetrisGameState* gameState = (TetrisGameState*)memory->permanentStorage;\r\n\t\tupdateTetris(core, gameState);\r\n\t} break;\r\n\tcase Game_aoe160k:\r\n\t{\r\n\t\tRtsGameState* gameState = (RtsGameState*)memory->permanentStorage;\r\n\t\tupdateAoe160k(core, gameState);\r\n\t} break;\r\n\tdefault:\r\n\t\tbreak;\r\n\t}\r\n\r\n\t{\r\n\t\tRtsGameState* gameState = (RtsGameState*)memory->permanentStorage;\r\n\t\tif (Input::isKeyPressed(Keycode::NUM_2))\r\n\t\t{\r\n\t\t\tserializeGamestate(gameState);\r\n\t\t}\r\n\t\tif (Input::isKeyPressed(Keycode::R))\r\n\t\t{\r\n\t\t\tdeSerializeGamestate(gameState);\r\n\t\t}\r\n\t}\r\n\r\n\tif (Input::isKeyPressed(Keycode::NUM_3))\r\n\t{\r\n#ifndef __EMSCRIPTEN__\r\n\t\tsystem(\"call buildStarter.bat\"); // hahaha!\r\n#endif\r\n\t}\r\n\r\n\tif (Input::isKeyPressed(Keycode::G))\r\n\t{\r\n\t\tLOGI(\"BUILD LOG \\n\");\r\n\t\tprintBuildLog();\r\n\t}\r\n\r\n\tif (Input::isKeyPressed(Keycode::NUM_5))\r\n\t{\r\n\t\tLOGI(\"re-initting game\\n\");\r\n\t\tinitGame(core);\r\n\t}\r\n\r\n\tif (Input::isKeyPressed(Keycode::NUM_4))\r\n\t{\r\n\t\tint * buffer = (int*)malloc(sizeof(Application));\r\n\t\tmemset(buffer, -1, sizeof(Application));\r\n\t\tvoid *ptr = ((void*)buffer);\r\n\r\n\t\tApplication app;\r\n\t\tapp.biggie.stuff.a = 10.5234f;\r\n\t\tapp.biggie.stuff.b = 5.55f;\r\n\t\tapp.biggie.stuff.c = 1337;\r\n\t\tapp.biggie.howCoolIsStuff = -1000;\r\n\r\n\t\tchar* bufer = new char[10000];\r\n\t\tchar* s = bufer;\r\n\t\tvoid* b = (void*)bufer;\r\n\r\n\r\n\t\t// lue \"header\"\r\n\t\t// Stuff: 5\r\n\t\t// Application: 10\r\n\r\n\t\tApplication app2{};\r\n\r\n\t\tserializeStruct(ArrayCount(membersOf_Application), &app, membersOf_Application, &b);\r\n\r\n\t\tio::WriteBufferToFile(\"assets/data/serilizaatio.txt\", bufer, strlen(bufer));\r\n\r\n\t\tdeSerializeStructR(ArrayCount(membersOf_Application), &app2, membersOf_Application, &s, 0);\r\n\r\n\t\tchar* test = io::ReadEntireFile(\"assets/data/serilizaatio.txt\");\r\n\t\tfloat* floats = (float*)ptr;\r\n\r\n\t\tfloat a0 = *(float*)buffer;\r\n\t\tfloat a1 = *((float*)buffer + 1);\r\n\t\tint a2 = (int)buffer[2];\r\n\t\tint a3 = (int)buffer[3];\r\n\r\n\t\tdebugBreak();\r\n\r\n\t\tfree(test);\r\n\t\tfree(buffer); // debug:fastlinmk\r\n\t}\r\n\t// LOGI(\"KOOTIA \\n\");\r\n\r\n}\r\n\r\nstatic void drawPlayer(Layer* layer, TetrisGameState* state)\r\n{\r\n\tvec4 uv{ 0.f, 0.f, 1.f, 1.f };\r\n\tvec4 color{ 1.0f, 1.0f, 1.0f, 1.0f };\r\n\tlayer->draw(&state->playerPos, &uv, &color);\r\n}\r\n\r\nEXPORT DRAW_GAME(drawGame)\r\n{\r\n\tusing namespace engine;\r\n\r\n\tupdateContext(core);\r\n\r\n\tvec4 pos{ 500.f, 400.f, 64.f, 64.f };\r\n\tvec4 uv{ 0.f, 0.f, 1.f, 1.f };\r\n\tvec4 color{ 1.0f, 1.0f, 1.0f, 1.0f };\r\n\tint texId = engine::getTexture(core->resources, textures::Texture_Block)->ID;\r\n\tint texId2 = engine::getTexture(core->resources, textures::Texture_Alien)->ID;\r\n\r\n\tLayer* layer = &core->layers[0];\r\n\tlayer->setTexture(texId);\r\n\r\n#ifndef __EMSCRIPTEN__\r\n\tif (ImGui::Button(\"next game\"))\r\n\t{\r\n\t\tint currentGame = (int)defaultGame;\r\n\t\t++currentGame;\r\n\r\n\t\tif (currentGame == Game_unknown)\r\n\t\t\tcurrentGame++;\r\n\t\telse if (currentGame == Game_max)\r\n\t\t\tcurrentGame = 1;\r\n\r\n\t\tswitchGame((CurrentGame)currentGame, core);\r\n\t}\r\n#endif\r\n\r\n#if _WIN32 && 0\r\n\tImGui::Text(\"Hello World! \\n\");\r\n\tstatic int test = 10;\r\n\tImGui::Separator();\r\n\tImGui::Text(\"Dumping tetris board\");\r\n\tImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2, 2));\r\n\tImGui::Columns(2);\r\n\tImGui::Separator();\r\n\tdumpStruct(ArrayCount(membersOf_TetrisBoard), membersOf_TetrisBoard, &gameState->tetris);\r\n\tImGui::Columns(1);\r\n\tImGui::Separator();\r\n\tImGui::PopStyleVar();\r\n#endif\r\n\r\n\t// static int intArray[10000]{};\r\n\r\n\t/*ImGuiListClipper clipper(10000);\r\n\tclipper.Begin(1000);\r\n\r\n\twhile (clipper.Step())\r\n\t\tfor (int i = clipper.DisplayStart; i < clipper.DisplayEnd; ++i)\r\n\t\t{\r\n\t\t\tImGui::PushID(i);\r\n\t\t\tImGui::InputInt(\"morjest\", &i);\r\n\t\t\tImGui::PopID();\r\n\t\t}\r\n*/\r\n\r\n\tVec2 po2s{ 10, 10 };\r\n\tlayer->drawString(\"hello world\", &po2s, 0xFFFFFFFF, 0);\r\n\r\n\r\n\tswitch (core->currentGame)\r\n\t{\r\n\tcase Game_unknown:\r\n\t\tbreak;\r\n\r\n\tcase Game_jam_game:\r\n\t{\r\n\t\tJamState* gameState = (JamState*)memory->permanentStorage;\r\n\t\tjam_draw(core, gameState);\r\n\t} break;\r\n\tcase Game_tetris:\r\n\t{\r\n\t\tTetrisGameState* gameState = (TetrisGameState*)memory->permanentStorage;\r\n\t\tdrawTetris(core, gameState);\r\n\t} break;\r\n\tcase Game_aoe160k:\r\n\t{\r\n\t\tRtsGameState* gameState = (RtsGameState*)memory->permanentStorage;\r\n\t\tdrawAoe160k(core, gameState);\r\n#if _WIN32\r\n\t\tstatic bool consoleOpen = true;\r\n\t\tgameState->console.Draw(\"console\", &consoleOpen);\r\n#endif\r\n\t} break;\r\n\tdefault:\r\n\t\tbreak;\r\n\t}\r\n\r\n}\r\n","// -*- C++ -*-\n//===---------------------------- chrono ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_CHRONO\n#define _LIBCPP_CHRONO\n\n/*\n    chrono synopsis\n\nnamespace std\n{\nnamespace chrono\n{\n\ntemplate <class ToDuration, class Rep, class Period>\nconstexpr\nToDuration\nduration_cast(const duration<Rep, Period>& fd);\n\ntemplate <class Rep> struct treat_as_floating_point : is_floating_point<Rep> {};\n\ntemplate <class Rep> constexpr bool treat_as_floating_point_v\n    = treat_as_floating_point<Rep>::value;                       // C++17\n\ntemplate <class Rep>\nstruct duration_values\n{\npublic:\n    static constexpr Rep zero();\n    static constexpr Rep max();\n    static constexpr Rep min();\n};\n\n// duration\n\ntemplate <class Rep, class Period = ratio<1>>\nclass duration\n{\n    static_assert(!__is_duration<Rep>::value, \"A duration representation can not be a duration\");\n    static_assert(__is_ratio<Period>::value, \"Second template parameter of duration must be a std::ratio\");\n    static_assert(Period::num > 0, \"duration period must be positive\");\npublic:\n    typedef Rep rep;\n    typedef Period period;\n\n    constexpr duration() = default;\n    template <class Rep2>\n        constexpr explicit duration(const Rep2& r,\n            typename enable_if\n            <\n               is_convertible<Rep2, rep>::value &&\n               (treat_as_floating_point<rep>::value ||\n               !treat_as_floating_point<rep>::value && !treat_as_floating_point<Rep2>::value)\n            >::type* = 0);\n\n    // conversions\n    template <class Rep2, class Period2>\n        constexpr duration(const duration<Rep2, Period2>& d,\n            typename enable_if\n            <\n                treat_as_floating_point<rep>::value ||\n                ratio_divide<Period2, period>::type::den == 1\n            >::type* = 0);\n\n    // observer\n\n    constexpr rep count() const;\n\n    // arithmetic\n\n    constexpr duration  operator+() const;\n    constexpr duration  operator-() const;\n    constexpr duration& operator++();\n    constexpr duration  operator++(int);\n    constexpr duration& operator--();\n    constexpr duration  operator--(int);\n\n    constexpr duration& operator+=(const duration& d);\n    constexpr duration& operator-=(const duration& d);\n\n    duration& operator*=(const rep& rhs);\n    duration& operator/=(const rep& rhs);\n\n    // special values\n\n    static constexpr duration zero();\n    static constexpr duration min();\n    static constexpr duration max();\n};\n\ntypedef duration<long long,         nano> nanoseconds;\ntypedef duration<long long,        micro> microseconds;\ntypedef duration<long long,        milli> milliseconds;\ntypedef duration<long long              > seconds;\ntypedef duration<     long, ratio<  60> > minutes;\ntypedef duration<     long, ratio<3600> > hours;\n\ntemplate <class Clock, class Duration = typename Clock::duration>\nclass time_point\n{\npublic:\n    typedef Clock                     clock;\n    typedef Duration                  duration;\n    typedef typename duration::rep    rep;\n    typedef typename duration::period period;\nprivate:\n    duration d_;  // exposition only\n\npublic:\n    time_point();  // has value \"epoch\" // constexpr in C++14\n    explicit time_point(const duration& d);  // same as time_point() + d // constexpr in C++14\n\n    // conversions\n    template <class Duration2>\n       time_point(const time_point<clock, Duration2>& t); // constexpr in C++14\n\n    // observer\n\n    duration time_since_epoch() const; // constexpr in C++14\n\n    // arithmetic\n\n    time_point& operator+=(const duration& d);\n    time_point& operator-=(const duration& d);\n\n    // special values\n\n    static constexpr time_point min();\n    static constexpr time_point max();\n};\n\n} // chrono\n\n// common_type traits\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n  struct common_type<chrono::duration<Rep1, Period1>, chrono::duration<Rep2, Period2>>;\n\ntemplate <class Clock, class Duration1, class Duration2>\n  struct common_type<chrono::time_point<Clock, Duration1>, chrono::time_point<Clock, Duration2>>;\n\nnamespace chrono {\n\n// duration arithmetic\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n  constexpr\n  typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2>>::type\n  operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n  constexpr\n  typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2>>::type\n  operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period, class Rep2>\n  constexpr\n  duration<typename common_type<Rep1, Rep2>::type, Period>\n  operator*(const duration<Rep1, Period>& d, const Rep2& s);\ntemplate <class Rep1, class Period, class Rep2>\n  constexpr\n  duration<typename common_type<Rep1, Rep2>::type, Period>\n  operator*(const Rep1& s, const duration<Rep2, Period>& d);\ntemplate <class Rep1, class Period, class Rep2>\n  constexpr\n  duration<typename common_type<Rep1, Rep2>::type, Period>\n  operator/(const duration<Rep1, Period>& d, const Rep2& s);\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n  constexpr\n  typename common_type<Rep1, Rep2>::type\n  operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\n\n// duration comparisons\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n   constexpr\n   bool operator==(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n   constexpr\n   bool operator!=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n   constexpr\n   bool operator< (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n   constexpr\n   bool operator<=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n   constexpr\n   bool operator> (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period1, class Rep2, class Period2>\n   constexpr\n   bool operator>=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);\n\n// duration_cast\ntemplate <class ToDuration, class Rep, class Period>\n  ToDuration duration_cast(const duration<Rep, Period>& d);\n\ntemplate <class ToDuration, class Rep, class Period>\n    constexpr ToDuration floor(const duration<Rep, Period>& d);    // C++17\ntemplate <class ToDuration, class Rep, class Period>\n    constexpr ToDuration ceil(const duration<Rep, Period>& d);     // C++17\ntemplate <class ToDuration, class Rep, class Period>\n    constexpr ToDuration round(const duration<Rep, Period>& d);    // C++17\n\n// time_point arithmetic (all constexpr in C++14)\ntemplate <class Clock, class Duration1, class Rep2, class Period2>\n  time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2>>::type>\n  operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Rep1, class Period1, class Clock, class Duration2>\n  time_point<Clock, typename common_type<duration<Rep1, Period1>, Duration2>::type>\n  operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);\ntemplate <class Clock, class Duration1, class Rep2, class Period2>\n  time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2>>::type>\n  operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);\ntemplate <class Clock, class Duration1, class Duration2>\n  typename common_type<Duration1, Duration2>::type\n  operator-(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);\n\n// time_point comparisons (all constexpr in C++14)\ntemplate <class Clock, class Duration1, class Duration2>\n   bool operator==(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);\ntemplate <class Clock, class Duration1, class Duration2>\n   bool operator!=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);\ntemplate <class Clock, class Duration1, class Duration2>\n   bool operator< (const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);\ntemplate <class Clock, class Duration1, class Duration2>\n   bool operator<=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);\ntemplate <class Clock, class Duration1, class Duration2>\n   bool operator> (const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);\ntemplate <class Clock, class Duration1, class Duration2>\n   bool operator>=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);\n\n// time_point_cast (constexpr in C++14)\n\ntemplate <class ToDuration, class Clock, class Duration>\n  time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration>& t);\n\ntemplate <class ToDuration, class Clock, class Duration>\n    constexpr time_point<Clock, ToDuration>\n    floor(const time_point<Clock, Duration>& tp);                  // C++17\n\ntemplate <class ToDuration, class Clock, class Duration>\n    constexpr time_point<Clock, ToDuration>\n    ceil(const time_point<Clock, Duration>& tp);                   // C++17\n\ntemplate <class ToDuration, class Clock, class Duration>\n    constexpr time_point<Clock, ToDuration>\n    round(const time_point<Clock, Duration>& tp);                  // C++17\n\ntemplate <class Rep, class Period>\n    constexpr duration<Rep, Period> abs(duration<Rep, Period> d);  // C++17\n// Clocks\n\nclass system_clock\n{\npublic:\n    typedef microseconds                     duration;\n    typedef duration::rep                    rep;\n    typedef duration::period                 period;\n    typedef chrono::time_point<system_clock> time_point;\n    static const bool is_steady =            false; // constexpr in C++14\n\n    static time_point now() noexcept;\n    static time_t     to_time_t  (const time_point& __t) noexcept;\n    static time_point from_time_t(time_t __t) noexcept;\n};\n\nclass steady_clock\n{\npublic:\n    typedef nanoseconds                                   duration;\n    typedef duration::rep                                 rep;\n    typedef duration::period                              period;\n    typedef chrono::time_point<steady_clock, duration>    time_point;\n    static const bool is_steady =                         true; // constexpr in C++14\n\n    static time_point now() noexcept;\n};\n\ntypedef steady_clock high_resolution_clock;\n\n}  // chrono\n\nconstexpr chrono::hours                                 operator \"\" h(unsigned long long); // C++14\nconstexpr chrono::duration<unspecified , ratio<3600,1>> operator \"\" h(long double); // C++14\nconstexpr chrono::minutes                               operator \"\" min(unsigned long long); // C++14\nconstexpr chrono::duration<unspecified , ratio<60,1>>   operator \"\" min(long double); // C++14\nconstexpr chrono::seconds                               operator \"\" s(unsigned long long); // C++14\nconstexpr chrono::duration<unspecified >                operator \"\" s(long double); // C++14\nconstexpr chrono::milliseconds                          operator \"\" ms(unsigned long long); // C++14\nconstexpr chrono::duration<unspecified , milli>         operator \"\" ms(long double); // C++14\nconstexpr chrono::microseconds                          operator \"\" us(unsigned long long); // C++14\nconstexpr chrono::duration<unspecified , micro>         operator \"\" us(long double); // C++14\nconstexpr chrono::nanoseconds                           operator \"\" ns(unsigned long long); // C++14\nconstexpr chrono::duration<unspecified , nano>          operator \"\" ns(long double); // C++14\n\n}  // std\n*/\n\n#include <__config>\n#include <ctime>\n#include <type_traits>\n#include <ratio>\n#include <limits>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nnamespace chrono\n{\n\ntemplate <class _Rep, class _Period = ratio<1> > class _LIBCPP_TEMPLATE_VIS duration;\n\ntemplate <class _Tp>\nstruct __is_duration : false_type {};\n\ntemplate <class _Rep, class _Period>\nstruct __is_duration<duration<_Rep, _Period> > : true_type  {};\n\ntemplate <class _Rep, class _Period>\nstruct __is_duration<const duration<_Rep, _Period> > : true_type  {};\n\ntemplate <class _Rep, class _Period>\nstruct __is_duration<volatile duration<_Rep, _Period> > : true_type  {};\n\ntemplate <class _Rep, class _Period>\nstruct __is_duration<const volatile duration<_Rep, _Period> > : true_type  {};\n\n} // chrono\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\nstruct _LIBCPP_TEMPLATE_VIS common_type<chrono::duration<_Rep1, _Period1>,\n                                         chrono::duration<_Rep2, _Period2> >\n{\n    typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,\n                             typename __ratio_gcd<_Period1, _Period2>::type> type;\n};\n\nnamespace chrono {\n\n// duration_cast\n\ntemplate <class _FromDuration, class _ToDuration,\n          class _Period = typename ratio_divide<typename _FromDuration::period, typename _ToDuration::period>::type,\n          bool = _Period::num == 1,\n          bool = _Period::den == 1>\nstruct __duration_cast;\n\ntemplate <class _FromDuration, class _ToDuration, class _Period>\nstruct __duration_cast<_FromDuration, _ToDuration, _Period, true, true>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    _ToDuration operator()(const _FromDuration& __fd) const\n    {\n        return _ToDuration(static_cast<typename _ToDuration::rep>(__fd.count()));\n    }\n};\n\ntemplate <class _FromDuration, class _ToDuration, class _Period>\nstruct __duration_cast<_FromDuration, _ToDuration, _Period, true, false>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    _ToDuration operator()(const _FromDuration& __fd) const\n    {\n        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;\n        return _ToDuration(static_cast<typename _ToDuration::rep>(\n                           static_cast<_Ct>(__fd.count()) / static_cast<_Ct>(_Period::den)));\n    }\n};\n\ntemplate <class _FromDuration, class _ToDuration, class _Period>\nstruct __duration_cast<_FromDuration, _ToDuration, _Period, false, true>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    _ToDuration operator()(const _FromDuration& __fd) const\n    {\n        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;\n        return _ToDuration(static_cast<typename _ToDuration::rep>(\n                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)));\n    }\n};\n\ntemplate <class _FromDuration, class _ToDuration, class _Period>\nstruct __duration_cast<_FromDuration, _ToDuration, _Period, false, false>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    _ToDuration operator()(const _FromDuration& __fd) const\n    {\n        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;\n        return _ToDuration(static_cast<typename _ToDuration::rep>(\n                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)\n                                                          / static_cast<_Ct>(_Period::den)));\n    }\n};\n\ntemplate <class _ToDuration, class _Rep, class _Period>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    __is_duration<_ToDuration>::value,\n    _ToDuration\n>::type\nduration_cast(const duration<_Rep, _Period>& __fd)\n{\n    return __duration_cast<duration<_Rep, _Period>, _ToDuration>()(__fd);\n}\n\ntemplate <class _Rep>\nstruct _LIBCPP_TEMPLATE_VIS treat_as_floating_point : is_floating_point<_Rep> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Rep> _LIBCPP_CONSTEXPR bool treat_as_floating_point_v\n    = treat_as_floating_point<_Rep>::value;\n#endif\n\ntemplate <class _Rep>\nstruct _LIBCPP_TEMPLATE_VIS duration_values\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR _Rep zero() {return _Rep(0);}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR _Rep max()  {return numeric_limits<_Rep>::max();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR _Rep min()  {return numeric_limits<_Rep>::lowest();}\n};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _ToDuration, class _Rep, class _Period>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    __is_duration<_ToDuration>::value,\n    _ToDuration\n>::type\nfloor(const duration<_Rep, _Period>& __d)\n{\n    _ToDuration __t = duration_cast<_ToDuration>(__d);\n    if (__t > __d)\n        __t = __t - _ToDuration{1};\n    return __t;\n}\n\ntemplate <class _ToDuration, class _Rep, class _Period>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    __is_duration<_ToDuration>::value,\n    _ToDuration\n>::type\nceil(const duration<_Rep, _Period>& __d)\n{\n    _ToDuration __t = duration_cast<_ToDuration>(__d);\n    if (__t < __d)\n        __t = __t + _ToDuration{1};\n    return __t;\n}\n\ntemplate <class _ToDuration, class _Rep, class _Period>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    __is_duration<_ToDuration>::value,\n    _ToDuration\n>::type\nround(const duration<_Rep, _Period>& __d)\n{\n    _ToDuration __lower = floor<_ToDuration>(__d);\n    _ToDuration __upper = __lower + _ToDuration{1};\n    auto __lowerDiff = __d - __lower;\n    auto __upperDiff = __upper - __d;\n    if (__lowerDiff < __upperDiff)\n        return __lower;\n    if (__lowerDiff > __upperDiff)\n        return __upper;\n    return __lower.count() & 1 ? __upper : __lower;\n}\n#endif\n\n// duration\n\ntemplate <class _Rep, class _Period>\nclass _LIBCPP_TEMPLATE_VIS duration\n{\n    static_assert(!__is_duration<_Rep>::value, \"A duration representation can not be a duration\");\n    static_assert(__is_ratio<_Period>::value, \"Second template parameter of duration must be a std::ratio\");\n    static_assert(_Period::num > 0, \"duration period must be positive\");\n\n    template <class _R1, class _R2>\n    struct __no_overflow\n    {\n    private:\n        static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;\n        static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;\n        static const intmax_t __n1 = _R1::num / __gcd_n1_n2;\n        static const intmax_t __d1 = _R1::den / __gcd_d1_d2;\n        static const intmax_t __n2 = _R2::num / __gcd_n1_n2;\n        static const intmax_t __d2 = _R2::den / __gcd_d1_d2;\n        static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * CHAR_BIT - 1)) + 1);\n\n        template <intmax_t _Xp, intmax_t _Yp, bool __overflow>\n        struct __mul    // __overflow == false\n        {\n            static const intmax_t value = _Xp * _Yp;\n        };\n\n        template <intmax_t _Xp, intmax_t _Yp>\n        struct __mul<_Xp, _Yp, true>\n        {\n            static const intmax_t value = 1;\n        };\n\n    public:\n        static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);\n        typedef ratio<__mul<__n1, __d2, !value>::value,\n                      __mul<__n2, __d1, !value>::value> type;\n    };\n    \npublic:\n    typedef _Rep rep;\n    typedef _Period period;\nprivate:\n    rep __rep_;\npublic:\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n#ifndef _LIBCPP_CXX03_LANG\n        duration() = default;\n#else\n        duration() {}\n#endif\n\n    template <class _Rep2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n        explicit duration(const _Rep2& __r,\n            typename enable_if\n            <\n               is_convertible<_Rep2, rep>::value &&\n               (treat_as_floating_point<rep>::value ||\n               !treat_as_floating_point<_Rep2>::value)\n            >::type* = 0)\n                : __rep_(__r) {}\n\n    // conversions\n    template <class _Rep2, class _Period2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n        duration(const duration<_Rep2, _Period2>& __d,\n            typename enable_if\n            <\n                __no_overflow<_Period2, period>::value && (\n                treat_as_floating_point<rep>::value ||\n                (__no_overflow<_Period2, period>::type::den == 1 &&\n                 !treat_as_floating_point<_Rep2>::value))\n            >::type* = 0)\n                : __rep_(_VSTD::chrono::duration_cast<duration>(__d).count()) {}\n\n    // observer\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR rep count() const {return __rep_;}\n\n    // arithmetic\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR duration  operator+() const {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR duration  operator-() const {return duration(-__rep_);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration& operator++()      {++__rep_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration  operator++(int)   {return duration(__rep_++);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration& operator--()      {--__rep_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration  operator--(int)   {return duration(__rep_--);}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration& operator+=(const duration& __d) {__rep_ += __d.count(); return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration& operator-=(const duration& __d) {__rep_ -= __d.count(); return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration& operator*=(const rep& rhs) {__rep_ *= rhs; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration& operator/=(const rep& rhs) {__rep_ /= rhs; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration& operator%=(const rep& rhs) {__rep_ %= rhs; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration& operator%=(const duration& rhs) {__rep_ %= rhs.count(); return *this;}\n\n    // special values\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR duration zero() {return duration(duration_values<rep>::zero());}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR duration min()  {return duration(duration_values<rep>::min());}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR duration max()  {return duration(duration_values<rep>::max());}\n};\n\ntypedef duration<long long,         nano> nanoseconds;\ntypedef duration<long long,        micro> microseconds;\ntypedef duration<long long,        milli> milliseconds;\ntypedef duration<long long              > seconds;\ntypedef duration<     long, ratio<  60> > minutes;\ntypedef duration<     long, ratio<3600> > hours;\n\n// Duration ==\n\ntemplate <class _LhsDuration, class _RhsDuration>\nstruct __duration_eq\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const\n        {\n            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;\n            return _Ct(__lhs).count() == _Ct(__rhs).count();\n        }\n};\n\ntemplate <class _LhsDuration>\nstruct __duration_eq<_LhsDuration, _LhsDuration>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const\n        {return __lhs.count() == __rhs.count();}\n};\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nbool\noperator==(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    return __duration_eq<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);\n}\n\n// Duration !=\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nbool\noperator!=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    return !(__lhs == __rhs);\n}\n\n// Duration <\n\ntemplate <class _LhsDuration, class _RhsDuration>\nstruct __duration_lt\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const\n        {\n            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;\n            return _Ct(__lhs).count() < _Ct(__rhs).count();\n        }\n};\n\ntemplate <class _LhsDuration>\nstruct __duration_lt<_LhsDuration, _LhsDuration>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const\n        {return __lhs.count() < __rhs.count();}\n};\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nbool\noperator< (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    return __duration_lt<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);\n}\n\n// Duration >\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nbool\noperator> (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    return __rhs < __lhs;\n}\n\n// Duration <=\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nbool\noperator<=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    return !(__rhs < __lhs);\n}\n\n// Duration >=\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nbool\noperator>=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    return !(__lhs < __rhs);\n}\n\n// Duration +\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type\noperator+(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;\n    return _Cd(_Cd(__lhs).count() + _Cd(__rhs).count());\n}\n\n// Duration -\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type\noperator-(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;\n    return _Cd(_Cd(__lhs).count() - _Cd(__rhs).count());\n}\n\n// Duration *\n\ntemplate <class _Rep1, class _Period, class _Rep2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,\n    duration<typename common_type<_Rep1, _Rep2>::type, _Period>\n>::type\noperator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)\n{\n    typedef typename common_type<_Rep1, _Rep2>::type _Cr;\n    typedef duration<_Cr, _Period> _Cd;\n    return _Cd(_Cd(__d).count() * static_cast<_Cr>(__s));\n}\n\ntemplate <class _Rep1, class _Period, class _Rep2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    is_convertible<_Rep1, typename common_type<_Rep1, _Rep2>::type>::value,\n    duration<typename common_type<_Rep1, _Rep2>::type, _Period>\n>::type\noperator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)\n{\n    return __d * __s;\n}\n\n// Duration /\n\ntemplate <class _Duration, class _Rep, bool = __is_duration<_Rep>::value>\nstruct __duration_divide_result\n{\n};\n\ntemplate <class _Duration, class _Rep2,\n    bool = is_convertible<_Rep2,\n                          typename common_type<typename _Duration::rep, _Rep2>::type>::value>\nstruct __duration_divide_imp\n{\n};\n\ntemplate <class _Rep1, class _Period, class _Rep2>\nstruct __duration_divide_imp<duration<_Rep1, _Period>, _Rep2, true>\n{\n    typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period> type;\n};\n\ntemplate <class _Rep1, class _Period, class _Rep2>\nstruct __duration_divide_result<duration<_Rep1, _Period>, _Rep2, false>\n    : __duration_divide_imp<duration<_Rep1, _Period>, _Rep2>\n{\n};\n\ntemplate <class _Rep1, class _Period, class _Rep2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type\noperator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s)\n{\n    typedef typename common_type<_Rep1, _Rep2>::type _Cr;\n    typedef duration<_Cr, _Period> _Cd;\n    return _Cd(_Cd(__d).count() / static_cast<_Cr>(__s));\n}\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename common_type<_Rep1, _Rep2>::type\noperator/(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Ct;\n    return _Ct(__lhs).count() / _Ct(__rhs).count();\n}\n\n// Duration %\n\ntemplate <class _Rep1, class _Period, class _Rep2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type\noperator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s)\n{\n    typedef typename common_type<_Rep1, _Rep2>::type _Cr;\n    typedef duration<_Cr, _Period> _Cd;\n    return _Cd(_Cd(__d).count() % static_cast<_Cr>(__s));\n}\n\ntemplate <class _Rep1, class _Period1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\ntypename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type\noperator%(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    typedef typename common_type<_Rep1, _Rep2>::type _Cr;\n    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;\n    return _Cd(static_cast<_Cr>(_Cd(__lhs).count()) % static_cast<_Cr>(_Cd(__rhs).count()));\n}\n\n//////////////////////////////////////////////////////////\n///////////////////// time_point /////////////////////////\n//////////////////////////////////////////////////////////\n\ntemplate <class _Clock, class _Duration = typename _Clock::duration>\nclass _LIBCPP_TEMPLATE_VIS time_point\n{\n    static_assert(__is_duration<_Duration>::value,\n                  \"Second template parameter of time_point must be a std::chrono::duration\");\npublic:\n    typedef _Clock                    clock;\n    typedef _Duration                 duration;\n    typedef typename duration::rep    rep;\n    typedef typename duration::period period;\nprivate:\n    duration __d_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 time_point() : __d_(duration::zero()) {}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 explicit time_point(const duration& __d) : __d_(__d) {}\n\n    // conversions\n    template <class _Duration2>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    time_point(const time_point<clock, _Duration2>& t,\n        typename enable_if\n        <\n            is_convertible<_Duration2, duration>::value\n        >::type* = 0)\n            : __d_(t.time_since_epoch()) {}\n\n    // observer\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 duration time_since_epoch() const {return __d_;}\n\n    // arithmetic\n\n    _LIBCPP_INLINE_VISIBILITY time_point& operator+=(const duration& __d) {__d_ += __d; return *this;}\n    _LIBCPP_INLINE_VISIBILITY time_point& operator-=(const duration& __d) {__d_ -= __d; return *this;}\n\n    // special values\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR time_point min() {return time_point(duration::min());}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR time_point max() {return time_point(duration::max());}\n};\n\n} // chrono\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\nstruct _LIBCPP_TEMPLATE_VIS common_type<chrono::time_point<_Clock, _Duration1>,\n                                         chrono::time_point<_Clock, _Duration2> >\n{\n    typedef chrono::time_point<_Clock, typename common_type<_Duration1, _Duration2>::type> type;\n};\n\nnamespace chrono {\n\ntemplate <class _ToDuration, class _Clock, class _Duration>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntime_point<_Clock, _ToDuration>\ntime_point_cast(const time_point<_Clock, _Duration>& __t)\n{\n    return time_point<_Clock, _ToDuration>(_VSTD::chrono::duration_cast<_ToDuration>(__t.time_since_epoch()));\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _ToDuration, class _Clock, class _Duration>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    __is_duration<_ToDuration>::value,\n    time_point<_Clock, _ToDuration>\n>::type\nfloor(const time_point<_Clock, _Duration>& __t)\n{\n    return time_point<_Clock, _ToDuration>{floor<_ToDuration>(__t.time_since_epoch())};\n}\n\ntemplate <class _ToDuration, class _Clock, class _Duration>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    __is_duration<_ToDuration>::value,\n    time_point<_Clock, _ToDuration>\n>::type\nceil(const time_point<_Clock, _Duration>& __t)\n{\n    return time_point<_Clock, _ToDuration>{ceil<_ToDuration>(__t.time_since_epoch())};\n}\n\ntemplate <class _ToDuration, class _Clock, class _Duration>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    __is_duration<_ToDuration>::value,\n    time_point<_Clock, _ToDuration>\n>::type\nround(const time_point<_Clock, _Duration>& __t)\n{\n    return time_point<_Clock, _ToDuration>{round<_ToDuration>(__t.time_since_epoch())};\n}\n\ntemplate <class _Rep, class _Period>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename enable_if\n<\n    numeric_limits<_Rep>::is_signed,\n    duration<_Rep, _Period>\n>::type\nabs(duration<_Rep, _Period> __d)\n{\n    return __d >= __d.zero() ? __d : -__d;\n}\n#endif\n\n// time_point ==\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return __lhs.time_since_epoch() == __rhs.time_since_epoch();\n}\n\n// time_point !=\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return !(__lhs == __rhs);\n}\n\n// time_point <\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return __lhs.time_since_epoch() < __rhs.time_since_epoch();\n}\n\n// time_point >\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return __rhs < __lhs;\n}\n\n// time_point <=\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return !(__rhs < __lhs);\n}\n\n// time_point >=\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return !(__lhs < __rhs);\n}\n\n// time_point operator+(time_point x, duration y);\n\ntemplate <class _Clock, class _Duration1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntime_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>\noperator+(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Tr;\n    return _Tr (__lhs.time_since_epoch() + __rhs);\n}\n\n// time_point operator+(duration x, time_point y);\n\ntemplate <class _Rep1, class _Period1, class _Clock, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntime_point<_Clock, typename common_type<duration<_Rep1, _Period1>, _Duration2>::type>\noperator+(const duration<_Rep1, _Period1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return __rhs + __lhs;\n}\n\n// time_point operator-(time_point x, duration y);\n\ntemplate <class _Clock, class _Duration1, class _Rep2, class _Period2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntime_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>\noperator-(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)\n{\n    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Ret;\n    return _Ret(__lhs.time_since_epoch() -__rhs);\n}\n\n// duration operator-(time_point x, time_point y);\n\ntemplate <class _Clock, class _Duration1, class _Duration2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename common_type<_Duration1, _Duration2>::type\noperator-(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)\n{\n    return __lhs.time_since_epoch() - __rhs.time_since_epoch();\n}\n\n//////////////////////////////////////////////////////////\n/////////////////////// clocks ///////////////////////////\n//////////////////////////////////////////////////////////\n\nclass _LIBCPP_TYPE_VIS system_clock\n{\npublic:\n    typedef microseconds                     duration;\n    typedef duration::rep                    rep;\n    typedef duration::period                 period;\n    typedef chrono::time_point<system_clock> time_point;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX11 const bool is_steady = false;\n\n    static time_point now() _NOEXCEPT;\n    static time_t     to_time_t  (const time_point& __t) _NOEXCEPT;\n    static time_point from_time_t(time_t __t) _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_HAS_NO_MONOTONIC_CLOCK\nclass _LIBCPP_TYPE_VIS steady_clock\n{\npublic:\n    typedef nanoseconds                                   duration;\n    typedef duration::rep                                 rep;\n    typedef duration::period                              period;\n    typedef chrono::time_point<steady_clock, duration>    time_point;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX11 const bool is_steady = true;\n\n    static time_point now() _NOEXCEPT;\n};\n\ntypedef steady_clock high_resolution_clock;\n#else\ntypedef system_clock high_resolution_clock;\n#endif\n\n} // chrono\n\n#if _LIBCPP_STD_VER > 11\n// Suffixes for duration literals [time.duration.literals]\ninline namespace literals\n{ \n  inline namespace chrono_literals\n  {\n\n    constexpr chrono::hours operator\"\" h(unsigned long long __h)\n    {\n        return chrono::hours(static_cast<chrono::hours::rep>(__h));\n    }\n\n    constexpr chrono::duration<long double, ratio<3600,1>> operator\"\" h(long double __h)\n    {\n        return chrono::duration<long double, ratio<3600,1>>(__h);\n    }\n\n\n    constexpr chrono::minutes operator\"\" min(unsigned long long __m)\n    {\n        return chrono::minutes(static_cast<chrono::minutes::rep>(__m));\n    }\n\n    constexpr chrono::duration<long double, ratio<60,1>> operator\"\" min(long double __m)\n    {\n        return chrono::duration<long double, ratio<60,1>> (__m);\n    }\n\n\n    constexpr chrono::seconds operator\"\" s(unsigned long long __s)\n    {\n        return chrono::seconds(static_cast<chrono::seconds::rep>(__s));\n    }\n\n    constexpr chrono::duration<long double> operator\"\" s(long double __s)\n    {\n        return chrono::duration<long double> (__s);\n    }\n\n\n    constexpr chrono::milliseconds operator\"\" ms(unsigned long long __ms)\n    {\n        return chrono::milliseconds(static_cast<chrono::milliseconds::rep>(__ms));\n    }\n\n    constexpr chrono::duration<long double, milli> operator\"\" ms(long double __ms)\n    {\n        return chrono::duration<long double, milli>(__ms);\n    }\n\n\n    constexpr chrono::microseconds operator\"\" us(unsigned long long __us)\n    {\n        return chrono::microseconds(static_cast<chrono::microseconds::rep>(__us));\n    }\n\n    constexpr chrono::duration<long double, micro> operator\"\" us(long double __us)\n    {\n        return chrono::duration<long double, micro> (__us);\n    }\n    \n\n    constexpr chrono::nanoseconds operator\"\" ns(unsigned long long __ns)\n    {\n        return chrono::nanoseconds(static_cast<chrono::nanoseconds::rep>(__ns));\n    }\n\n    constexpr chrono::duration<long double, nano> operator\"\" ns(long double __ns)\n    {\n        return chrono::duration<long double, nano> (__ns);\n    }\n\n}}\n\nnamespace chrono { // hoist the literals into namespace std::chrono\n   using namespace literals::chrono_literals;\n}\n\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_CHRONO\n","#pragma once\r\n#include <core/window.h>\r\n\r\nstruct SDL_Window;\r\n\r\nnamespace engine\r\n{\r\n\r\n\tclass Sdl_Window : public Window\r\n\t{\r\n\tpublic:\r\n\t\t// Sdl_Window()  {};\r\n\t\t// ~Sdl_Window() {};\r\n\t\t\r\n\t\t// virtual EGLNativeWindowType getNativeWindow() const;\r\n\t\tbool initWindow(int width, int height, const char* windowName);\r\n\t\tbool updateMessages();\r\n\t\tvoid swap();\r\n\t\tvoid setSize(int w, int h) { };\r\n\r\n\t\tSDL_Window* _window;\r\n\tprivate:\r\n\t\t// bool m_active;\r\n\t};\r\n}\r\n","#pragma once\r\n\r\n\r\n// #include <core/Entity.h> // TODO: vec2\r\n// #include <core/Export.h>\r\n// #include <glm/glm.hpp>\r\n// #include <cstdio>\r\n\r\n\r\n#define maxTouches 10\r\n#define M1 0\r\nstruct Touch\r\n{\r\n\tunsigned int   id; // ehk turha?\r\n\tbool down;\r\n\tvec2f position;\r\n};\r\n\r\nstruct Touches\r\n{\r\n\tint currentActiveCount;\r\n\tTouch touch[maxTouches];\r\n};\r\n\r\nenum class Mouse\r\n{\r\n\tLeft,\r\n\tMiddle,\r\n\tRight,\r\n};\r\n#include<SDL2/SDL_scancode.h>   // sdl platformeilla\r\nenum class Keycode\r\n{\r\n\tUNKNOWN = SDL_SCANCODE_UNKNOWN,\r\n\tA = SDL_SCANCODE_A,\r\n\tB = SDL_SCANCODE_B,\r\n\tC = SDL_SCANCODE_C,\r\n\tD = SDL_SCANCODE_D,\r\n\tE = SDL_SCANCODE_E,\r\n\tF = SDL_SCANCODE_F,\r\n\tG = SDL_SCANCODE_G,\r\n\tH = SDL_SCANCODE_H,\r\n\tI = SDL_SCANCODE_I,\r\n\tJ = SDL_SCANCODE_J,\r\n\tK = SDL_SCANCODE_K,\r\n\tL = SDL_SCANCODE_L,\r\n\tM = SDL_SCANCODE_M,\r\n\tN = SDL_SCANCODE_N,\r\n\tO = SDL_SCANCODE_O,\r\n\tP = SDL_SCANCODE_P,\r\n\tQ = SDL_SCANCODE_Q,\r\n\tR = SDL_SCANCODE_R,\r\n\tS = SDL_SCANCODE_S,\r\n\tT = SDL_SCANCODE_T,\r\n\tU = SDL_SCANCODE_U,\r\n\tV = SDL_SCANCODE_V,\r\n\tW = SDL_SCANCODE_W,\r\n\tX = SDL_SCANCODE_X,\r\n\tY = SDL_SCANCODE_Y,\r\n\tZ = SDL_SCANCODE_Z,\r\n\tNUM_1 = SDL_SCANCODE_1,\r\n\tNUM_2 = SDL_SCANCODE_2,\r\n\tNUM_3 = SDL_SCANCODE_3,\r\n\tNUM_4 = SDL_SCANCODE_4,\r\n\tNUM_5 = SDL_SCANCODE_5,\r\n\tNUM_6 = SDL_SCANCODE_6,\r\n\tNUM_7 = SDL_SCANCODE_7,\r\n\tNUM_8 = SDL_SCANCODE_8,\r\n\tNUM_9 = SDL_SCANCODE_9,\r\n\tNUM_0 = SDL_SCANCODE_0,\r\n\tRETURN = SDL_SCANCODE_RETURN,\r\n\tESCAPE = SDL_SCANCODE_ESCAPE,\r\n\tBACKSPACE = SDL_SCANCODE_BACKSPACE,\r\n\tTAB = SDL_SCANCODE_TAB,\r\n\tSPACE = SDL_SCANCODE_SPACE,\r\n\tMINUS = SDL_SCANCODE_MINUS,\r\n\tEQUALS = SDL_SCANCODE_EQUALS,\r\n\tLEFTBRACKET = SDL_SCANCODE_LEFTBRACKET,\r\n\tRIGHTBRACKET = SDL_SCANCODE_RIGHTBRACKET,\r\n\tBACKSLASH = SDL_SCANCODE_BACKSLASH,\r\n\tNONUSHASH = SDL_SCANCODE_NONUSHASH,\r\n\tSEMICOLON = SDL_SCANCODE_SEMICOLON,\r\n\tAPOSTROPHE = SDL_SCANCODE_APOSTROPHE,\r\n\tGRAVE = SDL_SCANCODE_GRAVE,\r\n\tCOMMA = SDL_SCANCODE_COMMA,\r\n\tPERIOD = SDL_SCANCODE_PERIOD,\r\n\tSLASH = SDL_SCANCODE_SLASH,\r\n\tCAPSLOCK = SDL_SCANCODE_CAPSLOCK,\r\n\tF1 = SDL_SCANCODE_F1,\r\n\tF2 = SDL_SCANCODE_F2,\r\n\tF3 = SDL_SCANCODE_F3,\r\n\tF4 = SDL_SCANCODE_F4,\r\n\tF5 = SDL_SCANCODE_F5,\r\n\tF6 = SDL_SCANCODE_F6,\r\n\tF7 = SDL_SCANCODE_F7,\r\n\tF8 = SDL_SCANCODE_F8,\r\n\tF9 = SDL_SCANCODE_F9,\r\n\tF10 = SDL_SCANCODE_F10,\r\n\tF11 = SDL_SCANCODE_F11,\r\n\tF12 = SDL_SCANCODE_F12,\r\n\tPRINTSCREEN = SDL_SCANCODE_PRINTSCREEN,\r\n\tSCROLLLOCK = SDL_SCANCODE_SCROLLLOCK,\r\n\tPAUSE = SDL_SCANCODE_PAUSE,\r\n\tINSERT = SDL_SCANCODE_INSERT,\r\n\tHOME = SDL_SCANCODE_HOME,\r\n\tPAGEUP = SDL_SCANCODE_PAGEUP,\r\n\tDELETE_ = SDL_SCANCODE_DELETE,\r\n\tEND = SDL_SCANCODE_END,\r\n\tPAGEDOWN = SDL_SCANCODE_PAGEDOWN,\r\n\tRIGHT = SDL_SCANCODE_RIGHT,\r\n\tLEFT = SDL_SCANCODE_LEFT,\r\n\tDOWN = SDL_SCANCODE_DOWN,\r\n\tUP = SDL_SCANCODE_UP,\r\n\tNUMLOCKCLEAR = SDL_SCANCODE_NUMLOCKCLEAR,\r\n\tKP_DIVIDE = SDL_SCANCODE_KP_DIVIDE,\r\n\tKP_MULTIPLY = SDL_SCANCODE_KP_MULTIPLY,\r\n\tKP_MINUS = SDL_SCANCODE_KP_MINUS,\r\n\tKP_PLUS = SDL_SCANCODE_KP_PLUS,\r\n\tKP_ENTER = SDL_SCANCODE_KP_ENTER,\r\n\tKP_1 = SDL_SCANCODE_KP_1,\r\n\tKP_2 = SDL_SCANCODE_KP_2,\r\n\tKP_3 = SDL_SCANCODE_KP_3,\r\n\tKP_4 = SDL_SCANCODE_KP_4,\r\n\tKP_5 = SDL_SCANCODE_KP_5,\r\n\tKP_6 = SDL_SCANCODE_KP_6,\r\n\tKP_7 = SDL_SCANCODE_KP_7,\r\n\tKP_8 = SDL_SCANCODE_KP_8,\r\n\tKP_9 = SDL_SCANCODE_KP_9,\r\n\tKP_0 = SDL_SCANCODE_KP_0,\r\n\tKP_PERIOD = SDL_SCANCODE_KP_PERIOD,\r\n\tNONUSBACKSLASH = SDL_SCANCODE_NONUSBACKSLASH,\r\n\tAPPLICATION = SDL_SCANCODE_APPLICATION,\r\n\tPOWER = SDL_SCANCODE_POWER,\r\n\tKP_EQUALS = SDL_SCANCODE_KP_EQUALS,\r\n\tF13 = SDL_SCANCODE_F13,\r\n\tF14 = SDL_SCANCODE_F14,\r\n\tF15 = SDL_SCANCODE_F15,\r\n\tF16 = SDL_SCANCODE_F16,\r\n\tF17 = SDL_SCANCODE_F17,\r\n\tF18 = SDL_SCANCODE_F18,\r\n\tF19 = SDL_SCANCODE_F19,\r\n\tF20 = SDL_SCANCODE_F20,\r\n\tF21 = SDL_SCANCODE_F21,\r\n\tF22 = SDL_SCANCODE_F22,\r\n\tF23 = SDL_SCANCODE_F23,\r\n\tF24 = SDL_SCANCODE_F24,\r\n\tEXECUTE = SDL_SCANCODE_EXECUTE,\r\n\tHELP = SDL_SCANCODE_HELP,\r\n\tMENU = SDL_SCANCODE_MENU,\r\n\tSELECT = SDL_SCANCODE_SELECT,\r\n\tSTOP = SDL_SCANCODE_STOP,\r\n\tAGAIN = SDL_SCANCODE_AGAIN,\r\n\tUNDO = SDL_SCANCODE_UNDO,\r\n\tCUT = SDL_SCANCODE_CUT,\r\n\tCOPY = SDL_SCANCODE_COPY,\r\n\tPASTE = SDL_SCANCODE_PASTE,\r\n\tFIND = SDL_SCANCODE_FIND,\r\n\tMUTE = SDL_SCANCODE_MUTE,\r\n\tVOLUMEUP = SDL_SCANCODE_VOLUMEUP,\r\n\tVOLUMEDOWN = SDL_SCANCODE_VOLUMEDOWN,\r\n\tINTERNATIONAL2 = SDL_SCANCODE_INTERNATIONAL2,\r\n\tINTERNATIONAL3 = SDL_SCANCODE_INTERNATIONAL3,\r\n\tINTERNATIONAL4 = SDL_SCANCODE_INTERNATIONAL4,\r\n\tINTERNATIONAL5 = SDL_SCANCODE_INTERNATIONAL5,\r\n\tINTERNATIONAL6 = SDL_SCANCODE_INTERNATIONAL6,\r\n\tINTERNATIONAL7 = SDL_SCANCODE_INTERNATIONAL7,\r\n\tINTERNATIONAL8 = SDL_SCANCODE_INTERNATIONAL8,\r\n\tINTERNATIONAL9 = SDL_SCANCODE_INTERNATIONAL9,\r\n\tLANG1 = SDL_SCANCODE_LANG1,\r\n\tLANG2 = SDL_SCANCODE_LANG2,\r\n\tLANG3 = SDL_SCANCODE_LANG3,\r\n\tLANG4 = SDL_SCANCODE_LANG4,\r\n\tLANG5 = SDL_SCANCODE_LANG5,\r\n\tLANG6 = SDL_SCANCODE_LANG6,\r\n\tLANG7 = SDL_SCANCODE_LANG7,\r\n\tLANG8 = SDL_SCANCODE_LANG8,\r\n\tLANG9 = SDL_SCANCODE_LANG9,\r\n\tALTERASE = SDL_SCANCODE_ALTERASE,\r\n\tSYSREQ = SDL_SCANCODE_SYSREQ,\r\n\tCANCEL = SDL_SCANCODE_CANCEL,\r\n\tCLEAR = SDL_SCANCODE_CLEAR,\r\n\tPRIOR = SDL_SCANCODE_PRIOR,\r\n\tRETURN2 = SDL_SCANCODE_RETURN2,\r\n\tSEPARATOR = SDL_SCANCODE_SEPARATOR,\r\n\tOUT_ = SDL_SCANCODE_OUT,\r\n\tOPER = SDL_SCANCODE_OPER,\r\n\tCLEARAGAIN = SDL_SCANCODE_CLEARAGAIN,\r\n\tCRSEL = SDL_SCANCODE_CRSEL,\r\n\tEXSEL = SDL_SCANCODE_EXSEL,\r\n\tKP_00 = SDL_SCANCODE_KP_00,\r\n\tKP_000 = SDL_SCANCODE_KP_000,\r\n\tTHOUSANDSSEPARATOR = SDL_SCANCODE_THOUSANDSSEPARATOR,\r\n\tDECIMALSEPARATOR = SDL_SCANCODE_DECIMALSEPARATOR,\r\n\tCURRENCYUNIT = SDL_SCANCODE_CURRENCYUNIT,\r\n\tCURRENCYSUBUNIT = SDL_SCANCODE_CURRENCYSUBUNIT,\r\n\tKP_LEFTPAREN = SDL_SCANCODE_KP_LEFTPAREN,\r\n\tKP_RIGHTPAREN = SDL_SCANCODE_KP_RIGHTPAREN,\r\n\tKP_LEFTBRACE = SDL_SCANCODE_KP_LEFTBRACE,\r\n\tKP_RIGHTBRACE = SDL_SCANCODE_KP_RIGHTBRACE,\r\n\tKP_TAB = SDL_SCANCODE_KP_TAB,\r\n\tKP_BACKSPACE = SDL_SCANCODE_KP_BACKSPACE,\r\n\tKP_A = SDL_SCANCODE_KP_A,\r\n\tKP_B = SDL_SCANCODE_KP_B,\r\n\tKP_C = SDL_SCANCODE_KP_C,\r\n\tKP_D = SDL_SCANCODE_KP_D,\r\n\tKP_E = SDL_SCANCODE_KP_E,\r\n\tKP_F = SDL_SCANCODE_KP_F,\r\n\tKP_XOR = SDL_SCANCODE_KP_XOR,\r\n\tKP_POWER = SDL_SCANCODE_KP_POWER,\r\n\tKP_PERCENT = SDL_SCANCODE_KP_PERCENT,\r\n\tKP_LESS = SDL_SCANCODE_KP_LESS,\r\n\tKP_GREATER = SDL_SCANCODE_KP_GREATER,\r\n\tKP_AMPERSAND = SDL_SCANCODE_KP_AMPERSAND,\r\n\tKP_DBLAMPERSAND = SDL_SCANCODE_KP_DBLAMPERSAND,\r\n\tKP_VERTICALBAR = SDL_SCANCODE_KP_VERTICALBAR,\r\n\tKP_DBLVERTICALBAR = SDL_SCANCODE_KP_DBLVERTICALBAR,\r\n\tKP_COLON = SDL_SCANCODE_KP_COLON,\r\n\tKP_HASH = SDL_SCANCODE_KP_HASH,\r\n\tKP_SPACE = SDL_SCANCODE_KP_SPACE,\r\n\tKP_AT = SDL_SCANCODE_KP_AT,\r\n\tKP_EXCLAM = SDL_SCANCODE_KP_EXCLAM,\r\n\tKP_MEMSTORE = SDL_SCANCODE_KP_MEMSTORE,\r\n\tKP_MEMRECALL = SDL_SCANCODE_KP_MEMRECALL,\r\n\tKP_MEMCLEAR = SDL_SCANCODE_KP_MEMCLEAR,\r\n\tKP_MEMADD = SDL_SCANCODE_KP_MEMADD,\r\n\tKP_MEMSUBTRACT = SDL_SCANCODE_KP_MEMSUBTRACT,\r\n\tKP_MEMMULTIPLY = SDL_SCANCODE_KP_MEMMULTIPLY,\r\n\tKP_MEMDIVIDE = SDL_SCANCODE_KP_MEMDIVIDE,\r\n\tKP_PLUSMINUS = SDL_SCANCODE_KP_PLUSMINUS,\r\n\tKP_CLEAR = SDL_SCANCODE_KP_CLEAR,\r\n\tKP_CLEARENTRY = SDL_SCANCODE_KP_CLEARENTRY,\r\n\tKP_BINARY = SDL_SCANCODE_KP_BINARY,\r\n\tKP_OCTAL = SDL_SCANCODE_KP_OCTAL,\r\n\tKP_DECIMAL = SDL_SCANCODE_KP_DECIMAL,\r\n\tKP_HEXADECIMAL = SDL_SCANCODE_KP_HEXADECIMAL,\r\n\tLCTRL = SDL_SCANCODE_LCTRL,\r\n\tLSHIFT = SDL_SCANCODE_LSHIFT,\r\n\tLALT = SDL_SCANCODE_LALT,\r\n\tLGUI = SDL_SCANCODE_LGUI,\r\n\tRCTRL = SDL_SCANCODE_RCTRL,\r\n\tRSHIFT = SDL_SCANCODE_RSHIFT,\r\n\tRALT = SDL_SCANCODE_RALT,\r\n\tRGUI = SDL_SCANCODE_RGUI,\r\n\tMODE = SDL_SCANCODE_MODE,\r\n\tAUDIONEXT = SDL_SCANCODE_AUDIONEXT,\r\n\tAUDIOPREV = SDL_SCANCODE_AUDIOPREV,\r\n\tAUDIOSTOP = SDL_SCANCODE_AUDIOSTOP,\r\n\tAUDIOPLAY = SDL_SCANCODE_AUDIOPLAY,\r\n\tAUDIOMUTE = SDL_SCANCODE_AUDIOMUTE,\r\n\tMEDIASELECT = SDL_SCANCODE_MEDIASELECT,\r\n\tWWW = SDL_SCANCODE_WWW,\r\n\tMAIL = SDL_SCANCODE_MAIL,\r\n\tCALCULATOR = SDL_SCANCODE_CALCULATOR,\r\n\tCOMPUTER = SDL_SCANCODE_COMPUTER,\r\n\tAC_SEARCH = SDL_SCANCODE_AC_SEARCH,\r\n\tAC_HOME = SDL_SCANCODE_AC_HOME,\r\n\tAC_BACK = SDL_SCANCODE_AC_BACK,\r\n\tAC_FORWARD = SDL_SCANCODE_AC_FORWARD,\r\n\tAC_STOP = SDL_SCANCODE_AC_STOP,\r\n\tAC_REFRESH = SDL_SCANCODE_AC_REFRESH,\r\n\tAC_BOOKMARKS = SDL_SCANCODE_AC_BOOKMARKS,\r\n\tBRIGHTNESSDOWN = SDL_SCANCODE_BRIGHTNESSDOWN,\r\n\tBRIGHTNESSUP = SDL_SCANCODE_BRIGHTNESSUP,\r\n\tDISPLAYSWITCH = SDL_SCANCODE_DISPLAYSWITCH,\r\n\tKBDILLUMTOGGLE = SDL_SCANCODE_KBDILLUMTOGGLE,\r\n\tKBDILLUMDOWN = SDL_SCANCODE_KBDILLUMDOWN,\r\n\tKBDILLUMUP = SDL_SCANCODE_KBDILLUMUP,\r\n\tEJECT = SDL_SCANCODE_EJECT,\r\n\tSLEEP = SDL_SCANCODE_SLEEP,\r\n\tAPP1 = SDL_SCANCODE_APP1,\r\n\tAPP2 = SDL_SCANCODE_APP2,\r\n\tSDL_NUM_SCANCODES = SDL_NUM_SCANCODES,\r\n};\r\n\r\n\r\n// inputista cross dll\r\n\r\nnamespace engine {\r\n\r\n#define MAXKEYS 512\r\n#define MAXMOUSE 10\r\n\tstruct InputData\r\n\t{\r\n\t\tint maxKeyBoardButtons = 512;\r\n\t\tbool thisFrame[MAXKEYS]{ };\r\n\t\tbool lastFrame[MAXKEYS]{ };\r\n\t\tbool mouse[MAXMOUSE]{ };\r\n\t\tbool mouseLastFrame[MAXMOUSE]{ };\r\n\t\tvec2f mousePos{ 0.f, 0.f };\r\n\r\n\t};\r\n#undef MAXKEYS\r\n#undef MAXMOUSE\r\n\r\n\r\n\tclass Camera2D;\r\n\r\n\tclass Input\r\n\t{\r\n\tpublic:\r\n\t\tstatic void init(InputData* data, int maxKeyboardButtons, Touches* touches);\r\n\t\tstatic void setContext(InputData* data);\r\n#if 0\r\n\t\tstatic void  InitLua();\r\n\t\tstatic void  InitLuaCamera();\r\n#endif\r\n\r\n\t\tstatic vec2f getMousePosition();\r\n#if 1\r\n\t\tstatic vec2f  getMousePositionWorld(EngineCore* core);\r\n#endif\r\n\t\tstatic bool  mouseDown(int numButton);\r\n\r\n\t\tstatic bool  isKeyPressed(Keycode keycode);\r\n\t\tstatic bool  isKeyDown(Keycode keycode);\r\n\t\tstatic bool\t mouseDown(Mouse button);\r\n\t\tstatic bool  mousePressed(Mouse button);\r\n\r\n\t\tstatic Touches getTouches();\r\n\t\tstatic vec2f   getTouchPosition(unsigned int touchId);\r\n\t\tstatic Touch   getTouch(unsigned int touchId);\r\n\r\n\t\t// static bool touched();\r\n\t\t// static bool isKeyPressed(); // scancode or string ?\r\n\t\t// static bool isKeyDown();\r\n\r\n\t\tstatic void unPressKey(int keycode);\r\n\r\n\t\tstatic void noHover();\r\n\t\tstatic void hover();\r\n\r\n\t\tstatic void setMainCamera(Camera2D* camera);\r\n\r\n#if 0\r\n\t\tstatic vec2 getMousePositionLua();\r\n#endif\r\n\r\n\t\tstatic void setMouseState(bool down, vec2f location);\r\n\t\tstatic void setButton(int keycode, bool state);\r\n\r\n\t\tstatic vec2f windowDimension;\r\n\tprivate:\r\n\t\t// vec2 Input::getMousePositionLua()\r\n\t\tstatic vec2f* _mousePos;\r\n\t\tstatic bool*  _thisFrame;\r\n\t\tstatic bool*  _lastFrame;\r\n\t\tstatic bool*  _mouseButtons;\r\n\t\tstatic bool*  _mouseButtonsLastFrame;\r\n\r\n\t\tstatic Touches* _touches;\r\n\t\tstatic bool    _hovered;\r\n\r\n\t\tstatic constexpr int maxMouseButtons = 5;\r\n\t\tstatic int maxKeyboardButtons;\r\n\r\n\t\tstatic engine::Camera2D* _mainCamera;\r\n\t};\r\n\r\n#if 0\r\n\tstruct InputRecorder\r\n\t{\r\n\t\tstruct PlaybackState\r\n\t\t{\r\n\t\t\tFILE* recordingFile; // input\r\n\t\t\tFILE* playingFile;\r\n\r\n\t\t\tvoid* memory;\r\n\t\t\tuint32_t totalMemorySize;\r\n\r\n\t\t\tvoid* playbackMemory = 0;\r\n\r\n\t\t\tint playbackSlotIndex;\r\n\t\t\tint recordMode;\t\t//\t\t/index\r\n\t\t\tbool playing;\r\n\t\t\tbool recording;\r\n\t\t} state;\r\n\r\n\t\tbool recording = false;\r\n\t\tbool playing = false;\r\n\t\tbool memoryRecording = true;\r\n\r\n\t\tvoid recordInput(InputData* inputData)\r\n\t\t{\r\n\t\t\tfwrite(inputData, sizeof(InputData), 1, state.recordingFile);\r\n\t\t}\r\n\r\n\t\tvoid endRecording()\r\n\t\t{\r\n\t\t\tfclose(state.recordingFile);\r\n\t\t}\r\n\r\n\t\tvoid startRecordInput(InputData* inputData, int playbackSlotIndex)\r\n\t\t{\r\n\t\t\tconst char* inputRecordFile = \"inputrecord\";\r\n\t\t\trecording = state.recordingFile = fopen(inputRecordFile, \"wb+\");\r\n\r\n\r\n\t\t\t// save whole gamestate\r\n\t\t\t// fwrite(state->memory, state->totalMemorySize, 1, state->recordingFile);\r\n\t\t\t// assert(playbackSlotIndex < ArrayCount(state->replayBuffer));\r\n\r\n\t\t\tif (memoryRecording)\r\n\t\t\t{\r\n\t\t\t\t// copy to ram\r\n\t\t\t\tif (!state.playbackMemory)\r\n\t\t\t\t{\r\n\t\t\t\t\tstate.playbackMemory = malloc(state.totalMemorySize);\r\n\t\t\t\t\tmemcpy(state.playbackMemory, state.memory, state.totalMemorySize);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t}\r\n\r\n\t\t\t// ReplayBuffer* replayBuffer = &state->replayBuffer[playbackSlotIndex];\r\n\t\t\t// memcpy(replayBuffer->memoryBlock, state->memory, state->totalMemorySize); // bencmark?\r\n\r\n\t\t\t// restore / save\r\n\t\t\t//\tcallLuafunction(\"save\", g_L);\r\n\t\t}\r\n\r\n\t\tvoid startInputPlayback(InputData* inputData, int playbackSlotIndex)\r\n\t\t{\r\n\t\t\t// open file*\r\n\t\t\t// in loop read from file streaming\r\n\t\t\tconst char* inputRecordFile = \"inputrecord\";\r\n\t\t\tplaying = state.playingFile = fopen(inputRecordFile, \"rb+\");\r\n\r\n\t\t\t// auto* buffer = &state->replayBuffer[playbackSlotIndex];\r\n\t\t\t// memcpy(state->memory, buffer->memoryBlock, state->totalMemorySize);\r\n\r\n\t\t\t// fread(state->memory, state->totalMemorySize, 1, state->playingFile);\r\n\t\t\t// reset lua state\r\n\r\n\t\t\t// restore / save\r\n\t\t\t//\tcallLuafunction(\"load\", g_L);\r\n\r\n\t\t\tif (memoryRecording)\r\n\t\t\t{\r\n\t\t\t\t// copy back the state\r\n\t\t\t\tif (state.playbackMemory)\r\n\t\t\t\t{\r\n\t\t\t\t\tmemcpy(state.memory, state.playbackMemory, state.totalMemorySize);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvoid endplayBack()\r\n\t\t{\r\n\t\t\tfclose(state.playingFile);\r\n\t\t}\r\n\r\n\t\tbool playBackInput(InputData* manager)\r\n\t\t{\r\n\t\t\tint elementsRead = fread(manager, sizeof(InputData), 1, state.playingFile);\r\n\t\t\tif (elementsRead != 1)\r\n\t\t\t{\r\n\t\t\t\t// eof\t\r\n\t\t\t\tendplayBack();\r\n\t\t\t\tstartInputPlayback(manager, state.playbackSlotIndex);\r\n\t\t\t\tfread(manager, sizeof(InputData), 1, state.playingFile);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n#endif\r\n\r\n}\r\n\r\n#if 0\r\n// #if _WIN32 || _LINUX\r\nEXPORT bool isKeyDown(int key);\r\n\r\nEXPORT bool isKeyPressed(int key);\r\n\r\n// EXPORT vec2 getMousePosition();\r\n\r\nEXPORT bool isMouseDown(int key);\r\n// #endif\r\n#endif\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","#pragma once\r\n#include <glm/glm.hpp>\r\n#include <glm/gtc/matrix_transform.hpp>\r\n// #include <core/Export.h>\r\n\r\nnamespace engine {\r\n\r\n\tclass Camera2D\r\n\t{\r\n\tpublic:\r\n\t\tCamera2D();\r\n\t\t~Camera2D();\r\n\r\n\t\t//laittaa orthographic matrixsin ja ruutu dimensionit kohdilleen\r\n\t\tvoid init(int screenWidth, int screenHeight);\r\n\r\n\t\tvoid update(); \r\n\r\n\t\tglm::vec2 convertScreenToWorld(glm::vec2 screenCoords);\r\n\r\n\t\tbool isBoxinView(const glm::vec2 &position, const glm::vec2 &dimensions);\r\n\r\n\t\tvoid mvoe(const glm::vec2& translate) { _needsMatrixUpdate = true; _position += translate; }\r\n\t\tvoid setPosition(const glm::vec2 &newPosition) { _position = newPosition; _needsMatrixUpdate = true; }\r\n\t\tvoid setScale(float newScale) { _scale = newScale; _needsMatrixUpdate = true; }\r\n\r\n\t\tvoid setDirty() { _needsMatrixUpdate = true; }\r\n\r\n\t\tvoid setPositionLua(float x, float y) { setPosition({ x, y }); };\r\n\t\tvoid moveLua(float x, float y) { mvoe({ x, y }); };\r\n\r\n\t\tvoid zoom(float factor);\r\n\r\n\t\tfloat getScale() { return _scale; }\r\n\t\tglm::vec2 getPosition() { return _position; }\r\n\t\tglm::mat4 getCameraMatrix() { return _cameraMatrix; }\r\n\r\n\t\tvec4 getCameraRect();\r\n\r\n\t\tfloat _scale;\r\n\t\tfloat angle;\r\n\t\tfloat pitch;\r\n\t\tfloat yaw;\r\n\t\tglm::vec2 _position;  \r\n\tprivate:\r\n\t\tint _screenWidth, _screenHeight;\r\n\t\tbool _needsMatrixUpdate;\r\n\t\tglm::mat4 _cameraMatrix;\r\n\t\tglm::mat4 _orthoMatrix;\r\n\t};\r\n}","#pragma once\r\n\r\n#if defined(__EMSCRIPTEN__)\r\n // #include <SDL2/SDL_opengles2.h>\r\n#else\r\n// #include <GLES3/gl3.h>\r\n#include <glad/glad.h>\r\n#endif \r\n\r\n#include \"Graphics/Shader.h\"\r\n\r\n\r\n// #include <glm/detail/type_vec2.hpp>\r\n// #include <glm/detail/type_vec3.hpp>\r\n\r\n// #include \"graphics/GraphicsSystem.h\"\r\n// #include <core/Texture2D.h>\r\n// #include <stdlib.h>\r\n\r\n// #include <core/Utils.h>\r\n// #include <core/Export.h>\r\n\r\n\r\n\r\nnamespace engine {\r\n\tclass SpriteRenderer\r\n\t{\r\n\tpublic:\r\n\t\tvoid Init(RenderData* renderData, int maxSize, Shader* shader);\r\n\r\n\t\t~SpriteRenderer() { free(indices); free(texUVs); free(quads); }\r\n\r\n\t\tvoid Clear(RenderData* renderData);\r\n\r\n\t\tinline void DrawSprite(float x, float y, float w, float h, \r\n\t\t\tfloat uv0, float uv1, float uv2, float uv3, int texId);\r\n\t\r\n\t\tvoid setTexture(int texId);\r\n\r\n\r\n\t\tvoid RenderLayer(Shader* shader, glm::mat4 cam, Layer* layer);\r\n\t\tvoid DrawSprite2(vec4* __restrict a, vec4* __restrict b, vec4* color);\r\n\r\n\t\tvoid DrawSpriteF(float x, float y, float w, float h, float uv0, float uv1, float uv2, float uv3,\r\n\t\t\tint texId, bool flippedX, bool flippedY);\r\n\r\n\t\tvoid Render(Shader* shader, glm::mat4* cam, RenderData* renderData);\r\n\r\n\t\tvoid drawString(const char* text, int count, Vec2* position, const Font& font,\r\n\t\t\tunsigned int color, RenderData* data);\r\n\r\n\tprivate:\r\n\t\tGLuint*\t   indices;\r\n\t\tglm::vec2* texUVs;\r\n\t\tglm::vec3* quads;\r\n\t\tGLfloat*     texIds;\r\n\t\tint _currentSize = 0;\r\n\t\tint maxSize;\r\n\t\tint maxIndicesSize;\r\n\t\tint size = 0;\r\n\t\tint indSize = 0;\r\n\t};\r\n}\r\n","#pragma once\r\n\r\n#include <Graphics/Texture2D.h>\r\n\r\n#if _WIN32 || defined(__EMSCRIPTEN__) || defined(_LINUX)\r\n\r\n#else\r\n#include <android_native_app_glue.h>\r\n#include <android/asset_manager.h>\r\n#include <android/asset_manager_jni.h>\r\n#endif\r\n\r\n\r\nnamespace engine\r\n{\r\n\t\r\n\r\n\tstatic bool IsPowerOfTwo(unsigned long x)\r\n\t{\r\n\t\treturn (x & (x - 1)) == 0;\r\n\t}\r\n\r\n\tstatic Texture2D loadTexture(int width, int height, int bytesPerPixel, const unsigned char* pixels)\r\n\t{\r\n\t\tTexture2D value; \r\n\r\n\t\tassert(bytesPerPixel == 3 || bytesPerPixel == 4);\r\n\t\tvalue.width = width;\r\n\t\tvalue.height = height;\r\n\r\n\t\tglPixelStorei(GL_UNPACK_ALIGNMENT, 1);\r\n\r\n\t\tglGenTextures(1, &value.ID);\r\n\t\tglBindTexture(GL_TEXTURE_2D, value.ID);\r\n\r\n\t\tGLuint fmt = bytesPerPixel == 3 ? GL_RGB : GL_RGBA;\r\n\t\tglTexImage2D(GL_TEXTURE_2D, 0, fmt, width, height, 0, fmt, GL_UNSIGNED_BYTE, pixels);\r\n\r\n\t\tif (IsPowerOfTwo(width) && IsPowerOfTwo(height))\r\n\t\t\tglGenerateMipmap(GL_TEXTURE_2D);              // webGL wants power of two textures \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  // for mipmaps.\r\n\r\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\r\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\r\n\r\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\r\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\r\n\r\n\t\treturn value;\r\n\t}\r\n\r\n\tTexture2D* getTexture(Resources* resources, int id);\r\n\r\n\t//\tclass ResourceManager\r\n//\t{\r\n//\tpublic:\r\n//\t\tstatic Texture2D* getTexture2D(std::string texturePath);\r\n//\r\n//#if 0\r\n//\t\tstatic SpriteSheet* getSpritesheet(std::string texturePath);\r\n//\t\tstatic void initializeSpritesheet(const char* spritesheetName, int spriteCountW, int spriteCountH, int pixelsPerW, int pixelsPerH, int offsetX, int offsetY, int padding = 0);\r\n//#endif \r\n//\r\n//\r\n//#if !((_WIN32) || defined(__EMSCRIPTEN__) ||  defined(_LINUX)) \r\n//\t\tstruct android_app;\r\n//\t\tstatic void init(android_app* application);\r\n//\t\r\n//\tpublic:\t\t\r\n//\t\tstatic AAssetManager* assetManager;\r\n//#endif\r\n//\r\n//\tprivate:\r\n//\t\tstatic std::unordered_map<std::string, Texture2D*> m_textures;\r\n//#if 0\r\n//\t\tstatic std::unordered_map<std::string, SpriteSheet> spriteSheetMap;\r\n//#endif\r\n}\r\n","// -*- C++ -*-\n//===------------------------- streambuf ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STEAMBUF\n#define _LIBCPP_STEAMBUF\n\n/*\n    streambuf synopsis\n\nnamespace std\n{\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_streambuf\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    locale pubimbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.6.2.2.2 buffer and positioning:\n    basic_streambuf* pubsetbuf(char_type* s, streamsize n);\n    pos_type pubseekoff(off_type off, ios_base::seekdir way,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    pos_type pubseekpos(pos_type sp,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    int pubsync();\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    streamsize in_avail();\n    int_type snextc();\n    int_type sbumpc();\n    int_type sgetc();\n    streamsize sgetn(char_type* s, streamsize n);\n\n    // 27.6.2.2.4 Putback:\n    int_type sputbackc(char_type c);\n    int_type sungetc();\n\n    // 27.6.2.2.5 Put area:\n    int_type sputc(char_type c);\n    streamsize sputn(const char_type* s, streamsize n);\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& rhs);\n    basic_streambuf& operator=(const basic_streambuf& rhs);\n    void swap(basic_streambuf& rhs);\n\n    // 27.6.2.3.2 Get area:\n    char_type* eback() const;\n    char_type* gptr() const;\n    char_type* egptr() const;\n    void gbump(int n);\n    void setg(char_type* gbeg, char_type* gnext, char_type* gend);\n\n    // 27.6.2.3.3 Put area:\n    char_type* pbase() const;\n    char_type* pptr() const;\n    char_type* epptr() const;\n    void pbump(int n);\n    void setp(char_type* pbeg, char_type* pend);\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* s, streamsize n);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* s, streamsize n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* s, streamsize n);\n    virtual int_type overflow (int_type c = traits_type::eof());\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <ios>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS basic_streambuf\n{\npublic:\n    // types:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    locale pubimbue(const locale& __loc) {\n        imbue(__loc);\n        locale __r = __loc_;\n        __loc_ = __loc;\n        return __r;\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    locale getloc() const { return __loc_; }\n\n    // 27.6.2.2.2 buffer and positioning:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    basic_streambuf* pubsetbuf(char_type* __s, streamsize __n)\n    { return setbuf(__s, __n); }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,\n                        ios_base::openmode __which = ios_base::in | ios_base::out)\n    { return seekoff(__off, __way, __which); }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    pos_type pubseekpos(pos_type __sp,\n                        ios_base::openmode __which = ios_base::in | ios_base::out)\n    { return seekpos(__sp, __which); }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int pubsync() { return sync(); }\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    streamsize in_avail() {\n        if (__ninp_ < __einp_)\n            return static_cast<streamsize>(__einp_ - __ninp_);\n        return showmanyc();\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type snextc() {\n        if (sbumpc() == traits_type::eof())\n            return traits_type::eof();\n        return sgetc();\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type sbumpc() {\n        if (__ninp_ == __einp_)\n            return uflow();\n        return traits_type::to_int_type(*__ninp_++);\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type sgetc() {\n        if (__ninp_ == __einp_)\n            return underflow();\n        return traits_type::to_int_type(*__ninp_);\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    streamsize sgetn(char_type* __s, streamsize __n)\n    { return xsgetn(__s, __n); }\n\n    // 27.6.2.2.4 Putback:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type sputbackc(char_type __c) {\n        if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))\n            return pbackfail(traits_type::to_int_type(__c));\n        return traits_type::to_int_type(*--__ninp_);\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type sungetc() {\n        if (__binp_ == __ninp_)\n          return pbackfail();\n        return traits_type::to_int_type(*--__ninp_);\n    }\n\n    // 27.6.2.2.5 Put area:\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    int_type sputc(char_type __c) {\n        if (__nout_ == __eout_)\n            return overflow(traits_type::to_int_type(__c));\n        *__nout_++ = __c;\n        return traits_type::to_int_type(__c);\n    }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    streamsize sputn(const char_type* __s, streamsize __n)\n    { return xsputn(__s, __n); }\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& __rhs);\n    basic_streambuf& operator=(const basic_streambuf& __rhs);\n    void swap(basic_streambuf& __rhs);\n\n    // 27.6.2.3.2 Get area:\n    _LIBCPP_ALWAYS_INLINE char_type* eback() const {return __binp_;}\n    _LIBCPP_ALWAYS_INLINE char_type* gptr()  const {return __ninp_;}\n    _LIBCPP_ALWAYS_INLINE char_type* egptr() const {return __einp_;}\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void gbump(int __n) { __ninp_ += __n; }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend) {\n        __binp_ = __gbeg;\n        __ninp_ = __gnext;\n        __einp_ = __gend;\n    }\n\n    // 27.6.2.3.3 Put area:\n    _LIBCPP_ALWAYS_INLINE char_type* pbase() const {return __bout_;}\n    _LIBCPP_ALWAYS_INLINE char_type* pptr()  const {return __nout_;}\n    _LIBCPP_ALWAYS_INLINE char_type* epptr() const {return __eout_;}\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void pbump(int __n) { __nout_ += __n; }\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void setp(char_type* __pbeg, char_type* __pend) {\n        __bout_ = __nout_ = __pbeg;\n        __eout_ = __pend;\n    }\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& __loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* __s, streamsize __n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* __s, streamsize __n);\n    virtual int_type overflow(int_type __c = traits_type::eof());\n\nprivate:\n    locale __loc_;\n    char_type* __binp_;\n    char_type* __ninp_;\n    char_type* __einp_;\n    char_type* __bout_;\n    char_type* __nout_;\n    char_type* __eout_;\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::~basic_streambuf()\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf()\n    : __binp_(0),\n      __ninp_(0),\n      __einp_(0),\n      __bout_(0),\n      __nout_(0),\n      __eout_(0)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)\n    : __loc_(__sb.__loc_),\n      __binp_(__sb.__binp_),\n      __ninp_(__sb.__ninp_),\n      __einp_(__sb.__einp_),\n      __bout_(__sb.__bout_),\n      __nout_(__sb.__nout_),\n      __eout_(__sb.__eout_)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>&\nbasic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb)\n{\n    __loc_ = __sb.__loc_;\n    __binp_ = __sb.__binp_;\n    __ninp_ = __sb.__ninp_;\n    __einp_ = __sb.__einp_;\n    __bout_ = __sb.__bout_;\n    __nout_ = __sb.__nout_;\n    __eout_ = __sb.__eout_;\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb)\n{\n    _VSTD::swap(__loc_, __sb.__loc_);\n    _VSTD::swap(__binp_, __sb.__binp_);\n    _VSTD::swap(__ninp_, __sb.__ninp_);\n    _VSTD::swap(__einp_, __sb.__einp_);\n    _VSTD::swap(__bout_, __sb.__bout_);\n    _VSTD::swap(__nout_, __sb.__nout_);\n    _VSTD::swap(__eout_, __sb.__eout_);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::imbue(const locale&)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>*\nbasic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize)\n{\n    return this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,\n                                          ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\nint\nbasic_streambuf<_CharT, _Traits>::sync()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::showmanyc()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n)\n{\n    const int_type __eof = traits_type::eof();\n    int_type __c;\n    streamsize __i = 0;\n    while(__i < __n)\n    {\n        if (__ninp_ < __einp_)\n        {\n            const streamsize __len = _VSTD::min(__einp_ - __ninp_, __n - __i);\n            traits_type::copy(__s, __ninp_, __len);\n            __s +=  __len;\n            __i +=  __len;\n            this->gbump(__len);\n        }\n        else if ((__c = uflow()) != __eof)\n        {\n            *__s = traits_type::to_char_type(__c);\n            ++__s;\n            ++__i;\n        }\n        else\n            break;\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::underflow()\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::uflow()\n{\n    if (underflow() == traits_type::eof())\n        return traits_type::eof();\n    return traits_type::to_int_type(*__ninp_++);\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::pbackfail(int_type)\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n)\n{\n    streamsize __i = 0;\n    int_type __eof = traits_type::eof();\n    while( __i < __n)\n    {\n        if (__nout_ >= __eout_)\n        {\n            if (overflow(traits_type::to_int_type(*__s)) == __eof)\n                break;\n            ++__s;\n            ++__i;\n        }\n        else\n        {\n            streamsize __chunk_size = _VSTD::min(__eout_ - __nout_, __n - __i);\n            traits_type::copy(__nout_, __s, __chunk_size);\n            __nout_ += __chunk_size;\n            __s     += __chunk_size;\n            __i     += __chunk_size;\n        }\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::overflow(int_type)\n{\n    return traits_type::eof();\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_streambuf<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_streambuf<wchar_t>)\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ios<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ios<wchar_t>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STEAMBUF\n","// -*- C++ -*-\n//===-------------------------- typeinfo ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __LIBCPP_TYPEINFO\n#define __LIBCPP_TYPEINFO\n\n/*\n\n    typeinfo synopsis\n\nnamespace std {\n\nclass type_info\n{\npublic:\n    virtual ~type_info();\n\n    bool operator==(const type_info& rhs) const noexcept;\n    bool operator!=(const type_info& rhs) const noexcept;\n\n    bool before(const type_info& rhs) const noexcept;\n    size_t hash_code() const noexcept;\n    const char* name() const noexcept;\n\n    type_info(const type_info& rhs) = delete;\n    type_info& operator=(const type_info& rhs) = delete;\n};\n\nclass bad_cast\n    : public exception\n{\npublic:\n    bad_cast() noexcept;\n    bad_cast(const bad_cast&) noexcept;\n    bad_cast& operator=(const bad_cast&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() noexcept;\n    bad_typeid(const bad_typeid&) noexcept;\n    bad_typeid& operator=(const bad_typeid&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#include <cstdint>\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#if defined(_LIBCPP_NONUNIQUE_RTTI_BIT)\n#define _LIBCPP_HAS_NONUNIQUE_TYPEINFO\n#else\n#define _LIBCPP_HAS_UNIQUE_TYPEINFO\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI type_info\n{\n    type_info& operator=(const type_info&);\n    type_info(const type_info&);\n\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    _LIBCPP_INLINE_VISIBILITY\n    int __compare_nonunique_names(const type_info &__arg) const _NOEXCEPT\n    { return __builtin_strcmp(name(), __arg.name()); }\n#endif\n\nprotected:\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    // A const char* with the non-unique RTTI bit possibly set.\n    uintptr_t __type_name;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n)\n      : __type_name(reinterpret_cast<uintptr_t>(__n)) {}\n#else\n    const char *__type_name;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n) : __type_name(__n) {}\n#endif\n\npublic:\n    virtual ~type_info();\n\n#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n    {\n      return reinterpret_cast<const char*>(__type_name &\n                                           ~_LIBCPP_NONUNIQUE_RTTI_BIT);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n    {\n      if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return __type_name < __arg.__type_name;\n      return __compare_nonunique_names(__arg) < 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n    {\n      if (!(__type_name & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return __type_name;\n\n      const char* __ptr = name();\n      size_t __hash = 5381;\n      while (unsigned char __c = static_cast<unsigned char>(*__ptr++))\n        __hash = (__hash * 33) ^ __c;\n      return __hash;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n    {\n      if (__type_name == __arg.__type_name)\n        return true;\n\n      if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n        return false;\n      return __compare_nonunique_names(__arg) == 0;\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n    { return __type_name; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n    { return __type_name < __arg.__type_name; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n    { return reinterpret_cast<size_t>(__type_name); }\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n    { return __type_name == __arg.__type_name; }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const type_info& __arg) const _NOEXCEPT\n    { return !operator==(__arg); }\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_cast\n    : public exception\n{\npublic:\n    bad_cast() _NOEXCEPT;\n    virtual ~bad_cast() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() _NOEXCEPT;\n    virtual ~bad_typeid() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n}  // std\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_cast()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_cast();\n#else\n\t_VSTD::abort();\n#endif\n}\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // __LIBCPP_TYPEINFO\n","// -*- C++ -*-\n//===-------------------------- __string ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___STRING\n#define _LIBCPP___STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static constexpr void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static constexpr int    compare(const char_type* s1, const char_type* s2, size_t n);\n    static constexpr size_t length(const char_type* s);\n    static constexpr const char_type* \n                            find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <algorithm>  // for search and min\n#include <cstdio>     // For EOF.\n#include <memory>     // for __murmur2_or_cityhash\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// char_traits\n\ntemplate <class _CharT>\nstruct _LIBCPP_TEMPLATE_VIS char_traits\n{\n    typedef _CharT    char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void _LIBCPP_CONSTEXPR_AFTER_CXX14\n        assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t length(const char_type* __s);\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ntemplate <class _CharT>\n_LIBCPP_CONSTEXPR_AFTER_CXX14 int\nchar_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\ninline\n_LIBCPP_CONSTEXPR_AFTER_CXX14 size_t\nchar_traits<_CharT>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ntemplate <class _CharT>\ninline\n_LIBCPP_CONSTEXPR_AFTER_CXX14 const _CharT*\nchar_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\n_CharT*\nchar_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n// char_traits<char>\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char>\n{\n    typedef char      char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n            {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return (unsigned char)__c1 < (unsigned char)__c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    static inline size_t _LIBCPP_CONSTEXPR_AFTER_CXX14\n    length(const char_type* __s)  _NOEXCEPT {return __builtin_strlen(__s);}\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {return __n == 0 ? __s1 : (char_type*) memmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)memcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n        {return __n == 0 ? __s : (char_type*)memset(__s, to_int_type(__a), __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type((unsigned char)__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    if (__n == 0)\n        return 0;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_memcmp(__s1, __s2, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return memcmp(__s1, __s2, __n);\n#else\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char*\nchar_traits<char>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    if (__n == 0)\n        return NULL;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_char_memchr(__s, to_int_type(__a), __n);\n#elif _LIBCPP_STD_VER <= 14\n    return (const char_type*) memchr(__s, to_int_type(__a), __n);\n#else\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return NULL;\n#endif\n}\n\n\n// char_traits<wchar_t>\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<wchar_t>\n{\n    typedef wchar_t   char_type;\n    typedef wint_t    int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t length(const char_type* __s) _NOEXCEPT;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {return __n == 0 ? __s1 : (char_type*)wmemmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)wmemcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n        {return __n == 0 ? __s : (char_type*)wmemset(__s, __a, __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(WEOF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<wchar_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    if (__n == 0)\n        return 0;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_wmemcmp(__s1, __s2, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return wmemcmp(__s1, __s2, __n);\n#else\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<wchar_t>::length(const char_type* __s) _NOEXCEPT\n{\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_wcslen(__s);\n#elif _LIBCPP_STD_VER <= 14\n    return wcslen(__s);\n#else\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst wchar_t*\nchar_traits<wchar_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    if (__n == 0)\n        return NULL;\n#if __has_feature(cxx_constexpr_string_builtins)\n        return __builtin_wmemchr(__s, __a, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return wmemchr(__s, __a, __n);\n#else\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return NULL;\n#endif\n}\n\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char16_t>\n{\n    typedef char16_t       char_type;\n    typedef uint_least16_t int_type;\n    typedef streamoff      off_type;\n    typedef u16streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t           length(const char_type* __s) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<char16_t>::length(const char_type* __s) _NOEXCEPT\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char16_t*\nchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char32_t>\n{\n    typedef char32_t       char_type;\n    typedef uint_least32_t int_type;\n    typedef streamoff      off_type;\n    typedef u32streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t           length(const char_type* __s) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFFFFFF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<char32_t>::length(const char_type* __s) _NOEXCEPT\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char32_t*\nchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n// helper fns for basic_string and string_view\n\n// __str_find\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n             _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos >= __sz)\n        return __npos;\n    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);\n    if (__r == 0)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 const _CharT *\n__search_substring(const _CharT *__first1, const _CharT *__last1,\n                   const _CharT *__first2, const _CharT *__last2) {\n  // Take advantage of knowing source and pattern lengths.\n  // Stop short when source is smaller than pattern.\n  const ptrdiff_t __len2 = __last2 - __first2;\n  if (__len2 == 0)\n    return __first1;\n\n  ptrdiff_t __len1 = __last1 - __first1;\n  if (__len1 < __len2)\n    return __last1;\n\n  // First element of __first2 is loop invariant.\n  _CharT __f2 = *__first2;\n  while (true) {\n    __len1 = __last1 - __first1;\n    // Check whether __first1 still has at least __len2 bytes.\n    if (__len1 < __len2)\n      return __last1;\n\n    // Find __f2 the first byte matching in __first1.\n    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);\n    if (__first1 == 0)\n      return __last1;\n\n    // It is faster to compare from the first byte of __first1 even if we\n    // already know that it matches the first byte of __first2: this is because\n    // __first2 is most likely aligned, as it is user's \"pattern\" string, and\n    // __first1 + 1 is most likely not aligned, as the match is in the middle of\n    // the string.\n    if (_Traits::compare(__first1, __first2, __len2) == 0)\n      return __first1;\n\n    ++__first1;\n  }\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n       const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos > __sz)\n        return __npos;\n\n    if (__n == 0) // There is nothing to search, just return __pos.\n        return __pos;\n\n    const _CharT *__r = __search_substring<_CharT, _Traits>(\n        __p + __pos, __p + __sz, __s, __s + __n);\n\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_rfind\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n              _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__sz < 1)\n        return __npos;\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n    {\n        if (_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n        const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    __pos = _VSTD::min(__pos, __sz);\n    if (__n < __sz - __pos)\n        __pos += __n;\n    else\n        __pos = __sz;\n    const _CharT* __r = _VSTD::__find_end(\n                  __p, __p + __pos, __s, __s + __n, _Traits::eq, \n                        random_access_iterator_tag(), random_access_iterator_tag());\n    if (__n > 0 && __r == __p + __pos)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n// __str_find_first_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_of(const _CharT *__p, _SizeT __sz,\n                const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos >= __sz || __n == 0)\n        return __npos;\n    const _CharT* __r = _VSTD::__find_first_of_ce\n        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_find_last_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_of(const _CharT *__p, _SizeT __sz,\n               const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n    {\n    if (__n != 0)\n    {\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        {\n            const _CharT* __r = _Traits::find(__s, __n, *--__ps);\n            if (__r)\n                return static_cast<_SizeT>(__ps - __p);\n        }\n    }\n    return __npos;\n}\n\n\n// __str_find_first_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                    const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (_Traits::find(__s, __n, *__ps) == 0)\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                          _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (!_Traits::eq(*__ps, __c))\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\n// __str_find_last_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                   const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (_Traits::find(__s, __n, *--__ps) == 0)\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                         _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (!_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\ntemplate<class _Ptr>\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t __do_string_hash(_Ptr __p, _Ptr __e)\n{\n    typedef typename iterator_traits<_Ptr>::value_type value_type;\n    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));\n}\n\ntemplate <class _CharT, class _Iter, class _Traits=char_traits<_CharT> >\nstruct __quoted_output_proxy\n{\n    _Iter  __first;\n    _Iter  __last;\n    _CharT  __delim;\n    _CharT  __escape;\n\n    __quoted_output_proxy(_Iter __f, _Iter __l, _CharT __d, _CharT __e)\n    : __first(__f), __last(__l), __delim(__d), __escape(__e) {}\n    //  This would be a nice place for a string_ref \n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___STRING\n","/// @ref gtc_type_ptr\r\n/// @file glm/gtc/type_ptr.inl\r\n\r\n#include <cstring>\r\n\r\nnamespace glm\r\n{\r\n\t/// @addtogroup gtc_type_ptr\r\n\t/// @{\r\n\r\n\t/// Return the constant address to the data of the vector input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T const * value_ptr\r\n\t(\r\n\t\ttvec2<T, P> const & vec\r\n\t)\r\n\t{\r\n\t\treturn &(vec.x);\r\n\t}\r\n\r\n\t//! Return the address to the data of the vector input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T * value_ptr\r\n\t(\r\n\t\ttvec2<T, P> & vec\r\n\t)\r\n\t{\r\n\t\treturn &(vec.x);\r\n\t}\r\n\r\n\t/// Return the constant address to the data of the vector input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T const * value_ptr\r\n\t(\r\n\t\ttvec3<T, P> const & vec\r\n\t)\r\n\t{\r\n\t\treturn &(vec.x);\r\n\t}\r\n\r\n\t//! Return the address to the data of the vector input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T * value_ptr\r\n\t(\r\n\t\ttvec3<T, P> & vec\r\n\t)\r\n\t{\r\n\t\treturn &(vec.x);\r\n\t}\r\n\t\t\r\n\t/// Return the constant address to the data of the vector input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T const * value_ptr\r\n\t(\t\r\n\t\ttvec4<T, P> const & vec\r\n\t)\r\n\t{\r\n\t\treturn &(vec.x);\r\n\t}\r\n\r\n\t//! Return the address to the data of the vector input.\r\n\t//! From GLM_GTC_type_ptr extension.\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T * value_ptr\r\n\t(\t\r\n\t\ttvec4<T, P> & vec\r\n\t)\r\n\t{\r\n\t\treturn &(vec.x);\r\n\t}\r\n\r\n\t/// Return the constant address to the data of the matrix input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T const * value_ptr\r\n\t(\r\n\t\ttmat2x2<T, P> const & mat\r\n\t)\r\n\t{\r\n\t\treturn &(mat[0].x);\r\n\t}\r\n\r\n\t//! Return the address to the data of the matrix input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T * value_ptr\r\n\t(\r\n\t\ttmat2x2<T, P> & mat\r\n\t)\r\n\t{\r\n\t\treturn &(mat[0].x);\r\n\t}\r\n\t\t\r\n\t/// Return the constant address to the data of the matrix input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T const * value_ptr\r\n\t(\r\n\t\ttmat3x3<T, P> const & mat\r\n\t)\r\n\t{\r\n\t\treturn &(mat[0].x);\r\n\t}\r\n\r\n\t//! Return the address to the data of the matrix input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T * value_ptr\r\n\t(\r\n\t\ttmat3x3<T, P> & mat\r\n\t)\r\n\t{\r\n\t\treturn &(mat[0].x);\r\n\t}\r\n\t\t\r\n\t/// Return the constant address to the data of the matrix input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T const * value_ptr\r\n\t(\r\n\t\ttmat4x4<T, P> const & mat\r\n\t)\r\n\t{\r\n\t\treturn &(mat[0].x);\r\n\t}\r\n\r\n\t//! Return the address to the data of the matrix input.\r\n\t//! From GLM_GTC_type_ptr extension.\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T * value_ptr\r\n\t(\r\n\t\ttmat4x4<T, P> & mat\r\n\t)\r\n\t{\r\n\t\treturn &(mat[0].x);\r\n\t}\r\n\r\n\t/// Return the constant address to the data of the matrix input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T const * value_ptr\r\n\t(\r\n\t\ttmat2x3<T, P> const & mat\r\n\t)\r\n\t{\r\n\t\treturn &(mat[0].x);\r\n\t}\r\n\r\n\t//! Return the address to the data of the matrix input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T * value_ptr\r\n\t(\r\n\t\ttmat2x3<T, P> & mat\r\n\t)\r\n\t{\r\n\t\treturn &(mat[0].x);\r\n\t}\r\n\t\t\r\n\t/// Return the constant address to the data of the matrix input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T const * value_ptr\r\n\t(\r\n\t\ttmat3x2<T, P> const & mat\r\n\t)\r\n\t{\r\n\t\treturn &(mat[0].x);\r\n\t}\r\n\r\n\t//! Return the address to the data of the matrix input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T * value_ptr\r\n\t(\r\n\t\ttmat3x2<T, P> & mat\r\n\t)\r\n\t{\r\n\t\treturn &(mat[0].x);\r\n\t}\r\n\t\t\r\n\t/// Return the constant address to the data of the matrix input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T const * value_ptr\r\n\t(\r\n\t\ttmat2x4<T, P> const & mat\r\n\t)\r\n\t{\r\n\t\treturn &(mat[0].x);\r\n\t}\r\n\r\n\t//! Return the address to the data of the matrix input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T * value_ptr\r\n\t(\r\n\t\ttmat2x4<T, P> & mat\r\n\t)\r\n\t{\r\n\t\treturn &(mat[0].x);\r\n\t}\r\n\t\t\r\n\t/// Return the constant address to the data of the matrix input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T const * value_ptr\r\n\t(\r\n\t\ttmat4x2<T, P> const & mat\r\n\t)\r\n\t{\r\n\t\treturn &(mat[0].x);\r\n\t}\r\n\r\n\t//! Return the address to the data of the matrix input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T * value_ptr\r\n\t(\t\r\n\t\ttmat4x2<T, P> & mat\r\n\t)\r\n\t{\r\n\t\treturn &(mat[0].x);\r\n\t}\r\n\t\t\r\n\t/// Return the constant address to the data of the matrix input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T const * value_ptr\r\n\t(\r\n\t\ttmat3x4<T, P> const & mat\r\n\t)\r\n\t{\r\n\t\treturn &(mat[0].x);\r\n\t}\r\n\r\n\t//! Return the address to the data of the matrix input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T * value_ptr\r\n\t(\r\n\t\ttmat3x4<T, P> & mat\r\n\t)\r\n\t{\r\n\t\treturn &(mat[0].x);\r\n\t}\r\n\t\t\r\n\t/// Return the constant address to the data of the matrix input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T const * value_ptr\r\n\t(\r\n\t\ttmat4x3<T, P> const & mat\r\n\t)\r\n\t{\r\n\t\treturn &(mat[0].x);\r\n\t}\r\n\r\n\t/// Return the address to the data of the matrix input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T * value_ptr(tmat4x3<T, P> & mat)\r\n\t{\r\n\t\treturn &(mat[0].x);\r\n\t}\r\n\r\n\t/// Return the constant address to the data of the input parameter.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T const * value_ptr\r\n\t(\r\n\t\ttquat<T, P> const & q\r\n\t)\r\n\t{\r\n\t\treturn &(q[0]);\r\n\t}\r\n\r\n\t/// Return the address to the data of the quaternion input.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate<typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T * value_ptr\r\n\t(\r\n\t\ttquat<T, P> & q\r\n\t)\r\n\t{\r\n\t\treturn &(q[0]);\r\n\t}\r\n\r\n\t/// Build a vector from a pointer.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tvec2<T, defaultp> make_vec2(T const * const ptr)\r\n\t{\r\n\t\ttvec2<T, defaultp> Result;\r\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tvec2<T, defaultp>));\r\n\t\treturn Result;\r\n\t}\r\n\r\n\t/// Build a vector from a pointer.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, defaultp> make_vec3(T const * const ptr)\r\n\t{\r\n\t\ttvec3<T, defaultp> Result;\r\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tvec3<T, defaultp>));\r\n\t\treturn Result;\r\n\t}\r\n\r\n\t/// Build a vector from a pointer.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tvec4<T, defaultp> make_vec4(T const * const ptr)\r\n\t{\r\n\t\ttvec4<T, defaultp> Result;\r\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tvec4<T, defaultp>));\r\n\t\treturn Result;\r\n\t}\r\n\r\n\t/// Build a matrix from a pointer.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat2x2<T, defaultp> make_mat2x2(T const * const ptr)\r\n\t{\r\n\t\ttmat2x2<T, defaultp> Result;\r\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat2x2<T, defaultp>));\r\n\t\treturn Result;\r\n\t}\r\n\r\n\t/// Build a matrix from a pointer.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat2x3<T, defaultp> make_mat2x3(T const * const ptr)\r\n\t{\r\n\t\ttmat2x3<T, defaultp> Result;\r\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat2x3<T, defaultp>));\r\n\t\treturn Result;\r\n\t}\r\n\r\n\t/// Build a matrix from a pointer.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat2x4<T, defaultp> make_mat2x4(T const * const ptr)\r\n\t{\r\n\t\ttmat2x4<T, defaultp> Result;\r\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat2x4<T, defaultp>));\r\n\t\treturn Result;\r\n\t}\r\n\r\n\t/// Build a matrix from a pointer.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat3x2<T, defaultp> make_mat3x2(T const * const ptr)\r\n\t{\r\n\t\ttmat3x2<T, defaultp> Result;\r\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat3x2<T, defaultp>));\r\n\t\treturn Result;\r\n\t}\r\n\r\n\t//! Build a matrix from a pointer.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat3x3<T, defaultp> make_mat3x3(T const * const ptr)\r\n\t{\r\n\t\ttmat3x3<T, defaultp> Result;\r\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat3x3<T, defaultp>));\r\n\t\treturn Result;\r\n\t}\r\n\r\n\t//! Build a matrix from a pointer.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat3x4<T, defaultp> make_mat3x4(T const * const ptr)\r\n\t{\r\n\t\ttmat3x4<T, defaultp> Result;\r\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat3x4<T, defaultp>));\r\n\t\treturn Result;\r\n\t}\r\n\r\n\t//! Build a matrix from a pointer.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat4x2<T, defaultp> make_mat4x2(T const * const ptr)\r\n\t{\r\n\t\ttmat4x2<T, defaultp> Result;\r\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat4x2<T, defaultp>));\r\n\t\treturn Result;\r\n\t}\r\n\r\n\t//! Build a matrix from a pointer.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat4x3<T, defaultp> make_mat4x3(T const * const ptr)\r\n\t{\r\n\t\ttmat4x3<T, defaultp> Result;\r\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat4x3<T, defaultp>));\r\n\t\treturn Result;\r\n\t}\r\n\r\n\t//! Build a matrix from a pointer.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> make_mat4x4(T const * const ptr)\r\n\t{\r\n\t\ttmat4x4<T, defaultp> Result;\r\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tmat4x4<T, defaultp>));\r\n\t\treturn Result;\r\n\t}\r\n\r\n\t//! Build a matrix from a pointer.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat2x2<T, defaultp> make_mat2(T const * const ptr)\r\n\t{\r\n\t\treturn make_mat2x2(ptr);\r\n\t}\r\n\r\n\t//! Build a matrix from a pointer.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat3x3<T, defaultp> make_mat3(T const * const ptr)\r\n\t{\r\n\t\treturn make_mat3x3(ptr);\r\n\t}\r\n\t\t\r\n\t//! Build a matrix from a pointer.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tmat4x4<T, defaultp> make_mat4(T const * const ptr)\r\n\t{\r\n\t\treturn make_mat4x4(ptr);\r\n\t}\r\n\r\n\t//! Build a quaternion from a pointer.\r\n\t/// @see gtc_type_ptr\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER tquat<T, defaultp> make_quat(T const * const ptr)\r\n\t{\r\n\t\ttquat<T, defaultp> Result;\r\n\t\tmemcpy(value_ptr(Result), ptr, sizeof(tquat<T, defaultp>));\r\n\t\treturn Result;\r\n\t}\r\n\r\n\t/// @}\r\n}//namespace glm\r\n\r\n","#pragma once\r\n\r\n// #include <core/Object.h>\r\n// #include <EGL/eglplatform.h> // TODO: Make to cross platform\r\n\r\nnamespace engine\r\n{\r\n//  Forward declate Application and Graphics -classes.\r\n//\tclass GraphicsApplication;\r\n//\tclass GraphicsSystem;\r\n\r\n\tclass Window\r\n\t{\r\n\tpublic:\r\n\t\t// Window() {};\r\n\t\t// ~Window();\r\n\r\n\t\t// virtual EGLNativeWindowType getNativeWindow() const = 0;\r\n\t\t\r\n\t\tvirtual void setSize(int w, int h) = 0;\r\n\r\n\t\tint getWidth()  { return _width;  }\r\n\t\tint getHeight() { return _height; }\r\n\r\n\t\t// void setApplication(GraphicsApplication* app);\r\n\t\t// void setGraphics(GraphicsSystem* graphics);\r\n\t\t\r\n\tprotected:\r\n\t\tint _width;\r\n\t\tint _height;\r\n\t\t// GraphicsApplication*\tm_app;\r\n\t\t// GraphicsSystem*\t\tm_graphics;\r\n\t};\r\n\r\n}","// -*- C++ -*-\n//===-------------------------- exception ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_EXCEPTION\n#define _LIBCPP_EXCEPTION\n\n/*\n    exception synopsis\n\nnamespace std\n{\n\nclass exception\n{\npublic:\n    exception() noexcept;\n    exception(const exception&) noexcept;\n    exception& operator=(const exception&) noexcept;\n    virtual ~exception() noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_exception\n    : public exception\n{\npublic:\n    bad_exception() noexcept;\n    bad_exception(const bad_exception&) noexcept;\n    bad_exception& operator=(const bad_exception&) noexcept;\n    virtual ~bad_exception() noexcept;\n    virtual const char* what() const noexcept;\n};\n\ntypedef void (*unexpected_handler)();\nunexpected_handler set_unexpected(unexpected_handler  f ) noexcept;\nunexpected_handler get_unexpected() noexcept;\n[[noreturn]] void unexpected();\n\ntypedef void (*terminate_handler)();\nterminate_handler set_terminate(terminate_handler  f ) noexcept;\nterminate_handler get_terminate() noexcept;\n[[noreturn]] void terminate() noexcept;\n\nbool uncaught_exception()  noexcept;\nint  uncaught_exceptions() noexcept;  // C++17\n\ntypedef unspecified exception_ptr;\n\nexception_ptr current_exception() noexcept;\nvoid rethrow_exception [[noreturn]] (exception_ptr p);\ntemplate<class E> exception_ptr make_exception_ptr(E e) noexcept;\n\nclass nested_exception\n{\npublic:\n    nested_exception() noexcept;\n    nested_exception(const nested_exception&) noexcept = default;\n    nested_exception& operator=(const nested_exception&) noexcept = default;\n    virtual ~nested_exception() = default;\n\n    // access functions\n    [[noreturn]] void rethrow_nested() const;\n    exception_ptr nested_ptr() const noexcept;\n};\n\ntemplate <class T> [[noreturn]] void throw_with_nested(T&& t);\ntemplate <class E> void rethrow_if_nested(const E& e);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <cstddef>\n#include <cstdlib>\n#include <type_traits>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI exception\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY exception() _NOEXCEPT {}\n    virtual ~exception() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_exception\n    : public exception\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY bad_exception() _NOEXCEPT {}\n    virtual ~bad_exception() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\ntypedef void (*unexpected_handler)();\n_LIBCPP_FUNC_VIS unexpected_handler set_unexpected(unexpected_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS unexpected_handler get_unexpected() _NOEXCEPT;\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void unexpected();\n\ntypedef void (*terminate_handler)();\n_LIBCPP_FUNC_VIS terminate_handler set_terminate(terminate_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS terminate_handler get_terminate() _NOEXCEPT;\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void terminate() _NOEXCEPT;\n\n_LIBCPP_FUNC_VIS bool uncaught_exception() _NOEXCEPT;\n_LIBCPP_FUNC_VIS int uncaught_exceptions() _NOEXCEPT;\n\nclass _LIBCPP_TYPE_VIS exception_ptr;\n\n_LIBCPP_FUNC_VIS exception_ptr current_exception() _NOEXCEPT;\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void rethrow_exception(exception_ptr);\n\nclass _LIBCPP_TYPE_VIS exception_ptr\n{\n    void* __ptr_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY exception_ptr() _NOEXCEPT : __ptr_() {}\n    _LIBCPP_INLINE_VISIBILITY exception_ptr(nullptr_t) _NOEXCEPT : __ptr_() {}\n    exception_ptr(const exception_ptr&) _NOEXCEPT;\n    exception_ptr& operator=(const exception_ptr&) _NOEXCEPT;\n    ~exception_ptr() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT\n        operator bool() const _NOEXCEPT {return __ptr_ != nullptr;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const exception_ptr& __x, const exception_ptr& __y) _NOEXCEPT\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const exception_ptr& __x, const exception_ptr& __y) _NOEXCEPT\n        {return !(__x == __y);}\n\n    friend _LIBCPP_FUNC_VIS exception_ptr current_exception() _NOEXCEPT;\n    friend _LIBCPP_FUNC_VIS void rethrow_exception(exception_ptr);\n};\n\ntemplate<class _Ep>\nexception_ptr\nmake_exception_ptr(_Ep __e) _NOEXCEPT\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n        throw __e;\n    }\n    catch (...)\n    {\n        return current_exception();\n    }\n#else\n    ((void)__e);\n    _VSTD::abort();\n#endif\n}\n\n// nested_exception\n\nclass _LIBCPP_EXCEPTION_ABI nested_exception\n{\n    exception_ptr __ptr_;\npublic:\n    nested_exception() _NOEXCEPT;\n//     nested_exception(const nested_exception&) noexcept = default;\n//     nested_exception& operator=(const nested_exception&) noexcept = default;\n    virtual ~nested_exception() _NOEXCEPT;\n\n    // access functions\n    _LIBCPP_NORETURN void rethrow_nested() const;\n    _LIBCPP_INLINE_VISIBILITY exception_ptr nested_ptr() const _NOEXCEPT {return __ptr_;}\n};\n\ntemplate <class _Tp>\nstruct __nested\n    : public _Tp,\n      public nested_exception\n{\n    _LIBCPP_INLINE_VISIBILITY explicit __nested(const _Tp& __t) : _Tp(__t) {}\n};\n\ntemplate <class _Tp>\n_LIBCPP_NORETURN\nvoid\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nthrow_with_nested(_Tp&& __t, typename enable_if<\n                  is_class<typename remove_reference<_Tp>::type>::value &&\n                  !is_base_of<nested_exception, typename remove_reference<_Tp>::type>::value\n                  && !__libcpp_is_final<typename remove_reference<_Tp>::type>::value\n                                    >::type* = 0)\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\nthrow_with_nested (_Tp& __t, typename enable_if<\n                  is_class<_Tp>::value && !is_base_of<nested_exception, _Tp>::value\n                                    >::type* = 0)\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw __nested<typename remove_reference<_Tp>::type>(_VSTD::forward<_Tp>(__t));\n#else\n    ((void)__t);\n    // FIXME: Make this abort.\n#endif\n}\n\ntemplate <class _Tp>\n_LIBCPP_NORETURN\nvoid\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nthrow_with_nested(_Tp&& __t, typename enable_if<\n                  !is_class<typename remove_reference<_Tp>::type>::value ||\n                  is_base_of<nested_exception, typename remove_reference<_Tp>::type>::value\n                  || __libcpp_is_final<typename remove_reference<_Tp>::type>::value\n                                    >::type* = 0)\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\nthrow_with_nested (_Tp& __t, typename enable_if<\n                  !is_class<_Tp>::value || is_base_of<nested_exception, _Tp>::value\n                                    >::type* = 0)\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw _VSTD::forward<_Tp>(__t);\n#else\n    ((void)__t);\n    // FIXME: Make this abort\n#endif\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nrethrow_if_nested(const _Ep& __e, typename enable_if<\n                                   is_polymorphic<_Ep>::value\n                                                   >::type* = 0)\n{\n    const nested_exception* __nep = dynamic_cast<const nested_exception*>(_VSTD::addressof(__e));\n    if (__nep)\n        __nep->rethrow_nested();\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nrethrow_if_nested(const _Ep&, typename enable_if<\n                                   !is_polymorphic<_Ep>::value\n                                                   >::type* = 0)\n{\n}\n\n}  // std\n\n#endif  // _LIBCPP_EXCEPTION\n","// -*- C++ -*-\n//===-------------------------- iterator ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ITERATOR\n#define _LIBCPP_ITERATOR\n\n/*\n    iterator synopsis\n\nnamespace std\n{\n\ntemplate<class Iterator>\nstruct iterator_traits\n{\n    typedef typename Iterator::difference_type difference_type;\n    typedef typename Iterator::value_type value_type;\n    typedef typename Iterator::pointer pointer;\n    typedef typename Iterator::reference reference;\n    typedef typename Iterator::iterator_category iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef T* pointer;\n    typedef T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<const T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef const T* pointer;\n    typedef const T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class Category, class T, class Distance = ptrdiff_t,\n         class Pointer = T*, class Reference = T&>\nstruct iterator\n{\n    typedef T         value_type;\n    typedef Distance  difference_type;\n    typedef Pointer   pointer;\n    typedef Reference reference;\n    typedef Category  iterator_category;\n};\n\nstruct input_iterator_tag  {};\nstruct output_iterator_tag {};\nstruct forward_iterator_tag       : public input_iterator_tag         {};\nstruct bidirectional_iterator_tag : public forward_iterator_tag       {};\nstruct random_access_iterator_tag : public bidirectional_iterator_tag {};\n\n// extension: second argument not conforming to C++03\ntemplate <class InputIterator>\nvoid advance(InputIterator& i,\n             typename iterator_traits<InputIterator>::difference_type n);\n\ntemplate <class InputIterator>\ntypename iterator_traits<InputIterator>::difference_type\ndistance(InputIterator first, InputIterator last);\n\ntemplate <class Iterator>\nclass reverse_iterator\n    : public iterator<typename iterator_traits<Iterator>::iterator_category,\n                      typename iterator_traits<Iterator>::value_type,\n                      typename iterator_traits<Iterator>::difference_type,\n                      typename iterator_traits<Iterator>::pointer,\n                      typename iterator_traits<Iterator>::reference>\n{\nprotected:\n    Iterator current;\npublic:\n    typedef Iterator                                            iterator_type;\n    typedef typename iterator_traits<Iterator>::difference_type difference_type;\n    typedef typename iterator_traits<Iterator>::reference       reference;\n    typedef typename iterator_traits<Iterator>::pointer         pointer;\n\n    constexpr reverse_iterator();\n    constexpr explicit reverse_iterator(Iterator x);\n    template <class U> constexpr reverse_iterator(const reverse_iterator<U>& u);\n    template <class U> constexpr reverse_iterator& operator=(const reverse_iterator<U>& u);\n    constexpr Iterator base() const;\n    constexpr reference operator*() const;\n    constexpr pointer   operator->() const;\n    constexpr reverse_iterator& operator++();\n    constexpr reverse_iterator  operator++(int);\n    constexpr reverse_iterator& operator--();\n    constexpr reverse_iterator  operator--(int);\n    constexpr reverse_iterator  operator+ (difference_type n) const;\n    constexpr reverse_iterator& operator+=(difference_type n);\n    constexpr reverse_iterator  operator- (difference_type n) const;\n    constexpr reverse_iterator& operator-=(difference_type n);\n    constexpr reference         operator[](difference_type n) const;\n};\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator==(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator<(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator!=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator>(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator>=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator<=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr auto\noperator-(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y)\n-> decltype(__y.base() - __x.base());   // constexpr in C++17\n\ntemplate <class Iterator>\nconstexpr reverse_iterator<Iterator>\noperator+(typename reverse_iterator<Iterator>::difference_type n, \n          const reverse_iterator<Iterator>& x);   // constexpr in C++17\n\ntemplate <class Iterator>\nconstexpr reverse_iterator<Iterator> make_reverse_iterator(Iterator i); // C++14, constexpr in C++17\n\ntemplate <class Container>\nclass back_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                   container_type;\n    typedef void                        value_type;\n    typedef void                        difference_type;\n    typedef void                        reference;\n    typedef void                        pointer;\n\n    explicit back_insert_iterator(Container& x);\n    back_insert_iterator& operator=(const typename Container::value_type& value);\n    back_insert_iterator& operator*();\n    back_insert_iterator& operator++();\n    back_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> back_insert_iterator<Container> back_inserter(Container& x);\n\ntemplate <class Container>\nclass front_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                    container_type;\n    typedef void                         value_type;\n    typedef void                         difference_type;\n    typedef void                         reference;\n    typedef void                         pointer;\n\n    explicit front_insert_iterator(Container& x);\n    front_insert_iterator& operator=(const typename Container::value_type& value);\n    front_insert_iterator& operator*();\n    front_insert_iterator& operator++();\n    front_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> front_insert_iterator<Container> front_inserter(Container& x);\n\ntemplate <class Container>\nclass insert_iterator\n{\nprotected:\n    Container* container;\n    typename Container::iterator iter;\npublic:\n    typedef Container              container_type;\n    typedef void                   value_type;\n    typedef void                   difference_type;\n    typedef void                   reference;\n    typedef void                   pointer;\n\n    insert_iterator(Container& x, typename Container::iterator i);\n    insert_iterator& operator=(const typename Container::value_type& value);\n    insert_iterator& operator*();\n    insert_iterator& operator++();\n    insert_iterator& operator++(int);\n};\n\ntemplate <class Container, class Iterator>\ninsert_iterator<Container> inserter(Container& x, Iterator i);\n\ntemplate <class Iterator>\nclass move_iterator {\npublic:\n    typedef Iterator                                              iterator_type;\n    typedef typename iterator_traits<Iterator>::difference_type   difference_type;\n    typedef Iterator                                              pointer;\n    typedef typename iterator_traits<Iterator>::value_type        value_type;\n    typedef typename iterator_traits<Iterator>::iterator_category iterator_category;\n    typedef value_type&&                                          reference;\n \n    constexpr move_iterator();  // all the constexprs are in C++17\n    constexpr explicit move_iterator(Iterator i);\n    template <class U>\n      constexpr move_iterator(const move_iterator<U>& u);\n    template <class U>\n      constexpr move_iterator& operator=(const move_iterator<U>& u);\n    constexpr iterator_type base() const;\n    constexpr reference operator*() const;\n    constexpr pointer operator->() const;\n    constexpr move_iterator& operator++();\n    constexpr move_iterator operator++(int);\n    constexpr move_iterator& operator--();\n    constexpr move_iterator operator--(int);\n    constexpr move_iterator operator+(difference_type n) const; \n    constexpr move_iterator& operator+=(difference_type n); \n    constexpr move_iterator operator-(difference_type n) const; \n    constexpr move_iterator& operator-=(difference_type n); \n    constexpr unspecified operator[](difference_type n) const;\nprivate:\n    Iterator current; // exposition only\n};\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator==(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator!=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator<(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator<=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator>(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator>=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr auto   // constexpr in C++17\noperator-(const move_iterator<Iterator1>& x,\n          const move_iterator<Iterator2>& y) -> decltype(x.base() - y.base());\n\ntemplate <class Iterator>\nconstexpr move_iterator<Iterator> operator+(   // constexpr in C++17\n            typename move_iterator<Iterator>::difference_type n, \n            const move_iterator<Iterator>& x);\n\ntemplate <class Iterator>   // constexpr in C++17\nconstexpr  move_iterator<Iterator> make_move_iterator(const Iterator& i);\n\n\ntemplate <class T, class charT = char, class traits = char_traits<charT>, class Distance = ptrdiff_t>\nclass istream_iterator\n    : public iterator<input_iterator_tag, T, Distance, const T*, const T&>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_istream<charT,traits> istream_type;\n\n    constexpr istream_iterator();\n    istream_iterator(istream_type& s);\n    istream_iterator(const istream_iterator& x);\n    ~istream_iterator();\n\n    const T& operator*() const;\n    const T* operator->() const;\n    istream_iterator& operator++();\n    istream_iterator  operator++(int);\n};\n\ntemplate <class T, class charT, class traits, class Distance>\nbool operator==(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\ntemplate <class T, class charT, class traits, class Distance>\nbool operator!=(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT> >\nclass ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void ,void>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_ostream<charT,traits> ostream_type;\n\n    ostream_iterator(ostream_type& s);\n    ostream_iterator(ostream_type& s, const charT* delimiter);\n    ostream_iterator(const ostream_iterator& x);\n    ~ostream_iterator();\n    ostream_iterator& operator=(const T& value);\n\n    ostream_iterator& operator*();\n    ostream_iterator& operator++();\n    ostream_iterator& operator++(int);\n};\n\ntemplate<class charT, class traits = char_traits<charT> >\nclass istreambuf_iterator\n    : public iterator<input_iterator_tag, charT,\n                      typename traits::off_type, unspecified,\n                      charT>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef typename traits::int_type     int_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_istream<charT,traits>   istream_type;\n\n    istreambuf_iterator() noexcept;\n    istreambuf_iterator(istream_type& s) noexcept;\n    istreambuf_iterator(streambuf_type* s) noexcept;\n    istreambuf_iterator(a-private-type) noexcept;\n\n    charT                operator*() const;\n    pointer operator->() const;\n    istreambuf_iterator& operator++();\n    a-private-type       operator++(int);\n\n    bool equal(const istreambuf_iterator& b) const;\n};\n\ntemplate <class charT, class traits>\nbool operator==(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\ntemplate <class charT, class traits>\nbool operator!=(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_ostream<charT,traits>   ostream_type;\n\n    ostreambuf_iterator(ostream_type& s) noexcept;\n    ostreambuf_iterator(streambuf_type* s) noexcept;\n    ostreambuf_iterator& operator=(charT c);\n    ostreambuf_iterator& operator*();\n    ostreambuf_iterator& operator++();\n    ostreambuf_iterator& operator++(int);\n    bool failed() const noexcept;\n};\n\ntemplate <class C> constexpr auto begin(C& c) -> decltype(c.begin());\ntemplate <class C> constexpr auto begin(const C& c) -> decltype(c.begin());\ntemplate <class C> constexpr auto end(C& c) -> decltype(c.end());\ntemplate <class C> constexpr auto end(const C& c) -> decltype(c.end());\ntemplate <class T, size_t N> constexpr T* begin(T (&array)[N]);\ntemplate <class T, size_t N> constexpr T* end(T (&array)[N]);\n\ntemplate <class C> auto constexpr cbegin(const C& c) -> decltype(std::begin(c));        // C++14\ntemplate <class C> auto constexpr cend(const C& c) -> decltype(std::end(c));            // C++14\ntemplate <class C> auto constexpr rbegin(C& c) -> decltype(c.rbegin());                 // C++14\ntemplate <class C> auto constexpr rbegin(const C& c) -> decltype(c.rbegin());           // C++14\ntemplate <class C> auto constexpr rend(C& c) -> decltype(c.rend());                     // C++14\ntemplate <class C> constexpr auto rend(const C& c) -> decltype(c.rend());               // C++14\ntemplate <class E> reverse_iterator<const E*> constexpr rbegin(initializer_list<E> il); // C++14\ntemplate <class E> reverse_iterator<const E*> constexpr rend(initializer_list<E> il);   // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> constexpr rbegin(T (&array)[N]);      // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> constexpr rend(T (&array)[N]);        // C++14\ntemplate <class C> constexpr auto crbegin(const C& c) -> decltype(std::rbegin(c));      // C++14\ntemplate <class C> constexpr auto crend(const C& c) -> decltype(std::rend(c));          // C++14\n\n// 24.8, container access:\ntemplate <class C> constexpr auto size(const C& c) -> decltype(c.size());         // C++17\ntemplate <class T, size_t N> constexpr size_t size(const T (&array)[N]) noexcept; // C++17\ntemplate <class C> constexpr auto empty(const C& c) -> decltype(c.empty());       // C++17\ntemplate <class T, size_t N> constexpr bool empty(const T (&array)[N]) noexcept;  // C++17\ntemplate <class E> constexpr bool empty(initializer_list<E> il) noexcept;         // C++17\ntemplate <class C> constexpr auto data(C& c) -> decltype(c.data());               // C++17\ntemplate <class C> constexpr auto data(const C& c) -> decltype(c.data());         // C++17\ntemplate <class T, size_t N> constexpr T* data(T (&array)[N]) noexcept;           // C++17\ntemplate <class E> constexpr const E* data(initializer_list<E> il) noexcept;      // C++17\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd> // for forward declarations of vector and string.\n#include <__functional_base>\n#include <type_traits>\n#include <cstddef>\n#include <initializer_list>\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nstruct _LIBCPP_TEMPLATE_VIS input_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS output_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS forward_iterator_tag       : public input_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS bidirectional_iterator_tag : public forward_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS random_access_iterator_tag : public bidirectional_iterator_tag {};\n\ntemplate <class _Tp>\nstruct __has_iterator_category\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::iterator_category* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits_impl {};\n\ntemplate <class _Iter>\nstruct __iterator_traits_impl<_Iter, true>\n{\n    typedef typename _Iter::difference_type   difference_type;\n    typedef typename _Iter::value_type        value_type;\n    typedef typename _Iter::pointer           pointer;\n    typedef typename _Iter::reference         reference;\n    typedef typename _Iter::iterator_category iterator_category;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits {};\n\ntemplate <class _Iter>\nstruct __iterator_traits<_Iter, true>\n    :  __iterator_traits_impl\n      <\n        _Iter,\n        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||\n        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value\n      >\n{};\n\n// iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category\n//    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a\n//    conforming extension which allows some programs to compile and behave as\n//    the client expects instead of failing at compile time.\n\ntemplate <class _Iter>\nstruct _LIBCPP_TEMPLATE_VIS iterator_traits\n    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS iterator_traits<_Tp*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef typename remove_const<_Tp>::type value_type;\n    typedef _Tp* pointer;\n    typedef _Tp& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>\nstruct __has_iterator_category_convertible_to\n    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>\n{};\n\ntemplate <class _Tp, class _Up>\nstruct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};\n\ntemplate <class _Tp>\nstruct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_exactly_input_iterator\n    : public integral_constant<bool, \n         __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value && \n        !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value> {};\n\ntemplate<class _Category, class _Tp, class _Distance = ptrdiff_t,\n         class _Pointer = _Tp*, class _Reference = _Tp&>\nstruct _LIBCPP_TEMPLATE_VIS iterator\n{\n    typedef _Tp        value_type;\n    typedef _Distance  difference_type;\n    typedef _Pointer   pointer;\n    typedef _Reference reference;\n    typedef _Category  iterator_category;\n};\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)\n{\n    for (; __n > 0; --__n)\n        ++__i;\n}\n\ntemplate <class _BiDirIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_BiDirIter& __i,\n             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)\n{\n    if (__n >= 0)\n        for (; __n > 0; --__n)\n            ++__i;\n    else\n        for (; __n < 0; ++__n)\n            --__i;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_RandIter& __i,\n             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)\n{\n   __i += __n;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n)\n{\n    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\n__distance(_InputIter __first, _InputIter __last, input_iterator_tag)\n{\n    typename iterator_traits<_InputIter>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        ++__r;\n    return __r;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_RandIter>::difference_type\n__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)\n{\n    return __last - __first;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\ndistance(_InputIter __first, _InputIter __last)\n{\n    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIter\nnext(_InputIter __x,\n     typename iterator_traits<_InputIter>::difference_type __n = 1,\n     typename enable_if<__is_input_iterator<_InputIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, __n);\n    return __x;\n}\n\ntemplate <class _BidiretionalIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidiretionalIter\nprev(_BidiretionalIter __x,\n     typename iterator_traits<_BidiretionalIter>::difference_type __n = 1,\n     typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, -__n);\n    return __x;\n}\n\ntemplate <class _Iter>\nclass _LIBCPP_TEMPLATE_VIS reverse_iterator\n    : public iterator<typename iterator_traits<_Iter>::iterator_category,\n                      typename iterator_traits<_Iter>::value_type,\n                      typename iterator_traits<_Iter>::difference_type,\n                      typename iterator_traits<_Iter>::pointer,\n                      typename iterator_traits<_Iter>::reference>\n{\nprivate:\n    /*mutable*/ _Iter __t;  // no longer used as of LWG #2360, not removed due to ABI break\nprotected:\n    _Iter current;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<_Iter>::difference_type difference_type;\n    typedef typename iterator_traits<_Iter>::reference       reference;\n    typedef typename iterator_traits<_Iter>::pointer         pointer;\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator() : __t(), current() {}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n        reverse_iterator(const reverse_iterator<_Up>& __u) : __t(__u.base()), current(__u.base()) {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n        reverse_iterator& operator=(const reverse_iterator<_Up>& __u)\n            { __t = current = __u.base(); return *this; }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    _Iter base() const {return current;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reference operator*() const {_Iter __tmp = current; return *--__tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    pointer  operator->() const {return _VSTD::addressof(operator*());}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator++() {--current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator++(int) {reverse_iterator __tmp(*this); --current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator--() {++current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator--(int) {reverse_iterator __tmp(*this); ++current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator+ (difference_type __n) const {return reverse_iterator(current - __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator+=(difference_type __n) {current -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator- (difference_type __n) const {return reverse_iterator(current + __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator-=(difference_type __n) {current += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reference         operator[](difference_type __n) const {return *(*this + __n);}\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n-> decltype(__y.base() - __x.base())\n{\n    return __y.base() - __x.base();\n}\n#else\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename reverse_iterator<_Iter1>::difference_type\noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __y.base() - __x.base();\n}\n#endif\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Iter>\noperator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)\n{\n    return reverse_iterator<_Iter>(__x.base() - __n);\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Iter> make_reverse_iterator(_Iter __i)\n{\n    return reverse_iterator<_Iter>(__i);\n}\n#endif\n\ntemplate <class _Container>\nclass _LIBCPP_TEMPLATE_VIS back_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      void>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit back_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_back(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_back(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nback_insert_iterator<_Container>\nback_inserter(_Container& __x)\n{\n    return back_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TEMPLATE_VIS front_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      void>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit front_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_front(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_front(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nfront_insert_iterator<_Container>\nfront_inserter(_Container& __x)\n{\n    return front_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TEMPLATE_VIS insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      void>\n{\nprotected:\n    _Container* container;\n    typename _Container::iterator iter;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY insert_iterator(_Container& __x, typename _Container::iterator __i)\n        : container(_VSTD::addressof(__x)), iter(__i) {}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {iter = container->insert(iter, __value_); ++iter; return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {iter = container->insert(iter, _VSTD::move(__value_)); ++iter; return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator*()        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++()       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++(int)    {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\ninsert_iterator<_Container>\ninserter(_Container& __x, typename _Container::iterator __i)\n{\n    return insert_iterator<_Container>(__x, __i);\n}\n\ntemplate <class _Tp, class _CharT = char,\n          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>\nclass _LIBCPP_TEMPLATE_VIS istream_iterator\n    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_istream<_CharT,_Traits> istream_type;\nprivate:\n    istream_type* __in_stream_;\n    _Tp __value_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istream_iterator() : __in_stream_(0), __value_() {}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator(istream_type& __s) : __in_stream_(_VSTD::addressof(__s))\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY const _Tp& operator*() const {return __value_;}\n    _LIBCPP_INLINE_VISIBILITY const _Tp* operator->() const {return _VSTD::addressof((operator*()));}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator& operator++()\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY istream_iterator  operator++(int)\n        {istream_iterator __t(*this); ++(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const istream_iterator& __x, const istream_iterator& __y)\n        {return __x.__in_stream_ == __y.__in_stream_;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_ostream<_CharT,_Traits> ostream_type;\nprivate:\n    ostream_type* __out_stream_;\n    const char_type* __delim_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s) _NOEXCEPT\n        : __out_stream_(_VSTD::addressof(__s)), __delim_(0) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s, const _CharT* __delimiter) _NOEXCEPT\n        : __out_stream_(_VSTD::addressof(__s)), __delim_(__delimiter) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator=(const _Tp& __value_)\n        {\n            *__out_stream_ << __value_;\n            if (__delim_)\n                *__out_stream_ << __delim_;\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++(int) {return *this;}\n};\n\ntemplate<class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS istreambuf_iterator\n    : public iterator<input_iterator_tag, _CharT,\n                      typename _Traits::off_type, _CharT*,\n                      _CharT>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef typename _Traits::int_type      int_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_istream<_CharT,_Traits>   istream_type;\nprivate:\n    mutable streambuf_type* __sbuf_;\n\n    class __proxy\n    {\n        char_type __keep_;\n        streambuf_type* __sbuf_;\n        _LIBCPP_INLINE_VISIBILITY __proxy(char_type __c, streambuf_type* __s)\n            : __keep_(__c), __sbuf_(__s) {}\n        friend class istreambuf_iterator;\n    public:\n        _LIBCPP_INLINE_VISIBILITY char_type operator*() const {return __keep_;}\n    };\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __test_for_eof() const\n    {\n        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))\n            __sbuf_ = 0;\n        return __sbuf_ == 0;\n    }\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istreambuf_iterator() _NOEXCEPT : __sbuf_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(istream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(const __proxy& __p) _NOEXCEPT\n        : __sbuf_(__p.__sbuf_) {}\n\n    _LIBCPP_INLINE_VISIBILITY char_type  operator*() const\n        {return static_cast<char_type>(__sbuf_->sgetc());}\n    _LIBCPP_INLINE_VISIBILITY char_type* operator->() const {return nullptr;}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator& operator++()\n        {\n            __sbuf_->sbumpc();\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY __proxy              operator++(int)\n        {\n            return __proxy(__sbuf_->sbumpc(), __sbuf_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY bool equal(const istreambuf_iterator& __b) const\n        {return __test_for_eof() == __b.__test_for_eof();}\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return __a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return !__a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_ostream<_CharT,_Traits>   ostream_type;\nprivate:\n    streambuf_type* __sbuf_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(ostream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator=(_CharT __c)\n        {\n            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))\n                __sbuf_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++(int) {return *this;}\n    _LIBCPP_INLINE_VISIBILITY bool failed() const _NOEXCEPT {return __sbuf_ == 0;}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\n    template <class _Ch, class _Tr>\n    friend\n    _LIBCPP_HIDDEN\n    ostreambuf_iterator<_Ch, _Tr>\n    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,\n                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,\n                     ios_base& __iob, _Ch __fl);\n#endif\n};\n\ntemplate <class _Iter>\nclass _LIBCPP_TEMPLATE_VIS move_iterator\n{\nprivate:\n    _Iter __i;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type difference_type;\n    typedef iterator_type pointer;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    typedef typename iterator_traits<iterator_type>::reference __reference;\n    typedef typename conditional<\n            is_reference<__reference>::value,\n            typename remove_reference<__reference>::type&&,\n            __reference\n        >::type reference;\n#else\n    typedef typename iterator_traits<iterator_type>::reference reference;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator() : __i() {}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    explicit move_iterator(_Iter __x) : __i(__x) {}\n    template <class _Up>\n      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n      move_iterator(const move_iterator<_Up>& __u) : __i(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 _Iter base() const {return __i;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 \n    reference operator*() const { return static_cast<reference>(*__i); }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    pointer  operator->() const { return __i;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator++() {++__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator++(int) {move_iterator __tmp(*this); ++__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator--() {--__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator--(int) {move_iterator __tmp(*this); --__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator+ (difference_type __n) const {return move_iterator(__i + __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator+=(difference_type __n) {__i += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator- (difference_type __n) const {return move_iterator(__i - __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator-=(difference_type __n) {__i -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reference operator[](difference_type __n) const { return static_cast<reference>(__i[__n]); }\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n-> decltype(__x.base() - __y.base())\n{\n    return __x.base() - __y.base();\n}\n#else\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename move_iterator<_Iter1>::difference_type\noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() - __y.base();\n}\n#endif\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nmove_iterator<_Iter>\noperator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)\n{\n    return move_iterator<_Iter>(__x.base() + __n);\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nmove_iterator<_Iter>\nmake_move_iterator(_Iter __i)\n{\n    return move_iterator<_Iter>(__i);\n}\n\n// __wrap_iter\n\ntemplate <class _Iter> class __wrap_iter;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nauto\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n-> decltype(__x.base() - __y.base());\n#else\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n#endif\n\ntemplate <class _Iter>\n_LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) _NOEXCEPT_DEBUG;\n\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY copy(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY copy_backward(_B1, _B1, _B2);\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY move(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY move_backward(_B1, _B1, _B2);\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*>);\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    __wrap_iter<_Tp*>\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i);\n\n#endif\n\ntemplate <class _Iter>\nclass __wrap_iter\n{\npublic:\n    typedef _Iter                                                      iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type        value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type   difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer           pointer;\n    typedef typename iterator_traits<iterator_type>::reference         reference;\nprivate:\n    iterator_type __i;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter() _NOEXCEPT_DEBUG\n#if _LIBCPP_STD_VER > 11\n                : __i{}\n#endif\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY __wrap_iter(const __wrap_iter<_Up>& __u,\n        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) _NOEXCEPT_DEBUG\n        : __i(__u.base())\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__u);\n#endif\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter(const __wrap_iter& __x)\n        : __i(__x.base())\n    {\n        __get_db()->__iterator_copy(this, &__x);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter& operator=(const __wrap_iter& __x)\n    {\n        if (this != &__x)\n        {\n            __get_db()->__iterator_copy(this, &__x);\n            __i = __x.__i;\n        }\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    ~__wrap_iter()\n    {\n        __get_db()->__erase_i(this);\n    }\n#endif\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return *__i;\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return (pointer)_VSTD::addressof(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator++() _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable iterator\");\n#endif\n        ++__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator++(int) _NOEXCEPT_DEBUG\n        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator--() _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable iterator\");\n#endif\n        --__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator--(int) _NOEXCEPT_DEBUG\n        {__wrap_iter __tmp(*this); --(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator+ (difference_type __n) const _NOEXCEPT_DEBUG\n        {__wrap_iter __w(*this); __w += __n; return __w;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator+=(difference_type __n) _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__addable(this, __n),\n                   \"Attempted to add/subtract iterator outside of valid range\");\n#endif\n        __i += __n;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator- (difference_type __n) const _NOEXCEPT_DEBUG\n        {return *this + (-__n);}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator-=(difference_type __n) _NOEXCEPT_DEBUG\n        {*this += -__n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference        operator[](difference_type __n) const _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__subscriptable(this, __n),\n                   \"Attempted to subscript iterator outside of valid range\");\n#endif\n        return __i[__n];\n    }\n\n    _LIBCPP_INLINE_VISIBILITY iterator_type base() const _NOEXCEPT_DEBUG {return __i;}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(const void* __p, iterator_type __x) : __i(__x)\n    {\n        __get_db()->__insert_ic(this, __p);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(iterator_type __x) _NOEXCEPT_DEBUG : __i(__x) {}\n#endif\n\n    template <class _Up> friend class __wrap_iter;\n    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;\n    template <class _Tp, class _Alloc> friend class _LIBCPP_TEMPLATE_VIS vector;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Iter1, class _Iter2>\n    friend\n    auto\n    operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n    -> decltype(__x.base() - __y.base());\n#else\n    template <class _Iter1, class _Iter2>\n    friend\n    typename __wrap_iter<_Iter1>::difference_type\n    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n#endif\n\n    template <class _Iter1>\n    friend\n    __wrap_iter<_Iter1>\n    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) _NOEXCEPT_DEBUG;\n\n    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);\n    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n    template <class _Tp>\n    friend\n    typename enable_if\n    <\n        is_trivially_copy_assignable<_Tp>::value,\n        _Tp*\n    >::type\n    __unwrap_iter(__wrap_iter<_Tp*>);\n#else\n  template <class _Tp>\n  inline _LIBCPP_INLINE_VISIBILITY\n  typename enable_if\n  <\n      is_trivially_copy_assignable<_Tp>::value,\n      __wrap_iter<_Tp*>\n  >::type\n  __unwrap_iter(__wrap_iter<_Tp*> __i);\n#endif\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to compare incomparable iterators\");\n#endif\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__y < __x);\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n-> decltype(__x.base() - __y.base())\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to subtract incompatible iterators\");\n#endif\n    return __x.base() - __y.base();\n}\n#else\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to subtract incompatible iterators\");\n#endif\n    return __x.base() - __y.base();\n}\n#endif\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type __n,\n          __wrap_iter<_Iter> __x) _NOEXCEPT_DEBUG\n{\n    __x += __n;\n    return __x;\n}\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator\n    : public _LIBCPP_BOOL_CONSTANT(is_pointer<_Iter>::value) {};\n    \ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<move_iterator<_Iter> >\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<reverse_iterator<_Iter> >\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nbegin(_Tp (&__array)[_Np])\n{\n    return __array;\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nend(_Tp (&__array)[_Np])\n{\n    return __array + _Np;\n}\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nbegin(_Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nbegin(const _Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nend(_Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nend(const _Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array + _Np);\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array);\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.end());\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.begin());\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cbegin(const _Cp& __c) -> decltype(_VSTD::begin(__c))\n{\n    return _VSTD::begin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cend(const _Cp& __c) -> decltype(_VSTD::end(__c))\n{\n    return _VSTD::end(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rbegin(_Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rbegin(const _Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rend(_Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rend(const _Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto crbegin(const _Cp& __c) -> decltype(_VSTD::rbegin(__c))\n{\n    return _VSTD::rbegin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto crend(const _Cp& __c) -> decltype(_VSTD::rend(__c))\n{\n    return _VSTD::rend(__c);\n}\n\n#endif\n\n\n#else  // defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nbegin(_Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nbegin(const _Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nend(_Cp& __c)\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nend(const _Cp& __c)\n{\n    return __c.end();\n}\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Cont>\nconstexpr auto size(const _Cont& __c) -> decltype(__c.size()) { return __c.size(); }\n\ntemplate <class _Tp, size_t _Sz>\nconstexpr size_t size(const _Tp (&)[_Sz]) noexcept { return _Sz; }\n\ntemplate <class _Cont>\nconstexpr auto empty(const _Cont& __c) -> decltype(__c.empty()) { return __c.empty(); }\n\ntemplate <class _Tp, size_t _Sz>\nconstexpr bool empty(const _Tp (&)[_Sz]) noexcept { return false; }\n\ntemplate <class _Ep>\nconstexpr bool empty(initializer_list<_Ep> __il) noexcept { return __il.size() == 0; }\n\ntemplate <class _Cont> constexpr\nauto data(_Cont& __c) -> decltype(__c.data()) { return __c.data(); }\n\ntemplate <class _Cont> constexpr\nauto data(const _Cont& __c) -> decltype(__c.data()) { return __c.data(); }\n\ntemplate <class _Tp, size_t _Sz>\nconstexpr _Tp* data(_Tp (&__array)[_Sz]) noexcept { return __array; }\n\ntemplate <class _Ep>\nconstexpr const _Ep* data(initializer_list<_Ep> __il) noexcept { return __il.begin(); }\n#endif\n\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ITERATOR\n","// -*- C++ -*-\n//===-------------------------- locale ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_LOCALE\n#define _LIBCPP_LOCALE\n\n/*\n    locale synopsis\n\nnamespace std\n{\n\nclass locale\n{\npublic:\n    // types:\n    class facet;\n    class id;\n\n    typedef int category;\n    static const category // values assigned here are for exposition only\n        none     = 0x000,\n        collate  = 0x010,\n        ctype    = 0x020,\n        monetary = 0x040,\n        numeric  = 0x080,\n        time     = 0x100,\n        messages = 0x200,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale() noexcept;\n    locale(const locale& other) noexcept;\n    explicit locale(const char* std_name);\n    explicit locale(const string& std_name);\n    locale(const locale& other, const char* std_name, category);\n    locale(const locale& other, const string& std_name, category);\n    template <class Facet> locale(const locale& other, Facet* f);\n    locale(const locale& other, const locale& one, category);\n\n    ~locale(); // not virtual\n\n    const locale& operator=(const locale& other) noexcept;\n\n    template <class Facet> locale combine(const locale& other) const;\n\n    // locale operations:\n    basic_string<char> name() const;\n    bool operator==(const locale& other) const;\n    bool operator!=(const locale& other) const;\n    template <class charT, class Traits, class Allocator>\n      bool operator()(const basic_string<charT,Traits,Allocator>& s1,\n                      const basic_string<charT,Traits,Allocator>& s2) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n};\n\ntemplate <class Facet> const Facet& use_facet(const locale&);\ntemplate <class Facet> bool has_facet(const locale&) noexcept;\n\n// 22.3.3, convenience interfaces:\ntemplate <class charT> bool isspace (charT c, const locale& loc);\ntemplate <class charT> bool isprint (charT c, const locale& loc);\ntemplate <class charT> bool iscntrl (charT c, const locale& loc);\ntemplate <class charT> bool isupper (charT c, const locale& loc);\ntemplate <class charT> bool islower (charT c, const locale& loc);\ntemplate <class charT> bool isalpha (charT c, const locale& loc);\ntemplate <class charT> bool isdigit (charT c, const locale& loc);\ntemplate <class charT> bool ispunct (charT c, const locale& loc);\ntemplate <class charT> bool isxdigit(charT c, const locale& loc);\ntemplate <class charT> bool isalnum (charT c, const locale& loc);\ntemplate <class charT> bool isgraph (charT c, const locale& loc);\ntemplate <class charT> charT toupper(charT c, const locale& loc);\ntemplate <class charT> charT tolower(charT c, const locale& loc);\n\ntemplate<class Codecvt, class Elem = wchar_t,\n         class Wide_alloc = allocator<Elem>,\n         class Byte_alloc = allocator<char>>\nclass wstring_convert\n{\npublic:\n    typedef basic_string<char, char_traits<char>, Byte_alloc> byte_string;\n    typedef basic_string<Elem, char_traits<Elem>, Wide_alloc> wide_string;\n    typedef typename Codecvt::state_type                      state_type;\n    typedef typename wide_string::traits_type::int_type       int_type;\n\n    explicit wstring_convert(Codecvt* pcvt = new Codecvt);          // explicit in C++14\n    wstring_convert(Codecvt* pcvt, state_type state);\n    explicit wstring_convert(const byte_string& byte_err,           // explicit in C++14\n                    const wide_string& wide_err = wide_string());\n    wstring_convert(const wstring_convert&) = delete;               // C++14\n    wstring_convert & operator=(const wstring_convert &) = delete;  // C++14\n    ~wstring_convert();\n\n    wide_string from_bytes(char byte);\n    wide_string from_bytes(const char* ptr);\n    wide_string from_bytes(const byte_string& str);\n    wide_string from_bytes(const char* first, const char* last);\n\n    byte_string to_bytes(Elem wchar);\n    byte_string to_bytes(const Elem* wptr);\n    byte_string to_bytes(const wide_string& wstr);\n    byte_string to_bytes(const Elem* first, const Elem* last);\n\n    size_t converted() const; // noexcept in C++14\n    state_type state() const;\n};\n\ntemplate <class Codecvt, class Elem = wchar_t, class Tr = char_traits<Elem>>\nclass wbuffer_convert\n    : public basic_streambuf<Elem, Tr>\n{\npublic:\n    typedef typename Tr::state_type state_type;\n\n    explicit wbuffer_convert(streambuf* bytebuf = 0, Codecvt* pcvt = new Codecvt,\n                    state_type state = state_type());       // explicit in C++14\n    wbuffer_convert(const wbuffer_convert&) = delete;               // C++14\n    wbuffer_convert & operator=(const wbuffer_convert &) = delete;  // C++14\n    ~wbuffer_convert();                                             // C++14\n    \n    streambuf* rdbuf() const;\n    streambuf* rdbuf(streambuf* bytebuf);\n\n    state_type state() const;\n};\n\n// 22.4.1 and 22.4.1.3, ctype:\nclass ctype_base;\ntemplate <class charT> class ctype;\ntemplate <> class ctype<char>; // specialization\ntemplate <class charT> class ctype_byname;\ntemplate <> class ctype_byname<char>; // specialization\n\nclass codecvt_base;\ntemplate <class internT, class externT, class stateT> class codecvt;\ntemplate <class internT, class externT, class stateT> class codecvt_byname;\n\n// 22.4.2 and 22.4.3, numeric:\ntemplate <class charT, class InputIterator> class num_get;\ntemplate <class charT, class OutputIterator> class num_put;\ntemplate <class charT> class numpunct;\ntemplate <class charT> class numpunct_byname;\n\n// 22.4.4, col lation:\ntemplate <class charT> class collate;\ntemplate <class charT> class collate_byname;\n\n// 22.4.5, date and time:\nclass time_base;\ntemplate <class charT, class InputIterator> class time_get;\ntemplate <class charT, class InputIterator> class time_get_byname;\ntemplate <class charT, class OutputIterator> class time_put;\ntemplate <class charT, class OutputIterator> class time_put_byname;\n\n// 22.4.6, money:\nclass money_base;\ntemplate <class charT, class InputIterator> class money_get;\ntemplate <class charT, class OutputIterator> class money_put;\ntemplate <class charT, bool Intl> class moneypunct;\ntemplate <class charT, bool Intl> class moneypunct_byname;\n\n// 22.4.7, message retrieval:\nclass messages_base;\ntemplate <class charT> class messages;\ntemplate <class charT> class messages_byname;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__locale>\n#include <__debug>\n#include <algorithm>\n#include <memory>\n#include <ios>\n#include <streambuf>\n#include <iterator>\n#include <limits>\n#ifndef __APPLE__\n#include <cstdarg>\n#endif\n#include <cstdlib>\n#include <ctime>\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n#include <support/win32/locale_win32.h>\n#elif defined(_NEWLIB_VERSION)\n// FIXME: replace all the uses of _NEWLIB_VERSION with __NEWLIB__ preceded by an\n// include of <sys/cdefs.h> once https://sourceware.org/ml/newlib-cvs/2014-q3/msg00038.html\n// has had a chance to bake for a bit\n#include <support/newlib/xlocale.h>\n#endif\n#ifdef _LIBCPP_HAS_CATOPEN\n#include <nl_types.h>\n#endif\n\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n#include <__bsd_locale_defaults.h>\n#else\n#include <__bsd_locale_fallbacks.h>\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if defined(__APPLE__) || defined(__FreeBSD__)\n#  define _LIBCPP_GET_C_LOCALE 0\n#elif defined(__CloudABI__) || defined(__NetBSD__)\n#  define _LIBCPP_GET_C_LOCALE LC_C_LOCALE\n#else\n#  define _LIBCPP_GET_C_LOCALE __cloc()\n   // Get the C locale object\n   _LIBCPP_FUNC_VIS locale_t __cloc();\n#define __cloc_defined\n#endif\n\ntypedef _VSTD::remove_pointer<locale_t>::type __locale_struct;\ntypedef _VSTD::unique_ptr<__locale_struct, decltype(&freelocale)> __locale_unique_ptr;\n\n// __scan_keyword\n// Scans [__b, __e) until a match is found in the basic_strings range\n//  [__kb, __ke) or until it can be shown that there is no match in [__kb, __ke).\n//  __b will be incremented (visibly), consuming CharT until a match is found\n//  or proved to not exist.  A keyword may be \"\", in which will match anything.\n//  If one keyword is a prefix of another, and the next CharT in the input\n//  might match another keyword, the algorithm will attempt to find the longest\n//  matching keyword.  If the longer matching keyword ends up not matching, then\n//  no keyword match is found.  If no keyword match is found, __ke is returned\n//  and failbit is set in __err.\n//  Else an iterator pointing to the matching keyword is found.  If more than\n//  one keyword matches, an iterator to the first matching keyword is returned.\n//  If on exit __b == __e, eofbit is set in __err.  If __case_sensitive is false,\n//  __ct is used to force to lower case before comparing characters.\n//  Examples:\n//  Keywords:  \"a\", \"abb\"\n//  If the input is \"a\", the first keyword matches and eofbit is set.\n//  If the input is \"abc\", no match is found and \"ab\" are consumed.\ntemplate <class _InputIterator, class _ForwardIterator, class _Ctype>\n_LIBCPP_HIDDEN\n_ForwardIterator\n__scan_keyword(_InputIterator& __b, _InputIterator __e,\n               _ForwardIterator __kb, _ForwardIterator __ke,\n               const _Ctype& __ct, ios_base::iostate& __err,\n               bool __case_sensitive = true)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type _CharT;\n    size_t __nkw = static_cast<size_t>(_VSTD::distance(__kb, __ke));\n    const unsigned char __doesnt_match = '\\0';\n    const unsigned char __might_match = '\\1';\n    const unsigned char __does_match = '\\2';\n    unsigned char __statbuf[100];\n    unsigned char* __status = __statbuf;\n    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(0, free);\n    if (__nkw > sizeof(__statbuf))\n    {\n        __status = (unsigned char*)malloc(__nkw);\n        if (__status == 0)\n            __throw_bad_alloc();\n        __stat_hold.reset(__status);\n    }\n    size_t __n_might_match = __nkw;  // At this point, any keyword might match\n    size_t __n_does_match = 0;       // but none of them definitely do\n    // Initialize all statuses to __might_match, except for \"\" keywords are __does_match\n    unsigned char* __st = __status;\n    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)\n    {\n        if (!__ky->empty())\n            *__st = __might_match;\n        else\n        {\n            *__st = __does_match;\n            --__n_might_match;\n            ++__n_does_match;\n        }\n    }\n    // While there might be a match, test keywords against the next CharT\n    for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)\n    {\n        // Peek at the next CharT but don't consume it\n        _CharT __c = *__b;\n        if (!__case_sensitive)\n            __c = __ct.toupper(__c);\n        bool __consume = false;\n        // For each keyword which might match, see if the __indx character is __c\n        // If a match if found, consume __c\n        // If a match is found, and that is the last character in the keyword,\n        //    then that keyword matches.\n        // If the keyword doesn't match this character, then change the keyword\n        //    to doesn't match\n        __st = __status;\n        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)\n        {\n            if (*__st == __might_match)\n            {\n                _CharT __kc = (*__ky)[__indx];\n                if (!__case_sensitive)\n                    __kc = __ct.toupper(__kc);\n                if (__c == __kc)\n                {\n                    __consume = true;\n                    if (__ky->size() == __indx+1)\n                    {\n                        *__st = __does_match;\n                        --__n_might_match;\n                        ++__n_does_match;\n                    }\n                }\n                else\n                {\n                    *__st = __doesnt_match;\n                    --__n_might_match;\n                }\n            }\n        }\n        // consume if we matched a character\n        if (__consume)\n        {\n            ++__b;\n            // If we consumed a character and there might be a matched keyword that\n            //   was marked matched on a previous iteration, then such keywords\n            //   which are now marked as not matching.\n            if (__n_might_match + __n_does_match > 1)\n            {\n                __st = __status;\n                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)\n                {\n                    if (*__st == __does_match && __ky->size() != __indx+1)\n                    {\n                        *__st = __doesnt_match;\n                        --__n_does_match;\n                    }\n                }\n            }\n        }\n    }\n    // We've exited the loop because we hit eof and/or we have no more \"might matches\".\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    // Return the first matching result\n    for (__st = __status; __kb != __ke; ++__kb, (void) ++__st)\n        if (*__st == __does_match)\n            break;\n    if (__kb == __ke)\n        __err |= ios_base::failbit;\n    return __kb;\n}\n\nstruct _LIBCPP_TYPE_VIS __num_get_base\n{\n    static const int __num_get_buf_sz = 40;\n\n    static int __get_base(ios_base&);\n    static const char __src[33];\n};\n\n_LIBCPP_FUNC_VIS\nvoid __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,\n                      ios_base::iostate& __err);\n\ntemplate <class _CharT>\nstruct __num_get\n    : protected __num_get_base\n{\n    static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);\n    static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,\n                                      _CharT& __thousands_sep);\n    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms);\n    static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,\n                                   char* __a, char*& __a_end,\n                                   _CharT __decimal_point, _CharT __thousands_sep,\n                                   const string& __grouping, unsigned* __g,\n                                   unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);\n};\n\ntemplate <class _CharT>\nstring\n__num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep)\n{\n    locale __loc = __iob.getloc();\n    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n    __thousands_sep = __np.thousands_sep();\n    return __np.grouping();\n}\n\ntemplate <class _CharT>\nstring\n__num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,\n                    _CharT& __thousands_sep)\n{\n    locale __loc = __iob.getloc();\n    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n    __decimal_point = __np.decimal_point();\n    __thousands_sep = __np.thousands_sep();\n    return __np.grouping();\n}\n\ntemplate <class _CharT>\nint\n__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)\n{\n    if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))\n    {\n        *__a_end++ = __ct == __atoms[24] ? '+' : '-';\n        __dc = 0;\n        return 0;\n    }\n    if (__grouping.size() != 0 && __ct == __thousands_sep)\n    {\n        if (__g_end-__g < __num_get_buf_sz)\n        {\n            *__g_end++ = __dc;\n            __dc = 0;\n        }\n        return 0;\n    }\n    ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;\n    if (__f >= 24)\n        return -1;\n    switch (__base)\n    {\n    case 8:\n    case 10:\n        if (__f >= __base)\n            return -1;\n        break;\n    case 16:\n        if (__f < 22)\n            break;\n        if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')\n        {\n            __dc = 0;\n            *__a_end++ = __src[__f];\n            return 0;\n        }\n        return -1;\n    }\n    *__a_end++ = __src[__f];\n    ++__dc;\n    return 0;\n}\n\ntemplate <class _CharT>\nint\n__num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,\n                    _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,\n                    unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms)\n{\n    if (__ct == __decimal_point)\n    {\n        if (!__in_units)\n            return -1;\n        __in_units = false;\n        *__a_end++ = '.';\n        if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)\n            *__g_end++ = __dc;\n        return 0;\n    }\n    if (__ct == __thousands_sep && __grouping.size() != 0)\n    {\n        if (!__in_units)\n            return -1;\n        if (__g_end-__g < __num_get_buf_sz)\n        {\n            *__g_end++ = __dc;\n            __dc = 0;\n        }\n        return 0;\n    }\n    ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;\n    if (__f >= 32)\n        return -1;\n    char __x = __src[__f];\n    if (__x == '-' || __x == '+')\n    {\n        if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))\n        {\n            *__a_end++ = __x;\n            return 0;\n        }\n        return -1;\n    }\n    if (__x == 'x' || __x == 'X')\n        __exp = 'P';\n    else if ((__x & 0x5F) == __exp)\n    {\n        __exp |= 0x80;\n        if (__in_units)\n        {\n            __in_units = false;\n            if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)\n                *__g_end++ = __dc;\n        }\n    }\n    *__a_end++ = __x;\n    if (__f >= 22)\n        return 0;\n    ++__dc;\n    return 0;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_get<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS num_get\n    : public locale::facet,\n      private __num_get<_CharT>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _InputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit num_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, bool& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned short& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned int& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned long long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, float& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, double& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long double& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, void*& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~num_get() {}\n\n    template <class _Fp>\n    iter_type __do_get_floating_point\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Fp& __v) const;\n\n    template <class _Signed>\n    iter_type __do_get_signed\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Signed& __v) const;\n\n    template <class _Unsigned>\n    iter_type __do_get_unsigned\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Unsigned& __v) const;\n\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, bool& __v) const;\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long& __v) const\n    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long long& __v) const\n    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned short& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned int& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned long& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned long long& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, float& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, double& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long double& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, void*& __v) const;\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\nnum_get<_CharT, _InputIterator>::id;\n\ntemplate <class _Tp>\n_Tp\n__num_get_signed_integral(const char* __a, const char* __a_end,\n                          ios_base::iostate& __err, int __base)\n{\n    if (__a != __a_end)\n    {\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        long long __ll = strtoll_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE         ||\n                 __ll < numeric_limits<_Tp>::min() ||\n                 numeric_limits<_Tp>::max() < __ll)\n        {\n            __err = ios_base::failbit;\n            if (__ll > 0)\n                return numeric_limits<_Tp>::max();\n            else\n                return numeric_limits<_Tp>::min();\n        }\n        return static_cast<_Tp>(__ll);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _Tp>\n_Tp\n__num_get_unsigned_integral(const char* __a, const char* __a_end,\n                            ios_base::iostate& __err, int __base)\n{\n    if (__a != __a_end)\n    {\n        if (*__a == '-')\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        unsigned long long __ll = strtoull_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE ||\n                 numeric_limits<_Tp>::max() < __ll)\n        {\n            __err = ios_base::failbit;\n            return numeric_limits<_Tp>::max();\n        }\n        return static_cast<_Tp>(__ll);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY\n_Tp __do_strtod(const char* __a, char** __p2);\n\ntemplate <>\ninline _LIBCPP_INLINE_VISIBILITY\nfloat __do_strtod<float>(const char* __a, char** __p2) {\n    return strtof_l(__a, __p2, _LIBCPP_GET_C_LOCALE);\n}\n\ntemplate <>\ninline _LIBCPP_INLINE_VISIBILITY\ndouble __do_strtod<double>(const char* __a, char** __p2) {\n    return strtod_l(__a, __p2, _LIBCPP_GET_C_LOCALE);\n}\n\ntemplate <>\ninline _LIBCPP_INLINE_VISIBILITY\nlong double __do_strtod<long double>(const char* __a, char** __p2) {\n    return strtold_l(__a, __p2, _LIBCPP_GET_C_LOCALE);\n}\n\ntemplate <class _Tp>\n_LIBCPP_HIDDEN\n_Tp\n__num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err)\n{\n    if (__a != __a_end)\n    {\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        _Tp __ld = __do_strtod<_Tp>(__a, &__p2);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE)\n            __err = ios_base::failbit;\n        return __ld;\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        bool& __v) const\n{\n    if ((__iob.flags() & ios_base::boolalpha) == 0)\n    {\n        long __lv = -1;\n        __b = do_get(__b, __e, __iob, __err, __lv);\n        switch (__lv)\n        {\n        case 0:\n            __v = false;\n            break;\n        case 1:\n            __v = true;\n            break;\n        default:\n            __v = true;\n            __err = ios_base::failbit;\n            break;\n        }\n        return __b;\n    }\n    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__iob.getloc());\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__iob.getloc());\n    typedef typename numpunct<_CharT>::string_type string_type;\n    const string_type __names[2] = {__np.truename(), __np.falsename()};\n    const string_type* __i = __scan_keyword(__b, __e, __names, __names+2,\n                                            __ct, __err);\n    __v = __i == __names;\n    return __b;\n}\n\n// signed\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Signed>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Signed& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n// unsigned\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Unsigned>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Unsigned& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n// floating point\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Fp>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Fp& __v) const\n{\n    // Stage 1, nothing to do\n    // Stage 2\n    char_type __atoms[32];\n    char_type __decimal_point;\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_float_prep(__iob, __atoms,\n                                                  __decimal_point,\n                                                  __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    bool __in_units = true;\n    char __exp = 'E';\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,\n                                      __decimal_point, __thousands_sep,\n                                      __grouping, __g, __g_end,\n                                      __dc, __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_float<_Fp>(__a, __a_end, __err);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        void*& __v) const\n{\n    // Stage 1\n    int __base = 16;\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep = 0;\n    string __grouping;\n    use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,\n                                                    __num_get_base::__src + 26, __atoms);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping,\n                                    __g, __g_end, __atoms))\n            break;\n    }\n    // Stage 3\n    __buf.resize(__a_end - __a);\n    if (__libcpp_sscanf_l(__buf.c_str(), _LIBCPP_GET_C_LOCALE, \"%p\", &__v) != 1)\n        __err = ios_base::failbit;\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_get<wchar_t>)\n\nstruct _LIBCPP_TYPE_VIS __num_put_base\n{\nprotected:\n    static void __format_int(char* __fmt, const char* __len, bool __signd,\n                             ios_base::fmtflags __flags);\n    static bool __format_float(char* __fmt, const char* __len,\n                               ios_base::fmtflags __flags);\n    static char* __identify_padding(char* __nb, char* __ne,\n                                    const ios_base& __iob);\n};\n\ntemplate <class _CharT>\nstruct __num_put\n    : protected __num_put_base\n{\n    static void __widen_and_group_int(char* __nb, char* __np, char* __ne,\n                                      _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                      const locale& __loc);\n    static void __widen_and_group_float(char* __nb, char* __np, char* __ne,\n                                        _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                        const locale& __loc);\n};\n\ntemplate <class _CharT>\nvoid\n__num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,\n                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                         const locale& __loc)\n{\n    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);\n    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);\n    string __grouping = __npt.grouping();\n    if (__grouping.empty())\n    {\n        __ct.widen(__nb, __ne, __ob);\n        __oe = __ob + (__ne - __nb);\n    }\n    else\n    {\n        __oe = __ob;\n        char* __nf = __nb;\n        if (*__nf == '-' || *__nf == '+')\n            *__oe++ = __ct.widen(*__nf++);\n        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||\n                                                   __nf[1] == 'X'))\n        {\n            *__oe++ = __ct.widen(*__nf++);\n            *__oe++ = __ct.widen(*__nf++);\n        }\n        reverse(__nf, __ne);\n        _CharT __thousands_sep = __npt.thousands_sep();\n        unsigned __dc = 0;\n        unsigned __dg = 0;\n        for (char* __p = __nf; __p < __ne; ++__p)\n        {\n            if (static_cast<unsigned>(__grouping[__dg]) > 0 &&\n                __dc == static_cast<unsigned>(__grouping[__dg]))\n            {\n                *__oe++ = __thousands_sep;\n                __dc = 0;\n                if (__dg < __grouping.size()-1)\n                    ++__dg;\n            }\n            *__oe++ = __ct.widen(*__p);\n            ++__dc;\n        }\n        reverse(__ob + (__nf - __nb), __oe);\n    }\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __ob + (__np - __nb);\n}\n\ntemplate <class _CharT>\nvoid\n__num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,\n                                           _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                           const locale& __loc)\n{\n    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);\n    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);\n    string __grouping = __npt.grouping();\n    __oe = __ob;\n    char* __nf = __nb;\n    if (*__nf == '-' || *__nf == '+')\n        *__oe++ = __ct.widen(*__nf++);\n    char* __ns;\n    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||\n                                               __nf[1] == 'X'))\n    {\n        *__oe++ = __ct.widen(*__nf++);\n        *__oe++ = __ct.widen(*__nf++);\n        for (__ns = __nf; __ns < __ne; ++__ns)\n            if (!isxdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))\n                break;\n    }\n    else\n    {\n        for (__ns = __nf; __ns < __ne; ++__ns)\n            if (!isdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))\n                break;\n    }\n    if (__grouping.empty())\n    {\n        __ct.widen(__nf, __ns, __oe);\n        __oe += __ns - __nf;\n    }\n    else\n    {\n        reverse(__nf, __ns);\n        _CharT __thousands_sep = __npt.thousands_sep();\n        unsigned __dc = 0;\n        unsigned __dg = 0;\n        for (char* __p = __nf; __p < __ns; ++__p)\n        {\n            if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))\n            {\n                *__oe++ = __thousands_sep;\n                __dc = 0;\n                if (__dg < __grouping.size()-1)\n                    ++__dg;\n            }\n            *__oe++ = __ct.widen(*__p);\n            ++__dc;\n        }\n        reverse(__ob + (__nf - __nb), __oe);\n    }\n    for (__nf = __ns; __nf < __ne; ++__nf)\n    {\n        if (*__nf == '.')\n        {\n            *__oe++ = __npt.decimal_point();\n            ++__nf;\n            break;\n        }\n        else\n            *__oe++ = __ct.widen(*__nf);\n    }\n    __ct.widen(__nf, __ne, __oe);\n    __oe += __ne - __nf;\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __ob + (__np - __nb);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS num_put\n    : public locale::facet,\n      private __num_put<_CharT>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _OutputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit num_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  bool __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  unsigned long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  unsigned long long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  double __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long double __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  const void* __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~num_put() {}\n\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             bool __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long long __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             unsigned long) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             unsigned long long) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             double __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long double __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             const void* __v) const;\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\nnum_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_LIBCPP_HIDDEN\n_OutputIterator\n__pad_and_output(_OutputIterator __s,\n                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,\n                 ios_base& __iob, _CharT __fl)\n{\n    streamsize __sz = __oe - __ob;\n    streamsize __ns = __iob.width();\n    if (__ns > __sz)\n        __ns -= __sz;\n    else\n        __ns = 0;\n    for (;__ob < __op; ++__ob, ++__s)\n        *__s = *__ob;\n    for (; __ns; --__ns, ++__s)\n        *__s = __fl;\n    for (; __ob < __oe; ++__ob, ++__s)\n        *__s = *__ob;\n    __iob.width(0);\n    return __s;\n}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\ntemplate <class _CharT, class _Traits>\n_LIBCPP_HIDDEN\nostreambuf_iterator<_CharT, _Traits>\n__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,\n                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,\n                 ios_base& __iob, _CharT __fl)\n{\n    if (__s.__sbuf_ == nullptr)\n        return __s;\n    streamsize __sz = __oe - __ob;\n    streamsize __ns = __iob.width();\n    if (__ns > __sz)\n        __ns -= __sz;\n    else\n        __ns = 0;\n    streamsize __np = __op - __ob;\n    if (__np > 0)\n    {\n        if (__s.__sbuf_->sputn(__ob, __np) != __np)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    if (__ns > 0)\n    {\n        basic_string<_CharT, _Traits> __sp(__ns, __fl);\n        if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    __np = __oe - __op;\n    if (__np > 0)\n    {\n        if (__s.__sbuf_->sputn(__op, __np) != __np)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    __iob.width(0);\n    return __s;\n}\n\n#endif\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, bool __v) const\n{\n    if ((__iob.flags() & ios_base::boolalpha) == 0)\n        return do_put(__s, __iob, __fl, (unsigned long)__v);\n    const numpunct<char_type>& __np = use_facet<numpunct<char_type> >(__iob.getloc());\n    typedef typename numpunct<char_type>::string_type string_type;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    string_type __tmp(__v ? __np.truename() : __np.falsename());\n    string_type __nm = _VSTD::move(__tmp);\n#else\n    string_type __nm = __v ? __np.truename() : __np.falsename();\n#endif\n    for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)\n        *__s = *__i;\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[6] = {'%', 0};\n    const char* __len = \"l\";\n    this->__format_int(__fmt+1, __len, true, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<long>::digits / 3)\n                          + ((numeric_limits<long>::digits % 3) != 0)\n                          + 2;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"ll\";\n    this->__format_int(__fmt+1, __len, true, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<long long>::digits / 3)\n                          + ((numeric_limits<long long>::digits % 3) != 0)\n                          + 2;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, unsigned long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[6] = {'%', 0};\n    const char* __len = \"l\";\n    this->__format_int(__fmt+1, __len, false, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<unsigned long>::digits / 3)\n                          + ((numeric_limits<unsigned long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, unsigned long long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"ll\";\n    this->__format_int(__fmt+1, __len, false, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<unsigned long long>::digits / 3)\n                          + ((numeric_limits<unsigned long long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, double __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"\";\n    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());\n    const unsigned __nbuf = 30;\n    char __nar[__nbuf];\n    char* __nb = __nar;\n    int __nc;\n    if (__specify_precision)\n        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,\n                                   (int)__iob.precision(), __v);\n    else\n        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    unique_ptr<char, void(*)(void*)> __nbh(0, free);\n    if (__nc > static_cast<int>(__nbuf-1))\n    {\n        if (__specify_precision)\n            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);\n        else\n            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n        if (__nb == 0)\n            __throw_bad_alloc();\n        __nbh.reset(__nb);\n    }\n    char* __ne = __nb + __nc;\n    char* __np = this->__identify_padding(__nb, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __ob = __o;\n    unique_ptr<char_type, void(*)(void*)> __obh(0, free);\n    if (__nb != __nar)\n    {\n        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));\n        if (__ob == 0)\n            __throw_bad_alloc();\n        __obh.reset(__ob);\n    }\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long double __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"L\";\n    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());\n    const unsigned __nbuf = 30;\n    char __nar[__nbuf];\n    char* __nb = __nar;\n    int __nc;\n    if (__specify_precision)\n        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,\n                                   (int)__iob.precision(), __v);\n    else\n        __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    unique_ptr<char, void(*)(void*)> __nbh(0, free);\n    if (__nc > static_cast<int>(__nbuf-1))\n    {\n        if (__specify_precision)\n            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);\n        else\n            __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n        if (__nb == 0)\n            __throw_bad_alloc();\n        __nbh.reset(__nb);\n    }\n    char* __ne = __nb + __nc;\n    char* __np = this->__identify_padding(__nb, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __ob = __o;\n    unique_ptr<char_type, void(*)(void*)> __obh(0, free);\n    if (__nb != __nar)\n    {\n        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));\n        if (__ob == 0)\n            __throw_bad_alloc();\n        __obh.reset(__ob);\n    }\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, const void* __v) const\n{\n    // Stage 1 - Get pointer in narrow char\n    char __fmt[6] = \"%p\";\n    const unsigned __nbuf = 20;\n    char __nar[__nbuf];\n    int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __ct.widen(__nar, __ne, __o);\n    __oe = __o + (__ne - __nar);\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __o + (__np - __nar);\n    // [__o, __oe) contains wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_put<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator>\n_LIBCPP_HIDDEN\nint\n__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,\n                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)\n{\n    // Precondition:  __n >= 1\n    if (__b == __e)\n    {\n        __err |= ios_base::eofbit | ios_base::failbit;\n        return 0;\n    }\n    // get first digit\n    _CharT __c = *__b;\n    if (!__ct.is(ctype_base::digit, __c))\n    {\n        __err |= ios_base::failbit;\n        return 0;\n    }\n    int __r = __ct.narrow(__c, 0) - '0';\n    for (++__b, (void) --__n; __b != __e && __n > 0; ++__b, (void) --__n)\n    {\n        // get next digit\n        __c = *__b;\n        if (!__ct.is(ctype_base::digit, __c))\n            return __r;\n        __r = __r * 10 + __ct.narrow(__c, 0) - '0';\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __r;\n}\n\nclass _LIBCPP_TYPE_VIS time_base\n{\npublic:\n    enum dateorder {no_order, dmy, mdy, ymd, ydm};\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS __time_get_c_storage\n{\nprotected:\n    typedef basic_string<_CharT> string_type;\n\n    virtual const string_type* __weeks() const;\n    virtual const string_type* __months() const;\n    virtual const string_type* __am_pm() const;\n    virtual const string_type& __c() const;\n    virtual const string_type& __r() const;\n    virtual const string_type& __x() const;\n    virtual const string_type& __X() const;\n\n    _LIBCPP_ALWAYS_INLINE\n    ~__time_get_c_storage() {}\n};\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS time_get\n    : public locale::facet,\n      public time_base,\n      private __time_get_c_storage<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _InputIterator          iter_type;\n    typedef time_base::dateorder    dateorder;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    dateorder date_order() const\n    {\n        return this->do_date_order();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_time(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_date(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,\n                          ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_weekday(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,\n                            ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_monthname(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_year(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, tm *__tm,\n                  char __fmt, char __mod = 0) const\n    {\n        return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);\n    }\n\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, tm* __tm,\n                  const char_type* __fmtb, const char_type* __fmte) const;\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_get() {}\n\n    virtual dateorder do_date_order() const;\n    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,\n                                     ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,\n                                       ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, tm* __tm,\n                             char __fmt, char __mod) const;\nprivate:\n    void __get_white_space(iter_type& __b, iter_type __e,\n                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;\n    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n\n    void __get_weekdayname(int& __m,\n                           iter_type& __b, iter_type __e,\n                           ios_base::iostate& __err,\n                           const ctype<char_type>& __ct) const;\n    void __get_monthname(int& __m,\n                         iter_type& __b, iter_type __e,\n                         ios_base::iostate& __err,\n                         const ctype<char_type>& __ct) const;\n    void __get_day(int& __d,\n                   iter_type& __b, iter_type __e,\n                   ios_base::iostate& __err,\n                   const ctype<char_type>& __ct) const;\n    void __get_month(int& __m,\n                     iter_type& __b, iter_type __e,\n                     ios_base::iostate& __err,\n                     const ctype<char_type>& __ct) const;\n    void __get_year(int& __y,\n                   iter_type& __b, iter_type __e,\n                   ios_base::iostate& __err,\n                   const ctype<char_type>& __ct) const;\n    void __get_year4(int& __y,\n                    iter_type& __b, iter_type __e,\n                    ios_base::iostate& __err,\n                    const ctype<char_type>& __ct) const;\n    void __get_hour(int& __d,\n                    iter_type& __b, iter_type __e,\n                    ios_base::iostate& __err,\n                    const ctype<char_type>& __ct) const;\n    void __get_12_hour(int& __h,\n                       iter_type& __b, iter_type __e,\n                       ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n    void __get_am_pm(int& __h,\n                     iter_type& __b, iter_type __e,\n                     ios_base::iostate& __err,\n                     const ctype<char_type>& __ct) const;\n    void __get_minute(int& __m,\n                      iter_type& __b, iter_type __e,\n                      ios_base::iostate& __err,\n                      const ctype<char_type>& __ct) const;\n    void __get_second(int& __s,\n                      iter_type& __b, iter_type __e,\n                      ios_base::iostate& __err,\n                      const ctype<char_type>& __ct) const;\n    void __get_weekday(int& __w,\n                       iter_type& __b, iter_type __e,\n                       ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n    void __get_day_year_num(int& __w,\n                            iter_type& __b, iter_type __e,\n                            ios_base::iostate& __err,\n                            const ctype<char_type>& __ct) const;\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\ntime_get<_CharT, _InputIterator>::id;\n\n// time_get primitives\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,\n                                                    iter_type& __b, iter_type __e,\n                                                    ios_base::iostate& __err,\n                                                    const ctype<char_type>& __ct) const\n{\n    // Note:  ignoring case comes from the POSIX strptime spec\n    const string_type* __wk = this->__weeks();\n    ptrdiff_t __i = __scan_keyword(__b, __e, __wk, __wk+14, __ct, __err, false) - __wk;\n    if (__i < 14)\n        __w = __i % 7;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_monthname(int& __m,\n                                                  iter_type& __b, iter_type __e,\n                                                  ios_base::iostate& __err,\n                                                  const ctype<char_type>& __ct) const\n{\n    // Note:  ignoring case comes from the POSIX strptime spec\n    const string_type* __month = this->__months();\n    ptrdiff_t __i = __scan_keyword(__b, __e, __month, __month+24, __ct, __err, false) - __month;\n    if (__i < 24)\n        __m = __i % 12;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_day(int& __d,\n                                            iter_type& __b, iter_type __e,\n                                            ios_base::iostate& __err,\n                                            const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)\n        __d = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_month(int& __m,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;\n    if (!(__err & ios_base::failbit) && __t <= 11)\n        __m = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_year(int& __y,\n                                             iter_type& __b, iter_type __e,\n                                             ios_base::iostate& __err,\n                                             const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);\n    if (!(__err & ios_base::failbit))\n    {\n        if (__t < 69)\n            __t += 2000;\n        else if (69 <= __t && __t <= 99)\n            __t += 1900;\n        __y = __t - 1900;\n    }\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_year4(int& __y,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);\n    if (!(__err & ios_base::failbit))\n        __y = __t - 1900;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_hour(int& __h,\n                                             iter_type& __b, iter_type __e,\n                                             ios_base::iostate& __err,\n                                             const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 23)\n        __h = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_12_hour(int& __h,\n                                                iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)\n        __h = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_minute(int& __m,\n                                               iter_type& __b, iter_type __e,\n                                               ios_base::iostate& __err,\n                                               const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 59)\n        __m = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_second(int& __s,\n                                               iter_type& __b, iter_type __e,\n                                               ios_base::iostate& __err,\n                                               const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 60)\n        __s = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_weekday(int& __w,\n                                                iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);\n    if (!(__err & ios_base::failbit) && __t <= 6)\n        __w = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_day_year_num(int& __d,\n                                                     iter_type& __b, iter_type __e,\n                                                     ios_base::iostate& __err,\n                                                     const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);\n    if (!(__err & ios_base::failbit) && __t <= 365)\n        __d = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_white_space(iter_type& __b, iter_type __e,\n                                                    ios_base::iostate& __err,\n                                                    const ctype<char_type>& __ct) const\n{\n    for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)\n        ;\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_am_pm(int& __h,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    const string_type* __ap = this->__am_pm();\n    if (__ap[0].size() + __ap[1].size() == 0)\n    {\n        __err |= ios_base::failbit;\n        return;\n    }\n    ptrdiff_t __i = __scan_keyword(__b, __e, __ap, __ap+2, __ct, __err, false) - __ap;\n    if (__i == 0 && __h == 12)\n        __h = 0;\n    else if (__i == 1 && __h < 12)\n        __h += 12;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_percent(iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    if (__b == __e)\n    {\n        __err |= ios_base::eofbit | ios_base::failbit;\n        return;\n    }\n    if (__ct.narrow(*__b, 0) != '%')\n        __err |= ios_base::failbit;\n    else if(++__b == __e)\n        __err |= ios_base::eofbit;\n}\n\n// time_get end primitives\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,\n                                      ios_base& __iob,\n                                      ios_base::iostate& __err, tm* __tm,\n                                      const char_type* __fmtb, const char_type* __fmte) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __err = ios_base::goodbit;\n    while (__fmtb != __fmte && __err == ios_base::goodbit)\n    {\n        if (__b == __e)\n        {\n            __err = ios_base::failbit;\n            break;\n        }\n        if (__ct.narrow(*__fmtb, 0) == '%')\n        {\n            if (++__fmtb == __fmte)\n            {\n                __err = ios_base::failbit;\n                break;\n            }\n            char __cmd = __ct.narrow(*__fmtb, 0);\n            char __opt = '\\0';\n            if (__cmd == 'E' || __cmd == '0')\n            {\n                if (++__fmtb == __fmte)\n                {\n                    __err = ios_base::failbit;\n                    break;\n                }\n                __opt = __cmd;\n                __cmd = __ct.narrow(*__fmtb, 0);\n            }\n            __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);\n            ++__fmtb;\n        }\n        else if (__ct.is(ctype_base::space, *__fmtb))\n        {\n            for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)\n                ;\n            for (        ;    __b != __e    && __ct.is(ctype_base::space, *__b);    ++__b)\n                ;\n        }\n        else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))\n        {\n            ++__b;\n            ++__fmtb;\n        }\n        else\n            __err = ios_base::failbit;\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\ntypename time_get<_CharT, _InputIterator>::dateorder\ntime_get<_CharT, _InputIterator>::do_date_order() const\n{\n    return mdy;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};\n    return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt)/sizeof(__fmt[0]));\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const string_type& __fmt = this->__x();\n    return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,\n                                                 ios_base& __iob,\n                                                 ios_base::iostate& __err,\n                                                 tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,\n                                                   ios_base& __iob,\n                                                   ios_base::iostate& __err,\n                                                   tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_year(__tm->tm_year, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                         ios_base& __iob,\n                                         ios_base::iostate& __err, tm* __tm,\n                                         char __fmt, char) const\n{\n    __err = ios_base::goodbit;\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    switch (__fmt)\n    {\n    case 'a':\n    case 'A':\n        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);\n        break;\n    case 'b':\n    case 'B':\n    case 'h':\n        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);\n        break;\n    case 'c':\n        {\n        const string_type& __fm = this->__c();\n        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());\n        }\n        break;\n    case 'd':\n    case 'e':\n        __get_day(__tm->tm_mday, __b, __e, __err, __ct);\n        break;\n    case 'D':\n        {\n        const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'F':\n        {\n        const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'H':\n        __get_hour(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'I':\n        __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'j':\n        __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);\n        break;\n    case 'm':\n        __get_month(__tm->tm_mon, __b, __e, __err, __ct);\n        break;\n    case 'M':\n        __get_minute(__tm->tm_min, __b, __e, __err, __ct);\n        break;\n    case 'n':\n    case 't':\n        __get_white_space(__b, __e, __err, __ct);\n        break;\n    case 'p':\n        __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'r':\n        {\n        const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'R':\n        {\n        const char_type __fm[] = {'%', 'H', ':', '%', 'M'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'S':\n        __get_second(__tm->tm_sec, __b, __e, __err, __ct);\n        break;\n    case 'T':\n        {\n        const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'w':\n        __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);\n        break;\n    case 'x':\n        return do_get_date(__b, __e, __iob, __err, __tm);\n    case 'X':\n        {\n        const string_type& __fm = this->__X();\n        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());\n        }\n        break;\n    case 'y':\n        __get_year(__tm->tm_year, __b, __e, __err, __ct);\n        break;\n    case 'Y':\n        __get_year4(__tm->tm_year, __b, __e, __err, __ct);\n        break;\n    case '%':\n        __get_percent(__b, __e, __err, __ct);\n        break;\n    default:\n        __err |= ios_base::failbit;\n    }\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get<wchar_t>)\n\nclass _LIBCPP_TYPE_VIS __time_get\n{\nprotected:\n    locale_t __loc_;\n\n    __time_get(const char* __nm);\n    __time_get(const string& __nm);\n    ~__time_get();\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS __time_get_storage\n    : public __time_get\n{\nprotected:\n    typedef basic_string<_CharT> string_type;\n\n    string_type __weeks_[14];\n    string_type __months_[24];\n    string_type __am_pm_[2];\n    string_type __c_;\n    string_type __r_;\n    string_type __x_;\n    string_type __X_;\n\n    explicit __time_get_storage(const char* __nm);\n    explicit __time_get_storage(const string& __nm);\n\n    _LIBCPP_ALWAYS_INLINE ~__time_get_storage() {}\n\n    time_base::dateorder __do_date_order() const;\n\nprivate:\n    void init(const ctype<_CharT>&);\n    string_type __analyze(char __fmt, const ctype<_CharT>&);\n};\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS time_get_byname\n    : public time_get<_CharT, _InputIterator>,\n      private __time_get_storage<_CharT>\n{\npublic:\n    typedef time_base::dateorder    dateorder;\n    typedef _InputIterator          iter_type;\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get_byname(const char* __nm, size_t __refs = 0)\n        : time_get<_CharT, _InputIterator>(__refs),\n          __time_get_storage<_CharT>(__nm) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get_byname(const string& __nm, size_t __refs = 0)\n        : time_get<_CharT, _InputIterator>(__refs),\n          __time_get_storage<_CharT>(__nm) {}\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ~time_get_byname() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    virtual dateorder do_date_order() const {return this->__do_date_order();}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __weeks() const  {return this->__weeks_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __months() const {return this->__months_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __am_pm() const  {return this->__am_pm_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __c() const      {return this->__c_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __r() const      {return this->__r_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __x() const      {return this->__x_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __X() const      {return this->__X_;}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get_byname<wchar_t>)\n\nclass _LIBCPP_TYPE_VIS __time_put\n{\n    locale_t __loc_;\nprotected:\n    _LIBCPP_ALWAYS_INLINE __time_put() : __loc_(_LIBCPP_GET_C_LOCALE) {}\n    __time_put(const char* __nm);\n    __time_put(const string& __nm);\n    ~__time_put();\n    void __do_put(char* __nb, char*& __ne, const tm* __tm,\n                  char __fmt, char __mod) const;\n    void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,\n                  char __fmt, char __mod) const;\n};\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS time_put\n    : public locale::facet,\n      private __time_put\n{\npublic:\n    typedef _CharT char_type;\n    typedef _OutputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,\n                  const char_type* __pb, const char_type* __pe) const;\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  const tm* __tm, char __fmt, char __mod = 0) const\n    {\n        return do_put(__s, __iob, __fl, __tm, __fmt, __mod);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_put() {}\n    virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,\n                             char __fmt, char __mod) const;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(const char* __nm, size_t __refs)\n        : locale::facet(__refs),\n          __time_put(__nm) {}\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(const string& __nm, size_t __refs)\n        : locale::facet(__refs),\n          __time_put(__nm) {}\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\ntime_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\ntime_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,\n                                       char_type __fl, const tm* __tm,\n                                       const char_type* __pb,\n                                       const char_type* __pe) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    for (; __pb != __pe; ++__pb)\n    {\n        if (__ct.narrow(*__pb, 0) == '%')\n        {\n            if (++__pb == __pe)\n            {\n                *__s++ = __pb[-1];\n                break;\n            }\n            char __mod = 0;\n            char __fmt = __ct.narrow(*__pb, 0);\n            if (__fmt == 'E' || __fmt == 'O')\n            {\n                if (++__pb == __pe)\n                {\n                    *__s++ = __pb[-2];\n                    *__s++ = __pb[-1];\n                    break;\n                }\n                __mod = __fmt;\n                __fmt = __ct.narrow(*__pb, 0);\n            }\n            __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);\n        }\n        else\n            *__s++ = *__pb;\n    }\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\ntime_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,\n                                          char_type, const tm* __tm,\n                                          char __fmt, char __mod) const\n{\n    char_type __nar[100];\n    char_type* __nb = __nar;\n    char_type* __ne = __nb + 100;\n    __do_put(__nb, __ne, __tm, __fmt, __mod);\n    return _VSTD::copy(__nb, __ne, __s);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS time_put_byname\n    : public time_put<_CharT, _OutputIterator>\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put_byname(const char* __nm, size_t __refs = 0)\n        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put_byname(const string& __nm, size_t __refs = 0)\n        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_put_byname() {}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put_byname<wchar_t>)\n\n// money_base\n\nclass _LIBCPP_TYPE_VIS money_base\n{\npublic:\n    enum part {none, space, symbol, sign, value};\n    struct pattern {char field[4];};\n\n    _LIBCPP_ALWAYS_INLINE money_base() {}\n};\n\n// moneypunct\n\ntemplate <class _CharT, bool _International = false>\nclass _LIBCPP_TEMPLATE_VIS moneypunct\n    : public locale::facet,\n      public money_base\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE char_type   decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type   thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string      grouping()      const {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type curr_symbol()   const {return do_curr_symbol();}\n    _LIBCPP_ALWAYS_INLINE string_type positive_sign() const {return do_positive_sign();}\n    _LIBCPP_ALWAYS_INLINE string_type negative_sign() const {return do_negative_sign();}\n    _LIBCPP_ALWAYS_INLINE int         frac_digits()   const {return do_frac_digits();}\n    _LIBCPP_ALWAYS_INLINE pattern     pos_format()    const {return do_pos_format();}\n    _LIBCPP_ALWAYS_INLINE pattern     neg_format()    const {return do_neg_format();}\n\n    static locale::id id;\n    static const bool intl = _International;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~moneypunct() {}\n\n    virtual char_type   do_decimal_point() const {return numeric_limits<char_type>::max();}\n    virtual char_type   do_thousands_sep() const {return numeric_limits<char_type>::max();}\n    virtual string      do_grouping()      const {return string();}\n    virtual string_type do_curr_symbol()   const {return string_type();}\n    virtual string_type do_positive_sign() const {return string_type();}\n    virtual string_type do_negative_sign() const {return string_type(1, '-');}\n    virtual int         do_frac_digits()   const {return 0;}\n    virtual pattern     do_pos_format()    const\n        {pattern __p = {{symbol, sign, none, value}}; return __p;}\n    virtual pattern     do_neg_format()    const\n        {pattern __p = {{symbol, sign, none, value}}; return __p;}\n};\n\ntemplate <class _CharT, bool _International>\nlocale::id\nmoneypunct<_CharT, _International>::id;\n\ntemplate <class _CharT, bool _International>\nconst bool\nmoneypunct<_CharT, _International>::intl;\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<char, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<char, true>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<wchar_t, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<wchar_t, true>)\n\n// moneypunct_byname\n\ntemplate <class _CharT, bool _International = false>\nclass _LIBCPP_TEMPLATE_VIS moneypunct_byname\n    : public moneypunct<_CharT, _International>\n{\npublic:\n    typedef money_base::pattern  pattern;\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)\n        : moneypunct<_CharT, _International>(__refs) {init(__nm);}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct_byname(const string& __nm, size_t __refs = 0)\n        : moneypunct<_CharT, _International>(__refs) {init(__nm.c_str());}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~moneypunct_byname() {}\n\n    virtual char_type   do_decimal_point() const {return __decimal_point_;}\n    virtual char_type   do_thousands_sep() const {return __thousands_sep_;}\n    virtual string      do_grouping()      const {return __grouping_;}\n    virtual string_type do_curr_symbol()   const {return __curr_symbol_;}\n    virtual string_type do_positive_sign() const {return __positive_sign_;}\n    virtual string_type do_negative_sign() const {return __negative_sign_;}\n    virtual int         do_frac_digits()   const {return __frac_digits_;}\n    virtual pattern     do_pos_format()    const {return __pos_format_;}\n    virtual pattern     do_neg_format()    const {return __neg_format_;}\n\nprivate:\n    char_type   __decimal_point_;\n    char_type   __thousands_sep_;\n    string      __grouping_;\n    string_type __curr_symbol_;\n    string_type __positive_sign_;\n    string_type __negative_sign_;\n    int         __frac_digits_;\n    pattern     __pos_format_;\n    pattern     __neg_format_;\n\n    void init(const char*);\n};\n\ntemplate<> void moneypunct_byname<char, false>::init(const char*);\ntemplate<> void moneypunct_byname<char, true>::init(const char*);\ntemplate<> void moneypunct_byname<wchar_t, false>::init(const char*);\ntemplate<> void moneypunct_byname<wchar_t, true>::init(const char*);\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<char, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<char, true>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<wchar_t, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<wchar_t, true>)\n\n// money_get\n\ntemplate <class _CharT>\nclass __money_get\n{\nprotected:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE __money_get() {}\n\n    static void __gather_info(bool __intl, const locale& __loc,\n                              money_base::pattern& __pat, char_type& __dp,\n                              char_type& __ts, string& __grp,\n                              string_type& __sym, string_type& __psn,\n                              string_type& __nsn, int& __fd);\n};\n\ntemplate <class _CharT>\nvoid\n__money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,\n                                   money_base::pattern& __pat, char_type& __dp,\n                                   char_type& __ts, string& __grp,\n                                   string_type& __sym, string_type& __psn,\n                                   string_type& __nsn, int& __fd)\n{\n    if (__intl)\n    {\n        const moneypunct<char_type, true>& __mp =\n            use_facet<moneypunct<char_type, true> >(__loc);\n        __pat = __mp.neg_format();\n        __nsn = __mp.negative_sign();\n        __psn = __mp.positive_sign();\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n    else\n    {\n        const moneypunct<char_type, false>& __mp =\n            use_facet<moneypunct<char_type, false> >(__loc);\n        __pat = __mp.neg_format();\n        __nsn = __mp.negative_sign();\n        __psn = __mp.positive_sign();\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_get<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS money_get\n    : public locale::facet,\n      private __money_get<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _InputIterator          iter_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit money_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,\n                  ios_base::iostate& __err, long double& __v) const\n    {\n        return do_get(__b, __e, __intl, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,\n                  ios_base::iostate& __err, string_type& __v) const\n    {\n        return do_get(__b, __e, __intl, __iob, __err, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n\n    _LIBCPP_ALWAYS_INLINE\n    ~money_get() {}\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,\n                             ios_base& __iob, ios_base::iostate& __err,\n                             long double& __v) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,\n                             ios_base& __iob, ios_base::iostate& __err,\n                             string_type& __v) const;\n\nprivate:\n    static bool __do_get(iter_type& __b, iter_type __e,\n                         bool __intl, const locale& __loc,\n                         ios_base::fmtflags __flags, ios_base::iostate& __err,\n                         bool& __neg, const ctype<char_type>& __ct,\n                         unique_ptr<char_type, void(*)(void*)>& __wb,\n                         char_type*& __wn, char_type* __we);\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\nmoney_get<_CharT, _InputIterator>::id;\n\n_LIBCPP_FUNC_VIS void __do_nothing(void*);\n\ntemplate <class _Tp>\n_LIBCPP_HIDDEN\nvoid\n__double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e)\n{\n    bool __owns = __b.get_deleter() != __do_nothing;\n    size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);\n    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?\n                       2 * __cur_cap : numeric_limits<size_t>::max();\n    if (__new_cap == 0)\n        __new_cap = sizeof(_Tp);\n    size_t __n_off = static_cast<size_t>(__n - __b.get());\n    _Tp* __t = (_Tp*)realloc(__owns ? __b.get() : 0, __new_cap);\n    if (__t == 0)\n        __throw_bad_alloc();\n    if (__owns)\n        __b.release();\n    __b = unique_ptr<_Tp, void(*)(void*)>(__t, free);\n    __new_cap /= sizeof(_Tp);\n    __n = __b.get() + __n_off;\n    __e = __b.get() + __new_cap;\n}\n\n// true == success\ntemplate <class _CharT, class _InputIterator>\nbool\nmoney_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,\n                                            bool __intl, const locale& __loc,\n                                            ios_base::fmtflags __flags,\n                                            ios_base::iostate& __err,\n                                            bool& __neg,\n                                            const ctype<char_type>& __ct,\n                                            unique_ptr<char_type, void(*)(void*)>& __wb,\n                                            char_type*& __wn, char_type* __we)\n{\n    const unsigned __bz = 100;\n    unsigned __gbuf[__bz];\n    unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);\n    unsigned* __gn = __gb.get();\n    unsigned* __ge = __gn + __bz;\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __psn;\n    string_type __nsn;\n    // Capture the spaces read into money_base::{space,none} so they\n    // can be compared to initial spaces in __sym.\n    string_type __spaces;\n    int __fd;\n    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,\n                                       __sym, __psn, __nsn, __fd);\n    const string_type* __trailing_sign = 0;\n    __wn = __wb.get();\n    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)\n    {\n        switch (__pat.field[__p])\n        {\n        case money_base::space:\n            if (__p != 3)\n            {\n                if (__ct.is(ctype_base::space, *__b))\n                    __spaces.push_back(*__b++);\n                else\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n            }\n            // drop through\n        case money_base::none:\n            if (__p != 3)\n            {\n                while (__b != __e && __ct.is(ctype_base::space, *__b))\n                    __spaces.push_back(*__b++);\n            }\n            break;\n        case money_base::sign:\n            if (__psn.size() + __nsn.size() > 0)\n            {\n                if (__psn.size() == 0 || __nsn.size() == 0)\n                {   // sign is optional\n                    if (__psn.size() > 0)\n                    {   // __nsn.size() == 0\n                        if (*__b == __psn[0])\n                        {\n                            ++__b;\n                            if (__psn.size() > 1)\n                                __trailing_sign = &__psn;\n                        }\n                        else\n                            __neg = true;\n                    }\n                    else if (*__b == __nsn[0])  // __nsn.size() > 0 &&  __psn.size() == 0\n                    {\n                        ++__b;\n                        __neg = true;\n                        if (__nsn.size() > 1)\n                            __trailing_sign = &__nsn;\n                    }\n                }\n                else  // sign is required\n                {\n                    if (*__b == __psn[0])\n                    {\n                        ++__b;\n                        if (__psn.size() > 1)\n                            __trailing_sign = &__psn;\n                    }\n                    else if (*__b == __nsn[0])\n                    {\n                        ++__b;\n                        __neg = true;\n                        if (__nsn.size() > 1)\n                            __trailing_sign = &__nsn;\n                    }\n                    else\n                    {\n                        __err |= ios_base::failbit;\n                        return false;\n                    }\n                }\n            }\n            break;\n        case money_base::symbol:\n            {\n            bool __more_needed = __trailing_sign ||\n                                 (__p < 2)       ||\n                                 (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));\n            bool __sb = (__flags & ios_base::showbase) != 0;\n            if (__sb || __more_needed)\n            {\n                typename string_type::const_iterator __sym_space_end = __sym.begin();\n                if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||\n                                __pat.field[__p - 1] == money_base::space)) {\n                    // Match spaces we've already read against spaces at\n                    // the beginning of __sym.\n                    while (__sym_space_end != __sym.end() &&\n                           __ct.is(ctype_base::space, *__sym_space_end))\n                        ++__sym_space_end;\n                    const size_t __num_spaces = __sym_space_end - __sym.begin();\n                    if (__num_spaces > __spaces.size() ||\n                        !equal(__spaces.end() - __num_spaces, __spaces.end(),\n                               __sym.begin())) {\n                        // No match. Put __sym_space_end back at the\n                        // beginning of __sym, which will prevent a\n                        // match in the next loop.\n                        __sym_space_end = __sym.begin();\n                    }\n                }\n                typename string_type::const_iterator __sym_curr_char = __sym_space_end;\n                while (__sym_curr_char != __sym.end() && __b != __e &&\n                       *__b == *__sym_curr_char) {\n                    ++__b;\n                    ++__sym_curr_char;\n                }\n                if (__sb && __sym_curr_char != __sym.end())\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n            }\n            }\n            break;\n        case money_base::value:\n            {\n            unsigned __ng = 0;\n            for (; __b != __e; ++__b)\n            {\n                char_type __c = *__b;\n                if (__ct.is(ctype_base::digit, __c))\n                {\n                    if (__wn == __we)\n                        __double_or_nothing(__wb, __wn, __we);\n                    *__wn++ = __c;\n                    ++__ng;\n                }\n                else if (__grp.size() > 0 && __ng > 0 && __c == __ts)\n                {\n                    if (__gn == __ge)\n                        __double_or_nothing(__gb, __gn, __ge);\n                    *__gn++ = __ng;\n                    __ng = 0;\n                }\n                else\n                    break;\n            }\n            if (__gb.get() != __gn && __ng > 0)\n            {\n                if (__gn == __ge)\n                    __double_or_nothing(__gb, __gn, __ge);\n                *__gn++ = __ng;\n            }\n            if (__fd > 0)\n            {\n                if (__b == __e || *__b != __dp)\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n                for (++__b; __fd > 0; --__fd, ++__b)\n                {\n                    if (__b == __e || !__ct.is(ctype_base::digit, *__b))\n                    {\n                        __err |= ios_base::failbit;\n                        return false;\n                    }\n                    if (__wn == __we)\n                        __double_or_nothing(__wb, __wn, __we);\n                    *__wn++ = *__b;\n                }\n            }\n            if (__wn == __wb.get())\n            {\n                __err |= ios_base::failbit;\n                return false;\n            }\n            }\n            break;\n        }\n    }\n    if (__trailing_sign)\n    {\n        for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)\n        {\n            if (__b == __e || *__b != (*__trailing_sign)[__i])\n            {\n                __err |= ios_base::failbit;\n                return false;\n            }\n        }\n    }\n    if (__gb.get() != __gn)\n    {\n        ios_base::iostate __et = ios_base::goodbit;\n        __check_grouping(__grp, __gb.get(), __gn, __et);\n        if (__et)\n        {\n            __err |= ios_base::failbit;\n            return false;\n        }\n    }\n    return true;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                          bool __intl, ios_base& __iob,\n                                          ios_base::iostate& __err,\n                                          long double& __v) const\n{\n    const int __bz = 100;\n    char_type __wbuf[__bz];\n    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);\n    char_type* __wn;\n    char_type* __we = __wbuf + __bz;\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = false;\n    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,\n                 __wb, __wn, __we))\n    {\n        const char __src[] = \"0123456789\";\n        char_type __atoms[sizeof(__src)-1];\n        __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);\n        char __nbuf[__bz];\n        char* __nc = __nbuf;\n        unique_ptr<char, void(*)(void*)> __h(0, free);\n        if (__wn - __wb.get() > __bz-2)\n        {\n            __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));\n            if (__h.get() == 0)\n                __throw_bad_alloc();\n            __nc = __h.get();\n        }\n        if (__neg)\n            *__nc++ = '-';\n        for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)\n            *__nc = __src[find(__atoms, _VSTD::end(__atoms), *__w) - __atoms];\n        *__nc = char();\n        if (sscanf(__nbuf, \"%Lf\", &__v) != 1)\n            __throw_runtime_error(\"money_get error\");\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                          bool __intl, ios_base& __iob,\n                                          ios_base::iostate& __err,\n                                          string_type& __v) const\n{\n    const int __bz = 100;\n    char_type __wbuf[__bz];\n    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);\n    char_type* __wn;\n    char_type* __we = __wbuf + __bz;\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = false;\n    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,\n                 __wb, __wn, __we))\n    {\n        __v.clear();\n        if (__neg)\n            __v.push_back(__ct.widen('-'));\n        char_type __z = __ct.widen('0');\n        char_type* __w;\n        for (__w = __wb.get(); __w < __wn-1; ++__w)\n            if (*__w != __z)\n                break;\n        __v.append(__w, __wn);\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_get<wchar_t>)\n\n// money_put\n\ntemplate <class _CharT>\nclass __money_put\n{\nprotected:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE __money_put() {}\n\n    static void __gather_info(bool __intl, bool __neg, const locale& __loc,\n                              money_base::pattern& __pat, char_type& __dp,\n                              char_type& __ts, string& __grp,\n                              string_type& __sym, string_type& __sn,\n                              int& __fd);\n    static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,\n                         ios_base::fmtflags __flags,\n                         const char_type* __db, const char_type* __de,\n                         const ctype<char_type>& __ct, bool __neg,\n                         const money_base::pattern& __pat, char_type __dp,\n                         char_type __ts, const string& __grp,\n                         const string_type& __sym, const string_type& __sn,\n                         int __fd);\n};\n\ntemplate <class _CharT>\nvoid\n__money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,\n                                   money_base::pattern& __pat, char_type& __dp,\n                                   char_type& __ts, string& __grp,\n                                   string_type& __sym, string_type& __sn,\n                                   int& __fd)\n{\n    if (__intl)\n    {\n        const moneypunct<char_type, true>& __mp =\n            use_facet<moneypunct<char_type, true> >(__loc);\n        if (__neg)\n        {\n            __pat = __mp.neg_format();\n            __sn = __mp.negative_sign();\n        }\n        else\n        {\n            __pat = __mp.pos_format();\n            __sn = __mp.positive_sign();\n        }\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n    else\n    {\n        const moneypunct<char_type, false>& __mp =\n            use_facet<moneypunct<char_type, false> >(__loc);\n        if (__neg)\n        {\n            __pat = __mp.neg_format();\n            __sn = __mp.negative_sign();\n        }\n        else\n        {\n            __pat = __mp.pos_format();\n            __sn = __mp.positive_sign();\n        }\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n}\n\ntemplate <class _CharT>\nvoid\n__money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,\n                              ios_base::fmtflags __flags,\n                              const char_type* __db, const char_type* __de,\n                              const ctype<char_type>& __ct, bool __neg,\n                              const money_base::pattern& __pat, char_type __dp,\n                              char_type __ts, const string& __grp,\n                              const string_type& __sym, const string_type& __sn,\n                              int __fd)\n{\n    __me = __mb;\n    for (unsigned __p = 0; __p < 4; ++__p)\n    {\n        switch (__pat.field[__p])\n        {\n        case money_base::none:\n            __mi = __me;\n            break;\n        case money_base::space:\n            __mi = __me;\n            *__me++ = __ct.widen(' ');\n            break;\n        case money_base::sign:\n            if (!__sn.empty())\n                *__me++ = __sn[0];\n            break;\n        case money_base::symbol:\n            if (!__sym.empty() && (__flags & ios_base::showbase))\n                __me = _VSTD::copy(__sym.begin(), __sym.end(), __me);\n            break;\n        case money_base::value:\n            {\n            // remember start of value so we can reverse it\n            char_type* __t = __me;\n            // find beginning of digits\n            if (__neg)\n                ++__db;\n            // find end of digits\n            const char_type* __d;\n            for (__d = __db; __d < __de; ++__d)\n                if (!__ct.is(ctype_base::digit, *__d))\n                    break;\n            // print fractional part\n            if (__fd > 0)\n            {\n                int __f;\n                for (__f = __fd; __d > __db && __f > 0; --__f)\n                    *__me++ = *--__d;\n                char_type __z = __f > 0 ? __ct.widen('0') : char_type();\n                for (; __f > 0; --__f)\n                    *__me++ = __z;\n                *__me++ = __dp;\n            }\n            // print units part\n            if (__d == __db)\n            {\n                *__me++ = __ct.widen('0');\n            }\n            else\n            {\n                unsigned __ng = 0;\n                unsigned __ig = 0;\n                unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()\n                                              : static_cast<unsigned>(__grp[__ig]);\n                while (__d != __db)\n                {\n                    if (__ng == __gl)\n                    {\n                        *__me++ = __ts;\n                        __ng = 0;\n                        if (++__ig < __grp.size())\n                            __gl = __grp[__ig] == numeric_limits<char>::max() ?\n                                        numeric_limits<unsigned>::max() :\n                                        static_cast<unsigned>(__grp[__ig]);\n                    }\n                    *__me++ = *--__d;\n                    ++__ng;\n                }\n            }\n            // reverse it\n            reverse(__t, __me);\n            }\n            break;\n        }\n    }\n    // print rest of sign, if any\n    if (__sn.size() > 1)\n        __me = _VSTD::copy(__sn.begin()+1, __sn.end(), __me);\n    // set alignment\n    if ((__flags & ios_base::adjustfield) == ios_base::left)\n        __mi = __me;\n    else if ((__flags & ios_base::adjustfield) != ios_base::internal)\n        __mi = __mb;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS money_put\n    : public locale::facet,\n      private __money_put<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _OutputIterator         iter_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit money_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,\n                  long double __units) const\n    {\n        return do_put(__s, __intl, __iob, __fl, __units);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,\n                  const string_type& __digits) const\n    {\n        return do_put(__s, __intl, __iob, __fl, __digits);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~money_put() {}\n\n    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,\n                             char_type __fl, long double __units) const;\n    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,\n                             char_type __fl, const string_type& __digits) const;\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\nmoney_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,\n                                           ios_base& __iob, char_type __fl,\n                                           long double __units) const\n{\n    // convert to char\n    const size_t __bs = 100;\n    char __buf[__bs];\n    char* __bb = __buf;\n    char_type __digits[__bs];\n    char_type* __db = __digits;\n    size_t __n = static_cast<size_t>(snprintf(__bb, __bs, \"%.0Lf\", __units));\n    unique_ptr<char, void(*)(void*)> __hn(0, free);\n    unique_ptr<char_type, void(*)(void*)> __hd(0, free);\n    // secure memory for digit storage\n    if (__n > __bs-1)\n    {\n        __n = static_cast<size_t>(__libcpp_asprintf_l(&__bb, _LIBCPP_GET_C_LOCALE, \"%.0Lf\", __units));\n        if (__bb == 0)\n            __throw_bad_alloc();\n        __hn.reset(__bb);\n        __hd.reset((char_type*)malloc(__n * sizeof(char_type)));\n        if (__hd == nullptr)\n            __throw_bad_alloc();\n        __db = __hd.get();\n    }\n    // gather info\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    __ct.widen(__bb, __bb + __n, __db);\n    bool __neg = __n > 0 && __bb[0] == '-';\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __sn;\n    int __fd;\n    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    // secure memory for formatting\n    char_type __mbuf[__bs];\n    char_type* __mb = __mbuf;\n    unique_ptr<char_type, void(*)(void*)> __hw(0, free);\n    size_t __exn = static_cast<int>(__n) > __fd ?\n                   (__n - static_cast<size_t>(__fd)) * 2 + __sn.size() +\n                    __sym.size() + static_cast<size_t>(__fd) + 1\n                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;\n    if (__exn > __bs)\n    {\n        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));\n        __mb = __hw.get();\n        if (__mb == 0)\n            __throw_bad_alloc();\n    }\n    // format\n    char_type* __mi;\n    char_type* __me;\n    this->__format(__mb, __mi, __me, __iob.flags(),\n                   __db, __db + __n, __ct,\n                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,\n                                           ios_base& __iob, char_type __fl,\n                                           const string_type& __digits) const\n{\n    // gather info\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __sn;\n    int __fd;\n    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    // secure memory for formatting\n    char_type __mbuf[100];\n    char_type* __mb = __mbuf;\n    unique_ptr<char_type, void(*)(void*)> __h(0, free);\n    size_t __exn = static_cast<int>(__digits.size()) > __fd ?\n                   (__digits.size() - static_cast<size_t>(__fd)) * 2 +\n                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1\n                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;\n    if (__exn > 100)\n    {\n        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));\n        __mb = __h.get();\n        if (__mb == 0)\n            __throw_bad_alloc();\n    }\n    // format\n    char_type* __mi;\n    char_type* __me;\n    this->__format(__mb, __mi, __me, __iob.flags(),\n                   __digits.data(), __digits.data() + __digits.size(), __ct,\n                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_put<wchar_t>)\n\n// messages\n\nclass _LIBCPP_TYPE_VIS messages_base\n{\npublic:\n    typedef ptrdiff_t catalog;\n\n    _LIBCPP_ALWAYS_INLINE messages_base() {}\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS messages\n    : public locale::facet,\n      public messages_base\n{\npublic:\n    typedef _CharT               char_type;\n    typedef basic_string<_CharT> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    catalog open(const basic_string<char>& __nm, const locale& __loc) const\n    {\n        return do_open(__nm, __loc);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    string_type get(catalog __c, int __set, int __msgid,\n                    const string_type& __dflt) const\n    {\n        return do_get(__c, __set, __msgid, __dflt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    void close(catalog __c) const\n    {\n        do_close(__c);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~messages() {}\n\n    virtual catalog do_open(const basic_string<char>&, const locale&) const;\n    virtual string_type do_get(catalog, int __set, int __msgid,\n                               const string_type& __dflt) const;\n    virtual void do_close(catalog) const;\n};\n\ntemplate <class _CharT>\nlocale::id\nmessages<_CharT>::id;\n\ntemplate <class _CharT>\ntypename messages<_CharT>::catalog\nmessages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const\n{\n#ifdef _LIBCPP_HAS_CATOPEN\n    catalog __cat = (catalog)catopen(__nm.c_str(), NL_CAT_LOCALE);\n    if (__cat != -1)\n        __cat = static_cast<catalog>((static_cast<size_t>(__cat) >> 1));\n    return __cat;\n#else // !_LIBCPP_HAS_CATOPEN\n    return -1;\n#endif // _LIBCPP_HAS_CATOPEN\n}\n\ntemplate <class _CharT>\ntypename messages<_CharT>::string_type\nmessages<_CharT>::do_get(catalog __c, int __set, int __msgid,\n                         const string_type& __dflt) const\n{\n#ifdef _LIBCPP_HAS_CATOPEN\n    string __ndflt;\n    __narrow_to_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__ndflt),\n                                                       __dflt.c_str(),\n                                                       __dflt.c_str() + __dflt.size());\n    if (__c != -1)\n        __c <<= 1;\n    nl_catd __cat = (nl_catd)__c;\n    char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());\n    string_type __w;\n    __widen_from_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__w),\n                                                        __n, __n + strlen(__n));\n    return __w;\n#else // !_LIBCPP_HAS_CATOPEN\n    return __dflt;\n#endif // _LIBCPP_HAS_CATOPEN\n}\n\ntemplate <class _CharT>\nvoid\nmessages<_CharT>::do_close(catalog __c) const\n{\n#ifdef _LIBCPP_HAS_CATOPEN\n    if (__c != -1)\n        __c <<= 1;\n    nl_catd __cat = (nl_catd)__c;\n    catclose(__cat);\n#endif // _LIBCPP_HAS_CATOPEN\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages<wchar_t>)\n\ntemplate <class _CharT>\nclass _LIBCPP_TEMPLATE_VIS messages_byname\n    : public messages<_CharT>\n{\npublic:\n    typedef messages_base::catalog catalog;\n    typedef basic_string<_CharT> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages_byname(const char*, size_t __refs = 0)\n        : messages<_CharT>(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages_byname(const string&, size_t __refs = 0)\n        : messages<_CharT>(__refs) {}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~messages_byname() {}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages_byname<wchar_t>)\n\ntemplate<class _Codecvt, class _Elem = wchar_t,\n         class _Wide_alloc = allocator<_Elem>,\n         class _Byte_alloc = allocator<char> >\nclass _LIBCPP_TEMPLATE_VIS wstring_convert\n{\npublic:\n    typedef basic_string<char, char_traits<char>, _Byte_alloc>   byte_string;\n    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;\n    typedef typename _Codecvt::state_type                        state_type;\n    typedef typename wide_string::traits_type::int_type          int_type;\n\nprivate:\n    byte_string __byte_err_string_;\n    wide_string __wide_err_string_;\n    _Codecvt* __cvtptr_;\n    state_type __cvtstate_;\n    size_t __cvtcount_;\n\n    wstring_convert(const wstring_convert& __wc);\n    wstring_convert& operator=(const wstring_convert& __wc);\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(_Codecvt* __pcvt = new _Codecvt);\n    _LIBCPP_ALWAYS_INLINE\n    wstring_convert(_Codecvt* __pcvt, state_type __state);\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(const byte_string& __byte_err,\n                    const wide_string& __wide_err = wide_string());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_ALWAYS_INLINE\n    wstring_convert(wstring_convert&& __wc);\n#endif\n    ~wstring_convert();\n\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(char __byte)\n        {return from_bytes(&__byte, &__byte+1);}\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(const char* __ptr)\n        {return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));}\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(const byte_string& __str)\n        {return from_bytes(__str.data(), __str.data() + __str.size());}\n    wide_string from_bytes(const char* __first, const char* __last);\n\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(_Elem __wchar)\n        {return to_bytes(&__wchar, &__wchar+1);}\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(const _Elem* __wptr)\n        {return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));}\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(const wide_string& __wstr)\n        {return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());}\n    byte_string to_bytes(const _Elem* __first, const _Elem* __last);\n\n    _LIBCPP_ALWAYS_INLINE\n    size_t converted() const _NOEXCEPT {return __cvtcount_;}\n    _LIBCPP_ALWAYS_INLINE\n    state_type state() const {return __cvtstate_;}\n};\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(_Codecvt* __pcvt)\n        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)\n{\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(_Codecvt* __pcvt, state_type __state)\n        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)\n{\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err)\n        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),\n          __cvtstate_(), __cvtcount_(0)\n{\n    __cvtptr_ = new _Codecvt;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(wstring_convert&& __wc)\n        : __byte_err_string_(_VSTD::move(__wc.__byte_err_string_)),\n          __wide_err_string_(_VSTD::move(__wc.__wide_err_string_)),\n          __cvtptr_(__wc.__cvtptr_),\n          __cvtstate_(__wc.__cvtstate_), __cvtcount_(__wc.__cvtcount_)\n{\n    __wc.__cvtptr_ = nullptr;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert()\n{\n    delete __cvtptr_;\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    from_bytes(const char* __frm, const char* __frm_end)\n{\n    __cvtcount_ = 0;\n    if (__cvtptr_ != nullptr)\n    {\n        wide_string __ws(2*(__frm_end - __frm), _Elem());\n        if (__frm != __frm_end)\n            __ws.resize(__ws.capacity());\n        codecvt_base::result __r = codecvt_base::ok;\n        state_type __st = __cvtstate_;\n        if (__frm != __frm_end)\n        {\n            _Elem* __to = &__ws[0];\n            _Elem* __to_end = __to + __ws.size();\n            const char* __frm_nxt;\n            do\n            {\n                _Elem* __to_nxt;\n                __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,\n                                          __to, __to_end, __to_nxt);\n                __cvtcount_ += __frm_nxt - __frm;\n                if (__frm_nxt == __frm)\n                {\n                    __r = codecvt_base::error;\n                }\n                else if (__r == codecvt_base::noconv)\n                {\n                    __ws.resize(__to - &__ws[0]);\n                    // This only gets executed if _Elem is char\n                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);\n                    __frm = __frm_nxt;\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __ws.resize(__to_nxt - &__ws[0]);\n                    __frm = __frm_nxt;\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __s = __to_nxt - &__ws[0];\n                    __ws.resize(2 * __s);\n                    __to = &__ws[0] + __s;\n                    __to_end = &__ws[0] + __ws.size();\n                    __frm = __frm_nxt;\n                }\n            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);\n        }\n        if (__r == codecvt_base::ok)\n            return __ws;\n    }\n\n    if (__wide_err_string_.empty())\n        __throw_range_error(\"wstring_convert: from_bytes error\");\n\n    return __wide_err_string_;\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    to_bytes(const _Elem* __frm, const _Elem* __frm_end)\n{\n    __cvtcount_ = 0;\n    if (__cvtptr_ != nullptr)\n    {\n        byte_string __bs(2*(__frm_end - __frm), char());\n        if (__frm != __frm_end)\n            __bs.resize(__bs.capacity());\n        codecvt_base::result __r = codecvt_base::ok;\n        state_type __st = __cvtstate_;\n        if (__frm != __frm_end)\n        {\n            char* __to = &__bs[0];\n            char* __to_end = __to + __bs.size();\n            const _Elem* __frm_nxt;\n            do\n            {\n                char* __to_nxt;\n                __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,\n                                           __to, __to_end, __to_nxt);\n                __cvtcount_ += __frm_nxt - __frm;\n                if (__frm_nxt == __frm)\n                {\n                    __r = codecvt_base::error;\n                }\n                else if (__r == codecvt_base::noconv)\n                {\n                    __bs.resize(__to - &__bs[0]);\n                    // This only gets executed if _Elem is char\n                    __bs.append((const char*)__frm, (const char*)__frm_end);\n                    __frm = __frm_nxt;\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __bs.resize(__to_nxt - &__bs[0]);\n                    __frm = __frm_nxt;\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __s = __to_nxt - &__bs[0];\n                    __bs.resize(2 * __s);\n                    __to = &__bs[0] + __s;\n                    __to_end = &__bs[0] + __bs.size();\n                    __frm = __frm_nxt;\n                }\n            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);\n        }\n        if (__r == codecvt_base::ok)\n        {\n            size_t __s = __bs.size();\n            __bs.resize(__bs.capacity());\n            char* __to = &__bs[0] + __s;\n            char* __to_end = __to + __bs.size();\n            do\n            {\n                char* __to_nxt;\n                __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);\n                if (__r == codecvt_base::noconv)\n                {\n                    __bs.resize(__to - &__bs[0]);\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __bs.resize(__to_nxt - &__bs[0]);\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __sp = __to_nxt - &__bs[0];\n                    __bs.resize(2 * __sp);\n                    __to = &__bs[0] + __sp;\n                    __to_end = &__bs[0] + __bs.size();\n                }\n            } while (__r == codecvt_base::partial);\n            if (__r == codecvt_base::ok)\n                return __bs;\n        }\n    }\n\n    if (__byte_err_string_.empty())\n        __throw_range_error(\"wstring_convert: to_bytes error\");\n\n    return __byte_err_string_;\n}\n\ntemplate <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >\nclass _LIBCPP_TEMPLATE_VIS wbuffer_convert\n    : public basic_streambuf<_Elem, _Tr>\n{\npublic:\n    // types:\n    typedef _Elem                          char_type;\n    typedef _Tr                            traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef typename _Codecvt::state_type  state_type;\n\nprivate:\n    char*       __extbuf_;\n    const char* __extbufnext_;\n    const char* __extbufend_;\n    char __extbuf_min_[8];\n    size_t __ebs_;\n    char_type* __intbuf_;\n    size_t __ibs_;\n    streambuf* __bufptr_;\n    _Codecvt* __cv_;\n    state_type __st_;\n    ios_base::openmode __cm_;\n    bool __owns_eb_;\n    bool __owns_ib_;\n    bool __always_noconv_;\n\n    wbuffer_convert(const wbuffer_convert&);\n    wbuffer_convert& operator=(const wbuffer_convert&);\npublic:\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wbuffer_convert(streambuf* __bytebuf = 0, \n            _Codecvt* __pcvt = new _Codecvt, state_type __state = state_type());\n    ~wbuffer_convert();\n\n    _LIBCPP_INLINE_VISIBILITY\n    streambuf* rdbuf() const {return __bufptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    streambuf* rdbuf(streambuf* __bytebuf)\n    {\n        streambuf* __r = __bufptr_;\n        __bufptr_ = __bytebuf;\n        return __r;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    state_type state() const {return __st_;}\n\nprotected:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,\n                                                            streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual int sync();\n\nprivate:\n    bool __read_mode();\n    void __write_mode();\n    wbuffer_convert* __close();\n};\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>::\n    wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)\n    : __extbuf_(0),\n      __extbufnext_(0),\n      __extbufend_(0),\n      __ebs_(0),\n      __intbuf_(0),\n      __ibs_(0),\n      __bufptr_(__bytebuf),\n      __cv_(__pcvt),\n      __st_(__state),\n      __cm_(0),\n      __owns_eb_(false),\n      __owns_ib_(false),\n      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)\n{\n    setbuf(0, 4096);\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()\n{\n    __close();\n    delete __cv_;\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return traits_type::eof();\n    bool __initial = __read_mode();\n    char_type __1buf;\n    if (this->gptr() == 0)\n        this->setg(&__1buf, &__1buf+1, &__1buf+1);\n    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);\n    int_type __c = traits_type::eof();\n    if (this->gptr() == this->egptr())\n    {\n        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));\n        if (__always_noconv_)\n        {\n            streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);\n            __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);\n            if (__nmemb != 0)\n            {\n                this->setg(this->eback(),\n                           this->eback() + __unget_sz,\n                           this->eback() + __unget_sz + __nmemb);\n                __c = *this->gptr();\n            }\n        }\n        else\n        {\n             _LIBCPP_ASSERT(!(__extbufnext_ == NULL && (__extbufend_ != __extbufnext_)), \"underflow moving from NULL\" );\n             if (__extbufend_ != __extbufnext_)\n                memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);\n            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);\n            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);\n            streamsize __nmemb = _VSTD::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),\n                                 static_cast<streamsize>(__extbufend_ - __extbufnext_));\n            codecvt_base::result __r;\n            // FIXME: Do we ever need to restore the state here?\n            //state_type __svs = __st_;\n            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);\n            if (__nr != 0)\n            {\n                __extbufend_ = __extbufnext_ + __nr;\n                char_type*  __inext;\n                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,\n                                       this->eback() + __unget_sz,\n                                       this->egptr(), __inext);\n                if (__r == codecvt_base::noconv)\n                {\n                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, (char_type*)__extbufend_);\n                    __c = *this->gptr();\n                }\n                else if (__inext != this->eback() + __unget_sz)\n                {\n                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);\n                    __c = *this->gptr();\n                }\n            }\n        }\n    }\n    else\n        __c = *this->gptr();\n    if (this->eback() == &__1buf)\n        this->setg(0, 0, 0);\n    return __c;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)\n{\n    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->gbump(-1);\n            return traits_type::not_eof(__c);\n        }\n        if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->gbump(-1);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return traits_type::eof();\n    __write_mode();\n    char_type __1buf;\n    char_type* __pb_save = this->pbase();\n    char_type* __epb_save = this->epptr();\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        if (this->pptr() == 0)\n            this->setp(&__1buf, &__1buf+1);\n        *this->pptr() = traits_type::to_char_type(__c);\n        this->pbump(1);\n    }\n    if (this->pptr() != this->pbase())\n    {\n        if (__always_noconv_)\n        {\n            streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());\n            if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)\n                return traits_type::eof();\n        }\n        else\n        {\n            char* __extbe = __extbuf_;\n            codecvt_base::result __r;\n            do\n            {\n                const char_type* __e;\n                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,\n                                        __extbuf_, __extbuf_ + __ebs_, __extbe);\n                if (__e == this->pbase())\n                    return traits_type::eof();\n                if (__r == codecvt_base::noconv)\n                {\n                    streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n                    if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)\n                        return traits_type::eof();\n                }\n                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)\n                {\n                    streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n                    if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)\n                        return traits_type::eof();\n                    if (__r == codecvt_base::partial)\n                    {\n                        this->setp((char_type*)__e, this->pptr());\n                        this->pbump(this->epptr() - this->pbase());\n                    }\n                }\n                else\n                    return traits_type::eof();\n            } while (__r == codecvt_base::partial);\n        }\n        this->setp(__pb_save, __epb_save);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nbasic_streambuf<_Elem, _Tr>*\nwbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n)\n{\n    this->setg(0, 0, 0);\n    this->setp(0, 0);\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n    __ebs_ = __n;\n    if (__ebs_ > sizeof(__extbuf_min_))\n    {\n        if (__always_noconv_ && __s)\n        {\n            __extbuf_ = (char*)__s;\n            __owns_eb_ = false;\n        }\n        else\n        {\n            __extbuf_ = new char[__ebs_];\n            __owns_eb_ = true;\n        }\n    }\n    else\n    {\n        __extbuf_ = __extbuf_min_;\n        __ebs_ = sizeof(__extbuf_min_);\n        __owns_eb_ = false;\n    }\n    if (!__always_noconv_)\n    {\n        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));\n        if (__s && __ibs_ >= sizeof(__extbuf_min_))\n        {\n            __intbuf_ = __s;\n            __owns_ib_ = false;\n        }\n        else\n        {\n            __intbuf_ = new char_type[__ibs_];\n            __owns_ib_ = true;\n        }\n    }\n    else\n    {\n        __ibs_ = 0;\n        __intbuf_ = 0;\n        __owns_ib_ = false;\n    }\n    return this;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,\n                                        ios_base::openmode __om)\n{\n    int __width = __cv_->encoding();\n    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())\n        return pos_type(off_type(-1));\n    // __width > 0 || __off == 0, now check __way\n    if (__way != ios_base::beg && __way != ios_base::cur && __way != ios_base::end)\n        return pos_type(off_type(-1));\n    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);\n    __r.state(__st_);\n    return __r;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)\n{\n    if (__cv_ == 0 || __bufptr_ == 0 || sync())\n        return pos_type(off_type(-1));\n    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))\n        return pos_type(off_type(-1));\n    return __sp;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nint\nwbuffer_convert<_Codecvt, _Elem, _Tr>::sync()\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return 0;\n    if (__cm_ & ios_base::out)\n    {\n        if (this->pptr() != this->pbase())\n            if (overflow() == traits_type::eof())\n                return -1;\n        codecvt_base::result __r;\n        do\n        {\n            char* __extbe;\n            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);\n            streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);\n            if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)\n                return -1;\n        } while (__r == codecvt_base::partial);\n        if (__r == codecvt_base::error)\n            return -1;\n        if (__bufptr_->pubsync())\n            return -1;\n    }\n    else if (__cm_ & ios_base::in)\n    {\n        off_type __c;\n        if (__always_noconv_)\n            __c = this->egptr() - this->gptr();\n        else\n        {\n            int __width = __cv_->encoding();\n            __c = __extbufend_ - __extbufnext_;\n            if (__width > 0)\n                __c += __width * (this->egptr() - this->gptr());\n            else\n            {\n                if (this->gptr() != this->egptr())\n                {\n                    reverse(this->gptr(), this->egptr());\n                    codecvt_base::result __r;\n                    const char_type* __e = this->gptr();\n                    char* __extbe;\n                    do\n                    {\n                        __r = __cv_->out(__st_, __e, this->egptr(), __e,\n                                         __extbuf_, __extbuf_ + __ebs_, __extbe);\n                        switch (__r)\n                        {\n                        case codecvt_base::noconv:\n                            __c += this->egptr() - this->gptr();\n                            break;\n                        case codecvt_base::ok:\n                        case codecvt_base::partial:\n                            __c += __extbe - __extbuf_;\n                            break;\n                        default:\n                            return -1;\n                        }\n                    } while (__r == codecvt_base::partial);\n                }\n            }\n        }\n        if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))\n            return -1;\n        this->setg(0, 0, 0);\n        __cm_ = 0;\n    }\n    return 0;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nbool\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()\n{\n    if (!(__cm_ & ios_base::in))\n    {\n        this->setp(0, 0);\n        if (__always_noconv_)\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + __ebs_,\n                       (char_type*)__extbuf_ + __ebs_);\n        else\n            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);\n        __cm_ = ios_base::in;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nvoid\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()\n{\n    if (!(__cm_ & ios_base::out))\n    {\n        this->setg(0, 0, 0);\n        if (__ebs_ > sizeof(__extbuf_min_))\n        {\n            if (__always_noconv_)\n                this->setp((char_type*)__extbuf_,\n                           (char_type*)__extbuf_ + (__ebs_ - 1));\n            else\n                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));\n        }\n        else\n            this->setp(0, 0);\n        __cm_ = ios_base::out;\n    }\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>*\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__close()\n{\n    wbuffer_convert* __rt = 0;\n    if (__cv_ != 0 && __bufptr_ != 0)\n    {\n        __rt = this;\n        if ((__cm_ & ios_base::out) && sync())\n            __rt = 0;\n    }\n    return __rt;\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_LOCALE\n","/// @ref core\r\n/// @file glm/detail/type_vec4.hpp\r\n\r\n#pragma once\r\n\r\n#include \"type_vec.hpp\"\r\n#if GLM_SWIZZLE == GLM_SWIZZLE_ENABLED\r\n#\tif GLM_HAS_UNRESTRICTED_UNIONS\r\n#\t\tinclude \"_swizzle.hpp\"\r\n#\telse\r\n#\t\tinclude \"_swizzle_func.hpp\"\r\n#\tendif\r\n#endif //GLM_SWIZZLE\r\n#include <cstddef>\r\n\r\nnamespace glm\r\n{\r\n\ttemplate <typename T, precision P = defaultp>\r\n\tstruct tvec4\r\n\t{\r\n\t\t// -- Implementation detail --\r\n\r\n\t\ttypedef T value_type;\r\n\t\ttypedef tvec4<T, P> type;\r\n\t\ttypedef tvec4<bool, P> bool_type;\r\n\r\n\t\t// -- Data --\r\n\r\n#\t\tif GLM_HAS_ONLY_XYZW\r\n\t\t\tT x, y, z, w;\r\n\r\n#\t\telif GLM_HAS_ALIGNED_TYPE\r\n#\t\t\tif GLM_COMPILER & GLM_COMPILER_GCC\r\n#\t\t\t\tpragma GCC diagnostic push\r\n#\t\t\t\tpragma GCC diagnostic ignored \"-Wpedantic\"\r\n#\t\t\tendif\r\n#\t\t\tif GLM_COMPILER & GLM_COMPILER_CLANG\r\n#\t\t\t\tpragma clang diagnostic push\r\n#\t\t\t\tpragma clang diagnostic ignored \"-Wgnu-anonymous-struct\"\r\n#\t\t\t\tpragma clang diagnostic ignored \"-Wnested-anon-types\"\r\n#\t\t\tendif\r\n\r\n\t\t\tunion\r\n\t\t\t{\r\n\t\t\t\tstruct { T x, y, z, w;};\r\n\t\t\t\tstruct { T r, g, b, a; };\r\n\t\t\t\tstruct { T s, t, p, q; };\r\n\r\n\t\t\t\ttypename detail::storage<T, sizeof(T) * 4, detail::is_aligned<P>::value>::type data;\r\n\r\n#\t\t\t\tif GLM_SWIZZLE == GLM_SWIZZLE_ENABLED\r\n\t\t\t\t\t_GLM_SWIZZLE4_2_MEMBERS(T, P, glm::tvec2, x, y, z, w)\r\n\t\t\t\t\t_GLM_SWIZZLE4_2_MEMBERS(T, P, glm::tvec2, r, g, b, a)\r\n\t\t\t\t\t_GLM_SWIZZLE4_2_MEMBERS(T, P, glm::tvec2, s, t, p, q)\r\n\t\t\t\t\t_GLM_SWIZZLE4_3_MEMBERS(T, P, glm::tvec3, x, y, z, w)\r\n\t\t\t\t\t_GLM_SWIZZLE4_3_MEMBERS(T, P, glm::tvec3, r, g, b, a)\r\n\t\t\t\t\t_GLM_SWIZZLE4_3_MEMBERS(T, P, glm::tvec3, s, t, p, q)\r\n\t\t\t\t\t_GLM_SWIZZLE4_4_MEMBERS(T, P, glm::tvec4, x, y, z, w)\r\n\t\t\t\t\t_GLM_SWIZZLE4_4_MEMBERS(T, P, glm::tvec4, r, g, b, a)\r\n\t\t\t\t\t_GLM_SWIZZLE4_4_MEMBERS(T, P, glm::tvec4, s, t, p, q)\r\n#\t\t\t\tendif//GLM_SWIZZLE\r\n\t\t\t};\r\n\r\n#\t\t\tif GLM_COMPILER & GLM_COMPILER_CLANG\r\n#\t\t\t\tpragma clang diagnostic pop\r\n#\t\t\tendif\r\n#\t\t\tif GLM_COMPILER & GLM_COMPILER_GCC\r\n#\t\t\t\tpragma GCC diagnostic pop\r\n#\t\t\tendif\r\n#\t\telse\r\n\t\t\tunion { T x, r, s; };\r\n\t\t\tunion { T y, g, t; };\r\n\t\t\tunion { T z, b, p; };\r\n\t\t\tunion { T w, a, q; };\r\n\r\n#\t\t\tif GLM_SWIZZLE == GLM_SWIZZLE_ENABLED\r\n\t\t\t\tGLM_SWIZZLE_GEN_VEC_FROM_VEC4(T, P, tvec4, tvec2, tvec3, tvec4)\r\n#\t\t\tendif//GLM_SWIZZLE\r\n#\t\tendif\r\n\r\n\t\t// -- Component accesses --\r\n\r\n\t\t/// Return the count of components of the vector\r\n\t\ttypedef length_t length_type;\r\n\t\tGLM_FUNC_DECL static length_type length(){return 4;}\r\n\r\n\t\tGLM_FUNC_DECL T & operator[](length_type i);\r\n\t\tGLM_FUNC_DECL T const & operator[](length_type i) const;\r\n\r\n\t\t// -- Implicit basic constructors --\r\n\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_SIMD tvec4() GLM_DEFAULT_CTOR;\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_SIMD tvec4(tvec4<T, P> const& v) GLM_DEFAULT;\r\n\t\ttemplate <precision Q>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_SIMD tvec4(tvec4<T, Q> const& v);\r\n\r\n\t\t// -- Explicit basic constructors --\r\n\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_SIMD explicit tvec4(ctor);\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_SIMD explicit tvec4(T scalar);\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_SIMD tvec4(T a, T b, T c, T d);\r\n\r\n\t\t// -- Conversion scalar constructors --\r\n\r\n\t\t/// Explicit converions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\r\n\t\ttemplate <typename A, typename B, typename C, typename D>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_SIMD tvec4(A a, B b, C c, D d);\r\n\t\ttemplate <typename A, typename B, typename C, typename D>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(tvec1<A, P> const& a, tvec1<B, P> const& b, tvec1<C, P> const& c, tvec1<D, P> const& d);\r\n\r\n\t\t// -- Conversion vector constructors --\r\n\r\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\r\n\t\ttemplate <typename A, typename B, typename C, precision Q>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(tvec2<A, Q> const & a, B b, C c);\r\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\r\n\t\ttemplate <typename A, typename B, typename C, precision Q>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(tvec2<A, Q> const & a, tvec1<B, Q> const & b, tvec1<C, Q> const & c);\r\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\r\n\t\ttemplate <typename A, typename B, typename C, precision Q>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(A a, tvec2<B, Q> const & b, C c);\r\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\r\n\t\ttemplate <typename A, typename B, typename C, precision Q>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(tvec1<A, Q> const & a, tvec2<B, Q> const & b, tvec1<C, Q> const & c);\r\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\r\n\t\ttemplate <typename A, typename B, typename C, precision Q>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(A a, B b, tvec2<C, Q> const & c);\r\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\r\n\t\ttemplate <typename A, typename B, typename C, precision Q>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(tvec1<A, Q> const & a, tvec1<B, Q> const & b, tvec2<C, Q> const & c);\r\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\r\n\t\ttemplate <typename A, typename B, precision Q>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(tvec3<A, Q> const & a, B b);\r\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\r\n\t\ttemplate <typename A, typename B, precision Q>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(tvec3<A, Q> const & a, tvec1<B, Q> const & b);\r\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\r\n\t\ttemplate <typename A, typename B, precision Q>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(A a, tvec3<B, Q> const & b);\r\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\r\n\t\ttemplate <typename A, typename B, precision Q>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(tvec1<A, Q> const & a, tvec3<B, Q> const & b);\r\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\r\n\t\ttemplate <typename A, typename B, precision Q>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec4(tvec2<A, Q> const & a, tvec2<B, Q> const & b);\r\n\r\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\r\n\t\ttemplate <typename U, precision Q>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR GLM_EXPLICIT tvec4(tvec4<U, Q> const& v);\r\n\r\n\t\t// -- Swizzle constructors --\r\n#\t\tif GLM_HAS_UNRESTRICTED_UNIONS && (GLM_SWIZZLE == GLM_SWIZZLE_ENABLED)\r\n\t\t\ttemplate <int E0, int E1, int E2, int E3>\r\n\t\t\tGLM_FUNC_DECL tvec4(detail::_swizzle<4, T, P, glm::tvec4, E0, E1, E2, E3> const & that)\r\n\t\t\t{\r\n\t\t\t\t*this = that();\r\n\t\t\t}\r\n\r\n\t\t\ttemplate <int E0, int E1, int F0, int F1>\r\n\t\t\tGLM_FUNC_DECL tvec4(detail::_swizzle<2, T, P, glm::tvec2, E0, E1, -1, -2> const & v, detail::_swizzle<2, T, P, glm::tvec2, F0, F1, -1, -2> const & u)\r\n\t\t\t{\r\n\t\t\t\t*this = tvec4<T, P>(v(), u());\r\n\t\t\t}\r\n\r\n\t\t\ttemplate <int E0, int E1>\r\n\t\t\tGLM_FUNC_DECL tvec4(T const & x, T const & y, detail::_swizzle<2, T, P, glm::tvec2, E0, E1, -1, -2> const & v)\r\n\t\t\t{\r\n\t\t\t\t*this = tvec4<T, P>(x, y, v());\r\n\t\t\t}\r\n\r\n\t\t\ttemplate <int E0, int E1>\r\n\t\t\tGLM_FUNC_DECL tvec4(T const & x, detail::_swizzle<2, T, P, glm::tvec2, E0, E1, -1, -2> const & v, T const & w)\r\n\t\t\t{\r\n\t\t\t\t*this = tvec4<T, P>(x, v(), w);\r\n\t\t\t}\r\n\r\n\t\t\ttemplate <int E0, int E1>\r\n\t\t\tGLM_FUNC_DECL tvec4(detail::_swizzle<2, T, P, glm::tvec2, E0, E1, -1, -2> const & v, T const & z, T const & w)\r\n\t\t\t{\r\n\t\t\t\t*this = tvec4<T, P>(v(), z, w);\r\n\t\t\t}\r\n\r\n\t\t\ttemplate <int E0, int E1, int E2>\r\n\t\t\tGLM_FUNC_DECL tvec4(detail::_swizzle<3, T, P, glm::tvec3, E0, E1, E2, -1> const & v, T const & w)\r\n\t\t\t{\r\n\t\t\t\t*this = tvec4<T, P>(v(), w);\r\n\t\t\t}\r\n\r\n\t\t\ttemplate <int E0, int E1, int E2>\r\n\t\t\tGLM_FUNC_DECL tvec4(T const & x, detail::_swizzle<3, T, P, glm::tvec3, E0, E1, E2, -1> const & v)\r\n\t\t\t{\r\n\t\t\t\t*this = tvec4<T, P>(x, v());\r\n\t\t\t}\r\n#\t\tendif// GLM_HAS_UNRESTRICTED_UNIONS && (GLM_SWIZZLE == GLM_SWIZZLE_ENABLED)\r\n\r\n\t\t// -- Unary arithmetic operators --\r\n\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator=(tvec4<T, P> const & v) GLM_DEFAULT;\r\n\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator=(tvec4<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator+=(U scalar);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator+=(tvec1<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator+=(tvec4<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator-=(U scalar);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator-=(tvec1<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator-=(tvec4<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator*=(U scalar);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator*=(tvec1<U, P> const& v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator*=(tvec4<U, P> const& v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator/=(U scalar);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator/=(tvec1<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator/=(tvec4<U, P> const & v);\r\n\r\n\t\t// -- Increment and decrement operators --\r\n\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator++();\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator--();\r\n\t\tGLM_FUNC_DECL tvec4<T, P> operator++(int);\r\n\t\tGLM_FUNC_DECL tvec4<T, P> operator--(int);\r\n\r\n\t\t// -- Unary bit operators --\r\n\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator%=(U scalar);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator%=(tvec1<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator%=(tvec4<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator&=(U scalar);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator&=(tvec1<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator&=(tvec4<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator|=(U scalar);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator|=(tvec1<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator|=(tvec4<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator^=(U scalar);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator^=(tvec1<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator^=(tvec4<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator<<=(U scalar);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator<<=(tvec1<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator<<=(tvec4<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator>>=(U scalar);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator>>=(tvec1<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec4<T, P> & operator>>=(tvec4<U, P> const & v);\r\n\t};\r\n\r\n\t// -- Unary operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator+(tvec4<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator-(tvec4<T, P> const & v);\r\n\r\n\t// -- Binary operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator+(tvec4<T, P> const & v, T scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec1<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator+(T scalar, tvec4<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator+(tvec1<T, P> const & v1, tvec4<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator-(tvec4<T, P> const & v, T scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec1<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator-(T scalar, tvec4<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator-(tvec1<T, P> const & v1, tvec4<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator*(tvec4<T, P> const & v, T scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec1<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator*(T scalar, tvec4<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator*(tvec1<T, P> const & v1, tvec4<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator/(tvec4<T, P> const & v, T scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec1<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator/(T scalar, tvec4<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator/(tvec1<T, P> const & v1, tvec4<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator%(tvec4<T, P> const & v, T scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator%(tvec4<T, P> const & v, tvec1<T, P> const & scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator%(T scalar, tvec4<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator%(tvec1<T, P> const & scalar, tvec4<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator%(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator&(tvec4<T, P> const & v, T scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator&(tvec4<T, P> const & v, tvec1<T, P> const & scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator&(T scalar, tvec4<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator&(tvec1<T, P> const & scalar, tvec4<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator&(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator|(tvec4<T, P> const & v, T scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator|(tvec4<T, P> const & v, tvec1<T, P> const & scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator|(T scalar, tvec4<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator|(tvec1<T, P> const & scalar, tvec4<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator|(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator^(tvec4<T, P> const & v, T scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator^(tvec4<T, P> const & v, tvec1<T, P> const & scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator^(T scalar, tvec4<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator^(tvec1<T, P> const & scalar, tvec4<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator^(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator<<(tvec4<T, P> const & v, T scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator<<(tvec4<T, P> const & v, tvec1<T, P> const & scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator<<(T scalar, tvec4<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator<<(tvec1<T, P> const & scalar, tvec4<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator<<(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator>>(tvec4<T, P> const & v, T scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator>>(tvec4<T, P> const & v, tvec1<T, P> const & scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator>>(T scalar, tvec4<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator>>(tvec1<T, P> const & scalar, tvec4<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec4<T, P> operator>>(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P> \r\n\tGLM_FUNC_DECL tvec4<T, P> operator~(tvec4<T, P> const & v);\r\n\r\n\t// -- Boolean operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL bool operator==(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL bool operator!=(tvec4<T, P> const & v1, tvec4<T, P> const & v2);\r\n\r\n\ttemplate <precision P>\r\n\tGLM_FUNC_DECL tvec4<bool, P> operator&&(tvec4<bool, P> const & v1, tvec4<bool, P> const & v2);\r\n\r\n\ttemplate <precision P>\r\n\tGLM_FUNC_DECL tvec4<bool, P> operator||(tvec4<bool, P> const & v1, tvec4<bool, P> const & v2);\r\n}//namespace glm\r\n\r\n#ifndef GLM_EXTERNAL_TEMPLATE\r\n#include \"type_vec4.inl\"\r\n#endif//GLM_EXTERNAL_TEMPLATE\r\n","/// @ref core\r\n/// @file glm/detail/type_vec3.hpp\r\n\r\n#pragma once\r\n\r\n#include \"type_vec.hpp\"\r\n#if GLM_SWIZZLE == GLM_SWIZZLE_ENABLED\r\n#\tif GLM_HAS_UNRESTRICTED_UNIONS\r\n#\t\tinclude \"_swizzle.hpp\"\r\n#\telse\r\n#\t\tinclude \"_swizzle_func.hpp\"\r\n#\tendif\r\n#endif //GLM_SWIZZLE == GLM_SWIZZLE_ENABLED\r\n#include <cstddef>\r\n\r\nnamespace glm\r\n{\r\n\ttemplate <typename T, precision P = defaultp>\r\n\tstruct tvec3\r\n\t{\r\n\t\t// -- Implementation detail --\r\n\r\n\t\ttypedef T value_type;\r\n\t\ttypedef tvec3<T, P> type;\r\n\t\ttypedef tvec3<bool, P> bool_type;\r\n\r\n\t\t// -- Data --\r\n\r\n#\t\tif GLM_HAS_ONLY_XYZW\r\n\t\t\tT x, y, z;\r\n\r\n#\t\telif GLM_HAS_ALIGNED_TYPE\r\n#\t\t\tif GLM_COMPILER & GLM_COMPILER_GCC\r\n#\t\t\t\tpragma GCC diagnostic push\r\n#\t\t\t\tpragma GCC diagnostic ignored \"-Wpedantic\"\r\n#\t\t\tendif\r\n#\t\t\tif GLM_COMPILER & GLM_COMPILER_CLANG\r\n#\t\t\t\tpragma clang diagnostic push\r\n#\t\t\t\tpragma clang diagnostic ignored \"-Wgnu-anonymous-struct\"\r\n#\t\t\t\tpragma clang diagnostic ignored \"-Wnested-anon-types\"\r\n#\t\t\tendif\r\n\r\n\t\t\tunion\r\n\t\t\t{\r\n\t\t\t\tstruct{ T x, y, z; };\r\n\t\t\t\tstruct{ T r, g, b; };\r\n\t\t\t\tstruct{ T s, t, p; };\r\n\r\n#\t\t\t\tif GLM_SWIZZLE == GLM_SWIZZLE_ENABLED\r\n\t\t\t\t\t_GLM_SWIZZLE3_2_MEMBERS(T, P, glm::tvec2, x, y, z)\r\n\t\t\t\t\t_GLM_SWIZZLE3_2_MEMBERS(T, P, glm::tvec2, r, g, b)\r\n\t\t\t\t\t_GLM_SWIZZLE3_2_MEMBERS(T, P, glm::tvec2, s, t, p)\r\n\t\t\t\t\t_GLM_SWIZZLE3_3_MEMBERS(T, P, glm::tvec3, x, y, z)\r\n\t\t\t\t\t_GLM_SWIZZLE3_3_MEMBERS(T, P, glm::tvec3, r, g, b)\r\n\t\t\t\t\t_GLM_SWIZZLE3_3_MEMBERS(T, P, glm::tvec3, s, t, p)\r\n\t\t\t\t\t_GLM_SWIZZLE3_4_MEMBERS(T, P, glm::tvec4, x, y, z)\r\n\t\t\t\t\t_GLM_SWIZZLE3_4_MEMBERS(T, P, glm::tvec4, r, g, b)\r\n\t\t\t\t\t_GLM_SWIZZLE3_4_MEMBERS(T, P, glm::tvec4, s, t, p)\r\n#\t\t\t\tendif//GLM_SWIZZLE\r\n\t\t\t};\r\n\t\t\r\n#\t\t\tif GLM_COMPILER & GLM_COMPILER_CLANG\r\n#\t\t\t\tpragma clang diagnostic pop\r\n#\t\t\tendif\r\n#\t\t\tif GLM_COMPILER & GLM_COMPILER_GCC\r\n#\t\t\t\tpragma GCC diagnostic pop\r\n#\t\t\tendif\r\n#\t\telse\r\n\t\t\tunion { T x, r, s; };\r\n\t\t\tunion { T y, g, t; };\r\n\t\t\tunion { T z, b, p; };\r\n\r\n#\t\t\tif GLM_SWIZZLE == GLM_SWIZZLE_ENABLED\r\n\t\t\t\tGLM_SWIZZLE_GEN_VEC_FROM_VEC3(T, P, tvec3, tvec2, tvec3, tvec4)\r\n#\t\t\tendif//GLM_SWIZZLE\r\n#\t\tendif//GLM_LANG\r\n\r\n\t\t// -- Component accesses --\r\n\r\n\t\t/// Return the count of components of the vector\r\n\t\ttypedef length_t length_type;\r\n\t\tGLM_FUNC_DECL static length_type length(){return 3;}\r\n\r\n\t\tGLM_FUNC_DECL T & operator[](length_type i);\r\n\t\tGLM_FUNC_DECL T const & operator[](length_type i) const;\r\n\r\n\t\t// -- Implicit basic constructors --\r\n\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec3() GLM_DEFAULT_CTOR;\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec3(tvec3<T, P> const & v) GLM_DEFAULT;\r\n\t\ttemplate <precision Q>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec3(tvec3<T, Q> const & v);\r\n\r\n\t\t// -- Explicit basic constructors --\r\n\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR explicit tvec3(ctor);\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR explicit tvec3(T scalar);\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec3(T a, T b, T c);\r\n\r\n\t\t// -- Conversion scalar constructors --\r\n\r\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\r\n\t\ttemplate <typename A, typename B, typename C>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec3(A a, B b, C c);\r\n\t\ttemplate <typename A, typename B, typename C>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec3(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c);\r\n\r\n\t\t// -- Conversion vector constructors --\r\n\r\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\r\n\t\ttemplate <typename A, typename B, precision Q>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec3(tvec2<A, Q> const & a, B b);\r\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\r\n\t\ttemplate <typename A, typename B, precision Q>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec3(tvec2<A, Q> const & a, tvec1<B, Q> const & b);\r\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\r\n\t\ttemplate <typename A, typename B, precision Q>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec3(A a, tvec2<B, Q> const & b);\r\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\r\n\t\ttemplate <typename A, typename B, precision Q>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR tvec3(tvec1<A, Q> const & a, tvec2<B, Q> const & b);\r\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\r\n\t\ttemplate <typename U, precision Q>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR GLM_EXPLICIT tvec3(tvec4<U, Q> const & v);\r\n\r\n\t\t/// Explicit conversions (From section 5.4.1 Conversion and scalar constructors of GLSL 1.30.08 specification)\r\n\t\ttemplate <typename U, precision Q>\r\n\t\tGLM_FUNC_DECL GLM_CONSTEXPR_CTOR GLM_EXPLICIT tvec3(tvec3<U, Q> const & v);\r\n\r\n\t\t// -- Swizzle constructors --\r\n#\t\tif GLM_HAS_UNRESTRICTED_UNIONS && (GLM_SWIZZLE == GLM_SWIZZLE_ENABLED)\r\n\t\t\ttemplate <int E0, int E1, int E2>\r\n\t\t\tGLM_FUNC_DECL tvec3(detail::_swizzle<3, T, P, glm::tvec3, E0, E1, E2, -1> const & that)\r\n\t\t\t{\r\n\t\t\t\t*this = that();\r\n\t\t\t}\r\n\r\n\t\t\ttemplate <int E0, int E1>\r\n\t\t\tGLM_FUNC_DECL tvec3(detail::_swizzle<2, T, P, glm::tvec2, E0, E1, -1, -2> const & v, T const & scalar)\r\n\t\t\t{\r\n\t\t\t\t*this = tvec3<T, P>(v(), scalar);\r\n\t\t\t}\r\n\r\n\t\t\ttemplate <int E0, int E1>\r\n\t\t\tGLM_FUNC_DECL tvec3(T const & scalar, detail::_swizzle<2, T, P, glm::tvec2, E0, E1, -1, -2> const & v)\r\n\t\t\t{\r\n\t\t\t\t*this = tvec3<T, P>(scalar, v());\r\n\t\t\t}\r\n#\t\tendif// GLM_HAS_UNRESTRICTED_UNIONS && (GLM_SWIZZLE == GLM_SWIZZLE_ENABLED)\r\n\r\n\t\t// -- Unary arithmetic operators --\r\n\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator=(tvec3<T, P> const & v) GLM_DEFAULT;\r\n\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator=(tvec3<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator+=(U scalar);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator+=(tvec1<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator+=(tvec3<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator-=(U scalar);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator-=(tvec1<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator-=(tvec3<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator*=(U scalar);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator*=(tvec1<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator*=(tvec3<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator/=(U scalar);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator/=(tvec1<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator/=(tvec3<U, P> const & v);\r\n\r\n\t\t// -- Increment and decrement operators --\r\n\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator++();\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator--();\r\n\t\tGLM_FUNC_DECL tvec3<T, P> operator++(int);\r\n\t\tGLM_FUNC_DECL tvec3<T, P> operator--(int);\r\n\r\n\t\t// -- Unary bit operators --\r\n\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator%=(U scalar);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator%=(tvec1<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator%=(tvec3<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator&=(U scalar);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator&=(tvec1<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator&=(tvec3<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator|=(U scalar);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator|=(tvec1<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator|=(tvec3<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator^=(U scalar);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator^=(tvec1<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator^=(tvec3<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator<<=(U scalar);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator<<=(tvec1<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator<<=(tvec3<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator>>=(U scalar);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator>>=(tvec1<U, P> const & v);\r\n\t\ttemplate <typename U>\r\n\t\tGLM_FUNC_DECL tvec3<T, P> & operator>>=(tvec3<U, P> const & v);\r\n\t};\r\n\r\n\t// -- Unary operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator+(tvec3<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator-(tvec3<T, P> const & v);\r\n\r\n\t// -- Binary operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator+(tvec3<T, P> const & v, T scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator+(tvec3<T, P> const & v, tvec1<T, P> const & scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator+(T scalar, tvec3<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator+(tvec1<T, P> const & v1, tvec3<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator+(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator-(tvec3<T, P> const & v, T scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator-(tvec3<T, P> const & v1, tvec1<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator-(T scalar, tvec3<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator-(tvec1<T, P> const & v1, tvec3<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator-(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator*(tvec3<T, P> const & v, T scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator*(tvec3<T, P> const & v1, tvec1<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator*(T scalar, tvec3<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator*(tvec1<T, P> const & v1, tvec3<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator*(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator/(tvec3<T, P> const & v, T scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator/(tvec3<T, P> const & v1, tvec1<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator/(T scalar, tvec3<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator/(tvec1<T, P> const & v1, tvec3<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator/(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator%(tvec3<T, P> const & v, T scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator%(tvec3<T, P> const & v1, tvec1<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator%(T const & scalar, tvec3<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator%(tvec1<T, P> const & v1, tvec3<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator%(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator&(tvec3<T, P> const & v1, T scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator&(tvec3<T, P> const & v1, tvec1<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator&(T scalar, tvec3<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator&(tvec1<T, P> const & v1, tvec3<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator&(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator|(tvec3<T, P> const & v, T scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator|(tvec3<T, P> const & v1, tvec1<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator|(T scalar, tvec3<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator|(tvec1<T, P> const & v1, tvec3<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator|(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator^(tvec3<T, P> const & v, T scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator^(tvec3<T, P> const & v1, tvec1<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator^(T scalar, tvec3<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator^(tvec1<T, P> const & v1, tvec3<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator^(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator<<(tvec3<T, P> const & v, T scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator<<(tvec3<T, P> const & v1, tvec1<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator<<(T scalar, tvec3<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator<<(tvec1<T, P> const & v1, tvec3<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator<<(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator>>(tvec3<T, P> const & v, T scalar);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator>>(tvec3<T, P> const & v1, tvec1<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator>>(T scalar, tvec3<T, P> const & v);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator>>(tvec1<T, P> const & v1, tvec3<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL tvec3<T, P> operator>>(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P> \r\n\tGLM_FUNC_DECL tvec3<T, P> operator~(tvec3<T, P> const & v);\r\n\r\n\t// -- Boolean operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL bool operator==(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_DECL bool operator!=(tvec3<T, P> const & v1, tvec3<T, P> const & v2);\r\n\r\n\ttemplate <precision P>\r\n\tGLM_FUNC_DECL tvec3<bool, P> operator&&(tvec3<bool, P> const & v1, tvec3<bool, P> const & v2);\r\n\r\n\ttemplate <precision P>\r\n\tGLM_FUNC_DECL tvec3<bool, P> operator||(tvec3<bool, P> const & v1, tvec3<bool, P> const & v2);\r\n}//namespace glm\r\n\r\n#ifndef GLM_EXTERNAL_TEMPLATE\r\n#include \"type_vec3.inl\"\r\n#endif//GLM_EXTERNAL_TEMPLATE\r\n","/// @ref core\r\n/// @file glm/detail/func_geometric.inl\r\n\r\n#include \"func_exponential.hpp\"\r\n#include \"func_common.hpp\"\r\n#include \"type_vec2.hpp\"\r\n#include \"type_vec4.hpp\"\r\n#include \"type_float.hpp\"\r\n\r\nnamespace glm{\r\nnamespace detail\r\n{\r\n\ttemplate <template <typename, precision> class vecType, typename T, precision P, bool Aligned>\r\n\tstruct compute_length\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static T call(vecType<T, P> const & v)\r\n\t\t{\r\n\t\t\treturn sqrt(dot(v, v));\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <template <typename, precision> class vecType, typename T, precision P, bool Aligned>\r\n\tstruct compute_distance\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static T call(vecType<T, P> const & p0, vecType<T, P> const & p1)\r\n\t\t{\r\n\t\t\treturn length(p1 - p0);\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <template <class, precision> class vecType, typename T, precision P, bool Aligned>\r\n\tstruct compute_dot{};\r\n\r\n\ttemplate <typename T, precision P, bool Aligned>\r\n\tstruct compute_dot<tvec1, T, P, Aligned>\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static T call(tvec1<T, P> const & a, tvec1<T, P> const & b)\r\n\t\t{\r\n\t\t\treturn a.x * b.x;\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P, bool Aligned>\r\n\tstruct compute_dot<tvec2, T, P, Aligned>\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static T call(tvec2<T, P> const & x, tvec2<T, P> const & y)\r\n\t\t{\r\n\t\t\ttvec2<T, P> tmp(x * y);\r\n\t\t\treturn tmp.x + tmp.y;\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P, bool Aligned>\r\n\tstruct compute_dot<tvec3, T, P, Aligned>\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static T call(tvec3<T, P> const & x, tvec3<T, P> const & y)\r\n\t\t{\r\n\t\t\ttvec3<T, P> tmp(x * y);\r\n\t\t\treturn tmp.x + tmp.y + tmp.z;\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P, bool Aligned>\r\n\tstruct compute_dot<tvec4, T, P, Aligned>\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static T call(tvec4<T, P> const & x, tvec4<T, P> const & y)\r\n\t\t{\r\n\t\t\ttvec4<T, P> tmp(x * y);\r\n\t\t\treturn (tmp.x + tmp.y) + (tmp.z + tmp.w);\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P, bool Aligned>\r\n\tstruct compute_cross\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static tvec3<T, P> call(tvec3<T, P> const & x, tvec3<T, P> const & y)\r\n\t\t{\r\n\t\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'cross' accepts only floating-point inputs\");\r\n\r\n\t\t\treturn tvec3<T, P>(\r\n\t\t\t\tx.y * y.z - y.y * x.z,\r\n\t\t\t\tx.z * y.x - y.z * x.x,\r\n\t\t\t\tx.x * y.y - y.x * x.y);\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType, bool Aligned>\r\n\tstruct compute_normalize\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static vecType<T, P> call(vecType<T, P> const & v)\r\n\t\t{\r\n\t\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'normalize' accepts only floating-point inputs\");\r\n\r\n\t\t\treturn v * inversesqrt(dot(v, v));\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType, bool Aligned>\r\n\tstruct compute_faceforward\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static vecType<T, P> call(vecType<T, P> const & N, vecType<T, P> const & I, vecType<T, P> const & Nref)\r\n\t\t{\r\n\t\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'normalize' accepts only floating-point inputs\");\r\n\r\n\t\t\treturn dot(Nref, I) < static_cast<T>(0) ? N : -N;\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType, bool Aligned>\r\n\tstruct compute_reflect\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static vecType<T, P> call(vecType<T, P> const & I, vecType<T, P> const & N)\r\n\t\t{\r\n\t\t\treturn I - N * dot(N, I) * static_cast<T>(2);\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType, bool Aligned>\r\n\tstruct compute_refract\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static vecType<T, P> call(vecType<T, P> const & I, vecType<T, P> const & N, T eta)\r\n\t\t{\r\n\t\t\tT const dotValue(dot(N, I));\r\n\t\t\tT const k(static_cast<T>(1) - eta * eta * (static_cast<T>(1) - dotValue * dotValue));\r\n\t\t\treturn (eta * I - (eta * dotValue + std::sqrt(k)) * N) * static_cast<T>(k >= static_cast<T>(0));\r\n\t\t}\r\n\t};\r\n}//namespace detail\r\n\r\n\t// length\r\n\ttemplate <typename genType>\r\n\tGLM_FUNC_QUALIFIER genType length(genType x)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'length' accepts only floating-point inputs\");\r\n\r\n\t\treturn abs(x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\r\n\tGLM_FUNC_QUALIFIER T length(vecType<T, P> const & v)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'length' accepts only floating-point inputs\");\r\n\r\n\t\treturn detail::compute_length<vecType, T, P, detail::is_aligned<P>::value>::call(v);\r\n\t}\r\n\r\n\t// distance\r\n\ttemplate <typename genType>\r\n\tGLM_FUNC_QUALIFIER genType distance(genType const & p0, genType const & p1)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'distance' accepts only floating-point inputs\");\r\n\r\n\t\treturn length(p1 - p0);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\r\n\tGLM_FUNC_QUALIFIER T distance(vecType<T, P> const & p0, vecType<T, P> const & p1)\r\n\t{\r\n\t\treturn detail::compute_distance<vecType, T, P, detail::is_aligned<P>::value>::call(p0, p1);\r\n\t}\r\n\r\n\t// dot\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER T dot(T x, T y)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'dot' accepts only floating-point inputs\");\r\n\t\treturn x * y;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\r\n\tGLM_FUNC_QUALIFIER T dot(vecType<T, P> const & x, vecType<T, P> const & y)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'dot' accepts only floating-point inputs\");\r\n\t\treturn detail::compute_dot<vecType, T, P, detail::is_aligned<P>::value>::call(x, y);\r\n\t}\r\n\r\n\t// cross\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> cross(tvec3<T, P> const & x, tvec3<T, P> const & y)\r\n\t{\r\n\t\treturn detail::compute_cross<T, P, detail::is_aligned<P>::value>::call(x, y);\r\n\t}\r\n\r\n\t// normalize\r\n\ttemplate <typename genType>\r\n\tGLM_FUNC_QUALIFIER genType normalize(genType const & x)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'normalize' accepts only floating-point inputs\");\r\n\r\n\t\treturn x < genType(0) ? genType(-1) : genType(1);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\r\n\tGLM_FUNC_QUALIFIER vecType<T, P> normalize(vecType<T, P> const & x)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'normalize' accepts only floating-point inputs\");\r\n\r\n\t\treturn detail::compute_normalize<T, P, vecType, detail::is_aligned<P>::value>::call(x);\r\n\t}\r\n\r\n\t// faceforward\r\n\ttemplate <typename genType>\r\n\tGLM_FUNC_QUALIFIER genType faceforward(genType const & N, genType const & I, genType const & Nref)\r\n\t{\r\n\t\treturn dot(Nref, I) < static_cast<genType>(0) ? N : -N;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\r\n\tGLM_FUNC_QUALIFIER vecType<T, P> faceforward(vecType<T, P> const & N, vecType<T, P> const & I, vecType<T, P> const & Nref)\r\n\t{\r\n\t\treturn detail::compute_faceforward<T, P, vecType, detail::is_aligned<P>::value>::call(N, I, Nref);\r\n\t}\r\n\r\n\t// reflect\r\n\ttemplate <typename genType>\r\n\tGLM_FUNC_QUALIFIER genType reflect(genType const & I, genType const & N)\r\n\t{\r\n\t\treturn I - N * dot(N, I) * genType(2);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\r\n\tGLM_FUNC_QUALIFIER vecType<T, P> reflect(vecType<T, P> const & I, vecType<T, P> const & N)\r\n\t{\r\n\t\treturn detail::compute_reflect<T, P, vecType, detail::is_aligned<P>::value>::call(I, N);\r\n\t}\r\n\r\n\t// refract\r\n\ttemplate <typename genType>\r\n\tGLM_FUNC_QUALIFIER genType refract(genType const & I, genType const & N, genType eta)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'refract' accepts only floating-point inputs\");\r\n\t\tgenType const dotValue(dot(N, I));\r\n\t\tgenType const k(static_cast<genType>(1) - eta * eta * (static_cast<genType>(1) - dotValue * dotValue));\r\n\t\treturn (eta * I - (eta * dotValue + sqrt(k)) * N) * static_cast<genType>(k >= static_cast<genType>(0));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\r\n\tGLM_FUNC_QUALIFIER vecType<T, P> refract(vecType<T, P> const & I, vecType<T, P> const & N, T eta)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'refract' accepts only floating-point inputs\");\r\n\t\treturn detail::compute_refract<T, P, vecType, detail::is_aligned<P>::value>::call(I, N, eta);\r\n\t}\r\n}//namespace glm\r\n\r\n#if GLM_ARCH != GLM_ARCH_PURE && GLM_HAS_UNRESTRICTED_UNIONS\r\n#\tinclude \"func_geometric_simd.inl\"\r\n#endif\r\n","/// @ref core\r\n/// @file glm/detail/func_exponential.inl\r\n\r\n#include \"func_vector_relational.hpp\"\r\n#include \"_vectorize.hpp\"\r\n#include <limits>\r\n#include <cmath>\r\n#include <cassert>\r\n\r\nnamespace glm{\r\nnamespace detail\r\n{\r\n#\tif GLM_HAS_CXX11_STL\r\n\t\tusing std::log2;\r\n#\telse\r\n\t\ttemplate <typename genType>\r\n\t\tgenType log2(genType Value)\r\n\t\t{\r\n\t\t\treturn std::log(Value) * static_cast<genType>(1.4426950408889634073599246810019);\r\n\t\t}\r\n#\tendif\r\n\r\n\ttemplate <typename T, precision P, template <class, precision> class vecType, bool isFloat, bool Aligned>\r\n\tstruct compute_log2\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static vecType<T, P> call(vecType<T, P> const & vec)\r\n\t\t{\r\n\t\t\treturn detail::functor1<T, T, P, vecType>::call(log2, vec);\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <template <class, precision> class vecType, typename T, precision P, bool Aligned>\r\n\tstruct compute_sqrt\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static vecType<T, P> call(vecType<T, P> const & x)\r\n\t\t{\r\n\t\t\treturn detail::functor1<T, T, P, vecType>::call(std::sqrt, x);\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <template <class, precision> class vecType, typename T, precision P, bool Aligned>\r\n\tstruct compute_inversesqrt\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static vecType<T, P> call(vecType<T, P> const & x)\r\n\t\t{\r\n\t\t\treturn static_cast<T>(1) / sqrt(x);\r\n\t\t}\r\n\t};\r\n\t\t\r\n\ttemplate <template <class, precision> class vecType, bool Aligned>\r\n\tstruct compute_inversesqrt<vecType, float, lowp, Aligned>\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static vecType<float, lowp> call(vecType<float, lowp> const & x)\r\n\t\t{\r\n\t\t\tvecType<float, lowp> tmp(x);\r\n\t\t\tvecType<float, lowp> xhalf(tmp * 0.5f);\r\n\t\t\tvecType<uint, lowp>* p = reinterpret_cast<vecType<uint, lowp>*>(const_cast<vecType<float, lowp>*>(&x));\r\n\t\t\tvecType<uint, lowp> i = vecType<uint, lowp>(0x5f375a86) - (*p >> vecType<uint, lowp>(1));\r\n\t\t\tvecType<float, lowp>* ptmp = reinterpret_cast<vecType<float, lowp>*>(&i);\r\n\t\t\ttmp = *ptmp;\r\n\t\t\ttmp = tmp * (1.5f - xhalf * tmp * tmp);\r\n\t\t\treturn tmp;\r\n\t\t}\r\n\t};\r\n}//namespace detail\r\n\r\n\t// pow\r\n\tusing std::pow;\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\r\n\tGLM_FUNC_QUALIFIER vecType<T, P> pow(vecType<T, P> const & base, vecType<T, P> const & exponent)\r\n\t{\r\n\t\treturn detail::functor2<T, P, vecType>::call(pow, base, exponent);\r\n\t}\r\n\r\n\t// exp\r\n\tusing std::exp;\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\r\n\tGLM_FUNC_QUALIFIER vecType<T, P> exp(vecType<T, P> const & x)\r\n\t{\r\n\t\treturn detail::functor1<T, T, P, vecType>::call(exp, x);\r\n\t}\r\n\r\n\t// log\r\n\tusing std::log;\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\r\n\tGLM_FUNC_QUALIFIER vecType<T, P> log(vecType<T, P> const & x)\r\n\t{\r\n\t\treturn detail::functor1<T, T, P, vecType>::call(log, x);\r\n\t}\r\n\r\n\t//exp2, ln2 = 0.69314718055994530941723212145818f\r\n\ttemplate <typename genType>\r\n\tGLM_FUNC_QUALIFIER genType exp2(genType x)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'exp2' only accept floating-point inputs\");\r\n\r\n\t\treturn std::exp(static_cast<genType>(0.69314718055994530941723212145818) * x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\r\n\tGLM_FUNC_QUALIFIER vecType<T, P> exp2(vecType<T, P> const & x)\r\n\t{\r\n\t\treturn detail::functor1<T, T, P, vecType>::call(exp2, x);\r\n\t}\r\n\r\n\t// log2, ln2 = 0.69314718055994530941723212145818f\r\n\ttemplate <typename genType>\r\n\tGLM_FUNC_QUALIFIER genType log2(genType x)\r\n\t{\r\n\t\treturn log2(tvec1<genType>(x)).x;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\r\n\tGLM_FUNC_QUALIFIER vecType<T, P> log2(vecType<T, P> const & x)\r\n\t{\r\n\t\treturn detail::compute_log2<T, P, vecType, std::numeric_limits<T>::is_iec559, detail::is_aligned<P>::value>::call(x);\r\n\t}\r\n\r\n\t// sqrt\r\n\tusing std::sqrt;\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\r\n\tGLM_FUNC_QUALIFIER vecType<T, P> sqrt(vecType<T, P> const & x)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'sqrt' only accept floating-point inputs\");\r\n\t\treturn detail::compute_sqrt<vecType, T, P, detail::is_aligned<P>::value>::call(x);\r\n\t}\r\n\r\n\t// inversesqrt\r\n\ttemplate <typename genType>\r\n\tGLM_FUNC_QUALIFIER genType inversesqrt(genType x)\r\n\t{\r\n\t\treturn static_cast<genType>(1) / sqrt(x);\r\n\t}\r\n\t\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\r\n\tGLM_FUNC_QUALIFIER vecType<T, P> inversesqrt(vecType<T, P> const & x)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'inversesqrt' only accept floating-point inputs\");\r\n\t\treturn detail::compute_inversesqrt<vecType, T, P, detail::is_aligned<P>::value>::call(x);\r\n\t}\r\n}//namespace glm\r\n\r\n#if GLM_ARCH != GLM_ARCH_PURE && GLM_HAS_UNRESTRICTED_UNIONS\r\n#\tinclude \"func_exponential_simd.inl\"\r\n#endif\r\n\r\n","// -*- C++ -*-\n//===--------------------------- stdexcept --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STDEXCEPT\n#define _LIBCPP_STDEXCEPT\n\n/*\n    stdexcept synopsis\n\nnamespace std\n{\n\nclass logic_error;\n    class domain_error;\n    class invalid_argument;\n    class length_error;\n    class out_of_range;\nclass runtime_error;\n    class range_error;\n    class overflow_error;\n    class underflow_error;\n\nfor each class xxx_error:\n\nclass xxx_error : public exception // at least indirectly\n{\npublic:\n    explicit xxx_error(const string& what_arg);\n    explicit xxx_error(const char*   what_arg);\n\n    virtual const char* what() const noexcept // returns what_arg\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <iosfwd>  // for string forward decl\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_HIDDEN __libcpp_refstring\n{\n    const char* __imp_;\n\n    bool __uses_refcount() const;\npublic:\n    explicit __libcpp_refstring(const char* msg);\n    __libcpp_refstring(const __libcpp_refstring& s) _NOEXCEPT;\n    __libcpp_refstring& operator=(const __libcpp_refstring& s) _NOEXCEPT;\n    ~__libcpp_refstring();\n\n    const char* c_str() const _NOEXCEPT {return __imp_;}\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI logic_error\n    : public exception\n{\nprivate:\n    _VSTD::__libcpp_refstring __imp_;\npublic:\n    explicit logic_error(const string&);\n    explicit logic_error(const char*);\n\n    logic_error(const logic_error&) _NOEXCEPT;\n    logic_error& operator=(const logic_error&) _NOEXCEPT;\n\n    virtual ~logic_error() _NOEXCEPT;\n\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI runtime_error\n    : public exception\n{\nprivate:\n    _VSTD::__libcpp_refstring __imp_;\npublic:\n    explicit runtime_error(const string&);\n    explicit runtime_error(const char*);\n\n    runtime_error(const runtime_error&) _NOEXCEPT;\n    runtime_error& operator=(const runtime_error&) _NOEXCEPT;\n\n    virtual ~runtime_error() _NOEXCEPT;\n\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI domain_error\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const char* __s)   : logic_error(__s) {}\n\n    virtual ~domain_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI invalid_argument\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const char* __s)   : logic_error(__s) {}\n\n    virtual ~invalid_argument() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI length_error\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit length_error(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit length_error(const char* __s)   : logic_error(__s) {}\n\n    virtual ~length_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI out_of_range\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const char* __s)   : logic_error(__s) {}\n\n    virtual ~out_of_range() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI range_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit range_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit range_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~range_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI overflow_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~overflow_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI underflow_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~underflow_error() _NOEXCEPT;\n};\n\n}  // std\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// in the dylib\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_logic_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw logic_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_domain_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw domain_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_invalid_argument(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw invalid_argument(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_length_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_out_of_range(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_range_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw range_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_overflow_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw overflow_error(__msg);\n#else\n    ((void)__msg);\n    _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_underflow_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw underflow_error(__msg);\n#else\n    ((void)__msg);\n    _VSTD::abort();\n#endif\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STDEXCEPT\n","// -*- C++ -*-\n//===--------------------------- tuple ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TUPLE\n#define _LIBCPP_TUPLE\n\n/*\n    tuple synopsis\n\nnamespace std\n{\n\ntemplate <class... T>\nclass tuple {\npublic:\n    constexpr tuple();\n    explicit tuple(const T&...);  // constexpr in C++14\n    template <class... U>\n        explicit tuple(U&&...);  // constexpr in C++14\n    tuple(const tuple&) = default;\n    tuple(tuple&&) = default;\n    template <class... U>\n        tuple(const tuple<U...>&);  // constexpr in C++14\n    template <class... U>\n        tuple(tuple<U...>&&);  // constexpr in C++14\n    template <class U1, class U2>\n        tuple(const pair<U1, U2>&); // iff sizeof...(T) == 2 // constexpr in C++14\n    template <class U1, class U2>\n        tuple(pair<U1, U2>&&); // iff sizeof...(T) == 2  // constexpr in C++14\n\n    // allocator-extended constructors\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, const T&...);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, U&&...);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, const tuple&);\n    template <class Alloc>\n        tuple(allocator_arg_t, const Alloc& a, tuple&&);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, const tuple<U...>&);\n    template <class Alloc, class... U>\n        tuple(allocator_arg_t, const Alloc& a, tuple<U...>&&);\n    template <class Alloc, class U1, class U2>\n        tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);\n    template <class Alloc, class U1, class U2>\n        tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);\n\n    tuple& operator=(const tuple&);\n    tuple&\n        operator=(tuple&&) noexcept(AND(is_nothrow_move_assignable<T>::value ...));\n    template <class... U>\n        tuple& operator=(const tuple<U...>&);\n    template <class... U>\n        tuple& operator=(tuple<U...>&&);\n    template <class U1, class U2>\n        tuple& operator=(const pair<U1, U2>&); // iff sizeof...(T) == 2\n    template <class U1, class U2>\n        tuple& operator=(pair<U1, U2>&&); //iffsizeof...(T) == 2\n\n    void swap(tuple&) noexcept(AND(swap(declval<T&>(), declval<T&>())...));\n};\n\nconst unspecified ignore;\n\ntemplate <class... T> tuple<V...>  make_tuple(T&&...); // constexpr in C++14\ntemplate <class... T> tuple<ATypes...> forward_as_tuple(T&&...) noexcept; // constexpr in C++14\ntemplate <class... T> tuple<T&...> tie(T&...) noexcept; // constexpr in C++14\ntemplate <class... Tuples> tuple<CTypes...> tuple_cat(Tuples&&... tpls); // constexpr in C++14\n\n// [tuple.apply], calling a function with a tuple of arguments:\ntemplate <class F, class Tuple>\n  constexpr decltype(auto) apply(F&& f, Tuple&& t); // C++17\ntemplate <class T, class Tuple>\n  constexpr T make_from_tuple(Tuple&& t); // C++17\n\n// 20.4.1.4, tuple helper classes:\ntemplate <class T> class tuple_size; // undefined\ntemplate <class... T> class tuple_size<tuple<T...>>;\ntemplate <class T>\n constexpr size_t tuple_size_v = tuple_size<T>::value; // C++17\ntemplate <size_t I, class T> class tuple_element; // undefined\ntemplate <size_t I, class... T> class tuple_element<I, tuple<T...>>;\ntemplate <size_t I, class T>\n  using tuple_element_t = typename tuple_element <I, T>::type; // C++14\n\n// 20.4.1.5, element access:\ntemplate <size_t I, class... T>\n    typename tuple_element<I, tuple<T...>>::type&\n    get(tuple<T...>&) noexcept; // constexpr in C++14\ntemplate <size_t I, class... T>\n    const typename tuple_element<I, tuple<T...>>::type&\n    get(const tuple<T...>&) noexcept; // constexpr in C++14\ntemplate <size_t I, class... T>\n    typename tuple_element<I, tuple<T...>>::type&&\n    get(tuple<T...>&&) noexcept; // constexpr in C++14\ntemplate <size_t I, class... T>\n    const typename tuple_element<I, tuple<T...>>::type&&\n    get(const tuple<T...>&&) noexcept; // constexpr in C++14\n\ntemplate <class T1, class... T>\n    constexpr T1& get(tuple<T...>&) noexcept;  // C++14\ntemplate <class T1, class... T>\n    constexpr const T1& get(const tuple<T...>&) noexcept;   // C++14\ntemplate <class T1, class... T>\n    constexpr T1&& get(tuple<T...>&&) noexcept;   // C++14\ntemplate <class T1, class... T>\n    constexpr const T1&& get(const tuple<T...>&&) noexcept;   // C++14\n\n// 20.4.1.6, relational operators:\ntemplate<class... T, class... U> bool operator==(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator<(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14\ntemplate<class... T, class... U> bool operator!=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator>(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14\ntemplate<class... T, class... U> bool operator<=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\ntemplate<class... T, class... U> bool operator>=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14\n\ntemplate <class... Types, class Alloc>\n  struct uses_allocator<tuple<Types...>, Alloc>;\n\ntemplate <class... Types>\n  void\n  swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <cstddef>\n#include <type_traits>\n#include <__functional_base>\n#include <utility>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n\n// __tuple_leaf\n\ntemplate <size_t _Ip, class _Hp,\n          bool=is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value\n         >\nclass __tuple_leaf;\n\ntemplate <size_t _Ip, class _Hp, bool _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)\n    _NOEXCEPT_(__is_nothrow_swappable<_Hp>::value)\n{\n    swap(__x.get(), __y.get());\n}\n\ntemplate <size_t _Ip, class _Hp, bool>\nclass __tuple_leaf\n{\n    _Hp value;\n\n    template <class _Tp>\n    static constexpr bool __can_bind_reference() {\n        using _RawTp = typename remove_reference<_Tp>::type;\n        using _RawHp = typename remove_reference<_Hp>::type;\n        using _CheckLValueArg = integral_constant<bool,\n            is_lvalue_reference<_Tp>::value\n        ||  is_same<_RawTp, reference_wrapper<_RawHp>>::value\n        ||  is_same<_RawTp, reference_wrapper<typename remove_const<_RawHp>::type>>::value\n        >;\n        return  !is_reference<_Hp>::value\n            || (is_lvalue_reference<_Hp>::value && _CheckLValueArg::value)\n            || (is_rvalue_reference<_Hp>::value && !is_lvalue_reference<_Tp>::value);\n    }\n\n    __tuple_leaf& operator=(const __tuple_leaf&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()\n             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) : value()\n       {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 0>, const _Alloc&)\n            : value()\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)\n            : value(allocator_arg_t(), __a)\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)\n            : value(__a)\n        {static_assert(!is_reference<_Hp>::value,\n              \"Attempted to default construct a reference element in a tuple\");}\n\n    template <class _Tp,\n              class = typename enable_if<\n                  __lazy_and<\n                      __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>\n                    , is_constructible<_Hp, _Tp>\n                    >::value\n                >::type\n            >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))\n            : value(_VSTD::forward<_Tp>(__t))\n        {static_assert(__can_bind_reference<_Tp>(),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)\n            : value(_VSTD::forward<_Tp>(__t))\n        {static_assert(__can_bind_reference<_Tp>(),\n       \"Attempted to construct a reference element in a tuple with an rvalue\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)\n            : value(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t))\n        {static_assert(!is_reference<_Hp>::value,\n            \"Attempted to uses-allocator construct a reference element in a tuple\");}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)\n            : value(_VSTD::forward<_Tp>(__t), __a)\n        {static_assert(!is_reference<_Hp>::value,\n           \"Attempted to uses-allocator construct a reference element in a tuple\");}\n\n    __tuple_leaf(const __tuple_leaf& __t) = default;\n    __tuple_leaf(__tuple_leaf&& __t) = default;\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf&\n        operator=(_Tp&& __t) _NOEXCEPT_((is_nothrow_assignable<_Hp&, _Tp>::value))\n        {\n            value = _VSTD::forward<_Tp>(__t);\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)\n    {\n        _VSTD::swap(*this, __t);\n        return 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11       _Hp& get()       _NOEXCEPT {return value;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Hp& get() const _NOEXCEPT {return value;}\n};\n\ntemplate <size_t _Ip, class _Hp>\nclass __tuple_leaf<_Ip, _Hp, true>\n    : private _Hp\n{\n\n    __tuple_leaf& operator=(const __tuple_leaf&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()\n             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)\n            : _Hp(allocator_arg_t(), __a) {}\n\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)\n            : _Hp(__a) {}\n\n    template <class _Tp,\n              class = typename enable_if<\n                  __lazy_and<\n                        __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>\n                      , is_constructible<_Hp, _Tp>\n                    >::value\n                >::type\n            >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))\n            : _Hp(_VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)\n            : _Hp(_VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)\n            : _Hp(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t)) {}\n\n    template <class _Tp, class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)\n            : _Hp(_VSTD::forward<_Tp>(__t), __a) {}\n\n    __tuple_leaf(__tuple_leaf const &) = default;\n    __tuple_leaf(__tuple_leaf &&) = default;\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_leaf&\n        operator=(_Tp&& __t) _NOEXCEPT_((is_nothrow_assignable<_Hp&, _Tp>::value))\n        {\n            _Hp::operator=(_VSTD::forward<_Tp>(__t));\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    int\n    swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)\n    {\n        _VSTD::swap(*this, __t);\n        return 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11       _Hp& get()       _NOEXCEPT {return static_cast<_Hp&>(*this);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Hp& get() const _NOEXCEPT {return static_cast<const _Hp&>(*this);}\n};\n\ntemplate <class ..._Tp>\n_LIBCPP_INLINE_VISIBILITY\nvoid __swallow(_Tp&&...) _NOEXCEPT {}\n\ntemplate <class ..._Tp>\nstruct __lazy_all : __all<_Tp::value...> {};\n\ntemplate <class _Tp>\nstruct __all_default_constructible;\n\ntemplate <class ..._Tp>\nstruct __all_default_constructible<__tuple_types<_Tp...>>\n    : __all<is_default_constructible<_Tp>::value...>\n{ };\n\n// __tuple_impl\n\ntemplate<class _Indx, class ..._Tp> struct __tuple_impl;\n\ntemplate<size_t ..._Indx, class ..._Tp>\nstruct __tuple_impl<__tuple_indices<_Indx...>, _Tp...>\n    : public __tuple_leaf<_Indx, _Tp>...\n{\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR __tuple_impl()\n        _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}\n\n    template <size_t ..._Uf, class ..._Tf,\n              size_t ..._Ul, class ..._Tl, class ..._Up>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        __tuple_impl(__tuple_indices<_Uf...>, __tuple_types<_Tf...>,\n                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,\n                     _Up&&... __u)\n                     _NOEXCEPT_((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value &&\n                                 __all<is_nothrow_default_constructible<_Tl>::value...>::value)) :\n            __tuple_leaf<_Uf, _Tf>(_VSTD::forward<_Up>(__u))...,\n            __tuple_leaf<_Ul, _Tl>()...\n            {}\n\n    template <class _Alloc, size_t ..._Uf, class ..._Tf,\n              size_t ..._Ul, class ..._Tl, class ..._Up>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit\n        __tuple_impl(allocator_arg_t, const _Alloc& __a,\n                     __tuple_indices<_Uf...>, __tuple_types<_Tf...>,\n                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,\n                     _Up&&... __u) :\n            __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,\n            _VSTD::forward<_Up>(__u))...,\n            __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)...\n            {}\n\n    template <class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        __tuple_impl(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))\n            : __tuple_leaf<_Indx, _Tp>(_VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...\n            {}\n\n    template <class _Alloc, class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(), __a,\n                                       _VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...\n            {}\n\n    template <class _Tuple>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            __tuple_assignable<_Tuple, tuple<_Tp...> >::value,\n            __tuple_impl&\n        >::type\n        operator=(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_assignable<_Tp&, typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))\n        {\n            __swallow(__tuple_leaf<_Indx, _Tp>::operator=(_VSTD::forward<typename tuple_element<_Indx,\n                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...);\n            return *this;\n        }\n\n    __tuple_impl(const __tuple_impl&) = default;\n    __tuple_impl(__tuple_impl&&) = default;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tuple_impl&\n    operator=(const __tuple_impl& __t) _NOEXCEPT_((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t).get())...);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tuple_impl&\n    operator=(__tuple_impl&& __t) _NOEXCEPT_((__all<is_nothrow_move_assignable<_Tp>::value...>::value))\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(_VSTD::forward<_Tp>(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t).get()))...);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(__tuple_impl& __t)\n        _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n    {\n        __swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);\n    }\n};\n\n\n\ntemplate <class ..._Tp>\nclass _LIBCPP_TEMPLATE_VIS tuple\n{\n    typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> base;\n\n    base base_;\n\n#if defined(_LIBCPP_ENABLE_TUPLE_IMPLICIT_REDUCED_ARITY_EXTENSION)\n    static constexpr bool _EnableImplicitReducedArityExtension = true;\n#else\n    static constexpr bool _EnableImplicitReducedArityExtension = false;\n#endif\n\n    template <class ..._Args>\n    struct _PackExpandsToThisTuple : false_type {};\n\n    template <class _Arg>\n    struct _PackExpandsToThisTuple<_Arg>\n        : is_same<typename __uncvref<_Arg>::type, tuple> {};\n\n    template <bool _MaybeEnable, class _Dummy = void>\n    struct _CheckArgsConstructor : __check_tuple_constructor_fail {};\n\n    template <class _Dummy>\n    struct _CheckArgsConstructor<true, _Dummy>\n    {\n        template <class ..._Args>\n        static constexpr bool __enable_default() {\n            return __all<is_default_constructible<_Args>::value...>::value;\n        }\n\n        template <class ..._Args>\n        static constexpr bool __enable_explicit() {\n            return\n                __tuple_constructible<\n                    tuple<_Args...>,\n                    typename __make_tuple_types<tuple,\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value &&\n                !__tuple_convertible<\n                    tuple<_Args...>,\n                    typename __make_tuple_types<tuple,\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value &&\n                __all_default_constructible<\n                    typename __make_tuple_types<tuple, sizeof...(_Tp),\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value;\n        }\n\n        template <class ..._Args>\n        static constexpr bool __enable_implicit() {\n            return\n                __tuple_convertible<\n                    tuple<_Args...>,\n                    typename __make_tuple_types<tuple,\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value &&\n                __all_default_constructible<\n                    typename __make_tuple_types<tuple, sizeof...(_Tp),\n                             sizeof...(_Args) < sizeof...(_Tp) ?\n                                 sizeof...(_Args) :\n                                 sizeof...(_Tp)>::type\n                >::value;\n        }\n    };\n\n    template <bool _MaybeEnable,\n              bool = sizeof...(_Tp) == 1,\n              class _Dummy = void>\n    struct _CheckTupleLikeConstructor : __check_tuple_constructor_fail {};\n\n    template <class _Dummy>\n    struct _CheckTupleLikeConstructor<true, false, _Dummy>\n    {\n        template <class _Tuple>\n        static constexpr bool __enable_implicit() {\n            return __tuple_convertible<_Tuple, tuple>::value;\n        }\n\n        template <class _Tuple>\n        static constexpr bool __enable_explicit() {\n            return __tuple_constructible<_Tuple, tuple>::value\n               && !__tuple_convertible<_Tuple, tuple>::value;\n        }\n    };\n\n    template <class _Dummy>\n    struct _CheckTupleLikeConstructor<true, true, _Dummy>\n    {\n        // This trait is used to disable the tuple-like constructor when\n        // the UTypes... constructor should be selected instead.\n        // See LWG issue #2549.\n        template <class _Tuple>\n        using _PreferTupleLikeConstructor = __lazy_or<\n            // Don't attempt the two checks below if the tuple we are given\n            // has the same type as this tuple.\n            is_same<typename __uncvref<_Tuple>::type, tuple>,\n            __lazy_and<\n                __lazy_not<is_constructible<_Tp..., _Tuple>>,\n                __lazy_not<is_convertible<_Tuple, _Tp...>>\n            >\n        >;\n\n        template <class _Tuple>\n        static constexpr bool __enable_implicit() {\n            return __lazy_and<\n                __tuple_convertible<_Tuple, tuple>,\n                _PreferTupleLikeConstructor<_Tuple>\n            >::value;\n        }\n\n        template <class _Tuple>\n        static constexpr bool __enable_explicit() {\n            return __lazy_and<\n                __tuple_constructible<_Tuple, tuple>,\n                _PreferTupleLikeConstructor<_Tuple>,\n                __lazy_not<__tuple_convertible<_Tuple, tuple>>\n            >::value;\n        }\n    };\n\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) _NOEXCEPT;\n    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11\n        const typename tuple_element<_Jp, tuple<_Up...> >::type&& get(const tuple<_Up...>&&) _NOEXCEPT;\npublic:\n\n    template <bool _Dummy = true, class = typename enable_if<\n        _CheckArgsConstructor<_Dummy>::template __enable_default<_Tp...>()\n    >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR tuple()\n        _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}\n\n    tuple(tuple const&) = default;\n    tuple(tuple&&) = default;\n\n    template <class _AllocArgT, class _Alloc, bool _Dummy = true, class = typename enable_if<\n        __lazy_and<\n            is_same<allocator_arg_t, _AllocArgT>,\n            __lazy_all<__dependent_type<is_default_constructible<_Tp>, _Dummy>...>\n       >::value\n    >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    tuple(_AllocArgT, _Alloc const& __a)\n      : base_(allocator_arg_t(), __a,\n                    __tuple_indices<>(), __tuple_types<>(),\n                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),\n                    __tuple_types<_Tp...>()) {}\n\n    template <bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_implicit<_Tp const&...>(),\n                         bool\n                      >::type = false\n        >\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    tuple(const _Tp& ... __t) _NOEXCEPT_((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))\n        : base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_explicit<_Tp const&...>(),\n                         bool\n                      >::type = false\n        >\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit tuple(const _Tp& ... __t) _NOEXCEPT_((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))\n        : base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class _Alloc, bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_implicit<_Tp const&...>(),\n                         bool\n                      >::type = false\n        >\n      _LIBCPP_INLINE_VISIBILITY\n      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)\n        : base_(allocator_arg_t(), __a,\n                typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class _Alloc, bool _Dummy = true,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                            _Dummy\n                         >::template __enable_explicit<_Tp const&...>(),\n                         bool\n                      >::type = false\n        >\n      _LIBCPP_INLINE_VISIBILITY\n      explicit\n      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)\n        : base_(allocator_arg_t(), __a,\n                typename __make_tuple_indices<sizeof...(_Tp)>::type(),\n                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),\n                typename __make_tuple_indices<0>::type(),\n                typename __make_tuple_types<tuple, 0>::type(),\n                __t...\n               ) {}\n\n    template <class ..._Up,\n              bool _PackIsTuple = _PackExpandsToThisTuple<_Up...>::value,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) == sizeof...(_Tp)\n                             && !_PackIsTuple\n                         >::template __enable_implicit<_Up...>() ||\n                        _CheckArgsConstructor<\n                            _EnableImplicitReducedArityExtension\n                            && sizeof...(_Up) < sizeof...(_Tp)\n                            && !_PackIsTuple\n                         >::template __enable_implicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        tuple(_Up&&... __u)\n            _NOEXCEPT_((\n                is_nothrow_constructible<base,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type,\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type,\n                    _Up...\n                >::value\n            ))\n            : base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class ..._Up,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) <= sizeof...(_Tp)\n                             && !_PackExpandsToThisTuple<_Up...>::value\n                         >::template __enable_explicit<_Up...>() ||\n                         _CheckArgsConstructor<\n                            !_EnableImplicitReducedArityExtension\n                            && sizeof...(_Up) < sizeof...(_Tp)\n                            && !_PackExpandsToThisTuple<_Up...>()\n                         >::template __enable_implicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        tuple(_Up&&... __u)\n            _NOEXCEPT_((\n                is_nothrow_constructible<base,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type,\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type,\n                    _Up...\n                >::value\n            ))\n            : base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Alloc, class ..._Up,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) == sizeof...(_Tp) &&\n                             !_PackExpandsToThisTuple<_Up...>::value\n                         >::template __enable_implicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)\n            : base_(allocator_arg_t(), __a,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Alloc, class ..._Up,\n              typename enable_if\n                      <\n                         _CheckArgsConstructor<\n                             sizeof...(_Up) == sizeof...(_Tp) &&\n                             !_PackExpandsToThisTuple<_Up...>::value\n                         >::template __enable_explicit<_Up...>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        explicit\n        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)\n            : base_(allocator_arg_t(), __a,\n                    typename __make_tuple_indices<sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),\n                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),\n                    _VSTD::forward<_Up>(__u)...) {}\n\n    template <class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                             && !_PackExpandsToThisTuple<_Tuple>::value\n                         >::template __enable_implicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        tuple(_Tuple&& __t) _NOEXCEPT_((is_nothrow_constructible<base, _Tuple>::value))\n            : base_(_VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                             && !_PackExpandsToThisTuple<_Tuple>::value\n                         >::template __enable_explicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        explicit\n        tuple(_Tuple&& __t) _NOEXCEPT_((is_nothrow_constructible<base, _Tuple>::value))\n            : base_(_VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Alloc, class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                         >::template __enable_implicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : base_(allocator_arg_t(), __a, _VSTD::forward<_Tuple>(__t)) {}\n\n    template <class _Alloc, class _Tuple,\n              typename enable_if\n                      <\n                         _CheckTupleLikeConstructor<\n                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value\n                         >::template __enable_explicit<_Tuple>(),\n                         bool\n                      >::type = false\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        explicit\n        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)\n            : base_(allocator_arg_t(), __a, _VSTD::forward<_Tuple>(__t)) {}\n\n    using _CanCopyAssign = __all<is_copy_assignable<_Tp>::value...>;\n    using _CanMoveAssign = __all<is_move_assignable<_Tp>::value...>;\n\n    _LIBCPP_INLINE_VISIBILITY\n    tuple& operator=(typename conditional<_CanCopyAssign::value, tuple, __nat>::type const& __t)\n        _NOEXCEPT_((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))\n    {\n        base_.operator=(__t.base_);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    tuple& operator=(typename conditional<_CanMoveAssign::value, tuple, __nat>::type&& __t)\n        _NOEXCEPT_((__all<is_nothrow_move_assignable<_Tp>::value...>::value))\n    {\n        base_.operator=(static_cast<base&&>(__t.base_));\n        return *this;\n    }\n\n    template <class _Tuple,\n              class = typename enable_if\n                      <\n                         __tuple_assignable<_Tuple, tuple>::value\n                      >::type\n             >\n        _LIBCPP_INLINE_VISIBILITY\n        tuple&\n        operator=(_Tuple&& __t) _NOEXCEPT_((is_nothrow_assignable<base&, _Tuple>::value))\n        {\n            base_.operator=(_VSTD::forward<_Tuple>(__t));\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(tuple& __t) _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n        {base_.swap(__t.base_);}\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS tuple<>\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR tuple() _NOEXCEPT {}\n    template <class _Alloc>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT {}\n    template <class _Alloc>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT {}\n    template <class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(array<_Up, 0>) _NOEXCEPT {}\n    template <class _Alloc, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(tuple&) _NOEXCEPT {}\n};\n\ntemplate <class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __all<__is_swappable<_Tp>::value...>::value,\n    void\n>::type\nswap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)\n                 _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)\n    {__t.swap(__u);}\n\n// get\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, tuple<_Tp...> >::type&\nget(tuple<_Tp...>& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<__tuple_leaf<_Ip, type>&>(__t.base_).get();\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, tuple<_Tp...> >::type&\nget(const tuple<_Tp...>& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<const __tuple_leaf<_Ip, type>&>(__t.base_).get();\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, tuple<_Tp...> >::type&&\nget(tuple<_Tp...>&& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<type&&>(\n             static_cast<__tuple_leaf<_Ip, type>&&>(__t.base_).get());\n}\n\ntemplate <size_t _Ip, class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, tuple<_Tp...> >::type&&\nget(const tuple<_Tp...>&& __t) _NOEXCEPT\n{\n    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;\n    return static_cast<const type&&>(\n             static_cast<const __tuple_leaf<_Ip, type>&&>(__t.base_).get());\n}\n\n#if _LIBCPP_STD_VER > 11\n\nnamespace __find_detail {\n\nstatic constexpr size_t __not_found = -1;\nstatic constexpr size_t __ambiguous = __not_found - 1;\n\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr size_t __find_idx_return(size_t __curr_i, size_t __res, bool __matches) {\n    return !__matches ? __res :\n        (__res == __not_found ? __curr_i : __ambiguous);\n}\n\ntemplate <size_t _Nx>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr size_t __find_idx(size_t __i, const bool (&__matches)[_Nx]) {\n  return __i == _Nx ? __not_found :\n      __find_idx_return(__i, __find_idx(__i + 1, __matches), __matches[__i]);\n}\n\ntemplate <class _T1, class ..._Args>\nstruct __find_exactly_one_checked {\n  static constexpr bool __matches[] = {is_same<_T1, _Args>::value...};\n    static constexpr size_t value = __find_detail::__find_idx(0, __matches);\n    static_assert (value != __not_found, \"type not found in type list\" );\n    static_assert(value != __ambiguous,\"type occurs more than once in type list\");\n};\n\ntemplate <class _T1>\nstruct __find_exactly_one_checked<_T1> {\n    static_assert(!is_same<_T1, _T1>::value, \"type not in empty type list\");\n};\n\n} // namespace __find_detail;\n\ntemplate <typename _T1, typename... _Args>\nstruct __find_exactly_one_t\n    : public __find_detail::__find_exactly_one_checked<_T1, _Args...> {\n};\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1& get(tuple<_Args...>& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1&& get(tuple<_Args...>&& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(_VSTD::move(__tup));\n}\n\ntemplate <class _T1, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const&& get(tuple<_Args...> const&& __tup) noexcept\n{\n    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(_VSTD::move(__tup));\n}\n\n#endif\n\n// tie\n\ntemplate <class ..._Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<_Tp&...>\ntie(_Tp&... __t) _NOEXCEPT\n{\n    return tuple<_Tp&...>(__t...);\n}\n\ntemplate <class _Up>\nstruct __ignore_t\n{\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        const __ignore_t& operator=(_Tp&&) const {return *this;}\n};\n\nnamespace { const __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>(); }\n\ntemplate <class _Tp>\nstruct __make_tuple_return_impl\n{\n    typedef _Tp type;\n};\n\ntemplate <class _Tp>\nstruct __make_tuple_return_impl<reference_wrapper<_Tp> >\n{\n    typedef _Tp& type;\n};\n\ntemplate <class _Tp>\nstruct __make_tuple_return\n{\n    typedef typename __make_tuple_return_impl<typename decay<_Tp>::type>::type type;\n};\n\ntemplate <class... _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<typename __make_tuple_return<_Tp>::type...>\nmake_tuple(_Tp&&... __t)\n{\n    return tuple<typename __make_tuple_return<_Tp>::type...>(_VSTD::forward<_Tp>(__t)...);\n}\n\ntemplate <class... _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<_Tp&&...>\nforward_as_tuple(_Tp&&... __t) _NOEXCEPT\n{\n    return tuple<_Tp&&...>(_VSTD::forward<_Tp>(__t)...);\n}\n\ntemplate <size_t _Ip>\nstruct __tuple_equal\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        return __tuple_equal<_Ip - 1>()(__x, __y) && _VSTD::get<_Ip-1>(__x) == _VSTD::get<_Ip-1>(__y);\n    }\n};\n\ntemplate <>\nstruct __tuple_equal<0>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp&, const _Up&)\n    {\n        return true;\n    }\n};\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __tuple_equal<sizeof...(_Tp)>()(__x, __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <size_t _Ip>\nstruct __tuple_less\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        const size_t __idx = tuple_size<_Tp>::value - _Ip;\n        if (_VSTD::get<__idx>(__x) < _VSTD::get<__idx>(__y))\n            return true;\n        if (_VSTD::get<__idx>(__y) < _VSTD::get<__idx>(__x))\n            return false;\n        return __tuple_less<_Ip-1>()(__x, __y);\n    }\n};\n\ntemplate <>\nstruct __tuple_less<0>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _Tp&, const _Up&)\n    {\n        return false;\n    }\n};\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __tuple_less<sizeof...(_Tp)>()(__x, __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class ..._Tp, class ..._Up>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)\n{\n    return !(__y < __x);\n}\n\n// tuple_cat\n\ntemplate <class _Tp, class _Up> struct __tuple_cat_type;\n\ntemplate <class ..._Ttypes, class ..._Utypes>\nstruct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> >\n{\n    typedef tuple<_Ttypes..., _Utypes...> type;\n};\n\ntemplate <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples>\nstruct __tuple_cat_return_1\n{\n};\n\ntemplate <class ..._Types, class _Tuple0>\nstruct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0>\n{\n    typedef typename __tuple_cat_type<tuple<_Types...>,\n            typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type>::type\n                                                                           type;\n};\n\ntemplate <class ..._Types, class _Tuple0, class _Tuple1, class ..._Tuples>\nstruct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>\n    : public __tuple_cat_return_1<\n                 typename __tuple_cat_type<\n                     tuple<_Types...>,\n                     typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type\n                 >::type,\n                 __tuple_like<typename remove_reference<_Tuple1>::type>::value,\n                 _Tuple1, _Tuples...>\n{\n};\n\ntemplate <class ..._Tuples> struct __tuple_cat_return;\n\ntemplate <class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return<_Tuple0, _Tuples...>\n    : public __tuple_cat_return_1<tuple<>,\n         __tuple_like<typename remove_reference<_Tuple0>::type>::value, _Tuple0,\n                                                                     _Tuples...>\n{\n};\n\ntemplate <>\nstruct __tuple_cat_return<>\n{\n    typedef tuple<> type;\n};\n\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntuple<>\ntuple_cat()\n{\n    return tuple<>();\n}\n\ntemplate <class _Rp, class _Indices, class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return_ref_imp;\n\ntemplate <class ..._Types, size_t ..._I0, class _Tuple0>\nstruct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0>\n{\n    typedef typename remove_reference<_Tuple0>::type _T0;\n    typedef tuple<_Types..., typename __apply_cv<_Tuple0,\n                          typename tuple_element<_I0, _T0>::type>::type&&...> type;\n};\n\ntemplate <class ..._Types, size_t ..._I0, class _Tuple0, class _Tuple1, class ..._Tuples>\nstruct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,\n                                  _Tuple0, _Tuple1, _Tuples...>\n    : public __tuple_cat_return_ref_imp<\n         tuple<_Types..., typename __apply_cv<_Tuple0,\n               typename tuple_element<_I0,\n                  typename remove_reference<_Tuple0>::type>::type>::type&&...>,\n         typename __make_tuple_indices<tuple_size<typename\n                                 remove_reference<_Tuple1>::type>::value>::type,\n         _Tuple1, _Tuples...>\n{\n};\n\ntemplate <class _Tuple0, class ..._Tuples>\nstruct __tuple_cat_return_ref\n    : public __tuple_cat_return_ref_imp<tuple<>,\n               typename __make_tuple_indices<\n                        tuple_size<typename remove_reference<_Tuple0>::type>::value\n               >::type, _Tuple0, _Tuples...>\n{\n};\n\ntemplate <class _Types, class _I0, class _J0>\nstruct __tuple_cat;\n\ntemplate <class ..._Types, size_t ..._I0, size_t ..._J0>\nstruct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> >\n{\n    template <class _Tuple0>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type\n    operator()(tuple<_Types...> __t, _Tuple0&& __t0)\n    {\n        return forward_as_tuple(_VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,\n                                      _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...);\n    }\n\n    template <class _Tuple0, class _Tuple1, class ..._Tuples>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type\n    operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&& ...__tpls)\n    {\n        typedef typename remove_reference<_Tuple0>::type _T0;\n        typedef typename remove_reference<_Tuple1>::type _T1;\n        return __tuple_cat<\n           tuple<_Types..., typename __apply_cv<_Tuple0, typename tuple_element<_J0, _T0>::type>::type&&...>,\n           typename __make_tuple_indices<sizeof ...(_Types) + tuple_size<_T0>::value>::type,\n           typename __make_tuple_indices<tuple_size<_T1>::value>::type>()\n                           (forward_as_tuple(\n                              _VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,\n                              _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...\n                            ),\n                            _VSTD::forward<_Tuple1>(__t1),\n                            _VSTD::forward<_Tuples>(__tpls)...);\n    }\n};\n\ntemplate <class _Tuple0, class... _Tuples>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename __tuple_cat_return<_Tuple0, _Tuples...>::type\ntuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls)\n{\n    typedef typename remove_reference<_Tuple0>::type _T0;\n    return __tuple_cat<tuple<>, __tuple_indices<>,\n                  typename __make_tuple_indices<tuple_size<_T0>::value>::type>()\n                  (tuple<>(), _VSTD::forward<_Tuple0>(__t0),\n                                            _VSTD::forward<_Tuples>(__tpls)...);\n}\n\ntemplate <class ..._Tp, class _Alloc>\nstruct _LIBCPP_TEMPLATE_VIS uses_allocator<tuple<_Tp...>, _Alloc>\n    : true_type {};\n\n#endif // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _T1, class _T2>\ntemplate <class... _Args1, class... _Args2, size_t ..._I1, size_t ..._I2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1, _T2>::pair(piecewise_construct_t,\n                     tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n                     __tuple_indices<_I1...>, __tuple_indices<_I2...>)\n    :  first(_VSTD::forward<_Args1>(_VSTD::get<_I1>( __first_args))...),\n      second(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n{\n}\n#endif // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp>\nconstexpr size_t tuple_size_v = tuple_size<_Tp>::value;\n\n#define _LIBCPP_NOEXCEPT_RETURN(...) noexcept(noexcept(__VA_ARGS__)) { return __VA_ARGS__; }\n\ntemplate <class _Fn, class _Tuple, size_t ..._Id>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr decltype(auto) __apply_tuple_impl(_Fn && __f, _Tuple && __t,\n                                            __tuple_indices<_Id...>)\n_LIBCPP_NOEXCEPT_RETURN(\n    _VSTD::__invoke_constexpr(\n        _VSTD::forward<_Fn>(__f),\n        _VSTD::get<_Id>(_VSTD::forward<_Tuple>(__t))...)\n)\n\ntemplate <class _Fn, class _Tuple>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr decltype(auto) apply(_Fn && __f, _Tuple && __t)\n_LIBCPP_NOEXCEPT_RETURN(\n    _VSTD::__apply_tuple_impl(\n        _VSTD::forward<_Fn>(__f), _VSTD::forward<_Tuple>(__t),\n        typename __make_tuple_indices<tuple_size_v<decay_t<_Tuple>>>::type{})\n)\n\ntemplate <class _Tp, class _Tuple, size_t... _Idx>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _Tp __make_from_tuple_impl(_Tuple&& __t, __tuple_indices<_Idx...>)\n_LIBCPP_NOEXCEPT_RETURN(\n    _Tp(_VSTD::get<_Idx>(_VSTD::forward<_Tuple>(__t))...)\n)\n\ntemplate <class _Tp, class _Tuple>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _Tp make_from_tuple(_Tuple&& __t)\n_LIBCPP_NOEXCEPT_RETURN(\n    _VSTD::__make_from_tuple_impl<_Tp>(_VSTD::forward<_Tuple>(__t),\n        typename __make_tuple_indices<tuple_size_v<decay_t<_Tuple>>>::type{})\n)\n\n#undef _LIBCPP_NOEXCEPT_RETURN\n\n#endif // _LIBCPP_STD_VER > 14\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TUPLE\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL_BASE\n#define _LIBCPP_FUNCTIONAL_BASE\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n#include <new>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Arg, class _Result>\nstruct _LIBCPP_TEMPLATE_VIS unary_function\n{\n    typedef _Arg    argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nstruct _LIBCPP_TEMPLATE_VIS binary_function\n{\n    typedef _Arg1   first_argument_type;\n    typedef _Arg2   second_argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Tp>\nstruct __has_result_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::result_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS less : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY \n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x < __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS less<void>\n{\n    template <class _T1, class _T2> \n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n// __weak_result_type\n\ntemplate <class _Tp>\nstruct __derives_from_unary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _Ap, class _Rp>\n        static unary_function<_Ap, _Rp>\n        __test(const volatile unary_function<_Ap, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp>\nstruct __derives_from_binary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _A1, class _A2, class _Rp>\n        static binary_function<_A1, _A2, _Rp>\n        __test(const volatile binary_function<_A1, _A2, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp, bool = __derives_from_unary_function<_Tp>::value>\nstruct __maybe_derive_from_unary_function  // bool is true\n    : public __derives_from_unary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_unary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __derives_from_binary_function<_Tp>::value>\nstruct __maybe_derive_from_binary_function  // bool is true\n    : public __derives_from_binary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_binary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __has_result_type<_Tp>::value>\nstruct __weak_result_type_imp // bool is true\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n    typedef typename _Tp::result_type result_type;\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type_imp<_Tp, false>\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type\n    : public __weak_result_type_imp<_Tp>\n{\n};\n\n// 0 argument case\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp ()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (&)()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (*)()>\n{\n    typedef _Rp result_type;\n};\n\n// 1 argument case\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (&)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (*)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)()>\n    : public unary_function<_Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const>\n    : public unary_function<const _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() volatile>\n    : public unary_function<volatile _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const volatile>\n    : public unary_function<const volatile _Cp*, _Rp>\n{\n};\n\n// 2 argument case\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (*)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (&)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1)>\n    : public binary_function<_Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const>\n    : public binary_function<const _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>\n    : public binary_function<volatile _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>\n    : public binary_function<const volatile _Cp*, _A1, _Rp>\n{\n};\n\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n// 3 or more arguments\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>\n{\n    typedef _Rp result_type;\n};\n\n#endif // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class ..._Args>\nstruct __invoke_return\n{\n    typedef decltype(__invoke(_VSTD::declval<_Tp>(), _VSTD::declval<_Args>()...)) type;\n};\n\n#else // defined(_LIBCPP_CXX03_LANG)\n\n#include <__functional_base_03>\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\n\ntemplate <class _Ret>\nstruct __invoke_void_return_wrapper\n{\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class ..._Args>\n    static _Ret __call(_Args&&... __args) {\n        return __invoke(_VSTD::forward<_Args>(__args)...);\n    }\n#else\n    template <class _Fn>\n    static _Ret __call(_Fn __f) {\n        return __invoke(__f);\n    }\n\n    template <class _Fn, class _A0>\n    static _Ret __call(_Fn __f, _A0& __a0) {\n        return __invoke(__f, __a0);\n    }\n\n    template <class _Fn, class _A0, class _A1>\n    static _Ret __call(_Fn __f, _A0& __a0, _A1& __a1) {\n        return __invoke(__f, __a0, __a1);\n    }\n\n    template <class _Fn, class _A0, class _A1, class _A2>\n    static _Ret __call(_Fn __f, _A0& __a0, _A1& __a1, _A2& __a2){\n        return __invoke(__f, __a0, __a1, __a2);\n    }\n#endif\n};\n\ntemplate <>\nstruct __invoke_void_return_wrapper<void>\n{\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class ..._Args>\n    static void __call(_Args&&... __args) {\n        __invoke(_VSTD::forward<_Args>(__args)...);\n    }\n#else\n    template <class _Fn>\n    static void __call(_Fn __f) {\n        __invoke(__f);\n    }\n\n    template <class _Fn, class _A0>\n    static void __call(_Fn __f, _A0& __a0) {\n        __invoke(__f, __a0);\n    }\n\n    template <class _Fn, class _A0, class _A1>\n    static void __call(_Fn __f, _A0& __a0, _A1& __a1) {\n        __invoke(__f, __a0, __a1);\n    }\n\n    template <class _Fn, class _A0, class _A1, class _A2>\n    static void __call(_Fn __f, _A0& __a0, _A1& __a1, _A2& __a2) {\n        __invoke(__f, __a0, __a1, __a2);\n    }\n#endif\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS reference_wrapper\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type* __f_;\n\npublic:\n    // construct/copy/destroy\n    _LIBCPP_INLINE_VISIBILITY reference_wrapper(type& __f) _NOEXCEPT\n        : __f_(_VSTD::addressof(__f)) {}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    private: reference_wrapper(type&&); public: // = delete; // do not bind to temps\n#endif\n\n    // access\n    _LIBCPP_INLINE_VISIBILITY operator type&    () const _NOEXCEPT {return *__f_;}\n    _LIBCPP_INLINE_VISIBILITY          type& get() const _NOEXCEPT {return *__f_;}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    // invoke\n    template <class... _ArgTypes>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_of<type&, _ArgTypes...>::type\n    operator() (_ArgTypes&&... __args) const {\n        return __invoke(get(), _VSTD::forward<_ArgTypes>(__args)...);\n    }\n#else\n\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return<type>::type\n    operator() () const {\n        return __invoke(get());\n    }\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return0<type, _A0>::type\n    operator() (_A0& __a0) const {\n        return __invoke(get(), __a0);\n    }\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return0<type, _A0 const>::type\n    operator() (_A0 const& __a0) const {\n        return __invoke(get(), __a0);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0, _A1>::type\n    operator() (_A0& __a0, _A1& __a1) const {\n        return __invoke(get(), __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0 const, _A1>::type\n    operator() (_A0 const& __a0, _A1& __a1) const {\n        return __invoke(get(), __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0, _A1 const>::type\n    operator() (_A0& __a0, _A1 const& __a1) const {\n        return __invoke(get(), __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0 const, _A1 const>::type\n    operator() (_A0 const& __a0, _A1 const& __a1) const {\n        return __invoke(get(), __a0, __a1);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1, _A2>::type\n    operator() (_A0& __a0, _A1& __a1, _A2& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1, _A2>::type\n    operator() (_A0 const& __a0, _A1& __a1, _A2& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1 const, _A2>::type\n    operator() (_A0& __a0, _A1 const& __a1, _A2& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1, _A2 const>::type\n    operator() (_A0& __a0, _A1& __a1, _A2 const& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1 const, _A2>::type\n    operator() (_A0 const& __a0, _A1 const& __a1, _A2& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1, _A2 const>::type\n    operator() (_A0 const& __a0, _A1& __a1, _A2 const& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1 const, _A2 const>::type\n    operator() (_A0& __a0, _A1 const& __a1, _A2 const& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1 const, _A2 const>::type\n    operator() (_A0 const& __a0, _A1 const& __a1, _A2 const& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n#endif // _LIBCPP_HAS_NO_VARIADICS\n};\n\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(_Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<_Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return ref(__t.get());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(const _Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<const _Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return cref(__t.get());\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp> void ref(const _Tp&&) = delete;\ntemplate <class _Tp> void cref(const _Tp&&) = delete;\n#endif\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp1, class _Tp2 = void>\nstruct __is_transparent\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::is_transparent* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp1>(0)) == 1;\n};\n#endif\n\n// allocator_arg_t\n\nstruct _LIBCPP_TEMPLATE_VIS allocator_arg_t { };\n\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_MEMORY)\nextern const allocator_arg_t allocator_arg;\n#else\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n#endif\n\n// uses_allocator\n\ntemplate <class _Tp>\nstruct __has_allocator_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::allocator_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>\nstruct __uses_allocator\n    : public integral_constant<bool,\n        is_convertible<_Alloc, typename _Tp::allocator_type>::value>\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct __uses_allocator<_Tp, _Alloc, false>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct _LIBCPP_TEMPLATE_VIS uses_allocator\n    : public __uses_allocator<_Tp, _Alloc>\n{\n};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp, class _Alloc>\nconstexpr size_t uses_allocator_v = uses_allocator<_Tp, _Alloc>::value;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// allocator construction\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor_imp\n{\n    typedef typename __uncvref<_Alloc>::type _RawAlloc;\n    static const bool __ua = uses_allocator<_Tp, _RawAlloc>::value;\n    static const bool __ic =\n        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;\n    static const int value = __ua ? 2 - __ic : 0;\n};\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor\n    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>\n    {};\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)...);\n}\n\n// FIXME: This should have a version which takes a non-const alloc.\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (allocator_arg, __a, _VSTD::forward<_Args>(__args)...);\n}\n\n// FIXME: This should have a version which takes a non-const alloc.\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)..., __a);\n}\n\n// FIXME: Theis should have a version which takes a non-const alloc.\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct (_Tp *__storage, const _Allocator &__a, _Args &&... __args)\n{ \n    __user_alloc_construct_impl( \n             __uses_alloc_ctor<_Tp, _Allocator>(), \n             __storage, __a, _VSTD::forward<_Args>(__args)...\n        );\n}\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL_BASE\n"]}